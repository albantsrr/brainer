<p>Imaginez deux amis séparés par une rue, lampe de poche à la main, cherchant à communiquer après l'extinction des feux. Comment transmettre des phrases entières avec un simple faisceau de lumière ? Ce défi, en apparence anodin, est exactement le type de contrainte qui a conduit à l'invention des <strong>codes</strong>, ces systèmes permettant de transmettre de l'information avec des moyens limités.</p>

<p>Ce chapitre explore le concept fondamental de code à travers l'exemple du code Morse. Vous découvrirez pourquoi certains codes sont plus efficaces que d'autres, et comment deux états distincts, aussi simples qu'une lumière allumée ou éteinte, suffisent à encoder toute information. Ce principe est la fondation de l'informatique moderne.</p>

<p>À l'issue de ce chapitre, vous comprendrez pourquoi votre ordinateur ne stocke que des zéros et des uns, et pourquoi cette apparent limitation est en réalité une force.</p>

<h2>Objectifs d'apprentissage</h2>

<p>À la fin de ce chapitre, vous serez capable de :</p>
<ul>
  <li><strong>Définir</strong> ce qu'est un code et identifier ses composantes essentielles</li>
  <li><strong>Comprendre</strong> comment le code Morse encode l'alphabet avec deux types de signaux</li>
  <li><strong>Analyser</strong> l'efficacité d'un code en comparant différentes stratégies d'encodage</li>
  <li><strong>Expliquer</strong> pourquoi deux états distincts suffisent à représenter n'importe quelle information</li>
</ul>

<h2>Pourquoi c'est important</h2>

<p>La notion de code est le fondement invisible de toute l'informatique. Votre ordinateur ne comprend que deux états électriques, 0 et 1, appelés <strong>bits</strong> (binary digits). Pourtant, avec ces deux seuls états, il stocke des textes, des images, de la musique et des films entiers. Comprendre comment cela est possible commence ici, avec le code Morse.</p>

<p>Tout développeur qui comprend ce principe sait pourquoi un caractère ASCII occupe 1 octet (8 bits = 256 valeurs possibles), pourquoi les protocoles réseau fonctionnent en séquences de bits, et pourquoi certaines erreurs d'encodage surviennent lors de la conversion entre systèmes. Ces connaissances sont quotidiennes dans les domaines du traitement de fichiers, des communications réseau et de la sécurité informatique.</p>

<h2>Les codes : des systèmes de correspondance</h2>

<h3>Concept fondamental</h3>
<p>Un <strong>code</strong> est un système de correspondance qui permet de transférer de l'information entre personnes, entre personnes et machines, ou à l'intérieur d'un système. Un code n'est pas nécessairement secret. La plupart des codes sont publics et doivent l'être pour être utiles, car les deux parties de la communication doivent partager le même système.</p>

<h3>Mécanisme interne</h3>
<p>Tout code est défini par deux éléments : un <strong>alphabet de symboles</strong> (les briques de base) et une <strong>table de correspondance</strong> (le mappage entre symboles et significations). Ces deux éléments doivent être connus des deux parties pour que la communication fonctionne :</p>
<ul>
  <li>La <strong>parole</strong> : sons articulés (alphabet phonétique) qui représentent des mots</li>
  <li>L'<strong>écriture</strong> : symboles graphiques qui représentent des sons ou des concepts</li>
  <li>Le <strong>braille</strong> : points en relief qui représentent des lettres</li>
  <li>La <strong>langue des signes</strong> : gestes qui représentent des lettres ou des mots entiers</li>
  <li>Le <strong>code Morse</strong> : signaux courts et longs qui représentent des lettres, chiffres et ponctuation</li>
</ul>

<h3>Exemple pratique</h3>
<p>Nos deux amis inventent spontanément leur premier code : 1 clignotement = A, 2 clignotements = B, jusqu'à 26 pour Z. Ce système fonctionne, mais une phrase simple comme "How are you ?" nécessite 131 clignotements. Le code Morse réduit ce même message à 32 signaux en utilisant deux types de clignotements au lieu d'un seul. Le gain est considérable parce que la conception du code est plus intelligente.</p>

<h2>Le code Morse : deux symboles, toutes les lettres</h2>

<h3>Concept fondamental</h3>
<p>Le code Morse utilise seulement deux types de signaux, le <strong>point</strong> (signal court) et le <strong>trait</strong> (signal long). Chaque lettre de l'alphabet correspond à une séquence unique de ces deux symboles. La clé de son efficacité : les lettres les plus fréquentes reçoivent les codes les plus courts. E (la lettre la plus courante en anglais) n'est qu'un seul point, tandis que Q (rare) requiert quatre symboles.</p>

<h3>Mécanisme interne</h3>
<p>Le code Morse repose sur trois éléments temporels relatifs, tous exprimés en multiples de la durée d'un point :</p>
<ul>
  <li>Un <strong>point</strong> : durée minimale d'activation (unité de référence)</li>
  <li>Un <strong>trait</strong> : durée d'environ 3 points</li>
  <li>Pause entre symboles d'une même lettre : 1 point</li>
  <li>Pause entre lettres d'un même mot : 1 trait (3 points)</li>
  <li>Pause entre mots : 2 traits (6 points)</li>
</ul>
<p>Ces durées sont <em>relatives</em>, pas absolues. Un opérateur lent et un opérateur rapide utilisent le même code, car ce sont les proportions qui comptent, pas les millisecondes exactes.</p>

<h3>Exemple pratique</h3>
<pre><code>Quelques lettres en code Morse :
  E : .         (1 symbole — très fréquent)
  T : -         (1 symbole — très fréquent)
  A : .-        (2 symboles)
  H : ....      (4 symboles)
  O : ---       (3 symboles)
  Q : --.-      (4 symboles — peu fréquent)

"hello" en Morse :
  H  E  L    L    O
  .. .  .-.. .-.. ---
  (pauses entre lettres)

SOS (signal de détresse international) :
  ...  ---  ...
  S    O    S
</code></pre>

<h3>Erreurs fréquentes</h3>
<ul>
  <li><strong>Erreur :</strong> Confondre la pause entre symboles et la pause entre lettres → <strong>Solution :</strong> La pause entre lettres dure 3 fois celle entre symboles de la même lettre. Sans cette distinction, on ne peut pas délimiter où une lettre finit et où la suivante commence.</li>
  <li><strong>Erreur :</strong> Croire que les durées sont fixes → <strong>Solution :</strong> Seuls les ratios importent. Un expéditeur rapide dont le "trait" dure 30 ms utilise des "points" de 10 ms. Un expéditeur lent avec des traits de 300 ms utilise des points de 100 ms. Le code reste identique.</li>
</ul>

<h2>Le principe fondamental : deux états suffisent</h2>

<h3>Concept fondamental</h3>
<p>Le code Morse révèle un principe universel de l'information : <strong>deux états distincts suffisent à encoder n'importe quelle information</strong>. Il n'est pas nécessaire d'avoir 26 niveaux de signal. Deux états bien différenciés, qu'il s'agisse de court/long, allumé/éteint, ou 0/1, permettent tout représenter grâce à des combinaisons de longueur suffisante.</p>

<h3>Mécanisme interne</h3>
<p>Avec un alphabet à 2 symboles, le nombre de valeurs représentables croît exponentiellement avec la longueur des séquences :</p>
<p><em>Une <strong>position</strong> est un emplacement dans la séquence — une « case » à remplir avec un symbole (. ou -). Comme les cases d'un cadenas à combinaison : chaque case peut prendre 2 valeurs, et le nombre de combinaisons totales explose avec le nombre de cases.</em></p>
<ul>
  <li>1 position = 2 valeurs (. ou -)</li>
  <li>2 positions = 4 valeurs (.., .-, -., --)</li>
  <li>3 positions = 8 valeurs</li>
  <li>n positions = 2<sup>n</sup> valeurs</li>
</ul>
<p>En informatique, une position binaire s'appelle un <strong>bit</strong>. Avec 8 bits (1 octet), on obtient 2<sup>8</sup> = 256 valeurs différentes, soit assez pour représenter les 128 caractères ASCII ou une couleur en niveaux de gris. Le code Morse exploitait déjà ce même principe de croissance exponentielle.</p>

<h3>Exemple pratique</h3>

<pre><code class="language-mermaid">
graph TD
    Deux["2 états distincts
(. et -)"]
    Deux --> Seq1["1 position : 2 valeurs"]
    Deux --> Seq2["2 positions : 4 valeurs"]
    Deux --> Seq3["3 positions : 8 valeurs"]
    Deux --> SeqN["n positions : 2ⁿ valeurs"]
    SeqN --> Bits["En informatique : bits
8 bits = 256 valeurs"]
</code></pre>

<h2>Synthèse</h2>

<p>Ce chapitre a couvert les points essentiels suivants :</p>
<ul>
  <li><strong>Code</strong> : système de correspondance entre symboles et significations, utilisé partout, de la parole à l'informatique</li>
  <li><strong>Code Morse</strong> : deux symboles (point et trait) suffisent à représenter l'alphabet, les chiffres et la ponctuation grâce aux combinaisons</li>
  <li><strong>Efficacité</strong> : assigner les codes les plus courts aux symboles les plus fréquents réduit considérablement le volume de transmission</li>
  <li><strong>Principe binaire</strong> : deux états distincts permettent de représenter 2<sup>n</sup> valeurs avec n positions, fondement direct du bit en informatique</li>
</ul>

<p><strong>À retenir :</strong> Le mot clé est <em>deux</em>. Deux types de clignotements, deux sons distincts, deux états électriques — deux n'importe quoi peut, avec des combinaisons suffisamment longues, encoder toute information imaginable. C'est précisément sur ce principe que repose chaque octet stocké dans votre ordinateur.</p>

<p><strong>Prochaines étapes :</strong> Le chapitre suivant explore comment des combinaisons de signaux simples permettent de construire des systèmes de codes plus complexes, posant les bases des systèmes de numération binaire utilisés en informatique.</p>
