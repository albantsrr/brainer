{"content": "<p>Imaginez un r\u00e9seau de signalisation qui ne peut que s'allumer ou s'\u00e9teindre. Une seule lampe semble ridiculement pauvre pour transmettre quoi que ce soit d'utile. Et pourtant, derri\u00e8re chaque message envoy\u00e9 sur Internet, chaque image affich\u00e9e \u00e0 l'\u00e9cran, chaque son jou\u00e9 par une enceinte, se cache exactement ce principe : deux \u00e9tats, rien de plus.</p>\n\n<p>Ce chapitre pose la question fondatrice de l'informatique : comment deux symboles peuvent-ils encoder toute l'information du monde ? La r\u00e9ponse r\u00e9side dans la combinatoire et dans l'art de composer des codes \u00e0 plusieurs niveaux.</p>\n\n<p>Nous allons construire cette r\u00e9ponse depuis les bases, en comprenant ce qu'est un code, en calculant sa capacit\u00e9 math\u00e9matique avec la formule 2<sup>N</sup>, et en d\u00e9couvrant les m\u00e9canismes qui permettent d'\u00e9tendre cette capacit\u00e9 bien au-del\u00e0 des limites apparentes.</p>\n\n<h2>Objectifs d'apprentissage</h2>\n\n<p>\u00c0 la fin de ce chapitre, vous serez capable de :</p>\n<ul>\n  <li><strong>D\u00e9finir</strong> un code comme une correspondance convenue entre symboles et significations</li>\n  <li><strong>Expliquer</strong> pourquoi deux \u00e9tats distincts suffisent \u00e0 repr\u00e9senter n'importe quelle information</li>\n  <li><strong>Calculer</strong> le nombre de combinaisons possibles pour N positions binaires avec la formule 2<sup>N</sup></li>\n  <li><strong>Distinguer</strong> les codes \u00e0 d\u00e9calage (shift codes) et les codes d'\u00e9chappement (escape codes)</li>\n  <li><strong>Analyser</strong> l'efficacit\u00e9 d'un code selon la fr\u00e9quence d'utilisation de ses symboles</li>\n</ul>\n\n<h2>Pourquoi c'est important</h2>\n\n<p>Toute donn\u00e9e dans un ordinateur est repr\u00e9sent\u00e9e en binaire, qu'il s'agisse de texte, d'images, de programmes ex\u00e9cutables ou de paquets r\u00e9seau. Comprendre comment les codes binaires fonctionnent n'est pas un d\u00e9tail th\u00e9orique : c'est le fondement de tout ce qui est abord\u00e9 dans ce cours.</p>\n\n<p>Sans cette compr\u00e9hension, des questions concr\u00e8tes restent opaques. Pourquoi un octet peut-il stocker exactement 256 valeurs ? Pourquoi un encodage de texte comme UTF-8 utilise-t-il 1 \u00e0 4 octets selon le caract\u00e8re ? Pourquoi certains protocoles r\u00e9seau r\u00e9servent-ils un code sp\u00e9cial pour signaler que les octets suivants doivent \u00eatre interpr\u00e9t\u00e9s diff\u00e9remment ?</p>\n\n<p>Les m\u00e9canismes que vous allez apprendre ici, la croissance exponentielle des combinaisons, les shift codes et les escape codes, se retrouvent dans les encodages de caract\u00e8res, les formats de fichiers, les jeux d'instructions des processeurs, et les protocoles de communication.</p>\n\n<h2>La notion de code</h2>\n\n<h3>Concept fondamental</h3>\n\n<p>Un <strong>code</strong> est une convention partag\u00e9e entre un \u00e9metteur et un r\u00e9cepteur qui \u00e9tablit une correspondance entre des symboles et des significations. Le mot \"convention\" est essentiel : un code n'a de sens que si les deux parties connaissent le m\u00eame dictionnaire de traduction.</p>\n\n<p>Un code peut utiliser n'importe quel type de symbole : des gestes, des sons, des couleurs, ou des \u00e9tats physiques comme l'ouverture ou la fermeture d'un circuit \u00e9lectrique. Ce qui importe n'est pas la nature des symboles, mais le fait qu'ils soient <em>distincts</em> et <em>reproductibles</em>.</p>\n\n<h3>M\u00e9canisme interne</h3>\n\n<p>Tout syst\u00e8me de communication se mod\u00e9lise comme une table de correspondance. Du c\u00f4t\u00e9 de l'\u00e9metteur, on entre une signification et on obtient la s\u00e9quence de symboles correspondante. Du c\u00f4t\u00e9 du r\u00e9cepteur, l'op\u00e9ration inverse s'applique.</p>\n\n<p>L'efficacit\u00e9 d'un code d\u00e9pend de l'ad\u00e9quation entre la longueur des s\u00e9quences et la fr\u00e9quence d'utilisation des symboles. Un code qui assigne des s\u00e9quences longues aux symboles fr\u00e9quents gaspille de la capacit\u00e9. \u00c0 l'inverse, un code qui assigne des s\u00e9quences courtes aux symboles courants transmet davantage d'information avec moins de symboles.</p>\n\n<h3>Exemple pratique</h3>\n\n<p>Un syst\u00e8me de gestion de stock utilise des codes pour indiquer l'\u00e9tat de chaque article en entrep\u00f4t. Cinq \u00e9tats sont possibles, avec des fr\u00e9quences tr\u00e8s in\u00e9gales :</p>\n\n<pre><code>Encodage uniforme (3 bits par \u00e9tat) :\n  Disponible \u2192 000   (70% des cas)\n  R\u00e9serv\u00e9    \u2192 001   (15% des cas)\n  En transit \u2192 010   (10% des cas)\n  Rupture    \u2192 011   (4%  des cas)\n  Retir\u00e9     \u2192 100   (1%  des cas)\n  (codes 101, 110, 111 inutilis\u00e9s)\n\nEncodage fr\u00e9quentiel (longueur variable) :\n  Disponible \u2192 0       (1 bit   \u2014 70% des cas)\n  R\u00e9serv\u00e9    \u2192 10      (2 bits  \u2014 15% des cas)\n  En transit \u2192 110     (3 bits  \u2014 10% des cas)\n  Rupture    \u2192 1110    (4 bits  \u2014  4% des cas)\n  Retir\u00e9     \u2192 1111    (4 bits  \u2014  1% des cas)</code></pre>\n\n<p>Le second encodage utilise en moyenne environ 1,6 bit par article contre 3 bits pour le premier, soit pr\u00e8s de deux fois moins d'espace pour la m\u00eame information. C'est le principe fondateur des algorithmes de compression.</p>\n\n<h2>Deux \u00e9tats, combinaisons exponentielles</h2>\n\n<h3>Concept fondamental</h3>\n\n<p>Le <strong>binaire</strong> d\u00e9signe tout syst\u00e8me reposant sur exactement deux \u00e9tats distincts. Ces deux \u00e9tats peuvent \u00eatre r\u00e9alis\u00e9s sur de nombreux supports physiques : ouvert/ferm\u00e9 pour un interrupteur, haut/bas pour une tension \u00e9lectrique, creux/bosse pour un disque optique. Ce qui les rend universels, c'est qu'ils sont les plus simples \u00e0 distinguer de fa\u00e7on fiable, m\u00eame en pr\u00e9sence de bruit ou de perturbations.</p>\n\n<p>La question cl\u00e9 est : combien d'informations diff\u00e9rentes peut-on encoder avec N positions binaires ? La r\u00e9ponse est <strong>2<sup>N</sup></strong>, et cette formule est l'une des plus importantes de l'informatique.</p>\n\n<h3>M\u00e9canisme interne</h3>\n\n<p>La logique est multiplicative. Avec 1 position, on a 2 possibilit\u00e9s. Chaque position suppl\u00e9mentaire <em>double</em> le nombre de combinaisons, car chaque nouvelle position peut \u00eatre 0 ou 1 ind\u00e9pendamment de toutes les autres. Ce doublement constant produit une croissance exponentielle :</p>\n\n<pre><code>1 position  \u2192    2 combinaisons  (2\u00b9)\n2 positions \u2192    4 combinaisons  (2\u00b2)\n3 positions \u2192    8 combinaisons  (2\u00b3)\n4 positions \u2192   16 combinaisons  (2\u2074)\n6 positions \u2192   64 combinaisons  (2\u2076)\n8 positions \u2192  256 combinaisons  (2\u2078)</code></pre>\n\n<p>On peut visualiser ce doublement comme un arbre binaire : chaque niveau ajoute une bifurcation \u00e0 chaque feuille existante.</p>\n\n<pre><code class=\"language-mermaid\">graph TD\n    S[D\u00e9part]\n    S --> A[bit 1 = 0]\n    S --> B[bit 1 = 1]\n    A --> C[00]\n    A --> D[01]\n    B --> E[10]\n    B --> F[11]</code></pre>\n\n<h3>Exemple pratique</h3>\n\n<p>Un syst\u00e8me domotique identifie chaque capteur par un num\u00e9ro binaire. Le nombre de capteurs adressables d\u00e9pend directement du nombre de bits allou\u00e9s \u00e0 cet identifiant :</p>\n\n<pre><code>4 bits  \u2192 2\u2074  =      16 capteurs  (maison individuelle)\n8 bits  \u2192 2\u2078  =     256 capteurs  (immeuble de bureaux)\n16 bits \u2192 2\u00b9\u2076 =  65 536 capteurs  (campus industriel)</code></pre>\n\n<p>C'est exactement cette logique qui gouverne la taille des types num\u00e9riques en informatique : un <code>uint8</code> (entier non sign\u00e9 sur 8 bits) contient des valeurs de 0 \u00e0 255, un <code>uint16</code> (16 bits) de 0 \u00e0 65 535.</p>\n\n<h3>Erreurs fr\u00e9quentes</h3>\n<ul>\n  <li><strong>Erreur :</strong> Additionner au lieu de multiplier, penser que 3 bits donnent 6 combinaisons. \u2192 <strong>Solution :</strong> Chaque bit multiplie par 2 le nombre de combinaisons pr\u00e9c\u00e9dentes, d'o\u00f9 2<sup>N</sup> et non 2\u00d7N.</li>\n  <li><strong>Erreur :</strong> Confondre le nombre de bits et le nombre de valeurs repr\u00e9sentables. \u2192 <strong>Solution :</strong> 8 bits repr\u00e9sentent 256 valeurs distinctes (de 0 \u00e0 255), pas 8 valeurs.</li>\n</ul>\n\n<h2>Codes \u00e0 d\u00e9calage et codes d'\u00e9chappement</h2>\n\n<h3>Concept fondamental</h3>\n\n<p>Quand un espace de codes de taille fixe ne suffit pas \u00e0 couvrir tous les symboles n\u00e9cessaires, deux m\u00e9canismes permettent d'\u00e9tendre la capacit\u00e9 sans augmenter le nombre de bits par symbole : les <strong>shift codes</strong> (codes \u00e0 d\u00e9calage) et les <strong>escape codes</strong> (codes d'\u00e9chappement).</p>\n\n<p>Ces deux m\u00e9canismes reposent sur le concept de contexte : la signification d'un code ne d\u00e9pend pas seulement de sa valeur, mais aussi des codes qui le pr\u00e9c\u00e8dent.</p>\n\n<h3>M\u00e9canisme interne</h3>\n\n<p>Un <strong>shift code</strong> change le mode d'interpr\u00e9tation de <em>tous</em> les codes suivants, jusqu'\u00e0 ce qu'un autre shift annule l'effet. C'est une bascule d'\u00e9tat globale et persistante.</p>\n\n<p>Un <strong>escape code</strong> modifie uniquement l'interpr\u00e9tation du <em>prochain</em> code, apr\u00e8s quoi le mode pr\u00e9c\u00e9dent reprend. C'est une modification locale et ponctuelle.</p>\n\n<pre><code class=\"language-mermaid\">stateDiagram-v2\n    [*] --> ModeA\n    ModeA --> ModeB : shift code\n    ModeB --> ModeA : shift code\n    ModeA --> ModeA : escape code\n    ModeB --> ModeB : escape code</code></pre>\n\n<h3>Exemple pratique</h3>\n\n<p>Un protocole de communication entre capteurs industriels utilise des codes sur 4 bits (16 combinaisons). En mode normal, les codes 0 \u00e0 11 repr\u00e9sentent des mesures. Le code 12 est un shift qui bascule en mode configuration, o\u00f9 les m\u00eames codes 0 \u00e0 11 d\u00e9signent des param\u00e8tres. Le code 13 est un escape qui indique que le code suivant est une alarme prioritaire, quel que soit le mode actuel.</p>\n\n<pre><code>S\u00e9quence re\u00e7ue :  3   12   7   13   9   2\n\nInterpr\u00e9tation :\n  3  \u2192 Mesure #3         (mode normal)\n  12 \u2192 [SHIFT : passage en mode configuration]\n  7  \u2192 Param\u00e8tre #7      (mode configuration)\n  13 \u2192 [ESCAPE : le prochain code est une alarme]\n  9  \u2192 Alarme #9         (escape : retour en mode configuration apr\u00e8s)\n  2  \u2192 Param\u00e8tre #2      (mode configuration)</code></pre>\n\n<h3>Erreurs fr\u00e9quentes</h3>\n<ul>\n  <li><strong>Erreur :</strong> Confondre shift et escape. \u2192 <strong>Solution :</strong> Un shift change l'\u00e9tat durablement pour tous les codes suivants ; un escape n'affecte qu'un seul code.</li>\n  <li><strong>Erreur :</strong> Interpr\u00e9ter les codes de fa\u00e7on isol\u00e9e sans tenir compte du contexte. \u2192 <strong>Solution :</strong> Dans tout syst\u00e8me utilisant des shifts ou des escapes, un code ne peut pas \u00eatre d\u00e9cod\u00e9 sans conna\u00eetre l'\u00e9tat courant.</li>\n</ul>\n\n<h2>Synth\u00e8se</h2>\n\n<p>Ce chapitre a couvert les points essentiels suivants :</p>\n<ul>\n  <li><strong>Un code</strong> est une convention partag\u00e9e \u00e9tablissant une correspondance entre symboles et significations ; son efficacit\u00e9 d\u00e9pend de l'ad\u00e9quation entre la longueur des s\u00e9quences et la fr\u00e9quence des symboles.</li>\n  <li><strong>Le binaire</strong> utilise exactement deux \u00e9tats distincts, ce qui le rend universellement r\u00e9alisable sur tout support physique.</li>\n  <li><strong>La formule 2<sup>N</sup></strong> donne le nombre de combinaisons encodables avec N positions binaires : chaque bit suppl\u00e9mentaire double la capacit\u00e9.</li>\n  <li><strong>Les shift codes</strong> modifient l'interpr\u00e9tation de tous les codes suivants jusqu'\u00e0 r\u00e9vocation explicite.</li>\n  <li><strong>Les escape codes</strong> modifient uniquement l'interpr\u00e9tation du code imm\u00e9diatement suivant.</li>\n</ul>\n\n<p><strong>\u00c0 retenir :</strong> Deux \u00e9tats, c'est tout ce qu'il faut. La puissance du binaire ne vient pas de la richesse de ses symboles, mais de la croissance exponentielle des combinaisons et des m\u00e9canismes contextuels qui permettent de r\u00e9utiliser les m\u00eames codes avec des significations diff\u00e9rentes.</p>\n\n<p><strong>Prochaines \u00e9tapes :</strong> Le chapitre suivant passe du signal \u00e0 sa transmission physique : comment l'\u00e9lectricit\u00e9 elle-m\u00eame peut-elle \u00eatre le porteur de ces \u00e9tats binaires ?</p>\n"}
