<p>Envoyer du code Morse est simple : il suffit de consulter un tableau alphabétique et de transmettre les points et tirets correspondants. Mais recevoir du Morse et le décoder est une tout autre affaire. Quand vous recevez une séquence tiret-point-tiret-tiret, vous devez parcourir le tableau dans l'autre sens, lettre par lettre, jusqu'à trouver la correspondance. Ce problème en apparence anodin révèle quelque chose de fondamental sur la structure des codes.</p>

<p>En cherchant comment organiser les codes Morse pour faciliter le décodage, on découvre un schéma mathématique omniprésent en informatique : les <strong>puissances de 2</strong>. Cette progression, 2, 4, 8, 16, 32..., gouverne la mémoire des ordinateurs, les encodages de caractères, les protocoles réseau et bien d'autres systèmes.</p>

<p>Ce chapitre explore la structure mathématique des codes binaires. Vous comprendrez pourquoi deux symboles suffisent à représenter une quantité illimitée d'information, et pourquoi le nombre 2 et ses puissances sont omniprésents dans tout ce qui touche à l'informatique.</p>

<h2>Objectifs d'apprentissage</h2>

<p>À la fin de ce chapitre, vous serez capable de :</p>
<ul>
  <li><strong>Expliquer</strong> le problème du décodage inversé et sa solution par regroupement par longueur</li>
  <li><strong>Comprendre</strong> pourquoi chaque symbole supplémentaire double le nombre de codes disponibles</li>
  <li><strong>Appliquer</strong> la formule 2<sup>n</sup> pour calculer le nombre de combinaisons binaires</li>
  <li><strong>Analyser</strong> la structure en arbre d'un système de codes binaires</li>
  <li><strong>Relier</strong> le caractère binaire du code Morse aux fondements du calcul informatique</li>
</ul>

<h2>Pourquoi c'est important</h2>

<p>Les puissances de 2 structurent l'informatique à tous les niveaux. Un octet contient 8 bits et peut représenter 2<sup>8</sup> = 256 valeurs. Un encodage UTF-8 peut utiliser jusqu'à 4 octets pour couvrir 2<sup>21</sup> caractères Unicode. Les adresses IPv4 sont sur 32 bits (2<sup>32</sup> adresses possibles). Comprendre ce schéma, c'est comprendre pourquoi les systèmes ont les capacités et les limites qu'ils ont.</p>

<p>Sans cette intuition, un développeur peut être surpris par un dépassement de capacité, ou se demander pourquoi les tailles de mémoire sont toujours des multiples de 2 (1 Ko, 2 Ko, 4 Ko, 1 Go, 2 Go...). Maîtriser le raisonnement sur les combinaisons binaires est une base essentielle pour tout travail sur la mémoire, l'encodage et les protocoles de communication.</p>

<h2>Organiser les codes par longueur</h2>

<h3>Concept fondamental</h3>
<p>Un tableau trié alphabétiquement permet de passer d'une lettre vers son code, mais pas l'inverse. Pour décoder efficacement, il faut organiser les codes selon leur <strong>longueur</strong>, c'est-à-dire le nombre de symboles qu'ils contiennent. Cette organisation révèle une structure mathématique précise.</p>

<h3>Mécanisme interne</h3>
<p>Avec 1 symbole (point ou tiret), on obtient exactement 2 codes possibles, pour les lettres E et T. Avec 2 symboles, chaque code de longueur 1 peut être suivi d'un point ou d'un tiret : le nombre de codes double, passant à 4 (I, A, N, M). Ce mécanisme de doublement se reproduit à chaque niveau :</p>
<ul>
  <li>1 symbole : 2 codes (E, T)</li>
  <li>2 symboles : 4 codes (I, A, N, M)</li>
  <li>3 symboles : 8 codes (S, U, R, W, D, K, G, O)</li>
  <li>4 symboles : 16 codes (les lettres restantes)</li>
</ul>
<p>Ces quatre niveaux donnent 2 + 4 + 8 + 16 = 30 codes, soit 4 de plus que les 26 lettres de l'alphabet latin. Les 4 codes supplémentaires sont utilisés pour des lettres accentuées.</p>

<h3>Exemple pratique</h3>
<pre><code>Longueur 1 :  ·  (E)     -  (T)

Longueur 2 :  ·· (I)    ·- (A)    -· (N)    -- (M)

Longueur 3 :  ··· (S)   ··- (U)   ·-· (R)   ·-- (W)
              -·· (D)   -·- (K)   --· (G)   --- (O)
</code></pre>
<p>Chaque ligne est obtenue en prenant tous les codes de la ligne précédente et en ajoutant soit un point, soit un tiret. C'est le doublement systématique à l'œuvre.</p>

<h2>La formule 2<sup>n</sup></h2>

<h3>Concept fondamental</h3>
<p>Le nombre de codes pour des séquences de n symboles binaires est toujours <strong>2<sup>n</sup></strong>. Cette formule synthétise le mécanisme de doublement : chaque nouvelle position multiplie par 2 le nombre de combinaisons possibles.</p>

<h3>Mécanisme interne</h3>
<p>Pour une séquence de n positions, chaque position peut prendre 2 valeurs indépendantes. Le nombre total de combinaisons est donc 2 multiplié par lui-même n fois :</p>
<pre><code>n=1 : 2 = 2¹
n=2 : 2 × 2 = 4 = 2²
n=3 : 2 × 2 × 2 = 8 = 2³
n=4 : 2 × 2 × 2 × 2 = 16 = 2⁴
...
n=10 : 2¹⁰ = 1024
</code></pre>

<pre><code class="language-mermaid">
graph LR
    A["n=1
2 codes"] --> B["n=2
4 codes"]
    B --> C["n=3
8 codes"]
    C --> D["n=4
16 codes"]
    D --> E["n=5
32 codes"]
</code></pre>

<h3>Exemple pratique</h3>
<p>Le code Morse utilise des séquences de 5 symboles pour les chiffres (2<sup>5</sup> = 32 codes disponibles, suffisant pour 10 chiffres) et jusqu'à 6 symboles pour la ponctuation (2<sup>6</sup> = 64 codes). Beaucoup de ces codes restent <em>non définis</em>, c'est-à-dire délibérément inutilisés. Recevoir un code non défini signale une probable erreur de transmission.</p>

<h2>L'arbre de décodage</h2>

<h3>Concept fondamental</h3>
<p>Un <strong>arbre de décodage</strong> est une structure en arbre où chaque nœud représente un état de réception et chaque branche correspond au prochain symbole reçu : un point à gauche, un tiret à droite. Chaque nœud terminal indique la lettre correspondante. Cette structure permet un décodage rapide et systématique.</p>

<h3>Mécanisme interne</h3>
<p>La construction de l'arbre garantit deux propriétés importantes : premièrement, chaque code n'apparaît qu'une seule fois, évitant les collisions. Deuxièmement, tous les codes possibles d'une longueur donnée sont représentés, sans lacune ni redondance. L'arbre reflète visuellement la structure en puissances de 2 : chaque niveau double le nombre de nœuds.</p>

<pre><code class="language-mermaid">
graph TD
    Debut[Début] --> E["E (·)"]
    Debut --> T["T (-)"]
    E --> I["I (··)"]
    E --> A["A (·-)"]
    T --> N["N (-·)"]
    T --> M["M (--)"]
</code></pre>

<h3>Exemple pratique</h3>
<p>Pour décoder la séquence point-tiret-point : partez de la racine, suivez la branche "point" vers E, puis la branche "tiret" vers A (depuis E), puis la branche "point" vers R. La lettre est R. Cette navigation est bien plus rapide que de parcourir un tableau alphabétique séquentiellement.</p>

<h3>Erreurs fréquentes</h3>
<ul>
  <li><strong>Erreur :</strong> Croire qu'un code non défini signifie toujours une erreur → <strong>Solution :</strong> Les codes non définis sont délibérément réservés ou inutilisés, seul le contexte détermine s'il s'agit d'une erreur</li>
  <li><strong>Erreur :</strong> Confondre le nombre de codes possibles et le nombre de codes utilisés → <strong>Solution :</strong> 2<sup>n</sup> codes sont <em>possibles</em> pour n symboles, mais un système peut en utiliser seulement une partie</li>
</ul>

<h2>Synthèse</h2>

<p>Ce chapitre a couvert les points essentiels suivants :</p>
<ul>
  <li><strong>Regroupement par longueur</strong> : organiser les codes par nombre de symboles simplifie le décodage et révèle leur structure mathématique</li>
  <li><strong>Doublement systématique</strong> : chaque symbole supplémentaire double le nombre de codes disponibles</li>
  <li><strong>Formule 2<sup>n</sup></strong> : n positions binaires produisent exactement 2<sup>n</sup> combinaisons possibles</li>
  <li><strong>Arbre de décodage</strong> : structure permettant un décodage rapide et sans ambiguïté</li>
  <li><strong>Codes non définis</strong> : un système peut ne pas utiliser tous les codes disponibles, laissant de l'espace pour des extensions futures</li>
</ul>

<p><strong>À retenir :</strong> Les puissances de 2 gouvernent tous les systèmes binaires. Chaque bit ajouté double l'espace de représentation, un principe fondamental qui s'applique à la mémoire, aux encodages et aux protocoles informatiques.</p>

<p><strong>Prochaines étapes :</strong> Le chapitre suivant applique ce même principe au code Braille, montrant comment une grille de 6 positions produit 2<sup>6</sup> = 64 caractères pour représenter l'alphabet entier et les chiffres.</p>