<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Chapter 8 Exceptional Control Flow</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" epub:type="chapter" id="P700049702700000000000000000666E"><header class="pcalibre1 pcalibre2 pcalibre48"><h1 class="pcalibre1 pcalibre2 pcalibre49" data-uri="chapter08.xhtml#P7000497027000000000000000044E58" epub:type="title" id="P7000497027000000000000000044E58"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006670" epub:type="pagebreak" id="P7000497027000000000000000006670" title="721"></span><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre50 pcalibre2">8 </span>Exceptional Control Flow</h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" id="d9e141296">
<nav class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000044E59" epub:type="toc" id="P7000497027000000000000000044E59">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044E5A" id="P7000497027000000000000000044E5A">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E5B" id="P7000497027000000000000000044E5B">
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E5C" id="P7000497027000000000000000044E5C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E5D" id="P7000497027000000000000000044E5D"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP70004970270000000000000000066A6.xhtml#P70004970270000000000000000066A6"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.1 </span>Exceptions 723</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E5E" id="P7000497027000000000000000044E5E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E5F" id="P7000497027000000000000000044E5F"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP70004970270000000000000000067D4.xhtml#P70004970270000000000000000067D4"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.2 </span>Processes 732</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E60" id="P7000497027000000000000000044E60"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E61" id="P7000497027000000000000000044E61"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000683E.xhtml#P700049702700000000000000000683E"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.3 </span>System Call Error Handling 737</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E62" id="P7000497027000000000000000044E62"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E63" id="P7000497027000000000000000044E63"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000685D.xhtml#P700049702700000000000000000685D"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.4 </span>Process Control 738</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E64" id="P7000497027000000000000000044E64"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E65" id="P7000497027000000000000000044E65"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006A2D.xhtml#P7000497027000000000000000006A2D"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.5 </span>Signals 756</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E66" id="P7000497027000000000000000044E66"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E67" id="P7000497027000000000000000044E67"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006DFA.xhtml#P7000497027000000000000000006DFA"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.6 </span>Nonlocal Jumps 781</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E68" id="P7000497027000000000000000044E68"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E69" id="P7000497027000000000000000044E69"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006E64.xhtml#P7000497027000000000000000006E64"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.7 </span>Tools for Manipulating Processes 786</span></a></p></li>
</ol>
</div>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044E6A" id="P7000497027000000000000000044E6A">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E6B" id="P7000497027000000000000000044E6B">
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter08.xhtml#P7000497027000000000000000044E6C" id="P7000497027000000000000000044E6C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E6D" id="P7000497027000000000000000044E6D"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006E75.xhtml#P7000497027000000000000000006E75"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.8 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary</span> 787</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter08.xhtml#P7000497027000000000000000044E6E" id="P7000497027000000000000000044E6E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E6F" id="P7000497027000000000000000044E6F"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006E7E.xhtml#P7000497027000000000000000006E7E"><span class="pcalibre1 pcalibre2" epub:type="title">Bibliographic Notes 787</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter08.xhtml#P7000497027000000000000000044E70" id="P7000497027000000000000000044E70"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E71" id="P7000497027000000000000000044E71"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006E81.xhtml#P7000497027000000000000000006E81"><span class="pcalibre1 pcalibre2" epub:type="title">Homework Problems 788</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter08.xhtml#P7000497027000000000000000044E72" id="P7000497027000000000000000044E72"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E73" id="P7000497027000000000000000044E73"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006F9A"><span class="pcalibre1 pcalibre2" epub:type="title">Solutions to Practice Problems 795</span></a></p></li>
</ol>
</div>
</nav>
<section class="pcalibre1 pcalibre2 pcalibre51" data-uri="chapter08.xhtml#P7000497027000000000000000044E74" epub:type="introduction" id="P7000497027000000000000000044E74">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E75" id="P7000497027000000000000000044E75"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000668E" epub:type="pagebreak" id="P700049702700000000000000000668E" title="722"></span>From the time you first apply power to a processor until the time you shut it off, the program counter assumes a sequence of values</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter08.xhtml#P7000497027000000000000000044E76" id="P7000497027000000000000000044E76">
<m:math altimg="../images/ch08-eq1.png" altimg-height="15" altimg-width="140" alttext="" data-uri="" display="block"><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mn>...</m:mn><m:mo>,</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E77" id="P7000497027000000000000000044E77">where each <i class="pcalibre17 pcalibre2 pcalibre1">a<sub class="pcalibre1 pcalibre2 pcalibre241">k</sub></i> is the address of some corresponding instruction <i class="pcalibre17 pcalibre2 pcalibre1">I<sub class="pcalibre1 pcalibre2 pcalibre241">k</sub></i>. Each transition from <i class="pcalibre17 pcalibre2 pcalibre1">a<sub class="pcalibre1 pcalibre2 pcalibre241">k</sub></i> to <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 pcalibre241"><var class="pcalibre17 pcalibre2 pcalibre1">k</var>+1</sub> is called a <i class="pcalibre17 pcalibre2 pcalibre1">control transfer</i>. A sequence of such control transfers is called the <i class="pcalibre17 pcalibre2 pcalibre1">flow of control</i>, or <i class="pcalibre17 pcalibre2 pcalibre1">control flow</i>, of the processor.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E78" id="P7000497027000000000000000044E78">The simplest kind of control flow is a “smooth” sequence where each <var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 pcalibre241"><var class="pcalibre17 pcalibre2 pcalibre1">k</var></sub> and <var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 pcalibre241"><var class="pcalibre17 pcalibre2 pcalibre1">k</var>+1</sub> are adjacent in memory. Typically, abrupt changes to this smooth flow, where <var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 pcalibre241"><var class="pcalibre17 pcalibre2 pcalibre1">k</var>+1</sub> is not adjacent to <i class="pcalibre17 pcalibre2 pcalibre1">I<sub class="pcalibre1 pcalibre2 pcalibre241">k</sub></i>, are caused by familiar program instructions such as jumps, calls, and returns. Such instructions are necessary mechanisms that allow programs to react to changes in internal program state represented by program variables.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E79" id="P7000497027000000000000000044E79">But systems must also be able to react to changes in system state that are not captured by internal program variables and are not necessarily related to the execution of the program. For example, a hardware timer goes off at regular intervals and must be dealt with. Packets arrive at the network adapter and must be stored in memory. Programs request data from a disk and then sleep until they are notified that the data are ready. Parent processes that create child processes must be notified when their children terminate.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E7A" id="P7000497027000000000000000044E7A">Modern systems react to these situations by making abrupt changes in the control flow. In general, we refer to these abrupt changes as <i class="pcalibre17 pcalibre2 pcalibre1">exceptional control flow (ECF</i>). ECF occurs at all levels of a computer system. For example, at the hardware level, events detected by the hardware trigger abrupt control transfers to exception handlers. At the operating systems level, the kernel transfers control from one user process to another via context switches. At the application level, a process can send a <i class="pcalibre17 pcalibre2 pcalibre1">signal</i> to another process that abruptly transfers control to a signal handler in the recipient. An individual program can react to errors by sidestepping the usual stack discipline and making nonlocal jumps to arbitrary locations in other functions.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E7B" id="P7000497027000000000000000044E7B">As programmers, there are a number of reasons why it is important for you to understand ECF:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E7C" id="P7000497027000000000000000044E7C">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E7D" id="P7000497027000000000000000044E7D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E7E" id="P7000497027000000000000000044E7E"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding ECF will help you understand important systems concepts. </span>ECF is the basic mechanism that operating systems use to implement I/O, processes, and virtual memory. Before you can really understand these important ideas, you need to understand ECF.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E7F" id="P7000497027000000000000000044E7F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E80" id="P7000497027000000000000000044E80"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding ECF will help you understand how applications interact with the operating system. </span>Applications request services from the operating system by using a form of ECF known as a <i class="pcalibre17 pcalibre2 pcalibre1">trap</i> or <i class="pcalibre17 pcalibre2 pcalibre1">system call</i>. For example, writing data to a disk, reading data from a network, creating a new process, and terminating the current process are all accomplished by application programs invoking system calls. Understanding the basic system call mechanism will help you understand how these services are provided to applications.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E81" id="P7000497027000000000000000044E81"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E82" id="P7000497027000000000000000044E82"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding ECF will help you write interesting new application programs. </span>The operating system provides application programs with powerful ECF <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000669C" epub:type="pagebreak" id="P700049702700000000000000000669C" title="723"></span>mechanisms for creating new processes, waiting for processes to terminate, notifying other processes of exceptional events in the system, and detecting and responding to these events. If you understand these ECF mechanisms, then you can use them to write interesting programs such as Unix shells and Web servers.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E83" id="P7000497027000000000000000044E83"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E84" id="P7000497027000000000000000044E84"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding ECF will help you understand concurrency. </span>ECF is a basic mechanism for implementing concurrency in computer systems. The following are all examples of concurrency in action: an exception handler that interrupts the execution of an application program; processes and threads whose execution overlap in time; and a signal handler that interrupts the execution of an application program. Understanding ECF is a first step to understanding concurrency. We will return to study it in more detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">12</span></a>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E85" id="P7000497027000000000000000044E85"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E86" id="P7000497027000000000000000044E86"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding ECF will help you understand how software exceptions work. </span>Languages such as C++ and Java provide software exception mechanisms via <code class="pcalibre52 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E87" id="P7000497027000000000000000044E87">try, catch</code>, and <code class="pcalibre52 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E88" id="P7000497027000000000000000044E88">throw</code> statements. Software exceptions allow the program to make <i class="pcalibre17 pcalibre2 pcalibre1">nonlocal</i> jumps (i.e., jumps that violate the usual call/return stack discipline) in response to error conditions. Nonlocal jumps are a form of application-level ECF and are provided in C via the <code class="pcalibre52 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E89" id="P7000497027000000000000000044E89">setjmp</code> and <code class="pcalibre52 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E8A" id="P7000497027000000000000000044E8A">longjmp</code> functions. Understanding these low-level functions will help you understand how higher-level software exceptions can be implemented.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E8B" id="P7000497027000000000000000044E8B">Up to this point in your study of systems, you have learned how applications interact with the hardware. This chapter is pivotal in the sense that you will begin to learn how your applications interact with the operating system. Interestingly, these interactions all revolve around ECF. We describe the various forms of ECF that exist at all levels of a computer system. We start with exceptions, which lie at the intersection of the hardware and the operating system. We also discuss system calls, which are exceptions that provide applications with entry points into the operating system. We then move up a level of abstraction and describe processes and signals, which lie at the intersection of applications and the operating system. Finally, we discuss nonlocal jumps, which are an application-level form of ECF.</p>
</section>
</section>
<!--EOF:P70004970270000000000000000066A6-->
<!--EOF:P70004970270000000000000000067D4-->
<!--EOF:P700049702700000000000000000683E-->
<!--EOF:P700049702700000000000000000685D-->
<!--EOF:P7000497027000000000000000006A2D-->
<!--EOF:P7000497027000000000000000006DFA-->
<!--EOF:P7000497027000000000000000006E64-->
<!--EOF:P7000497027000000000000000006E75-->
<!--EOF:P7000497027000000000000000006E7E-->
<!--EOF:P7000497027000000000000000006E81-->
<!--EOF:P7000497027000000000000000006F9A-->
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>8.1 Exceptions</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P70004970270000000000000000066A6"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044E8C" epub:type="title" id="P7000497027000000000000000044E8C"><span class="pcalibre1 pcalibre21 pcalibre2">8.1 </span>Exceptions</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E8D" id="P7000497027000000000000000044E8D">Exceptions are a form of exceptional control flow that are implemented partly by the hardware and partly by the operating system. Because they are partly implemented in hardware, the details vary from system to system. However, the basic ideas are the same for every system. Our aim in this section is to give you a general understanding of exceptions and exception handling and to help demystify what is often a confusing aspect of modern computer systems.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E8E" id="P7000497027000000000000000044E8E">An <i class="pcalibre17 pcalibre2 pcalibre1">exception</i> is an abrupt change in the control flow in response to some change in the processor's state. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000066B1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.1</span></a> shows the basic idea.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E8F" id="P7000497027000000000000000044E8F">In the figure, the processor is executing some current instruction <var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 calibre14">curr</sub> when a significant change in the processor's <i class="pcalibre17 pcalibre2 pcalibre1">state</i> occurs. The state is encoded in various bits and signals inside the processor. The change in state is known as an <i class="pcalibre17 pcalibre2 pcalibre1">event</i>.</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E90" id="P7000497027000000000000000044E90"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter08.xhtml#P7000497027000000000000000044E91" epub:type="title" id="P7000497027000000000000000044E91"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000066AD" epub:type="pagebreak" id="P70004970270000000000000000066AD" title="724"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Hardware versus software exceptions</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E92" id="P7000497027000000000000000044E92">C++ and Java programmers will have noticed that the term “exception” is also used to describe the application-level ECF mechanism provided by C++ and Java in the form of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E93" id="P7000497027000000000000000044E93">catch, throw</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E94" id="P7000497027000000000000000044E94">try</code> statements. If we wanted to be perfectly clear, we might distinguish between “hardware” and “software” exceptions, but this is usually unnecessary because the meaning is clear from the context.</p>
</aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000066B1" id="P70004970270000000000000000066B1">
<img alt="A diagram illustrates an exception." class="pcalibre1 pcalibre2 pcalibre242" data-uri="P700049702700000000000000000B760" id="P7000497027000000000000000044E95" src="Images/chapter-07-image-01.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044E96" id="P7000497027000000000000000044E96"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044E97" epub:type="title" id="P7000497027000000000000000044E97"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.1 </span>Anatomy of an exception.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044E98" id="P7000497027000000000000000044E98"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E99" id="P7000497027000000000000000044E99"> A change in the processor's state (an event) triggers an abrupt control transfer (an exception) from the application program to an exception handler. After it finishes processing, the handler either returns control to the interrupted program or aborts.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P70004970270000000000000000251B5" id="P70004970270000000000000000251B5">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E9A" id="P7000497027000000000000000044E9A">A diagram has an arrow pointing down from Application program to I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>, an arrow representing exception pointing right, below exception handler, an arrow pointing down representing exception processing, an arrow representing exception return (optional) pointing below Icurr to I<sub class="pcalibre1 pcalibre2 calibre14">next</sub>, and then another arrow pointing down. The event occurs between I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub> and I<sub class="pcalibre1 pcalibre2 calibre14">next</sub>.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E9B" id="P7000497027000000000000000044E9B">The event might be directly related to the execution of the current instruction. For example, a virtual memory page fault occurs, an arithmetic overflow occurs, or an instruction attempts a divide by zero. On the other hand, the event might be unrelated to the execution of the current instruction. For example, a system timer goes off or an I/O request completes.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E9C" id="P7000497027000000000000000044E9C">In any case, when the processor detects that the event has occurred, it makes an indirect procedure call (the exception), through a jump table called an <i class="pcalibre17 pcalibre2 pcalibre1">exception table</i>, to an operating system subroutine (the <i class="pcalibre17 pcalibre2 pcalibre1">exception handler</i>) that is specifically designed to process this particular kind of event. When the exception handler finishes processing, one of three things happens, depending on the type of event that caused the exception:</p>
<ol class="pcalibre1 calibre19 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E9D" id="P7000497027000000000000000044E9D">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E9E" id="P7000497027000000000000000044E9E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E9F" id="P7000497027000000000000000044E9F">The handler returns control to the current instruction <var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 calibre14">curr</sub>, the instruction that was executing when the event occurred.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EA0" id="P7000497027000000000000000044EA0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EA1" id="P7000497027000000000000000044EA1">The handler returns control to <var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 calibre14">next</sub>, the instruction that would have executed next had the exception not occurred.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EA2" id="P7000497027000000000000000044EA2"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EA3" id="P7000497027000000000000000044EA3">The handler aborts the interrupted program.</p></li>
</ol>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EA4" id="P7000497027000000000000000044EA4"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000066E1"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.1.2</span></a> says more about these possibilities.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000066C1" id="P70004970270000000000000000066C1"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EA5" epub:type="title" id="P7000497027000000000000000044EA5"><span class="pcalibre1 pcalibre21 pcalibre2">8.1.1  </span>Exception Handling</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EA6" id="P7000497027000000000000000044EA6">Exceptions can be difficult to understand because handling them involves close cooperation between hardware and software. It is easy to get confused about</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000066C4" id="P70004970270000000000000000066C4">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000066C5" epub:type="pagebreak" id="P70004970270000000000000000066C5" title="725"></span><img alt="A diagram shows an exception table with entries 0, 1, 2,…n minus 1, from top to bottom, containing code for exception handler 0 through code for exception handler n minus 1." class="pcalibre1 pcalibre2 pcalibre243" data-uri="P700049702700000000000000000B761" id="P7000497027000000000000000044EA7" src="Images/chapter-07-image-02.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044EA8" id="P7000497027000000000000000044EA8"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044EA9" epub:type="title" id="P7000497027000000000000000044EA9"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.2 </span>Exception table.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EAA" id="P7000497027000000000000000044EAA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EAB" id="P7000497027000000000000000044EAB"> The exception table is a jump table where entry <var class="pcalibre17 pcalibre2 pcalibre1">k</var> contains the address of the handler code for exception <var class="pcalibre17 pcalibre2 pcalibre1">k</var>.</p></div>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000066CB" id="P70004970270000000000000000066CB">
<img alt="A diagram illustrates generating the address of an exception handler." class="pcalibre244 pcalibre1 pcalibre2" data-uri="P700049702700000000000000000B762" id="P7000497027000000000000000044EAC" src="Images/chapter-07-image-03.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044EAD" id="P7000497027000000000000000044EAD"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044EAE" epub:type="title" id="P7000497027000000000000000044EAE"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.3 </span>Generating the address of an exception handler.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044EAF" id="P7000497027000000000000000044EAF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EB0" id="P7000497027000000000000000044EB0">The exception number is an index into the exception table.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P70004970270000000000000000251CD" id="P70004970270000000000000000251CD">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EB1" id="P7000497027000000000000000044EB1">A diagram shows an exception table with an arrow pointing to the top of entry 2. The arrow, representing address of entry for exception # k, extends from +, which has arrows from exception table base register and exception number (x 8).</p>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EB2" id="P7000497027000000000000000044EB2">which component performs which task. Let's look at the division of labor between hardware and software in more detail.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EB3" id="P7000497027000000000000000044EB3">Each type of possible exception in a system is assigned a unique nonnegative integer <i class="pcalibre17 pcalibre2 pcalibre1">exception number</i>. Some of these numbers are assigned by the designers of the processor. Other numbers are assigned by the designers of the operating system <i class="pcalibre17 pcalibre2 pcalibre1">kernel</i> (the memory-resident part of the operating system). Examples of the former include divide by zero, page faults, memory access violations, breakpoints, and arithmetic overflows. Examples of the latter include system calls and signals from external I/O devices.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EB4" id="P7000497027000000000000000044EB4">At system boot time (when the computer is reset or powered on), the operating system allocates and initializes a jump table called an <i class="pcalibre17 pcalibre2 pcalibre1">exception table</i>, so that entry <var class="pcalibre17 pcalibre2 pcalibre1">k</var> contains the address of the handler for exception <var class="pcalibre17 pcalibre2 pcalibre1">k</var>. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000066C4"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.2</span></a> shows the format of an exception table.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EB5" id="P7000497027000000000000000044EB5">At run time (when the system is executing some program), the processor detects that an event has occurred and determines the corresponding exception number <var class="pcalibre17 pcalibre2 pcalibre1">k</var>. The processor then triggers the exception by making an indirect procedure call, through entry <var class="pcalibre17 pcalibre2 pcalibre1">k</var> of the exception table, to the corresponding handler. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000066CB"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.3</span></a> shows how the processor uses the exception table to form the address of the appropriate exception handler. The exception number is an index into the exception table, whose starting address is contained in a special CPU register called the <i class="pcalibre17 pcalibre2 pcalibre1">exception table base register</i>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EB6" id="P7000497027000000000000000044EB6">An exception is akin to a procedure call, but with some important differences:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EB7" id="P7000497027000000000000000044EB7">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EB8" id="P7000497027000000000000000044EB8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EB9" id="P7000497027000000000000000044EB9">As with a procedure call, the processor pushes a return address on the stack before branching to the handler. However, depending on the class of exception, the return address is either the current instruction (the instruction that <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000066D9" epub:type="pagebreak" id="P70004970270000000000000000066D9" title="726"></span>was executing when the event occurred) or the next instruction (the instruction that would have executed after the current instruction had the event not occurred).</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EBA" id="P7000497027000000000000000044EBA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EBB" id="P7000497027000000000000000044EBB">The processor also pushes some additional processor state onto the stack that will be necessary to restart the interrupted program when the handler returns. For example, an x86-64 system pushes the EFLAGS register containing the current condition codes, among other things, onto the stack.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EBC" id="P7000497027000000000000000044EBC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EBD" id="P7000497027000000000000000044EBD">When control is being transferred from a user program to the kernel, all of these items are pushed onto the kernel's stack rather than onto the user's stack.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EBE" id="P7000497027000000000000000044EBE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EBF" id="P7000497027000000000000000044EBF">Exception handlers run in <i class="pcalibre17 pcalibre2 pcalibre1">kernel mode</i> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000067D4.xhtml#P7000497027000000000000000006816"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.2.4</span></a>), which means they have complete access to all system resources.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EC0" id="P7000497027000000000000000044EC0">Once the hardware triggers the exception, the rest of the work is done in software by the exception handler. After the handler has processed the event, it optionally returns to the interrupted program by executing a special “return from interrupt” instruction, which pops the appropriate state back into the processor's control and data registers, restores the state to <i class="pcalibre17 pcalibre2 pcalibre1">user mode</i> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000067D4.xhtml#P7000497027000000000000000006816"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.2.4</span></a>) if the exception interrupted a user program, and then returns control to the interrupted program.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000066E1" id="P70004970270000000000000000066E1"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EC1" epub:type="title" id="P7000497027000000000000000044EC1"><span class="pcalibre1 pcalibre21 pcalibre2">8.1.2  </span>Classes of Exceptions</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EC2" id="P7000497027000000000000000044EC2">Exceptions can be divided into four classes: <i class="pcalibre17 pcalibre2 pcalibre1">interrupts</i>, <i class="pcalibre17 pcalibre2 pcalibre1">traps</i>, <i class="pcalibre17 pcalibre2 pcalibre1">faults</i>, and <i class="pcalibre17 pcalibre2 pcalibre1">aborts</i>. The table in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000066E8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.4</span></a> summarizes the attributes of these classes.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000066E4" id="P70004970270000000000000000066E4"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EC3" epub:type="title" id="P7000497027000000000000000044EC3">Interrupts</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EC4" id="P7000497027000000000000000044EC4"><i class="pcalibre17 pcalibre2 pcalibre1">Interrupts</i> occur <i class="pcalibre17 pcalibre2 pcalibre1">asynchronously</i> as a result of signals from I/O devices that are external to the processor. Hardware interrupts are asynchronous in the sense that they are not caused by the execution of any particular instruction. Exception handlers for hardware interrupts are often called <i class="pcalibre17 pcalibre2 pcalibre1">interrupt handlers</i>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EC5" id="P7000497027000000000000000044EC5"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006702"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5 </span></a>summarizes the processing for an interrupt. I/O devices such as network adapters, disk controllers, and timer chips trigger interrupts by signaling a pin on the processor chip and placing onto the system bus the exception number that identifies the device that caused the interrupt.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000066E8" id="P70004970270000000000000000066E8">
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter08.xhtml#P7000497027000000000000000044EC6" id="P7000497027000000000000000044EC6">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044EC7" id="P7000497027000000000000000044EC7">Class</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044EC8" id="P7000497027000000000000000044EC8">Cause</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044EC9" id="P7000497027000000000000000044EC9">Async/sync</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044ECA" id="P7000497027000000000000000044ECA">Return behavior</th></tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ECB" id="P7000497027000000000000000044ECB">Interrupt</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ECC" id="P7000497027000000000000000044ECC">Signal from I/O device</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ECD" id="P7000497027000000000000000044ECD">Async</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ECE" id="P7000497027000000000000000044ECE">Always returns to next instruction</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ECF" id="P7000497027000000000000000044ECF">Trap</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ED0" id="P7000497027000000000000000044ED0">Intentional exception</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ED1" id="P7000497027000000000000000044ED1">Sync</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ED2" id="P7000497027000000000000000044ED2">Always returns to next instruction</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ED3" id="P7000497027000000000000000044ED3">Fault</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ED4" id="P7000497027000000000000000044ED4">Potentially recoverable error</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ED5" id="P7000497027000000000000000044ED5">Sync</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ED6" id="P7000497027000000000000000044ED6">Might return to current instruction</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ED7" id="P7000497027000000000000000044ED7">Abort</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ED8" id="P7000497027000000000000000044ED8">Nonrecoverable error</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044ED9" id="P7000497027000000000000000044ED9">Sync</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044EDA" id="P7000497027000000000000000044EDA">Never returns</td></tr>
</tbody>
</table>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044EDB" id="P7000497027000000000000000044EDB"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044EDC" epub:type="title" id="P7000497027000000000000000044EDC"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.4 </span>Classes of exceptions.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EDD" id="P7000497027000000000000000044EDD"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EDE" id="P7000497027000000000000000044EDE">Asynchronous exceptions occur as a result of events in I/O devices that are external to the processor. Synchronous exceptions occur as a direct result of executing an instruction.</p></div>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006702" id="P7000497027000000000000000006702">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006703" epub:type="pagebreak" id="P7000497027000000000000000006703" title="727"></span><img alt="A diagram illustrates steps in interrupt handling." class="pcalibre245 pcalibre2 pcalibre1" data-uri="P700049702700000000000000000B49D" id="P7000497027000000000000000044EDF" src="Images/chapter-07-image-04.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044EE0" id="P7000497027000000000000000044EE0"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044EE1" epub:type="title" id="P7000497027000000000000000044EE1"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.5 </span>Interrupt handling.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044EE2" id="P7000497027000000000000000044EE2"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EE3" id="P7000497027000000000000000044EE3">The interrupt handler returns control to the next instruction in the application program's control flow.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P7000497027000000000000000025201" id="P7000497027000000000000000025201">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EE4" id="P7000497027000000000000000044EE4">Steps in interrupt handling are summarized below.</p>
<ol class="pcalibre75 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EE5" id="P7000497027000000000000000044EE5">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EE6" id="P7000497027000000000000000044EE6"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EE7" id="P7000497027000000000000000044EE7">Interrupt pin goes high during execution of current instruction (arrow pointing down to I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EE8" id="P7000497027000000000000000044EE8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EE9" id="P7000497027000000000000000044EE9">Control passes to handler after current instruction finishes (arrow pointing right from I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EEA" id="P7000497027000000000000000044EEA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EEB" id="P7000497027000000000000000044EEB">Interrupt handler runs (arrow pointing down)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EEC" id="P7000497027000000000000000044EEC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EED" id="P7000497027000000000000000044EED">Handler returns to next instruction (arrow back to I<sub class="pcalibre1 pcalibre2 calibre14">next</sub>, below I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
</ol>
</details>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006709" id="P7000497027000000000000000006709">
<img alt="A diagram illustrates steps in trap handling." class="pcalibre1 pcalibre246 pcalibre2" data-uri="P700049702700000000000000000B763" id="P7000497027000000000000000044EEE" src="Images/chapter-07-image-05.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044EEF" id="P7000497027000000000000000044EEF"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044EF0" epub:type="title" id="P7000497027000000000000000044EF0"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.6 </span>Trap handling.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044EF1" id="P7000497027000000000000000044EF1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EF2" id="P7000497027000000000000000044EF2">The trap handler returns control to the next instruction in the application program's control flow.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P7000497027000000000000000025211" id="P7000497027000000000000000025211">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EF3" id="P7000497027000000000000000044EF3">Steps in interrupt handling are summarized below.</p>
<ol class="pcalibre75 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EF4" id="P7000497027000000000000000044EF4">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EF5" id="P7000497027000000000000000044EF5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EF6" id="P7000497027000000000000000044EF6">Application makes a system call (arrow pointing down to syscall)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EF7" id="P7000497027000000000000000044EF7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EF8" id="P7000497027000000000000000044EF8">Control passes to handler (arrow pointing right from syscall)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EF9" id="P7000497027000000000000000044EF9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EFA" id="P7000497027000000000000000044EFA">Trap handler runs (arrow pointing down)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044EFB" id="P7000497027000000000000000044EFB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044EFC" id="P7000497027000000000000000044EFC">Handler returns to instruction following the syscall (arrow back to I<sub class="pcalibre1 pcalibre2 calibre14">next</sub>, below syscall)</p></li>
</ol>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EFD" id="P7000497027000000000000000044EFD">After the current instruction finishes executing, the processor notices that the interrupt pin has gone high, reads the exception number from the system bus, and then calls the appropriate interrupt handler. When the handler returns, it returns control to the next instruction (i.e., the instruction that would have followed the current instruction in the control flow had the interrupt not occurred). The effect is that the program continues executing as though the interrupt had never happened.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EFE" id="P7000497027000000000000000044EFE">The remaining classes of exceptions (traps, faults, and aborts) occur <i class="pcalibre17 pcalibre2 pcalibre1">synchronously</i> as a result of executing the current instruction. We refer to this instruction as the <i class="pcalibre17 pcalibre2 pcalibre1">faulting instruction</i>.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006711" id="P7000497027000000000000000006711"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044EFF" epub:type="title" id="P7000497027000000000000000044EFF">Traps and System Calls</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F00" id="P7000497027000000000000000044F00"><i class="pcalibre17 pcalibre2 pcalibre1">Traps</i> are <i class="pcalibre17 pcalibre2 pcalibre1">intentional</i> exceptions that occur as a result of executing an instruction. Like interrupt handlers, trap handlers return control to the next instruction. The most important use of traps is to provide a procedure-like interface between user programs and the kernel, known as a <i class="pcalibre17 pcalibre2 pcalibre1">system call</i>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F01" id="P7000497027000000000000000044F01">User programs often need to request services from the kernel such as reading a file (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F02" id="P7000497027000000000000000044F02">read</code>), creating a new process (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F03" id="P7000497027000000000000000044F03">fork</code>), loading a new program (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F04" id="P7000497027000000000000000044F04">execve</code>), and terminating the current process (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F05" id="P7000497027000000000000000044F05">exit</code>). To allow controlled access to such kernel services, processors provide a special <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F06" id="P7000497027000000000000000044F06">syscall</code> <var class="pcalibre17 pcalibre2 pcalibre1">n</var> instruction that user programs can execute when they want to request service <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. Executing the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F07" id="P7000497027000000000000000044F07">syscall</code> instruction causes a trap to an exception handler that decodes the argument and calls the appropriate kernel routine. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006709"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.6</span></a> summarizes the processing for a system call.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F08" id="P7000497027000000000000000044F08">From a programmer's perspective, a system call is identical to a regular function call. However, their implementations are quite different. Regular functions</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P700049702700000000000000000671C" id="P700049702700000000000000000671C">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000671D" epub:type="pagebreak" id="P700049702700000000000000000671D" title="728"></span><img alt="A diagram illustrates steps in fault handling." class="pcalibre1 pcalibre2 calibre63" data-uri="P700049702700000000000000000B764" id="P7000497027000000000000000044F09" src="Images/chapter-07-image-06.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044F0A" id="P7000497027000000000000000044F0A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044F0B" epub:type="title" id="P7000497027000000000000000044F0B"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.7 </span>Fault handling.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F0C" id="P7000497027000000000000000044F0C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044F0D" id="P7000497027000000000000000044F0D">Depending on whether the fault can be repaired or not, the fault handler either re-executes the faulting instruction or aborts.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P700049702700000000000000002522D" id="P700049702700000000000000002522D">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F0E" id="P7000497027000000000000000044F0E">Steps in fault handling are summarized below.</p>
<ol class="pcalibre75 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F0F" id="P7000497027000000000000000044F0F">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F10" id="P7000497027000000000000000044F10"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044F11" id="P7000497027000000000000000044F11">Current instruction causes a fault (arrow pointing down to I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F12" id="P7000497027000000000000000044F12"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044F13" id="P7000497027000000000000000044F13">Control passes to handler (arrow pointing right from I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F14" id="P7000497027000000000000000044F14"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044F15" id="P7000497027000000000000000044F15">Fault handler runs (arrow pointing down)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F16" id="P7000497027000000000000000044F16"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044F17" id="P7000497027000000000000000044F17">Handler either re-executes current instruction (arrow pointing back to I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>) or aborts (arrow pointing right to abort)</p></li>
</ol>
</details>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006723" id="P7000497027000000000000000006723">
<img alt="A diagram illustrates steps in abort handling." class="pcalibre1 calibre64 pcalibre2" data-uri="P700049702700000000000000000B765" id="P7000497027000000000000000044F18" src="Images/chapter-07-image-07.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044F19" id="P7000497027000000000000000044F19"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044F1A" epub:type="title" id="P7000497027000000000000000044F1A"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.8 </span>Abort handling.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F1B" id="P7000497027000000000000000044F1B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044F1C" id="P7000497027000000000000000044F1C">The abort handler passes control to a kernel <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F1D" id="P7000497027000000000000000044F1D">abort</code> routine that terminates the application program.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P700049702700000000000000002523E" id="P700049702700000000000000002523E">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F1E" id="P7000497027000000000000000044F1E">Steps in fault handling are summarized below.</p>
<ol class="pcalibre75 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F1F" id="P7000497027000000000000000044F1F">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F20" id="P7000497027000000000000000044F20"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044F21" id="P7000497027000000000000000044F21">Fatal hardware error occurs (arrow pointing down to I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F22" id="P7000497027000000000000000044F22"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044F23" id="P7000497027000000000000000044F23">Control passes to handler (arrow pointing right from I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F24" id="P7000497027000000000000000044F24"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044F25" id="P7000497027000000000000000044F25">Abort handler runs (arrow pointing down)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F26" id="P7000497027000000000000000044F26"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044F27" id="P7000497027000000000000000044F27">Handler returns to abort routine (arrow pointing right to abort)</p></li>
</ol>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F28" id="P7000497027000000000000000044F28">run in <i class="pcalibre17 pcalibre2 pcalibre1">user mode</i>, which restricts the types of instructions they can execute, and they access the same stack as the calling function. A system call runs in <i class="pcalibre17 pcalibre2 pcalibre1">kernel mode</i>, which allows it to execute privileged instructions and access a stack defined in the kernel. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000067D4.xhtml#P7000497027000000000000000006816"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.2.4</span></a> discusses user and kernel modes in more detail.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P700049702700000000000000000672B" id="P700049702700000000000000000672B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F29" epub:type="title" id="P7000497027000000000000000044F29">Faults</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F2A" id="P7000497027000000000000000044F2A">Faults result from error conditions that a handler might be able to correct. When a fault occurs, the processor transfers control to the fault handler. If the handler is able to correct the error condition, it returns control to the faulting instruction, thereby re-executing it. Otherwise, the handler returns to an <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F2B" id="P7000497027000000000000000044F2B">abort</code> routine in the kernel that terminates the application program that caused the fault. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000671C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.7 </span></a>summarizes the processing for a fault.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F2C" id="P7000497027000000000000000044F2C">A classic example of a fault is the page fault exception, which occurs when an instruction references a virtual address whose corresponding page is not resident in memory and must therefore be retrieved from disk. As we will see in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">9</span></a>, a page is a contiguous block (typically 4 KB) of virtual memory. The page fault handler loads the appropriate page from disk and then returns control to the instruction that caused the fault. When the instruction executes again, the appropriate page is now resident in memory and the instruction is able to run to completion without faulting.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006730" id="P7000497027000000000000000006730"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F2D" epub:type="title" id="P7000497027000000000000000044F2D">Aborts</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F2E" id="P7000497027000000000000000044F2E">Aborts result from unrecoverable fatal errors, typically hardware errors such as parity errors that occur when DRAM or SRAM bits are corrupted. Abort handlers never return control to the application program. As shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006723"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.8</span></a>, the handler returns control to an <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F2F" id="P7000497027000000000000000044F2F">abort</code> routine that terminates the application program.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006734" id="P7000497027000000000000000006734">
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter08.xhtml#P7000497027000000000000000044F30" id="P7000497027000000000000000044F30">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044F31" id="P7000497027000000000000000044F31"><span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter08.xhtml#P7000497027000000000000000006737" epub:type="pagebreak" id="P7000497027000000000000000006737" title="729"></span>Exception number</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044F32" id="P7000497027000000000000000044F32">Description</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044F33" id="P7000497027000000000000000044F33">Exception class</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F34" id="P7000497027000000000000000044F34">0</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F35" id="P7000497027000000000000000044F35">Divide error</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F36" id="P7000497027000000000000000044F36">Fault</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F37" id="P7000497027000000000000000044F37">13</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F38" id="P7000497027000000000000000044F38">General protection fault</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F39" id="P7000497027000000000000000044F39">Fault</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F3A" id="P7000497027000000000000000044F3A">14</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F3B" id="P7000497027000000000000000044F3B">Page fault</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F3C" id="P7000497027000000000000000044F3C">Fault</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F3D" id="P7000497027000000000000000044F3D">18</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F3E" id="P7000497027000000000000000044F3E">Machine check</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F3F" id="P7000497027000000000000000044F3F">Abort</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F40" id="P7000497027000000000000000044F40">32-255</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F41" id="P7000497027000000000000000044F41">OS-defined exceptions</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F42" id="P7000497027000000000000000044F42">Interrupt or trap</td></tr>
</tbody>
</table>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044F43" id="P7000497027000000000000000044F43"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044F44" epub:type="title" id="P7000497027000000000000000044F44"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.9 </span>Examples of exceptions in x86-64 systems.</h1></header>
</figcaption>
</figure>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P700049702700000000000000000674B" id="P700049702700000000000000000674B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F45" epub:type="title" id="P7000497027000000000000000044F45"><span class="pcalibre1 pcalibre21 pcalibre2">8.1.3  </span>Exceptions in Linux/x86-64 Systems</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F46" id="P7000497027000000000000000044F46">To help make things more concrete, let's look at some of the exceptions defined for x86-64 systems. There are up to 256 different exception types [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B406">50</a>]. Numbers in the range from 0 to 31 correspond to exceptions that are defined by the Intel architects and thus are identical for any x86-64 system. Numbers in the range from 32 to 255 correspond to interrupts and traps that are defined by the operating system. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006734"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.9 </span></a>shows a few examples.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P700049702700000000000000000674E" id="P700049702700000000000000000674E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F47" epub:type="title" id="P7000497027000000000000000044F47">Linux/x86-64 Faults and Aborts</h1></header>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F48" id="P7000497027000000000000000044F48">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F49" id="P7000497027000000000000000044F49"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000044F4A" id="P7000497027000000000000000044F4A"><span class="pcalibre1 pcalibre2 pcalibre41">Divide error. </span>A divide error (exception 0) occurs when an application attempts to divide by zero or when the result of a divide instruction is too big for the destination operand. Unix does not attempt to recover from divide errors, opting instead to abort the program. Linux shells typically report divide errors as “Floating exceptions.”</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F4B" id="P7000497027000000000000000044F4B"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000044F4C" id="P7000497027000000000000000044F4C"><span class="pcalibre1 pcalibre2 pcalibre41">General protection fault. </span>The infamous general protection fault (exception 13) occurs for many reasons, usually because a program references an undefined area of virtual memory or because the program attempts to write to a read-only text segment. Linux does not attempt to recover from this fault. Linux shells typically report general protection faults as “Segmentation faults.”</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F4D" id="P7000497027000000000000000044F4D"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000044F4E" id="P7000497027000000000000000044F4E"><span class="pcalibre1 pcalibre2 pcalibre41">Page fault. </span>A page fault (exception 14) is an example of an exception where the faulting instruction is restarted. The handler maps the appropriate page of virtual memory on disk into a page of physical memory and then restarts the faulting instruction. We will see how page faults work in detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">9</span></a>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044F4F" id="P7000497027000000000000000044F4F"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000044F50" id="P7000497027000000000000000044F50"><span class="pcalibre1 pcalibre2 pcalibre41">Machine check. </span>A machine check (exception 18) occurs as a result of a fatal hardware error that is detected during the execution of the faulting instruction. Machine check handlers never return control to the application program.</p></li>
</ul>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006759" id="P7000497027000000000000000006759"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F51" epub:type="title" id="P7000497027000000000000000044F51">Linux/x86-64 System Calls</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F52" id="P7000497027000000000000000044F52">Linux provides hundreds of system calls that application programs use when they want to request services from the kernel, such as reading a file, writing a file, and</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P700049702700000000000000000675C" id="P700049702700000000000000000675C">
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter08.xhtml#P7000497027000000000000000044F53" id="P7000497027000000000000000044F53">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044F54" id="P7000497027000000000000000044F54"><span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter08.xhtml#P700049702700000000000000000675F" epub:type="pagebreak" id="P700049702700000000000000000675F" title="730"></span>
Number</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044F55" id="P7000497027000000000000000044F55">Name</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044F56" id="P7000497027000000000000000044F56">Description</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044F57" id="P7000497027000000000000000044F57">Number</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044F58" id="P7000497027000000000000000044F58">Name</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044F59" id="P7000497027000000000000000044F59">Description</th></tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F5A" id="P7000497027000000000000000044F5A">0</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F5B" id="P7000497027000000000000000044F5B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F5C" id="P7000497027000000000000000044F5C">read</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F5D" id="P7000497027000000000000000044F5D">Read file</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F5E" id="P7000497027000000000000000044F5E">33</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F5F" id="P7000497027000000000000000044F5F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F60" id="P7000497027000000000000000044F60">pause</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F61" id="P7000497027000000000000000044F61">Suspend process until signal arrives</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F62" id="P7000497027000000000000000044F62">1</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F63" id="P7000497027000000000000000044F63"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F64" id="P7000497027000000000000000044F64">write</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F65" id="P7000497027000000000000000044F65">Write file</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F66" id="P7000497027000000000000000044F66">37</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F67" id="P7000497027000000000000000044F67"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F68" id="P7000497027000000000000000044F68">alarm</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F69" id="P7000497027000000000000000044F69">Schedule delivery of alarm signal</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F6A" id="P7000497027000000000000000044F6A">2</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F6B" id="P7000497027000000000000000044F6B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F6C" id="P7000497027000000000000000044F6C">open</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F6D" id="P7000497027000000000000000044F6D">Open file</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F6E" id="P7000497027000000000000000044F6E">39</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F6F" id="P7000497027000000000000000044F6F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F70" id="P7000497027000000000000000044F70">getpid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F71" id="P7000497027000000000000000044F71">Get process ID</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F72" id="P7000497027000000000000000044F72">3</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F73" id="P7000497027000000000000000044F73"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F74" id="P7000497027000000000000000044F74">close</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F75" id="P7000497027000000000000000044F75">Close file</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F76" id="P7000497027000000000000000044F76">57</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F77" id="P7000497027000000000000000044F77"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F78" id="P7000497027000000000000000044F78">fork</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F79" id="P7000497027000000000000000044F79">Create process</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F7A" id="P7000497027000000000000000044F7A">4</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F7B" id="P7000497027000000000000000044F7B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F7C" id="P7000497027000000000000000044F7C">stat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F7D" id="P7000497027000000000000000044F7D">Get info about file</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F7E" id="P7000497027000000000000000044F7E">59</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F7F" id="P7000497027000000000000000044F7F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F80" id="P7000497027000000000000000044F80">execve</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F81" id="P7000497027000000000000000044F81">Execute a program</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F82" id="P7000497027000000000000000044F82">9</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F83" id="P7000497027000000000000000044F83"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F84" id="P7000497027000000000000000044F84">mmap</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F85" id="P7000497027000000000000000044F85">Map memory page to file</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F86" id="P7000497027000000000000000044F86">60</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F87" id="P7000497027000000000000000044F87"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F88" id="P7000497027000000000000000044F88">_exit</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F89" id="P7000497027000000000000000044F89">Terminate process</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F8A" id="P7000497027000000000000000044F8A">12</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F8B" id="P7000497027000000000000000044F8B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F8C" id="P7000497027000000000000000044F8C">brk</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F8D" id="P7000497027000000000000000044F8D">Reset the top of the heap</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F8E" id="P7000497027000000000000000044F8E">61</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F8F" id="P7000497027000000000000000044F8F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F90" id="P7000497027000000000000000044F90">wait4</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F91" id="P7000497027000000000000000044F91">Wait for a process to terminate</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F92" id="P7000497027000000000000000044F92">32</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F93" id="P7000497027000000000000000044F93"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F94" id="P7000497027000000000000000044F94">dup2</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F95" id="P7000497027000000000000000044F95">Copy file descriptor</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F96" id="P7000497027000000000000000044F96">62</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F97" id="P7000497027000000000000000044F97"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F98" id="P7000497027000000000000000044F98">kill</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044F99" id="P7000497027000000000000000044F99">Send signal to a process</td></tr>
</tbody>
</table>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044F9A" id="P7000497027000000000000000044F9A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044F9B" epub:type="title" id="P7000497027000000000000000044F9B"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.10 </span>Examples of popular system calls in Linux x86-64 systems.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F9C" id="P7000497027000000000000000044F9C">creating a new process. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000675C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.10 </span></a>lists some popular Linux system calls. Each system call has a unique integer number that corresponds to an offset in a jump table in the kernel. (Notice that this jump table is not the same as the exception table.)</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F9D" id="P7000497027000000000000000044F9D">C programs can invoke any system call directly by using the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F9E" id="P7000497027000000000000000044F9E">syscall</code> function. However, this is rarely necessary in practice. The C standard library provides a set of convenient wrapper functions for most system calls. The wrapper functions package up the arguments, trap to the kernel with the appropriate system call instruction, and then pass the return status of the system call back to the calling program. Throughout this text, we will refer to system calls and their associated wrapper functions interchangeably as <i class="pcalibre17 pcalibre2 pcalibre1">system-level functions</i>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044F9F" id="P7000497027000000000000000044F9F">System calls are provided on x86-64 systems via a trapping instruction called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FA0" id="P7000497027000000000000000044FA0">syscall</code>. It is quite interesting to study how programs can use this instruction to invoke Linux system calls directly. All arguments to Linux system calls are passed through general-purpose registers rather than the stack. By convention, register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FA1" id="P7000497027000000000000000044FA1">%rax</code> contains the syscall number, with up to six arguments in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FA2" id="P7000497027000000000000000044FA2">%rdi, %rsi, %rdx, %r10, %r8</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FA3" id="P7000497027000000000000000044FA3">%r9</code>. The first argument is in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FA4" id="P7000497027000000000000000044FA4">%rdi</code>, the second in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FA5" id="P7000497027000000000000000044FA5">%rsi</code>, and so on. On return from the system call, registers <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FA6" id="P7000497027000000000000000044FA6">%rcx</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FA7" id="P7000497027000000000000000044FA7">%r11</code> are destroyed, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FA8" id="P7000497027000000000000000044FA8">%rax</code> contains the return value. A negative return value between -4,095 and -1 indicates an error corresponding to negative <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FA9" id="P7000497027000000000000000044FA9">errno</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FAA" id="P7000497027000000000000000044FAA">For example, consider the following version of the familiar <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FAB" id="P7000497027000000000000000044FAB">hello</code> program, written using the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FAC" id="P7000497027000000000000000044FAC">write</code> system-level function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007939.xhtml#P7000497027000000000000000007939"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">10.4</span></a>) instead of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FAD" id="P7000497027000000000000000044FAD">printf</code>:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044FAE" id="P7000497027000000000000000044FAE">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FAF" id="P7000497027000000000000000044FAF">
1	int main()
2	{
3	write(1, "hello, world\n", 13);
4	_exit(0);
5	}</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FB0" id="P7000497027000000000000000044FB0">The first argument to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FB1" id="P7000497027000000000000000044FB1">write</code> sends the output to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FB2" id="P7000497027000000000000000044FB2">stdout</code>. The second argument is the sequence of bytes to write, and the third argument gives the number of bytes to write.</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FB3" id="P7000497027000000000000000044FB3"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter08.xhtml#P7000497027000000000000000044FB4" epub:type="title" id="P7000497027000000000000000044FB4"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000067C0" epub:type="pagebreak" id="P70004970270000000000000000067C0" title="731"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>A note on terminology</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044FB5" id="P7000497027000000000000000044FB5">The terminology for the various classes of exceptions varies from system to system. Processor ISA specifications often distinguish between asynchronous “interrupts” and synchronous “exceptions” yet provide no umbrella term to refer to these very similar concepts. To avoid having to constantly refer to “exceptions and interrupts” and “exceptions or interrupts,” we use the word “exception” as the general term and distinguish between asynchronous exceptions (interrupts) and synchronous exceptions (traps, faults, and aborts) only when it is appropriate. As we have noted, the basic ideas are the same for every system, but you should be aware that some manufacturers' manuals use the word “exception” to refer only to those changes in control flow caused by synchronous events.</p>
</aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000067C2" id="P70004970270000000000000000067C2">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FB6" id="P7000497027000000000000000044FB6">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/hello-asm64.sa</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044FB7" id="P7000497027000000000000000044FB7">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FB8" id="P7000497027000000000000000044FB8">
1	.section .data
2	string:
3		.ascii "hello, world\n"
4	string_end:
5		.equ len, string_end - string
6	.section .text
7	.globl main
8	main:
<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">First, call write(1, "hello, world\n", 13</i>)</b>
9		movq $1, %rax		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">write is system call 1</i></b>
10		movq $1, %rdi		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Arg1: stdout has descriptor 1</i></b>
11		movq $string, %rsi	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Arg2: hello world string</i></b>
12		movq $len, %rdx		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Arg3: string length</i></b>
13		syscall			<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Make the system call</i></b>
<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Next, call _exit(0</i>)</b>
14	movq $60, %rax			<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">_exit is system call 60</i></b>
15	movq $0, %rdi			<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Arg1: exit status is 0</i></b>
16	syscall				<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Make the system call</i></b>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FB9" id="P7000497027000000000000000044FB9">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/hello-asm64.sa</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044FBA" id="P7000497027000000000000000044FBA"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044FBB" epub:type="title" id="P7000497027000000000000000044FBB"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.11 </span>Implementing the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FBC" id="P7000497027000000000000000044FBC">hello</code> program directly with Linux system calls.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FBD" id="P7000497027000000000000000044FBD"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000067C2"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.11</span></a> shows an assembly-language version of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FBE" id="P7000497027000000000000000044FBE">hello</code> that uses the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FBF" id="P7000497027000000000000000044FBF">syscall</code> instruction to invoke the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FC0" id="P7000497027000000000000000044FC0">write</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FC1" id="P7000497027000000000000000044FC1">exit</code> system calls directly. Lines 9-13 invoke the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FC2" id="P7000497027000000000000000044FC2">write</code> function. First, line 9 stores the number of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FC3" id="P7000497027000000000000000044FC3">write</code> system call in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FC4" id="P7000497027000000000000000044FC4">%rax</code>, and lines 10-12 set up the argument list. Then, line 13 uses the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FC5" id="P7000497027000000000000000044FC5">syscall</code> instruction to invoke the system call. Similarly, lines 14-16 invoke the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FC6" id="P7000497027000000000000000044FC6">_exit</code> system call.</p>
</section>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>8.2 Processes</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P70004970270000000000000000067D4"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044FC7" epub:type="title" id="P7000497027000000000000000044FC7"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000067D6" epub:type="pagebreak" id="P70004970270000000000000000067D6" title="732"></span><span class="pcalibre1 pcalibre21 pcalibre2">8.2 </span>Processes</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FC8" id="P7000497027000000000000000044FC8">Exceptions are the basic building blocks that allow the operating system kernel to provide the notion of a <i class="pcalibre17 pcalibre2 pcalibre1">process</i>, one of the most profound and successful ideas in computer science.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FC9" id="P7000497027000000000000000044FC9">When we run a program on a modern system, we are presented with the illusion that our program is the only one currently running in the system. Our program appears to have exclusive use of both the processor and the memory. The processor appears to execute the instructions in our program, one after the other, without interruption. Finally, the code and data of our program appear to be the only objects in the system's memory. These illusions are provided to us by the notion of a process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FCA" id="P7000497027000000000000000044FCA">The classic definition of a process is <i class="pcalibre17 pcalibre2 pcalibre1">an instance of a program in execution</i>. Each program in the system runs in the <i class="pcalibre17 pcalibre2 pcalibre1">context</i> of some process. The context consists of the state that the program needs to run correctly. This state includes the program's code and data stored in memory, its stack, the contents of its general purpose registers, its program counter, environment variables, and the set of open file descriptors.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FCB" id="P7000497027000000000000000044FCB">Each time a user runs a program by typing the name of an executable object file to the shell, the shell creates a new process and then runs the executable object file in the context of this new process. Application programs can also create new processes and run either their own code or other applications in the context of the new process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FCC" id="P7000497027000000000000000044FCC">A detailed discussion of how operating systems implement processes is beyond our scope. Instead, we will focus on the key abstractions that a process provides to the application:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FCD" id="P7000497027000000000000000044FCD">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044FCE" id="P7000497027000000000000000044FCE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044FCF" id="P7000497027000000000000000044FCF">An independent logical control flow that provides the illusion that our program has exclusive use of the processor.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044FD0" id="P7000497027000000000000000044FD0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044FD1" id="P7000497027000000000000000044FD1">A private address space that provides the illusion that our program has exclusive use of the memory system.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FD2" id="P7000497027000000000000000044FD2">Let's look more closely at these abstractions.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000067E2" id="P70004970270000000000000000067E2"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FD3" epub:type="title" id="P7000497027000000000000000044FD3"><span class="pcalibre1 pcalibre21 pcalibre2">8.2.1  </span>Logical Control Flow</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FD4" id="P7000497027000000000000000044FD4">A process provides each program with the illusion that it has exclusive use of the processor, even though many other programs are typically running concurrently on the system. If we were to use a debugger to single-step the execution of our program, we would observe a series of program counter (PC) values that corresponded exclusively to instructions contained in our program's executable object file or in shared objects linked into our program dynamically at run time. This sequence of PC values is known as a <i class="pcalibre17 pcalibre2 pcalibre1">logical control flow</i>, or simply <i class="pcalibre17 pcalibre2 pcalibre1">logical flow</i>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FD5" id="P7000497027000000000000000044FD5">Consider a system that runs three processes, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000067E6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.12</span></a>. The single physical control flow of the processor is partitioned into three logical flows, one for each process. Each vertical line represents a portion of the logical flow for</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000067E6" id="P70004970270000000000000000067E6">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000067E7" epub:type="pagebreak" id="P70004970270000000000000000067E7" title="733"></span><img alt="A diagram shows a vertical arrow representing time and vertical lines moving from Process A to Process B to Process C to Process A to Process C, over time." class="pcalibre1 pcalibre2 pcalibre247" data-uri="P700049702700000000000000000B768" id="P7000497027000000000000000044FD6" src="Images/chapter-07-image-08.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000044FD7" id="P7000497027000000000000000044FD7"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000044FD8" epub:type="title" id="P7000497027000000000000000044FD8"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.12 </span>Logical control flows.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FD9" id="P7000497027000000000000000044FD9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044FDA" id="P7000497027000000000000000044FDA">Processes provide each program with the illusion that it has exclusive use of the processor. Each vertical bar represents a portion of the logical control flow for a process.</p></div>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FDB" id="P7000497027000000000000000044FDB">a process. In the example, the execution of the three logical flows is interleaved. Process A runs for a while, followed by B, which runs to completion. Process C then runs for a while, followed by A, which runs to completion. Finally, C is able to run to completion.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FDC" id="P7000497027000000000000000044FDC">The key point in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000067E6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.12</span></a> is that processes take turns using the processor. Each process executes a portion of its flow and then is <i class="pcalibre17 pcalibre2 pcalibre1">preempted</i> (temporarily suspended) while other processes take their turns. To a program running in the context of one of these processes, it appears to have exclusive use of the processor. The only evidence to the contrary is that if we were to precisely measure the elapsed time of each instruction, we would notice that the CPU appears to periodically stall between the execution of some of the instructions in our program. However, each time the processor stalls, it subsequently resumes execution of our program without any change to the contents of the program's memory locations or registers.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000067EF" id="P70004970270000000000000000067EF"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FDD" epub:type="title" id="P7000497027000000000000000044FDD"><span class="pcalibre1 pcalibre21 pcalibre2">8.2.2  </span>Concurrent Flows</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FDE" id="P7000497027000000000000000044FDE">Logical flows take many different forms in computer systems. Exception handlers, processes, signal handlers, threads, and Java processes are all examples of logical flows.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FDF" id="P7000497027000000000000000044FDF">A logical flow whose execution overlaps in time with another flow is called a <i class="pcalibre17 pcalibre2 pcalibre1">concurrent flow</i>, and the two flows are said to <i class="pcalibre17 pcalibre2 pcalibre1">run concurrently</i>. More precisely, flows X and Y are concurrent with respect to each other if and only if X begins after Y begins and before Y finishes, or Y begins after X begins and before X finishes. For example, in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000067E6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.12</span></a>, processes A and B run concurrently, as do A and C. On the other hand, B and C do not run concurrently, because the last instruction of B executes before the first instruction of C.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FE0" id="P7000497027000000000000000044FE0">The general phenomenon of multiple flows executing concurrently is known as <i class="pcalibre17 pcalibre2 pcalibre1">concurrency</i>. The notion of a process taking turns with other processes is also known as <i class="pcalibre17 pcalibre2 pcalibre1">multitasking</i>. Each time period that a process executes a portion of its flow is called a <i class="pcalibre17 pcalibre2 pcalibre1">time slice</i>. Thus, multitasking is also referred to as <i class="pcalibre17 pcalibre2 pcalibre1">time slicing</i>. For example, in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000067E6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.12</span></a>, the flow for process A consists of two time slices.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FE1" id="P7000497027000000000000000044FE1">Notice that the idea of concurrent flows is independent of the number of processor cores or computers that the flows are running on. If two flows overlap in time, then they are concurrent, even if they are running on the same processor. However, we will sometimes find it useful to identify a proper subset of concurrent <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000067F5" epub:type="pagebreak" id="P70004970270000000000000000067F5" title="734"></span>flows known as <i class="pcalibre17 pcalibre2 pcalibre1">parallel flows</i>. If two flows are running concurrently on different processor cores or computers, then we say that they are <i class="pcalibre17 pcalibre2 pcalibre1">parallel flows</i>, that they are <i class="pcalibre17 pcalibre2 pcalibre1">running in parallel</i>, and have <i class="pcalibre17 pcalibre2 pcalibre1">parallel execution</i>.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000067F6" id="P70004970270000000000000000067F6"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FE2" epub:type="title" id="P7000497027000000000000000044FE2"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.1 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006E81.xhtml#P7000497027000000000000000006F86">795</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FE3" id="P7000497027000000000000000044FE3">Consider three processes with the following starting and ending times:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter08.xhtml#P7000497027000000000000000044FE4" id="P7000497027000000000000000044FE4">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044FE5" id="P7000497027000000000000000044FE5">
Process</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044FE6" id="P7000497027000000000000000044FE6">Start time</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044FE7" id="P7000497027000000000000000044FE7">End time</th></tr></thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FE8" id="P7000497027000000000000000044FE8">A</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FE9" id="P7000497027000000000000000044FE9">0</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FEA" id="P7000497027000000000000000044FEA">2</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FEB" id="P7000497027000000000000000044FEB">B</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FEC" id="P7000497027000000000000000044FEC">1</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FED" id="P7000497027000000000000000044FED">4</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FEE" id="P7000497027000000000000000044FEE">C</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FEF" id="P7000497027000000000000000044FEF">3</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FF0" id="P7000497027000000000000000044FF0">5</td></tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FF1" id="P7000497027000000000000000044FF1">For each pair of processes, indicate whether they run concurrently (Y) or not (N):</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter08.xhtml#P7000497027000000000000000044FF2" id="P7000497027000000000000000044FF2">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044FF3" id="P7000497027000000000000000044FF3">
Process pair</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P7000497027000000000000000044FF4" id="P7000497027000000000000000044FF4">Concurrent?</th></tr></thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FF5" id="P7000497027000000000000000044FF5">AB</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FF6" id="P7000497027000000000000000044FF6"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FF7" id="P7000497027000000000000000044FF7">AC</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FF8" id="P7000497027000000000000000044FF8"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FF9" id="P7000497027000000000000000044FF9">BC</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044FFA" id="P7000497027000000000000000044FFA"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
</tbody>
</table>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006810" id="P7000497027000000000000000006810"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FFB" epub:type="title" id="P7000497027000000000000000044FFB"><span class="pcalibre1 pcalibre21 pcalibre2">8.2.3  </span>Private Address Space</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FFC" id="P7000497027000000000000000044FFC">A process provides each program with the illusion that it has exclusive use of the system's address space. On a machine with <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-bit addresses, the <i class="pcalibre17 pcalibre2 pcalibre1">address space</i> is the set of 2<sup class="pcalibre1 pcalibre2 pcalibre85"><var class="pcalibre17 pcalibre2 pcalibre1">n</var></sup> possible addresses, 0, 1, ... , 2<sup class="pcalibre1 pcalibre2 pcalibre85"><var class="pcalibre17 pcalibre2 pcalibre1">n</var></sup> - 1. A process provides each program with its own <i class="pcalibre17 pcalibre2 pcalibre1">private address space</i>. This space is private in the sense that a byte of memory associated with a particular address in the space cannot in general be read or written by any other process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FFD" id="P7000497027000000000000000044FFD">Although the contents of the memory associated with each private address space is different in general, each such space has the same general organization. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006819"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.13</span></a> shows the organization of the address space for an x86-64 Linux process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FFE" id="P7000497027000000000000000044FFE">The bottom portion of the address space is reserved for the user program, with the usual code, data, heap, and stack segments. The code segment always begins at address <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044FFF" id="P7000497027000000000000000044FFF">0x400000</code>. The top portion of the address space is reserved for the kernel (the memory-resident part of the operating system). This part of the address space contains the code, data, and stack that the kernel uses when it executes instructions on behalf of the process (e.g., when the application program executes a system call).</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006816" id="P7000497027000000000000000006816"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045000" epub:type="title" id="P7000497027000000000000000045000"><span class="pcalibre1 pcalibre21 pcalibre2">8.2.4  </span>User and Kernel Modes</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045001" id="P7000497027000000000000000045001">In order for the operating system kernel to provide an airtight process abstraction, the processor must provide a mechanism that restricts the instructions that an</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006819" id="P7000497027000000000000000006819">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000681A" epub:type="pagebreak" id="P700049702700000000000000000681A" title="735"></span><img alt="A diagram illustrates process address space." class="pcalibre1 pcalibre2 pcalibre248" data-uri="P700049702700000000000000000B769" id="P7000497027000000000000000045002" src="Images/chapter-07-image-09.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045003" id="P7000497027000000000000000045003"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045004" epub:type="title" id="P7000497027000000000000000045004"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.13 </span>Process address space.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P7000497027000000000000000025326" id="P7000497027000000000000000025326">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045005" id="P7000497027000000000000000045005">A diagram shows a stack with sections summarized below from bottom to top.</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter08.xhtml#P7000497027000000000000000045006" id="P7000497027000000000000000045006">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045007" id="P7000497027000000000000000045007"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045008" id="P7000497027000000000000000045008">Gap from 0 to 0x400000</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045009" id="P7000497027000000000000000045009"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004500A" id="P700049702700000000000000004500A">Loaded from the executable file:</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter08.xhtml#P700049702700000000000000004500B" id="P700049702700000000000000004500B">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004500C" id="P700049702700000000000000004500C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004500D" id="P700049702700000000000000004500D">Read-only code segment (.init, .text, .rodata)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004500E" id="P700049702700000000000000004500E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004500F" id="P700049702700000000000000004500F">Read/write segment (.data, .bss)</p></li>
</ul></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045010" id="P7000497027000000000000000045010"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045011" id="P7000497027000000000000000045011">Run-time heap (created by malloc), to brk</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045012" id="P7000497027000000000000000045012"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045013" id="P7000497027000000000000000045013">Gap</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045014" id="P7000497027000000000000000045014"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045015" id="P7000497027000000000000000045015">Memory-mapped region for shared libraries</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045016" id="P7000497027000000000000000045016"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045017" id="P7000497027000000000000000045017">Gap to %esp (stack pointer)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045018" id="P7000497027000000000000000045018"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045019" id="P7000497027000000000000000045019">User stack (created at run time), to 2<sup class="pcalibre1 pcalibre2 pcalibre85">48</sup> minus 1</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004501A" id="P700049702700000000000000004501A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004501B" id="P700049702700000000000000004501B">Kernel virtual memory (code, data, heap, stack), to memory invisible to user code</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004501C" id="P700049702700000000000000004501C">application can execute, as well as the portions of the address space that it can access.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004501D" id="P700049702700000000000000004501D">Processors typically provide this capability with a <i class="pcalibre17 pcalibre2 pcalibre1">mode bit</i> in some control register that characterizes the privileges that the process currently enjoys. When the mode bit is set, the process is running in <i class="pcalibre17 pcalibre2 pcalibre1">kernel mode</i> (sometimes called <i class="pcalibre17 pcalibre2 pcalibre1">supervisor mode</i>). A process running in kernel mode can execute any instruction in the instruction set and access any memory location in the system.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004501E" id="P700049702700000000000000004501E">When the mode bit is not set, the process is running in <i class="pcalibre17 pcalibre2 pcalibre1">user mode</i>. A process in user mode is not allowed to execute <i class="pcalibre17 pcalibre2 pcalibre1">privileged instructions</i> that do things such as halt the processor, change the mode bit, or initiate an I/O operation. Nor is it allowed to directly reference code or data in the kernel area of the address space. Any such attempt results in a fatal protection fault. User programs must instead access kernel code and data indirectly via the system call interface.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004501F" id="P700049702700000000000000004501F">A process running application code is initially in user mode. The only way for the process to change from user mode to kernel mode is via an exception such as an interrupt, a fault, or a trapping system call. When the exception occurs, and control passes to the exception handler, the processor changes the mode from user mode to kernel mode. The handler runs in kernel mode. When it returns to the application code, the processor changes the mode from kernel mode back to user mode.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045020" id="P7000497027000000000000000045020">Linux provides a clever mechanism, called the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045021" id="P7000497027000000000000000045021">/proc</code> filesystem, that allows user mode processes to access the contents of kernel data structures. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045022" id="P7000497027000000000000000045022">/proc</code> filesystem exports the contents of many kernel data structures as a hierarchy of text <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006825" epub:type="pagebreak" id="P7000497027000000000000000006825" title="736"></span>files that can be read by user programs. For example, you can use the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045023" id="P7000497027000000000000000045023">/proc</code> filesystem to find out general system attributes such as CPU type (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045024" id="P7000497027000000000000000045024">/proc/cpuinfo</code>), or the memory segments used by a particular process (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045025" id="P7000497027000000000000000045025">/proc/<i class="pcalibre17 pcalibre2 pcalibre1">process-id</i>/maps</code>). The 2.6 version of the Linux kernel introduced a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045026" id="P7000497027000000000000000045026">/sys</code> filesystem, which exports additional low-level information about system buses and devices.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P700049702700000000000000000682A" id="P700049702700000000000000000682A"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045027" epub:type="title" id="P7000497027000000000000000045027"><span class="pcalibre1 pcalibre21 pcalibre2">8.2.5  </span>Context Switches</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045028" id="P7000497027000000000000000045028">The operating system kernel implements multitasking using a higher-level form of exceptional control flow known as a <i class="pcalibre17 pcalibre2 pcalibre1">context switch</i>. The context switch mechanism is built on top of the lower-level exception mechanism that we discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000066A6.xhtml#P70004970270000000000000000066A6"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.1</span></a>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045029" id="P7000497027000000000000000045029">The kernel maintains a <i class="pcalibre17 pcalibre2 pcalibre1">context</i> for each process. The context is the state that the kernel needs to restart a preempted process. It consists of the values of objects such as the general-purpose registers, the floating-point registers, the program counter, user's stack, status registers, kernel's stack, and various kernel data structures such as a <i class="pcalibre17 pcalibre2 pcalibre1">page table</i> that characterizes the address space, a <i class="pcalibre17 pcalibre2 pcalibre1">process table</i> that contains information about the current process, and a <i class="pcalibre17 pcalibre2 pcalibre1">file table</i> that contains information about the files that the process has opened.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004502A" id="P700049702700000000000000004502A">At certain points during the execution of a process, the kernel can decide to preempt the current process and restart a previously preempted process. This decision is known as <i class="pcalibre17 pcalibre2 pcalibre1">scheduling</i> and is handled by code in the kernel, called the <i class="pcalibre17 pcalibre2 pcalibre1">scheduler</i>. When the kernel selects a new process to run, we say that the kernel has <i class="pcalibre17 pcalibre2 pcalibre1">scheduled</i> that process. After the kernel has scheduled a new process to run, it preempts the current process and transfers control to the new process using a mechanism called a <i class="pcalibre17 pcalibre2 pcalibre1">context switch</i> that (1) saves the context of the current process, (2) restores the saved context of some previously preempted process, and (3) passes control to this newly restored process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004502B" id="P700049702700000000000000004502B">A context switch can occur while the kernel is executing a system call on behalf of the user. If the system call blocks because it is waiting for some event to occur, then the kernel can put the current process to sleep and switch to another process. For example, if a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004502C" id="P700049702700000000000000004502C">read</code> system call requires a disk access, the kernel can opt to perform a context switch and run another process instead of waiting for the data to arrive from the disk. Another example is the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004502D" id="P700049702700000000000000004502D">sleep</code> system call, which is an explicit request to put the calling process to sleep. In general, even if a system call does not block, the kernel can decide to perform a context switch rather than return control to the calling process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004502E" id="P700049702700000000000000004502E">A context switch can also occur as a result of an interrupt. For example, all systems have some mechanism for generating periodic timer interrupts, typically every 1 ms or 10 ms. Each time a timer interrupt occurs, the kernel can decide that the current process has run long enough and switch to a new process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004502F" id="P700049702700000000000000004502F"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006819"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.13 </span></a>shows an example of context switching between a pair of processes A and B. In this example, initially process A is running in user mode until it traps to the kernel by executing a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045030" id="P7000497027000000000000000045030">read</code> system call. The trap handler in the kernel requests a DMA transfer from the disk controller and arranges for the disk to interrupt the</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006835" id="P7000497027000000000000000006835">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006836" epub:type="pagebreak" id="P7000497027000000000000000006836" title="737"></span><img alt="A diagram illustrates a process context switch." class="pcalibre1 pcalibre2 pcalibre249" data-uri="P700049702700000000000000000B76A" id="P7000497027000000000000000045031" src="Images/chapter-07-image-10.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045032" id="P7000497027000000000000000045032"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045033" epub:type="title" id="P7000497027000000000000000045033"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.14 </span>Anatomy of a process context switch.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P7000497027000000000000000025356" id="P7000497027000000000000000025356">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045034" id="P7000497027000000000000000045034">A diagram shows a flow of steps over time, moving between Process A and Process B. The flow extends through user code in Process A to read, and then moves through kernel code (context switch), switching from Process A to Process B. In Process B, the flow moves through user code to disk interrupt, and then through kernel code (context switch) from Process B to Process A, to Return from read, before moving through user code in Process A.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045035" id="P7000497027000000000000000045035">processor after the disk controller has finished transferring the data from disk to memory.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045036" id="P7000497027000000000000000045036">The disk will take a relatively long time to fetch the data (on the order of tens of milliseconds), so instead of waiting and doing nothing in the interim, the kernel performs a context switch from process A to B. Note that, before the switch, the kernel is executing instructions in user mode on behalf of process A (i.e., there is no separate kernel process). During the first part of the switch, the kernel is executing instructions in kernel mode on behalf of process A. Then at some point it begins executing instructions (still in kernel mode) on behalf of process B. And after the switch, the kernel is executing instructions in user mode on behalf of process B.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045037" id="P7000497027000000000000000045037">Process B then runs for a while in user mode until the disk sends an interrupt to signal that data have been transferred from disk to memory. The kernel decides that process B has run long enough and performs a context switch from process B to A, returning control in process A to the instruction immediately following the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045038" id="P7000497027000000000000000045038">read</code> system call. Process A continues to run until the next exception occurs, and so on.</p>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>8.3 System Call Error Handling</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000683E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045039" epub:type="title" id="P7000497027000000000000000045039"><span class="pcalibre1 pcalibre21 pcalibre2">8.3 </span>System Call Error Handling</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004503A" id="P700049702700000000000000004503A">When Unix system-level functions encounter an error, they typically return -1 and set the global integer variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004503B" id="P700049702700000000000000004503B">errno</code> to indicate what went wrong. Programmers should <i class="pcalibre17 pcalibre2 pcalibre1">always</i> check for errors, but unfortunately, many skip error checking because it bloats the code and makes it harder to read. For example, here is how we might check for errors when we call the Linux <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004503C" id="P700049702700000000000000004503C">fork</code> function:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004503D" id="P700049702700000000000000004503D">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004503E" id="P700049702700000000000000004503E">
1	if ((pid = fork())&lt; 0) {
2		fprintf(stderr, "fork error: %s\n", strerror(errno));
3		exit(0);
4	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004503F" id="P700049702700000000000000004503F">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045040" id="P7000497027000000000000000045040">strerror</code> function returns a text string that describes the error associated with a particular value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045041" id="P7000497027000000000000000045041">errno.</code> We can simplify this code somewhat by defining the following <i class="pcalibre17 pcalibre2 pcalibre1">error-reporting function:</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045042" id="P7000497027000000000000000045042">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045043" id="P7000497027000000000000000045043">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000684A" epub:type="pagebreak" id="P700049702700000000000000000684A" title="738"></span>1	void unix_error(char *msg) /* Unix-style error */
2	{
3		fprintf(stderr, "%s: %s\n", msg, strerror(errno));
4		exit(0);
5	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045044" id="P7000497027000000000000000045044">Given this function, our call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045045" id="P7000497027000000000000000045045">fork</code> reduces from four lines to two lines:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045046" id="P7000497027000000000000000045046">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045047" id="P7000497027000000000000000045047">
1		if ((pid = fork())&lt; 0)
2			unix_error("fork error");
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045048" id="P7000497027000000000000000045048">We can simplify our code even further by using <i class="pcalibre17 pcalibre2 pcalibre1">error-handling wrappers</i>, as pioneered by Stevens in [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>]. For a given base function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045049" id="P7000497027000000000000000045049">foo</code>, we define a wrapper function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004504A" id="P700049702700000000000000004504A">Foo</code> with identical arguments but with the first letter of the name capitalized. The wrapper calls the base function, checks for errors, and terminates if there are any problems. For example, here is the error-handling wrapper for the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004504B" id="P700049702700000000000000004504B">fork</code> function:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004504C" id="P700049702700000000000000004504C">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004504D" id="P700049702700000000000000004504D">
1	pid_t Fork(void)
2	{
3		pid_t pid;
4
5		if ((pid = fork())&lt; 0)
6			unix_error("Fork error");
7		return pid;
8	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004504E" id="P700049702700000000000000004504E">Given this wrapper, our call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004504F" id="P700049702700000000000000004504F">fork</code> shrinks to a single compact line:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045050" id="P7000497027000000000000000045050"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045051" id="P7000497027000000000000000045051">1 pid = Fork();</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045052" id="P7000497027000000000000000045052">We will use error-handling wrappers throughout the remainder of this book. They allow us to keep our code examples concise without giving you the mistaken impression that it is permissible to ignore error checking. Note that when we discuss system-level functions in the text, we will always refer to them by their lowercase base names, rather than by their uppercase wrapper names.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045053" id="P7000497027000000000000000045053">See Appendix A for a discussion of Unix error handling and the error-handling wrappers used throughout this book. The wrappers are defined in a file called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045054" id="P7000497027000000000000000045054">csapp.c</code>, and their prototypes are defined in a header file called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045055" id="P7000497027000000000000000045055">csapp.h.</code> These are available online from the CS:APP Web site.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>8.4 Process Control</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000685D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045056" epub:type="title" id="P7000497027000000000000000045056"><span class="pcalibre1 pcalibre21 pcalibre2">8.4 </span>Process Control</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045057" id="P7000497027000000000000000045057">Unix provides a number of system calls for manipulating processes from C programs. This section describes the important functions and gives examples of how they are used.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006860" id="P7000497027000000000000000006860"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045058" epub:type="title" id="P7000497027000000000000000045058"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006862" epub:type="pagebreak" id="P7000497027000000000000000006862" title="739"></span><span class="pcalibre1 pcalibre21 pcalibre2">8.4.1  </span>Obtaining Process IDs</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045059" id="P7000497027000000000000000045059">Each process has a unique positive (nonzero) <i class="pcalibre17 pcalibre2 pcalibre1">process ID (PID)</i>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004505A" id="P700049702700000000000000004505A">getpid</code> function returns the PID of the calling process. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004505B" id="P700049702700000000000000004505B">getppid</code> function returns the PID of its <i class="pcalibre17 pcalibre2 pcalibre1">parent</i> (i.e., the process that created the calling process).</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004505C" id="P700049702700000000000000004505C">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004505D" id="P700049702700000000000000004505D">
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t getpid(void);
pid_t getppid(void);
				Returns: PID of either the caller or the parent
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004505E" id="P700049702700000000000000004505E">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004505F" id="P700049702700000000000000004505F">getpid</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045060" id="P7000497027000000000000000045060">getppid</code> routines return an integer value of type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045061" id="P7000497027000000000000000045061">pid_t</code>, which on Linux systems is defined in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045062" id="P7000497027000000000000000045062">types.h</code> as an int.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P700049702700000000000000000686D" id="P700049702700000000000000000686D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045063" epub:type="title" id="P7000497027000000000000000045063"><span class="pcalibre1 pcalibre21 pcalibre2">8.4.2  </span>Creating and Terminating Processes</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045064" id="P7000497027000000000000000045064">From a programmer's perspective, we can think of a process as being in one of three states:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045065" id="P7000497027000000000000000045065">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045066" id="P7000497027000000000000000045066"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045067" id="P7000497027000000000000000045067"><span class="pcalibre1 pcalibre2 pcalibre41">Running. </span>The process is either executing on the CPU or waiting to be executed and will eventually be scheduled by the kernel.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045068" id="P7000497027000000000000000045068"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045069" id="P7000497027000000000000000045069"><span class="pcalibre1 pcalibre2 pcalibre41">Stopped. </span>The execution of the process is <i class="pcalibre17 pcalibre2 pcalibre1">suspended</i> and will not be scheduled. A process stops as a result of receiving a SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU signal, and it remains stopped until it receives a SIGCONT signal, at which point it becomes running again. (A <i class="pcalibre17 pcalibre2 pcalibre1">signal</i> is a form of software interrupt that we will describe in detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006993"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5</span></a>.)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004506A" id="P700049702700000000000000004506A"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P700049702700000000000000004506B" id="P700049702700000000000000004506B"><span class="pcalibre1 pcalibre2 pcalibre41">Terminated. </span>The process is stopped permanently. A process becomes terminated for one of three reasons: (1) receiving a signal whose default action is to terminate the process, (2) returning from the main routine, or (3) calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004506C" id="P700049702700000000000000004506C">exit</code> function.</p></li>
</ul>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004506D" id="P700049702700000000000000004506D">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004506E" id="P700049702700000000000000004506E">
#include &lt;stdlib.h&gt;
void exit(int status);
				This function does not return
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004506F" id="P700049702700000000000000004506F">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045070" id="P7000497027000000000000000045070">exit</code> function terminates the process with an <i class="pcalibre17 pcalibre2 pcalibre1">exit status</i> of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045071" id="P7000497027000000000000000045071">status</code>. (The other way to set the exit status is to return an integer value from the main routine.)</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045072" id="P7000497027000000000000000045072"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000687E" epub:type="pagebreak" id="P700049702700000000000000000687E" title="740"></span>A <i class="pcalibre17 pcalibre2 pcalibre1">parent process</i> creates a new running <i class="pcalibre17 pcalibre2 pcalibre1">child process</i> by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045073" id="P7000497027000000000000000045073">fork</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045074" id="P7000497027000000000000000045074">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045075" id="P7000497027000000000000000045075">
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t fork(void);
			Returns: 0 to child, PID of child to parent, -1 on error
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045076" id="P7000497027000000000000000045076">The newly created child process is almost, but not quite, identical to the parent. The child gets an identical (but separate) copy of the parent's user-level virtual address space, including the code and data segments, heap, shared libraries, and user stack. The child also gets identical copies of any of the parent's open file descriptors, which means the child can read and write any files that were open in the parent when it called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045077" id="P7000497027000000000000000045077">fork</code>. The most significant difference between the parent and the newly created child is that they have different PIDs.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045078" id="P7000497027000000000000000045078">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045079" id="P7000497027000000000000000045079">fork</code> function is interesting (and often confusing) because it is called <i class="pcalibre17 pcalibre2 pcalibre1">once</i> but it returns <i class="pcalibre17 pcalibre2 pcalibre1">twice:</i> once in the calling process (the parent), and once in the newly created child process. In the parent, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004507A" id="P700049702700000000000000004507A">fork</code> returns the PID of the child. In the child, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004507B" id="P700049702700000000000000004507B">fork</code> returns a value of 0. Since the PID of the child is always nonzero, the return value provides an unambiguous way to tell whether the program is executing in the parent or the child.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004507C" id="P700049702700000000000000004507C"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000689A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.15 </span></a>shows a simple example of a parent process that uses <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004507D" id="P700049702700000000000000004507D">fork</code> to create a child process. When the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004507E" id="P700049702700000000000000004507E">fork</code> call returns in line 6, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004507F" id="P700049702700000000000000004507F">x</code> has a value of 1 in both the parent and child. The child increments and prints its copy of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045080" id="P7000497027000000000000000045080">x</code> in line 8. Similarly, the parent decrements and prints its copy of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045081" id="P7000497027000000000000000045081">x</code> in line 13.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045082" id="P7000497027000000000000000045082">When we run the program on our Unix system, we get the following result:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045083" id="P7000497027000000000000000045083">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045084" id="P7000497027000000000000000045084">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./fork</i>
parent: x=0
child : x=2
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045085" id="P7000497027000000000000000045085">There are some subtle aspects to this simple example.</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045086" id="P7000497027000000000000000045086">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045087" id="P7000497027000000000000000045087"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045088" id="P7000497027000000000000000045088"><span class="pcalibre1 pcalibre2 pcalibre41">Call once, return twice. </span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045089" id="P7000497027000000000000000045089">fork</code> function is called once by the parent, but it returns twice: once to the parent and once to the newly created child. This is fairly straightforward for programs that create a single child. But programs with multiple instances of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004508A" id="P700049702700000000000000004508A">fork</code> can be confusing and need to be reasoned about carefully.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004508B" id="P700049702700000000000000004508B"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P700049702700000000000000004508C" id="P700049702700000000000000004508C"><span class="pcalibre1 pcalibre2 pcalibre41">Concurrent execution. </span>The parent and the child are separate processes that run concurrently. The instructions in their logical control flows can be interleaved by the kernel in an arbitrary way. When we run the program on our system, the parent process completes its <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004508D" id="P700049702700000000000000004508D">printf</code> statement first, followed by the child. However, on another system the reverse might be true. In general, as programmers we can never make assumptions about the interleaving of the instructions in different processes.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P700049702700000000000000000689A" id="P700049702700000000000000000689A">
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P700049702700000000000000004508E" id="P700049702700000000000000004508E"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000689C" epub:type="pagebreak" id="P700049702700000000000000000689C" title="741"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/fork.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004508F" id="P700049702700000000000000004508F">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045090" id="P7000497027000000000000000045090">
1	int main()
2	{
3		pid_t pid;
4		int x = 1;
5	
6		pid = Fork();
7		if (pid == 0) { /* Child */
8			printf("child : x=%d\n", ++x);
9			exit(0);
10		}
11	
12		/* Parent */
13			printf("parent: x=%d\n", --x);
14			exit(0);
15	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045091" id="P7000497027000000000000000045091">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/fork.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045092" id="P7000497027000000000000000045092"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045093" epub:type="title" id="P7000497027000000000000000045093"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.15 </span>Using <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045094" id="P7000497027000000000000000045094">fork</code> to create a new process.</h1></header>
</figcaption>
</figure>
</li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045095" id="P7000497027000000000000000045095"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045096" id="P7000497027000000000000000045096"><span class="pcalibre1 pcalibre2 pcalibre41">Duplicate but separate address spaces. </span>If we could halt both the parent and the child immediately after the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045097" id="P7000497027000000000000000045097">fork</code> function returned in each process, we would see that the address space of each process is identical. Each process has the same user stack, the same local variable values, the same heap, the same global variable values, and the same code. Thus, in our example program, local variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045098" id="P7000497027000000000000000045098">x</code> has a value of 1 in both the parent and the child when the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045099" id="P7000497027000000000000000045099">fork</code> function returns in line 6. However, since the parent and the child are separate processes, they each have their own private address spaces. Any subsequent changes that a parent or child makes to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004509A" id="P700049702700000000000000004509A">x</code> are private and are not reflected in the memory of the other process. This is why the variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004509B" id="P700049702700000000000000004509B">x</code> has different values in the parent and child when they call their respective <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004509C" id="P700049702700000000000000004509C">printf</code> statements.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004509D" id="P700049702700000000000000004509D"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P700049702700000000000000004509E" id="P700049702700000000000000004509E"><span class="pcalibre1 pcalibre2 pcalibre41">Shared files. </span>When we run the example program, we notice that both parent and child print their output on the screen. The reason is that the child inherits all of the parent's open files. When the parent calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004509F" id="P700049702700000000000000004509F">fork</code>, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450A0" id="P70004970270000000000000000450A0">stdout</code> file is open and directed to the screen. The child inherits this file, and thus its output is also directed to the screen.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450A1" id="P70004970270000000000000000450A1">When you are first learning about the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450A2" id="P70004970270000000000000000450A2">fork</code> function, it is often helpful to sketch the <i class="pcalibre17 pcalibre2 pcalibre1">process graph</i>, which is a simple kind of precedence graph that captures the partial ordering of program statements. Each vertex <var class="pcalibre17 pcalibre2 pcalibre1">a</var> corresponds to the execution of a program statement. A directed edge <var class="pcalibre17 pcalibre2 pcalibre1">a</var> → <var class="pcalibre17 pcalibre2 pcalibre1">b</var> denotes that statement <var class="pcalibre17 pcalibre2 pcalibre1">a</var> “happens before” statement <var class="pcalibre17 pcalibre2 pcalibre1">b</var>. Edges can be labeled with information such as the current value of a variable. Vertices corresponding to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450A3" id="P70004970270000000000000000450A3">printf</code> statements can be labeled with the output of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450A4" id="P70004970270000000000000000450A4">printf</code>. Each graph begins with a vertex that</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000068B3" id="P70004970270000000000000000068B3">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000068B4" epub:type="pagebreak" id="P70004970270000000000000000068B4" title="742"></span><img alt="A diagram shows a process graph." class="pcalibre1 pcalibre2 pcalibre250" data-uri="P700049702700000000000000000B76C" id="P70004970270000000000000000450A5" src="Images/chapter-07-image-11.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000450A6" id="P70004970270000000000000000450A6"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000450A7" epub:type="title" id="P70004970270000000000000000450A7"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.16 </span>Process graph for the example program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000689A"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.15</span></a>.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P70004970270000000000000000253CB" id="P70004970270000000000000000253CB">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450A8" id="P70004970270000000000000000450A8">A diagram shows a process graph flowing as summarized below.</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter08.xhtml#P70004970270000000000000000450A9" id="P70004970270000000000000000450A9">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450AA" id="P70004970270000000000000000450AA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450AB" id="P70004970270000000000000000450AB">X==1 from main to fork, splitting toward Child and Parent:</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter08.xhtml#P70004970270000000000000000450AC" id="P70004970270000000000000000450AC">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450AD" id="P70004970270000000000000000450AD"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450AE" id="P70004970270000000000000000450AE">To printf at child: x=2, and then exit at Child</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450AF" id="P70004970270000000000000000450AF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450B0" id="P70004970270000000000000000450B0">To printf at parent: x=0, and then exit at Parent</p></li>
</ul></li>
</ul>
</details>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000068B8" id="P70004970270000000000000000068B8">
<img alt="A diagram shows a code and associated process graph." class="pcalibre1 pcalibre251 pcalibre2" data-uri="P700049702700000000000000000B76D" id="P70004970270000000000000000450B1" src="Images/chapter-07-image-12.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000450B2" id="P70004970270000000000000000450B2"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000450B3" epub:type="title" id="P70004970270000000000000000450B3"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.17 </span>Process graph for a nested <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450B4" id="P70004970270000000000000000450B4">fork</code>.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P70004970270000000000000000253D9" id="P70004970270000000000000000253D9">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450B5" id="P70004970270000000000000000450B5">The lines of the code are listed below.</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450B6" id="P70004970270000000000000000450B6">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450B7" id="P70004970270000000000000000450B7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450B8" id="P70004970270000000000000000450B8">Int main()</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450B9" id="P70004970270000000000000000450B9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450BA" id="P70004970270000000000000000450BA">{</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450BB" id="P70004970270000000000000000450BB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450BC" id="P70004970270000000000000000450BC">Fork();</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450BD" id="P70004970270000000000000000450BD"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450BE" id="P70004970270000000000000000450BE">Fork();</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450BF" id="P70004970270000000000000000450BF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450C0" id="P70004970270000000000000000450C0">printf(“hello\n”);</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450C1" id="P70004970270000000000000000450C1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450C2" id="P70004970270000000000000000450C2">exit(0);</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450C3" id="P70004970270000000000000000450C3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450C4" id="P70004970270000000000000000450C4">}</p></li>
</ul>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450C5" id="P70004970270000000000000000450C5">The graph has an arrow from main leading to a fork, which splits into two other forks. Each of the forks splits to two printf at hello and then exit.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450C6" id="P70004970270000000000000000450C6">corresponds to the parent process calling main. This vertex has no inedges and exactly one outedge. The sequence of vertices for each process ends with a vertex corresponding to a call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450C7" id="P70004970270000000000000000450C7">exit</code>. This vertex has one inedge and no outedges.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450C8" id="P70004970270000000000000000450C8">For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000068B3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.16 </span></a>shows the process graph for the example program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000689A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.15</span></a>. Initially, the parent sets variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450C9" id="P70004970270000000000000000450C9">x</code> to 1. The parent calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450CA" id="P70004970270000000000000000450CA">fork</code>, which creates a child process that runs concurrently with the parent in its own private address space.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450CB" id="P70004970270000000000000000450CB">For a program running on a single processor, any <i class="pcalibre17 pcalibre2 pcalibre1">topological sort</i> of the vertices in the corresponding process graph represents a feasible total ordering of the statements in the program. Here's a simple way to understand the idea of a topological sort: Given some permutation of the vertices in the process graph, draw the sequence of vertices in a line from left to right, and then draw each of the directed edges. The permutation is a topological sort if and only if each edge in the drawing goes from left to right. Thus, in our example program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000689A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.15</span></a>, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450CC" id="P70004970270000000000000000450CC">printf</code> statements in the parent and child can occur in either order because each of the orderings corresponds to some topological sort of the graph vertices.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450CD" id="P70004970270000000000000000450CD">The process graph can be especially helpful in understanding programs with nested <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450CE" id="P70004970270000000000000000450CE">fork</code> calls. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000068B8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.17</span></a> shows a program with two calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450CF" id="P70004970270000000000000000450CF">fork</code> in the source code. The corresponding process graph helps us see that this program runs four processes, each of which makes a call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450D0" id="P70004970270000000000000000450D0">printf</code> and which can execute in any order.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000068C8" id="P70004970270000000000000000068C8"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450D1" epub:type="title" id="P70004970270000000000000000450D1"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000068CA" epub:type="pagebreak" id="P70004970270000000000000000068CA" title="743"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.2 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006E81.xhtml#P7000497027000000000000000006F86">795</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450D2" id="P70004970270000000000000000450D2">Consider the following program:</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450D3" id="P70004970270000000000000000450D3">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob0.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450D4" id="P70004970270000000000000000450D4">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450D5" id="P70004970270000000000000000450D5">
1	int main()
2	{
3		int x = 1;
4	
5		if (Fork() == 0)
6			printf("p1: x=%d\n", ++x);
7		printf("p2: x=%d\n", --x);
8		exit(0);
9	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450D6" id="P70004970270000000000000000450D6">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob0.c</i></p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter08.xhtml#P70004970270000000000000000450D7" id="P70004970270000000000000000450D7">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450D8" id="P70004970270000000000000000450D8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450D9" id="P70004970270000000000000000450D9">What is the output of the child process?</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450DA" id="P70004970270000000000000000450DA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450DB" id="P70004970270000000000000000450DB">What is the output of the parent process?</p></li>
</ol>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000068D5" id="P70004970270000000000000000068D5"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450DC" epub:type="title" id="P70004970270000000000000000450DC"><span class="pcalibre1 pcalibre21 pcalibre2">8.4.3  </span>Reaping Child Processes</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450DD" id="P70004970270000000000000000450DD">When a process terminates for any reason, the kernel does not remove it from the system immediately. Instead, the process is kept around in a terminated state until it is <i class="pcalibre17 pcalibre2 pcalibre1">reaped</i> by its parent. When the parent reaps the terminated child, the kernel passes the child's exit status to the parent and then discards the terminated process, at which point it ceases to exist. A terminated process that has not yet been reaped is called a <i class="pcalibre17 pcalibre2 pcalibre1">zombie</i>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450DE" id="P70004970270000000000000000450DE">When a parent process terminates, the kernel arranges for the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450DF" id="P70004970270000000000000000450DF">init</code> process to become the adopted parent of any orphaned children. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450E0" id="P70004970270000000000000000450E0">init</code> process, which has a PID of 1, is created by the kernel during system start-up, never terminates, and is the ancestor of every process. If a parent process terminates without reaping its zombie children, then the kernel arranges for the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450E1" id="P70004970270000000000000000450E1">init</code> process to reap them. However, long-running programs such as shells or servers should always reap their zombie children. Even though zombies are not running, they still consume system memory resources.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450E2" id="P70004970270000000000000000450E2">A process waits for its children to terminate or stop by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450E3" id="P70004970270000000000000000450E3">waitpid</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450E4" id="P70004970270000000000000000450E4">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450E5" id="P70004970270000000000000000450E5">
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
pid_t waitpid(pid_t pid, int *statusp, int options);
			Returns: PID of child if OK, 0 (if WNOHANG), or -1 on error
</code>
</pre>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450E6" id="P70004970270000000000000000450E6"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter08.xhtml#P70004970270000000000000000450E7" epub:type="title" id="P70004970270000000000000000450E7"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000068E2" epub:type="pagebreak" id="P70004970270000000000000000068E2" title="744"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Why are terminated children called zombies?</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450E8" id="P70004970270000000000000000450E8">In folklore, a zombie is a living corpse, an entity that is half alive and half dead. A zombie process is similar in the sense that although it has already terminated, the kernel maintains some of its state until it can be reaped by the parent.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450E9" id="P70004970270000000000000000450E9">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450EA" id="P70004970270000000000000000450EA">waitpid</code> function is complicated. By default (when <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450EB" id="P70004970270000000000000000450EB">options = 0</code>), <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450EC" id="P70004970270000000000000000450EC">waitpid</code> suspends execution of the calling process until a child process in its <i class="pcalibre17 pcalibre2 pcalibre1">wait set</i> terminates. If a process in the wait set has already terminated at the time of the call, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450ED" id="P70004970270000000000000000450ED">waitpid</code> returns immediately. In either case, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450EE" id="P70004970270000000000000000450EE">waitpid</code> returns the PID of the terminated child that caused <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450EF" id="P70004970270000000000000000450EF">waitpid</code> to return. At this point, the terminated child has been reaped and the kernel removes all traces of it from the system.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000068EB" id="P70004970270000000000000000068EB"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450F0" epub:type="title" id="P70004970270000000000000000450F0">Determining the Members of the Wait Set</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450F1" id="P70004970270000000000000000450F1">The members of the wait set are determined by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450F2" id="P70004970270000000000000000450F2">pid</code> argument:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450F3" id="P70004970270000000000000000450F3">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450F4" id="P70004970270000000000000000450F4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450F5" id="P70004970270000000000000000450F5">If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450F6" id="P70004970270000000000000000450F6">pid &gt; 0</code>, then the wait set is the singleton child process whose process ID is equal to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450F7" id="P70004970270000000000000000450F7">pid</code>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000450F8" id="P70004970270000000000000000450F8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000450F9" id="P70004970270000000000000000450F9">If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450FA" id="P70004970270000000000000000450FA">pid = -1</code>, then the wait set consists of all of the parent's child processes.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450FB" id="P70004970270000000000000000450FB">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450FC" id="P70004970270000000000000000450FC">waitpid</code> function also supports other kinds of wait sets, involving Unix process groups, which we will not discuss.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000068F9" id="P70004970270000000000000000068F9"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450FD" epub:type="title" id="P70004970270000000000000000450FD">Modifying the Default Behavior</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450FE" id="P70004970270000000000000000450FE">The default behavior can be modified by setting <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000450FF" id="P70004970270000000000000000450FF">options</code> to various combinations of the WNOHANG, WUNTRACED, and WCONTINUED constants:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045100" id="P7000497027000000000000000045100">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045101" id="P7000497027000000000000000045101"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045102" id="P7000497027000000000000000045102"><span class="pcalibre1 pcalibre2 pcalibre41">WNOHANG. </span>Return immediately (with a return value of 0) if none of the child processes in the wait set has terminated yet. The default behavior suspends the calling process until a child terminates; this option is useful in those cases where you want to continue doing useful work while waiting for a child to terminate.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045103" id="P7000497027000000000000000045103"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045104" id="P7000497027000000000000000045104"><span class="pcalibre1 pcalibre2 pcalibre41">WUNTRACED. </span>Suspend execution of the calling process until a process in the wait set becomes either terminated or stopped. Return the PID of the terminated or stopped child that caused the return. The default behavior returns only for terminated children; this option is useful when you want to check for both terminated <i class="pcalibre17 pcalibre2 pcalibre1">and</i> stopped children.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045105" id="P7000497027000000000000000045105"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045106" id="P7000497027000000000000000045106"><span class="pcalibre1 pcalibre2 pcalibre41">WCONTINUED. </span>Suspend execution of the calling process until a running process in the wait set is terminated or until a stopped process in the wait set has been resumed by the receipt of a SIGCONT signal. (Signals are explained in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006993"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5</span></a>.)</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045107" id="P7000497027000000000000000045107">You can combine options by <span class="pcalibre1 pcalibre29 pcalibre2">or</span>ing them together. For example:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045108" id="P7000497027000000000000000045108">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045109" id="P7000497027000000000000000045109"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004510A" id="P700049702700000000000000004510A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006908" epub:type="pagebreak" id="P7000497027000000000000000006908" title="745"></span>WNOHANG	|	WUNTRACED: Return immediately, with a return value of 0, if none of the children in the wait set has stopped or terminated, or with a return value equal to the PID of one of the stopped or terminated children.</p></li>
</ul>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006909" id="P7000497027000000000000000006909"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004510B" epub:type="title" id="P700049702700000000000000004510B">Checking the Exit Status of a Reaped Child</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004510C" id="P700049702700000000000000004510C">If the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004510D" id="P700049702700000000000000004510D">statusp</code> argument is non-NULL, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004510E" id="P700049702700000000000000004510E">waitpid</code> encodes status information about the child that caused the return in status, which is the value pointed to by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004510F" id="P700049702700000000000000004510F">statusp</code>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045110" id="P7000497027000000000000000045110">wait.h</code> include file defines several macros for interpreting the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045111" id="P7000497027000000000000000045111">status</code> argument:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045112" id="P7000497027000000000000000045112">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045113" id="P7000497027000000000000000045113"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045114" id="P7000497027000000000000000045114"><span class="pcalibre1 pcalibre2 pcalibre41">WIFEXITED(<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045115" id="P7000497027000000000000000045115">status</code>). </span>Returns true if the child terminated normally, via a call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045116" id="P7000497027000000000000000045116">exit</code> or a return.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045117" id="P7000497027000000000000000045117"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045118" id="P7000497027000000000000000045118"><span class="pcalibre1 pcalibre2 pcalibre41">WEXITSTATUS(<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045119" id="P7000497027000000000000000045119">status</code>). </span>Returns the exit status of a normally terminated child. This status is only defined if WIFEXITED() returned true.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004511A" id="P700049702700000000000000004511A"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P700049702700000000000000004511B" id="P700049702700000000000000004511B"><span class="pcalibre1 pcalibre2 pcalibre41">WIFSIGNALED(<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004511C" id="P700049702700000000000000004511C">status</code>). </span>Returns true if the child process terminated because of a signal that was not caught.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004511D" id="P700049702700000000000000004511D"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P700049702700000000000000004511E" id="P700049702700000000000000004511E"><span class="pcalibre1 pcalibre2 pcalibre41">WTERMSIG(<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004511F" id="P700049702700000000000000004511F">status</code>). </span>Returns the number of the signal that caused the child process to terminate. This status is only defined if WIFSIGNALED() returned true.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045120" id="P7000497027000000000000000045120"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045121" id="P7000497027000000000000000045121"><span class="pcalibre1 pcalibre2 pcalibre41">WIFSTOPPED(<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045122" id="P7000497027000000000000000045122">status</code>). </span>Returns true if the child that caused the return is currently stopped.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045123" id="P7000497027000000000000000045123"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045124" id="P7000497027000000000000000045124"><span class="pcalibre1 pcalibre2 pcalibre41">WSTOPSIG(<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045125" id="P7000497027000000000000000045125">status</code>). </span>Returns the number of the signal that caused the child to stop. This status is only defined if WIFSTOPPED() returned true.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045126" id="P7000497027000000000000000045126"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045127" id="P7000497027000000000000000045127"><span class="pcalibre1 pcalibre2 pcalibre41">WIFCONTINUED(<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045128" id="P7000497027000000000000000045128">status</code>). </span>Returns true if the child process was restarted by receipt of a SIGCONT signal.</p></li></ul>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006928" id="P7000497027000000000000000006928"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045129" epub:type="title" id="P7000497027000000000000000045129">Error Conditions</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004512A" id="P700049702700000000000000004512A">If the calling process has no children, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004512B" id="P700049702700000000000000004512B">waitpid</code> returns -1 and sets <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004512C" id="P700049702700000000000000004512C">errno</code> to ECHILD. If the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004512D" id="P700049702700000000000000004512D">waitpid</code> function was interrupted by a signal, then it returns -1 and sets <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004512E" id="P700049702700000000000000004512E">errno</code> to EINTR.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P700049702700000000000000000692F" id="P700049702700000000000000000692F"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004512F" epub:type="title" id="P700049702700000000000000004512F"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.3 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045130" id="P7000497027000000000000000045130">List all of the possible output sequences for the following program:</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045131" id="P7000497027000000000000000045131">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitprob0.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045132" id="P7000497027000000000000000045132">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045133" id="P7000497027000000000000000045133">
1	int main()
2	{
3		if (Fork() == 0) {
4			printf("a"); fflush(stdout);
5		}
6		else {
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006935" epub:type="pagebreak" id="P7000497027000000000000000006935" title="746"></span>7			printf("b"); fflush(stdout);
8			waitpid(-1, NULL, 0);
9		}
10		printf("c"); fflush(stdout);
11		exit(0);
12	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045134" id="P7000497027000000000000000045134">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitprob0.c</i></p>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006937" id="P7000497027000000000000000006937"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045135" epub:type="title" id="P7000497027000000000000000045135">The <code class="pcalibre1 pcalibre2 calibre16" data-uri="chapter08.xhtml#P7000497027000000000000000045136" id="P7000497027000000000000000045136">wait</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045137" id="P7000497027000000000000000045137">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045138" id="P7000497027000000000000000045138">wait</code> function is a simpler version of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045139" id="P7000497027000000000000000045139">waitpid</code>.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004513A" id="P700049702700000000000000004513A">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004513B" id="P700049702700000000000000004513B">
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
pid_t wait(int *statusp);
				Returns: PID of child if OK or -1 on error
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004513C" id="P700049702700000000000000004513C">Calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004513D" id="P700049702700000000000000004513D">wait(&amp;status)</code> is equivalent to calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004513E" id="P700049702700000000000000004513E">waitpid(-1, &amp;status, 0).</code></p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006942" id="P7000497027000000000000000006942"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004513F" epub:type="title" id="P700049702700000000000000004513F">Examples of Using <code class="pcalibre1 pcalibre2 calibre16" data-uri="chapter08.xhtml#P7000497027000000000000000045140" id="P7000497027000000000000000045140">waitpid</code></h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045141" id="P7000497027000000000000000045141">Because the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045142" id="P7000497027000000000000000045142">waitpid</code> function is somewhat complicated, it is helpful to look at a few examples. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006957"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.18 </span></a>shows a program that uses <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045143" id="P7000497027000000000000000045143">waitpid</code> to wait, in no particular order, for all of its <var class="pcalibre17 pcalibre2 pcalibre1">N</var> children to terminate. In line 11, the parent creates each of the <var class="pcalibre17 pcalibre2 pcalibre1">N</var> children, and in line 12, each child exits with a unique exit status.</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045144" id="P7000497027000000000000000045144"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter08.xhtml#P7000497027000000000000000045145" epub:type="title" id="P7000497027000000000000000045145"><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Constants associated with Unix functions</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045146" id="P7000497027000000000000000045146">Constants such as WNOHANG and WUNTRACED are defined by system header files. For example, WNOHANG and WUNTRACED are defined (indirectly) by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045147" id="P7000497027000000000000000045147">wait.h</code> header file:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045148" id="P7000497027000000000000000045148">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045149" id="P7000497027000000000000000045149">
/* Bits in the third argument to ‘waitpid’. */
#define WNOHANG 1 /* Don't block waiting. */
#define WUNTRACED 2 /* Report status of stopped children. */
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P700049702700000000000000004514A" id="P700049702700000000000000004514A">In order to use these constants, you must include the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004514B" id="P700049702700000000000000004514B">wait.h</code> header file in your code:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004514C" id="P700049702700000000000000004514C"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004514D" id="P700049702700000000000000004514D">
#include &lt;sys/wait.h&gt;
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004514E" id="P700049702700000000000000004514E">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004514F" id="P700049702700000000000000004514F">man</code> page for each Unix function lists the header files to include whenever you use that function in your code. Also, in order to check return codes such as ECHILD and EINTR, you must include <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045150" id="P7000497027000000000000000045150">errno.h.</code> To simplify our code examples, we include a single header file called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045151" id="P7000497027000000000000000045151">csapp.h</code> that includes the header files for all of the functions used in the book. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045152" id="P7000497027000000000000000045152">csapp.h</code> header file is available online from the CS:APP Web site.</p>
</aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006957" id="P7000497027000000000000000006957">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045153" id="P7000497027000000000000000045153">------------------------------------------------------------------------------------------------------<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006959" epub:type="pagebreak" id="P7000497027000000000000000006959" title="747"></span><i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitpid1.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045154" id="P7000497027000000000000000045154">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045155" id="P7000497027000000000000000045155">
1	#include "csapp.h"
2	#define N 2
3	
4	int main()
5	{
6		int status, i;
7		pid_t pid;
8	
9		/* Parent creates N children */
10		for (i = 0; i &lt; N; i++)
11			if ((pid = Fork()) == 0) /* Child */
12				exit(100+i);
13	
14		/* Parent reaps N children in no particular order */
15		while ((pid = waitpid(-1, &amp;status, 0)) &gt; 0) {
16			if (WIFEXITED(status))
17				printf("child %d terminated normally with exit status=%d\n",
18					pid, WEXITSTATUS(status));
19		else
20			printf("child %d terminated abnormally\n", pid);
21		}
22	
23		/* The only normal termination is if there are no more children */
24		if (errno != ECHILD)
25			unix_error("waitpid error");
26	
27		exit(0);
28	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045156" id="P7000497027000000000000000045156">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitpid1.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045157" id="P7000497027000000000000000045157"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045158" epub:type="title" id="P7000497027000000000000000045158"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.18 </span>Using the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045159" id="P7000497027000000000000000045159">waitpid</code> function to reap zombie children in no particular order.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004515A" id="P700049702700000000000000004515A">---------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitpid1.c</i></p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004515B" id="P700049702700000000000000004515B">Before moving on, make sure you understand why line 12 is executed by each of the children, but not the parent.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004515C" id="P700049702700000000000000004515C">In line 15, the parent waits for all of its children to terminate by using <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004515D" id="P700049702700000000000000004515D">waitpid</code> as the test condition of a while loop. Because the first argument is -1, the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004515E" id="P700049702700000000000000004515E">waitpid</code> blocks until an arbitrary child has terminated. As each child terminates, the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004515F" id="P700049702700000000000000004515F">waitpid</code> returns with the nonzero PID of that child. Line 16 checks the exit status of the child. If the child terminated normally—in this case, by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045160" id="P7000497027000000000000000045160">exit</code> function—then the parent extracts the exit status and prints it on <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045161" id="P7000497027000000000000000045161">stdout</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045162" id="P7000497027000000000000000045162">When all of the children have been reaped, the next call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045163" id="P7000497027000000000000000045163">waitpid</code> returns -1 and sets <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045164" id="P7000497027000000000000000045164">errno</code> to ECHILD. Line 24 checks that the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045165" id="P7000497027000000000000000045165">waitpid</code> function terminated normally, and prints an error message otherwise. When we run the program on our Linux system, it produces the following output:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045166" id="P7000497027000000000000000045166">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045167" id="P7000497027000000000000000045167">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000696D" epub:type="pagebreak" id="P700049702700000000000000000696D" title="748"></span>linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./waitpid1</i>
child 22966 terminated normally with exit status=100
child 22967 terminated normally with exit status=101
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045168" id="P7000497027000000000000000045168">Notice that the program reaps its children in no particular order. The order that they were reaped is a property of this specific computer system. On another system, or even another execution on the same system, the two children might have been reaped in the opposite order. This is an example of the <i class="pcalibre17 pcalibre2 pcalibre1">nondeterministic</i> behavior that can make reasoning about concurrency so difficult. Either of the two possible outcomes is equally correct, and as a programmer you may <i class="pcalibre17 pcalibre2 pcalibre1">never</i> assume that one outcome will always occur, no matter how unlikely the other outcome appears to be. The only correct assumption is that each possible outcome is equally likely.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045169" id="P7000497027000000000000000045169"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000697D"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.19 </span></a>shows a simple change that eliminates this nondeterminism in the output order by reaping the children in the same order that they were created by the parent. In line 11, the parent stores the PIDs of its children in order and then waits for each child in this same order by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004516A" id="P700049702700000000000000004516A">waitpid</code> with the appropriate PID in the first argument.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006971" id="P7000497027000000000000000006971"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004516B" epub:type="title" id="P700049702700000000000000004516B"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.4 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004516C" id="P700049702700000000000000004516C">Consider the following program:</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004516D" id="P700049702700000000000000004516D">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitprob1.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004516E" id="P700049702700000000000000004516E">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004516F" id="P700049702700000000000000004516F">
1	int main()
2	{
3		int status;
4		pid_t pid;
5	
6		printf("Hello\n");
7		pid = Fork();
8		printf("%d\n", !pid);
9		if (pid != 0) {
10			if (waitpid(-1, &amp;status, 0) &gt; 0) {
11				if (WIFEXITED(status) != 0)
12					printf("%d\n", WEXITSTATUS(status));
13				}
14		}
15		printf("Bye\n");
16		exit(2);
17	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045170" id="P7000497027000000000000000045170">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitprob1.c</i></p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter08.xhtml#P7000497027000000000000000045171" id="P7000497027000000000000000045171">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045172" id="P7000497027000000000000000045172"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045173" id="P7000497027000000000000000045173">How many output lines does this program generate?</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045174" id="P7000497027000000000000000045174"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045175" id="P7000497027000000000000000045175">What is one possible ordering of these output lines?</p></li>
</ol>
</section>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P700049702700000000000000000697D" id="P700049702700000000000000000697D">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045176" id="P7000497027000000000000000045176"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000697F" epub:type="pagebreak" id="P700049702700000000000000000697F" title="749"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitpid2.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045177" id="P7000497027000000000000000045177">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045178" id="P7000497027000000000000000045178">
1	#include "csapp.h"
2	#define N 2
3
4	int main()
5	{
6		int status, i;
7		pid_t pid[N], retpid;
8	
9		/* Parent creates N children */
10		for (i = 0; i &lt; N; i++)
11			if ((pid[i] = Fork()) == 0) /* Child */
12				exit(100+i);
13	
14		/* Parent reaps N children in order */
15		i = 0;
16		while ((retpid = waitpid(pid[i++], &amp;status, 0)) &gt; 0) {
17			if (WIFEXITED(status))
18				printf("child %d terminated normally with exit status=%d\n",
19					retpid, WEXITSTATUS(status));
20			else
21				printf("child %d terminated abnormally\n", retpid);
22		}
23	
24		/* The only normal termination is if there are no more children */
25		if (errno != ECHILD)
26		unix_error("waitpid error");
27	
28		exit(0);
29	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045179" id="P7000497027000000000000000045179">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitpid2.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004517A" id="P700049702700000000000000004517A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004517B" epub:type="title" id="P700049702700000000000000004517B"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.19 </span>Using <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004517C" id="P700049702700000000000000004517C">waitpid</code> to reap zombie children in the order they were created.</h1></header>
</figcaption>
</figure>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006986" id="P7000497027000000000000000006986"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004517D" epub:type="title" id="P700049702700000000000000004517D"><span class="pcalibre1 pcalibre21 pcalibre2">8.4.4  </span>Putting Processes to Sleep</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004517E" id="P700049702700000000000000004517E">The sleep function suspends a process for a specified period of time.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004517F" id="P700049702700000000000000004517F">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045180" id="P7000497027000000000000000045180">
#include &lt;unistd.h&gt;
unsigned int sleep(unsigned int secs);
					Returns: seconds left to sleep
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045181" id="P7000497027000000000000000045181"><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045182" id="P7000497027000000000000000045182">Sleep</code> returns zero if the requested amount of time has elapsed, and the number of seconds still left to sleep otherwise. The latter case is possible if the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045183" id="P7000497027000000000000000045183">sleep</code> function <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000698E" epub:type="pagebreak" id="P700049702700000000000000000698E" title="750"></span>returns prematurely because it was interrupted by a <i class="pcalibre17 pcalibre2 pcalibre1">signal.</i> We will discuss signals in detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006993"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5</span></a>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045184" id="P7000497027000000000000000045184">Another function that we will find useful is the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045185" id="P7000497027000000000000000045185">pause</code> function, which puts the calling function to sleep until a signal is received by the process.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045186" id="P7000497027000000000000000045186">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045187" id="P7000497027000000000000000045187">
#include &lt;unistd.h&gt;
int pause(void);
Always returns -1
</code>
</pre>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006993" id="P7000497027000000000000000006993"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045188" epub:type="title" id="P7000497027000000000000000045188"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045189" id="P7000497027000000000000000045189">Write a wrapper function for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004518A" id="P700049702700000000000000004518A">sleep</code>, called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004518B" id="P700049702700000000000000004518B">snooze</code>, with the following interface:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004518C" id="P700049702700000000000000004518C"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004518D" id="P700049702700000000000000004518D">unsigned int snooze(unsigned int secs);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004518E" id="P700049702700000000000000004518E">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004518F" id="P700049702700000000000000004518F">snooze</code> function behaves exactly as the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045190" id="P7000497027000000000000000045190">sleep</code> function, except that it prints a message describing how long the process actually slept:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045191" id="P7000497027000000000000000045191"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045192" id="P7000497027000000000000000045192">Slept for 4 of 5 secs.</code></pre>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P700049702700000000000000000699F" id="P700049702700000000000000000699F"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045193" epub:type="title" id="P7000497027000000000000000045193"><span class="pcalibre1 pcalibre21 pcalibre2">8.4.5  </span>Loading and Running Programs</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045194" id="P7000497027000000000000000045194">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045195" id="P7000497027000000000000000045195">execve</code> function loads and runs a new program in the context of the current process.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045196" id="P7000497027000000000000000045196">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045197" id="P7000497027000000000000000045197">
#include &lt;unistd.h&gt;
int execve(const char *filename, const char *argv[],
const char *envp[]);
Does not return if OK; returns -1 on error
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045198" id="P7000497027000000000000000045198">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045199" id="P7000497027000000000000000045199">execve</code> function loads and runs the executable object file <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004519A" id="P700049702700000000000000004519A">filename</code> with the argument list <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004519B" id="P700049702700000000000000004519B">argv</code> and the environment variable list <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004519C" id="P700049702700000000000000004519C">envp. Execve</code> returns to the calling program only if there is an error, such as not being able to find <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004519D" id="P700049702700000000000000004519D">filename</code>. So unlike <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004519E" id="P700049702700000000000000004519E">fork</code>, which is called once but returns twice, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004519F" id="P700049702700000000000000004519F">execve</code> is called once and never returns.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451A0" id="P70004970270000000000000000451A0">The argument list is represented by the data structure shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000069B1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.20</span></a>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451A1" id="P70004970270000000000000000451A1">argv</code> variable points to a null-terminated array of pointers, each of which points to an argument string. By convention, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451A2" id="P70004970270000000000000000451A2">argv [0]</code> is the name of the executable object file. The list of environment variables is represented by a similar data structure, shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000069B6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.21</span></a>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451A3" id="P70004970270000000000000000451A3">envp</code> variable points to a null-terminated array of pointers to environment variable strings, each of which is a name-value pair of the form <i class="pcalibre17 pcalibre2 pcalibre1">name=value.</i></p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000069B1" id="P70004970270000000000000000069B1">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000069B2" epub:type="pagebreak" id="P70004970270000000000000000069B2" title="751"></span><img alt="A diagram shows the organization of an argument list." class="pcalibre252 pcalibre2 pcalibre1" data-uri="P700049702700000000000000000B76E" id="P70004970270000000000000000451A4" src="Images/chapter-07-image-13.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000451A5" id="P70004970270000000000000000451A5"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000451A6" epub:type="title" id="P70004970270000000000000000451A6"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.20 </span>Organization of an argument list.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P70004970270000000000000000254CC" id="P70004970270000000000000000254CC">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451A7" id="P70004970270000000000000000451A7">A stack titled argv[] has the following sections from top to bottom:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter08.xhtml#P70004970270000000000000000451A8" id="P70004970270000000000000000451A8">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451A9" id="P70004970270000000000000000451A9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451AA" id="P70004970270000000000000000451AA">argv[0] (input argv, output “ls”)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451AB" id="P70004970270000000000000000451AB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451AC" id="P70004970270000000000000000451AC">argv[1] (output “-lt”)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451AD" id="P70004970270000000000000000451AD"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451AE" id="P70004970270000000000000000451AE">Gap</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451AF" id="P70004970270000000000000000451AF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451B0" id="P70004970270000000000000000451B0">Argv[argc-1] (output “/user/include”)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451B1" id="P70004970270000000000000000451B1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451B2" id="P70004970270000000000000000451B2">NULL</p></li>
</ul>
</details>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000069B6" id="P70004970270000000000000000069B6">
<img alt="A diagram shows the organization of an environment variable list." class="pcalibre253 pcalibre1 pcalibre2" data-uri="P700049702700000000000000000B76F" id="P70004970270000000000000000451B3" src="Images/chapter-07-image-14.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000451B4" id="P70004970270000000000000000451B4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000451B5" epub:type="title" id="P70004970270000000000000000451B5"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.21 </span>Organization of an environment variable list.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P70004970270000000000000000254DC" id="P70004970270000000000000000254DC">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451B6" id="P70004970270000000000000000451B6">A stack titled envp[] has the following sections from top to bottom:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter08.xhtml#P70004970270000000000000000451B7" id="P70004970270000000000000000451B7">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451B8" id="P70004970270000000000000000451B8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451B9" id="P70004970270000000000000000451B9">envp[0] (input envp, output “PWD=/usr/droh”)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451BA" id="P70004970270000000000000000451BA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451BB" id="P70004970270000000000000000451BB">envp[1] (output “PRINTER=iron”)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451BC" id="P70004970270000000000000000451BC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451BD" id="P70004970270000000000000000451BD">Gap</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451BE" id="P70004970270000000000000000451BE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451BF" id="P70004970270000000000000000451BF">envp[n-1] (output “USER=droh”)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451C0" id="P70004970270000000000000000451C0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451C1" id="P70004970270000000000000000451C1">NULL</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451C2" id="P70004970270000000000000000451C2">After <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451C3" id="P70004970270000000000000000451C3">execve</code> loads <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451C4" id="P70004970270000000000000000451C4">filename</code>, it calls the start-up code described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006385.xhtml#P7000497027000000000000000006385"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">7.9</span></a>. The start-up code sets up the stack and passes control to the main routine of the new program, which has a prototype of the form</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451C5" id="P70004970270000000000000000451C5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451C6" id="P70004970270000000000000000451C6">int main(int arge, char **argv, char **envp);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451C7" id="P70004970270000000000000000451C7">or equivalently,</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451C8" id="P70004970270000000000000000451C8"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451C9" id="P70004970270000000000000000451C9">int main(int arge, char *argv[], char *envp[]);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451CA" id="P70004970270000000000000000451CA">When <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451CB" id="P70004970270000000000000000451CB">main</code> begins executing, the user stack has the organization shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000069D2"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.22</span></a>. Let's work our way from the bottom of the stack (the highest address) to the top (the lowest address). First are the argument and environment strings. These are followed further up the stack by a null-terminated array of pointers, each of which points to an environment variable string on the stack. The global variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451CC" id="P70004970270000000000000000451CC">environ</code> points to the first of these pointers, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451CD" id="P70004970270000000000000000451CD">envp [0]</code>. The environment array is followed by the null-terminated <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451CE" id="P70004970270000000000000000451CE">argv []</code> array, with each element pointing to an argument string on the stack. At the top of the stack is the stack frame for the system start-up function, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451CF" id="P70004970270000000000000000451CF">libc_start_main</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006385.xhtml#P7000497027000000000000000006385"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">7.9</span></a>).</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451D0" id="P70004970270000000000000000451D0">There are three arguments to function main, each stored in a register according to the x86-64 stack discipline: (1) <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451D1" id="P70004970270000000000000000451D1">argc</code>, which gives the number of non-null pointers in the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451D2" id="P70004970270000000000000000451D2">argv []</code> array; (2) <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451D3" id="P70004970270000000000000000451D3">argv</code>, which points to the first entry in the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451D4" id="P70004970270000000000000000451D4">argv []</code> array; and (3) <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451D5" id="P70004970270000000000000000451D5">envp</code>, which points to the first entry in the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451D6" id="P70004970270000000000000000451D6">envp []</code> array.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451D7" id="P70004970270000000000000000451D7">Linux provides several functions for manipulating the environment array:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451D8" id="P70004970270000000000000000451D8">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451D9" id="P70004970270000000000000000451D9">
#include &lt;stdlib.h&gt;
char *getenv(const char *name);
				Returns: pointer to name if it exists, NULL if no match
</code>
</pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P70004970270000000000000000069D2" id="P70004970270000000000000000069D2">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000069D3" epub:type="pagebreak" id="P70004970270000000000000000069D3" title="752"></span><img alt="A diagram shows the typical organization of the user stack." class="pcalibre1 pcalibre2 pcalibre254" data-uri="P700049702700000000000000000B770" id="P70004970270000000000000000451DA" src="Images/chapter-07-image-15.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000451DB" id="P70004970270000000000000000451DB"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000451DC" epub:type="title" id="P70004970270000000000000000451DC"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.22 </span>Typical organization of the user stack when a new program starts.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P7000497027000000000000000025504" id="P7000497027000000000000000025504">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451DD" id="P70004970270000000000000000451DD">The sections of the stack are summarized below from bottom to top:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter08.xhtml#P70004970270000000000000000451DE" id="P70004970270000000000000000451DE">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451DF" id="P70004970270000000000000000451DF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451E0" id="P70004970270000000000000000451E0">Future stack frame for main, below top of stack</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451E1" id="P70004970270000000000000000451E1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451E2" id="P70004970270000000000000000451E2">Stack frame for libc_start_main, labeled argc (in %rdi), above top of stack</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451E3" id="P70004970270000000000000000451E3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451E4" id="P70004970270000000000000000451E4">Gap</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451E5" id="P70004970270000000000000000451E5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451E6" id="P70004970270000000000000000451E6">Argv[0], arrow from argv (in %rsi) (arrow to above gap near bottom of stack)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451E7" id="P70004970270000000000000000451E7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451E8" id="P70004970270000000000000000451E8">…</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451E9" id="P70004970270000000000000000451E9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451EA" id="P70004970270000000000000000451EA">argv[argc-1]</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451EB" id="P70004970270000000000000000451EB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451EC" id="P70004970270000000000000000451EC">argv[argc] = NULL</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451ED" id="P70004970270000000000000000451ED"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451EE" id="P70004970270000000000000000451EE">envp[0], arrow from environ (global var) and envp (in %rdx), and arrow to bottom of stack</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451EF" id="P70004970270000000000000000451EF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451F0" id="P70004970270000000000000000451F0">…</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451F1" id="P70004970270000000000000000451F1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451F2" id="P70004970270000000000000000451F2">envp[n-1]</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451F3" id="P70004970270000000000000000451F3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451F4" id="P70004970270000000000000000451F4">envp[n] == NULL</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451F5" id="P70004970270000000000000000451F5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451F6" id="P70004970270000000000000000451F6">Gap</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451F7" id="P70004970270000000000000000451F7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451F8" id="P70004970270000000000000000451F8">Null-terminated command-line arg strings (arrow from argv[0])</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451F9" id="P70004970270000000000000000451F9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000451FA" id="P70004970270000000000000000451FA">Null-terminated environment variable strings to bottom of stack (arrow from envp[0])</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451FB" id="P70004970270000000000000000451FB">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451FC" id="P70004970270000000000000000451FC">getenv</code> function searches the environment array for a string <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451FD" id="P70004970270000000000000000451FD">name=<i class="pcalibre17 pcalibre2 pcalibre1">value.</i></code> If found, it returns a pointer to <i class="pcalibre17 pcalibre2 pcalibre1">value;</i> otherwise, it returns <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000451FE" id="P70004970270000000000000000451FE">NULL</code>.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000451FF" id="P70004970270000000000000000451FF">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045200" id="P7000497027000000000000000045200">
#include &lt;stdlib.h&gt;
int setenv(const char *name, const char *newvalue, int overwrite);
					Returns: 0 on success, -1 on error
void unsetenv(const char *name);
							 Returns: nothing
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045201" id="P7000497027000000000000000045201">If the environment array contains a string of the form <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045202" id="P7000497027000000000000000045202">name=<i class="pcalibre17 pcalibre2 pcalibre1">oldvalue</i></code>, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045203" id="P7000497027000000000000000045203">unsetenv</code> deletes it and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045204" id="P7000497027000000000000000045204">setenv</code> replaces <i class="pcalibre17 pcalibre2 pcalibre1">oldvalue</i> with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045205" id="P7000497027000000000000000045205">newvalue</code>, but only if <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045206" id="P7000497027000000000000000045206">overwrite</code> is nonzero. If name does not exist, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045207" id="P7000497027000000000000000045207">setenv</code> adds <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045208" id="P7000497027000000000000000045208">name=newvalue</code> to the array.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000069E5" epub:type="practice" id="P70004970270000000000000000069E5"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045209" epub:type="title" id="P7000497027000000000000000045209"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.6 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P700049702700000000000000004520A" id="P700049702700000000000000004520A">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P700049702700000000000000004520B" id="P700049702700000000000000004520B"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P700049702700000000000000004520C" id="P700049702700000000000000004520C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004520D" id="P700049702700000000000000004520D">Write a program called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004520E" id="P700049702700000000000000004520E">myecho</code> that prints its command-line arguments and environment variables. For example:</p></div>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004520F" id="P700049702700000000000000004520F">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045210" id="P7000497027000000000000000045210">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./myecho argl arg2</i>
Command-ine arguments:
argv[ 0]: myecho
argv[ 1]: arg1
argv[ 2]: arg2
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P70004970270000000000000000069EE" epub:type="pagebreak" id="P70004970270000000000000000069EE" title="753"></span>Environment variables :
envp[ 0]: PWD=/usr0/droh/ics/code/ecf
envp [ 1]: TERM=emacs
⋮
envp[25]: USER=droh
envp[26]: SHELL=/usr/local/bin/tcsh
envp[27]: HOME=/usr0/droh
</code>
</pre>
</li>
</ol>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P70004970270000000000000000069EF" id="P70004970270000000000000000069EF"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045211" epub:type="title" id="P7000497027000000000000000045211"><span class="pcalibre1 pcalibre21 pcalibre2">8.4.6 </span>Using <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045212" id="P7000497027000000000000000045212">fork</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045213" id="P7000497027000000000000000045213">execve</code> to Run Programs</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045214" id="P7000497027000000000000000045214">Programs such as Unix shells and Web servers make heavy use of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045215" id="P7000497027000000000000000045215">fork</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045216" id="P7000497027000000000000000045216">execve</code> functions. A <i class="pcalibre17 pcalibre2 pcalibre1">shell</i> is an interactive application-level program that runs other programs on behalf of the user. The original shell was the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045217" id="P7000497027000000000000000045217">sh</code> program, which was followed by variants such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045218" id="P7000497027000000000000000045218">csh, tcsh, ksh</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045219" id="P7000497027000000000000000045219">bash</code>. A shell performs a sequence of <i class="pcalibre17 pcalibre2 pcalibre1">read/evaluate</i> steps and then terminates. The read step reads a command line from the user. The evaluate step parses the command line and runs programs on behalf of the user.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004521A" id="P700049702700000000000000004521A"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006A09"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.23 </span></a>shows the main routine of a simple shell. The shell prints a command-line prompt, waits for the user to type a command line on <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004521B" id="P700049702700000000000000004521B">stdin</code>, and then evaluates the command line.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004521C" id="P700049702700000000000000004521C"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006A1B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.24 </span></a>shows the code that evaluates the command line. Its first task is to call the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004521D" id="P700049702700000000000000004521D">parseline</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006A24"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.25</span></a>), which parses the space-separated command-line arguments and builds the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004521E" id="P700049702700000000000000004521E">argv</code> vector that will eventually be passed to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004521F" id="P700049702700000000000000004521F">execve</code>. The first argument is assumed to be either the name of a built-in shell command that is interpreted immediately, or an executable object file that will be loaded and run in the context of a new child process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045220" id="P7000497027000000000000000045220">If the last argument is an ‘&amp;’ character, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045221" id="P7000497027000000000000000045221">parseline</code> returns 1, indicating that the program should be executed in the <i class="pcalibre17 pcalibre2 pcalibre1">background</i> (the shell does not wait for it to complete). Otherwise, it returns 0, indicating that the program should be run in the <i class="pcalibre17 pcalibre2 pcalibre1">foreground</i> (the shell waits for it to complete).</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045222" id="P7000497027000000000000000045222"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter08.xhtml#P7000497027000000000000000045223" epub:type="title" id="P7000497027000000000000000045223"><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Programs versus processes</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045224" id="P7000497027000000000000000045224">This is a good place to pause and make sure you understand the distinction between a program and a process. A program is a collection of code and data; programs can exist as object files on disk or as segments in an address space. A process is a specific instance of a program in execution; a program always runs in the context of some process. Understanding this distinction is important if you want to understand the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045225" id="P7000497027000000000000000045225">fork</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045226" id="P7000497027000000000000000045226">execve</code> functions. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045227" id="P7000497027000000000000000045227">fork</code> function runs the same program in a new child process that is a duplicate of the parent. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045228" id="P7000497027000000000000000045228">execve</code> function loads and runs a new program in the context of the current process. While it overwrites the address space of the current process, it does <i class="pcalibre17 pcalibre2 pcalibre1">not</i> create a new process. The new program still has the same PID, and it inherits all of the file descriptors that were open at the time of the call to the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045229" id="P7000497027000000000000000045229">execve</code> function.</p>
</aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006A09" id="P7000497027000000000000000006A09">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004522A" id="P700049702700000000000000004522A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006A0B" epub:type="pagebreak" id="P7000497027000000000000000006A0B" title="754"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004522B" id="P700049702700000000000000004522B">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004522C" id="P700049702700000000000000004522C">
1	#include "csapp.h"
2	#define MAXARGS 128
3	
4	/* Function prototypes */
5	void evaKchar *cmdline);
6	int parseline(char *buf, char **argv);
7	int builtin_command(char **argv);
8	
9	int main()
10	{
11		char cmdline[MAXLINE]; /* Command line */
12	
13		while (1) {
14		/* Read */
15		printf("&gt; ");
16		Fgets(cmdline, MAXLINE, stdin);
17		if (feof(stdin))
18			exit(0);
19	
20		/* Evaluate */
21		eval(cmdline);
22	}
23	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004522D" id="P700049702700000000000000004522D">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004522E" id="P700049702700000000000000004522E"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004522F" epub:type="title" id="P700049702700000000000000004522F"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.23 </span>The main routine for a simple shell program.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045230" id="P7000497027000000000000000045230">After parsing the command line, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045231" id="P7000497027000000000000000045231">eval</code> function calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045232" id="P7000497027000000000000000045232">builtin_command</code> function, which checks whether the first command-line argument is a built-in shell command. If so, it interprets the command immediately and returns 1. Otherwise, it returns 0. Our simple shell has just one built-in command, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045233" id="P7000497027000000000000000045233">quit</code> command, which terminates the shell. Real shells have numerous commands, such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045234" id="P7000497027000000000000000045234">pwd, jobs</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045235" id="P7000497027000000000000000045235">fg</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045236" id="P7000497027000000000000000045236">If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045237" id="P7000497027000000000000000045237">builtin_command</code> returns 0, then the shell creates a child process and executes the requested program inside the child. If the user has asked for the program to run in the background, then the shell returns to the top of the loop and waits for the next command line. Otherwise the shell uses the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045238" id="P7000497027000000000000000045238">waitpid</code> function to wait for the job to terminate. When the job terminates, the shell goes on to the next iteration.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045239" id="P7000497027000000000000000045239">Notice that this simple shell is flawed because it does not reap any of its background children. Correcting this flaw requires the use of signals, which we describe in the next section.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006A1B" id="P7000497027000000000000000006A1B">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004523A" id="P700049702700000000000000004523A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006A1D" epub:type="pagebreak" id="P7000497027000000000000000006A1D" title="755"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004523B" id="P700049702700000000000000004523B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004523C" id="P700049702700000000000000004523C">
1	/* eval - Evaluate a command line */
2	void evaKchar *cmdline)
3	{
4		char *argv[MAXARGS];	/* Argument list execve() */
5		char buf[MAXLINE];	/* Holds modified command line */
6		int bg;	/* Should the job run in bg or fg? */
7		pid_t pid;	/* Process id */
8	
9		strcpy(buf, cmdline);
10		bg = parseline(buf, argv);
11		if (argv[0] == NULL)
12			return;	/* Ignore empty lines */
13	
14		if (!builtin_command(argv)) {
15			if ((pid = Fork()) == 0) {	/* Child runs user job */
16				if (execve(argv[0], argv, environ) &lt; 0) {
17					printf("%s: Command not found.\n", argv[0]);
18					exit(0);
19				}
20			}
21	
22			/* Parent waits for foreground job to terminate */
23			if (!bg) {
24				int status;
25				if (waitpid(pid, &amp;status, 0) &lt; 0)
26					unix_error("waitfg: waitpid error");
27			}
28			else
29				printf (%d %s", pid, cmdline);
30		}
31		return;
32	}
33	
34	/* If first arg is a builtin command, run it and return true */
35	int builtin_command(char **argv)
36	{
37		if (!strcmp(argv[0], "quit"))	/* quit command */
38			exit(0);
39		if (!strcmp(argv[0], "&amp;"))	/* Ignore singleton &amp; */
40		return 1;
41		return 0;	/* Not a builtin command */
42	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004523D" id="P700049702700000000000000004523D">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004523E" id="P700049702700000000000000004523E"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004523F" epub:type="title" id="P700049702700000000000000004523F"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.24 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045240" id="P7000497027000000000000000045240">eval</code> evaluates the shell command line.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006A24" id="P7000497027000000000000000006A24">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045241" id="P7000497027000000000000000045241"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006A26" epub:type="pagebreak" id="P7000497027000000000000000006A26" title="756"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045242" id="P7000497027000000000000000045242"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045243" id="P7000497027000000000000000045243">
1	/* parseline - Parse the command line and build the argv array */
2	int parseline(char *buf, char **argv)
3	{
4		char *delim;	/* Points to first space delimiter */
5		int argc;	/* Number of args */
6		int bg;	/* Background job? */ 7
7	
8		buf[strlen(buf) -1] = ‘ ’;	/* Replace trailing ‘\n’ with space */
9		while (*buf &amp;&amp; (*buf == ‘ ’)) /* Ignore leading spaces */
10			buf++;
11	
12		/* Build the argv list */
13		argc = 0;
14		while ((delim = strchr(buf, ‘ ’))) {
15			argv [argc++] = buf;
16			*delim = ‘\0’;
17			buf = delim + 1;
18			while (*buf &amp;&amp; (*buf == ‘ ’)) /* Ignore spaces */
19				buf++;
20		}
21		argv [argc] = NULL;
22	
23		if (argc == 0) /* Ignore blank line */
24			return 1;
25	
26		/* Should the job run in the background? */
27		if ((bg = (*argv[argc-1] == ‘&amp;’)) != 0)
28			argv[—argc] = NULL;
29	
30		return bg;
31	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045244" id="P7000497027000000000000000045244">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045245" id="P7000497027000000000000000045245"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045246" epub:type="title" id="P7000497027000000000000000045246"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.25 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045247" id="P7000497027000000000000000045247">parseline</code> parses a line of input for the shell.</h1></header>
</figcaption>
</figure>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>8.5 Signals</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000006A2D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045248" epub:type="title" id="P7000497027000000000000000045248"><span class="pcalibre1 pcalibre21 pcalibre2">8.5 </span>Signals</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045249" id="P7000497027000000000000000045249">To this point in our study of exceptional control flow, we have seen how hardware and software cooperate to provide the fundamental low-level exception mechanism. We have also seen how the operating system uses exceptions to support a form of exceptional control flow known as the process context switch. In this section, we will study a higher-level software form of exceptional control flow, known as a Linux signal, that allows processes and the kernel to interrupt other processes.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006A30" id="P7000497027000000000000000006A30">
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter08.xhtml#P700049702700000000000000004524A" id="P700049702700000000000000004524A">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P700049702700000000000000004524B" id="P700049702700000000000000004524B"><span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter08.xhtml#P7000497027000000000000000006A33" epub:type="pagebreak" id="P7000497027000000000000000006A33" title="757"></span>Number	</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P700049702700000000000000004524C" id="P700049702700000000000000004524C">Name	</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P700049702700000000000000004524D" id="P700049702700000000000000004524D">Default action	</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P700049702700000000000000004524E" id="P700049702700000000000000004524E">Corresponding event</th></tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004524F" id="P700049702700000000000000004524F">1</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045250" id="P7000497027000000000000000045250">SIGHUP</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045251" id="P7000497027000000000000000045251">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045252" id="P7000497027000000000000000045252">Terminal line hangup</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045253" id="P7000497027000000000000000045253">2</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045254" id="P7000497027000000000000000045254">SIGINT</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045255" id="P7000497027000000000000000045255">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045256" id="P7000497027000000000000000045256">Interrupt from keyboard</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045257" id="P7000497027000000000000000045257">3</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045258" id="P7000497027000000000000000045258">SIGQUIT</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045259" id="P7000497027000000000000000045259">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004525A" id="P700049702700000000000000004525A">Quit from keyboard</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004525B" id="P700049702700000000000000004525B">4</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004525C" id="P700049702700000000000000004525C">SIGILL</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004525D" id="P700049702700000000000000004525D">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004525E" id="P700049702700000000000000004525E">Illegal instruction</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004525F" id="P700049702700000000000000004525F">5</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045260" id="P7000497027000000000000000045260">SIGTRAP</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045261" id="P7000497027000000000000000045261">Terminate and dump core<sup class="pcalibre1 pcalibre2 calibre8">a</sup></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045262" id="P7000497027000000000000000045262">Trace trap</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045263" id="P7000497027000000000000000045263">6</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045264" id="P7000497027000000000000000045264">SIGABRT</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045265" id="P7000497027000000000000000045265">Terminate and dump core<sup class="pcalibre1 pcalibre2 calibre8">a</sup></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045266" id="P7000497027000000000000000045266">Abort signal from abort function</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045267" id="P7000497027000000000000000045267">7</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045268" id="P7000497027000000000000000045268">SIGBUS</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045269" id="P7000497027000000000000000045269">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004526A" id="P700049702700000000000000004526A">Bus error</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004526B" id="P700049702700000000000000004526B">8</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004526C" id="P700049702700000000000000004526C">SIGFPE</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004526D" id="P700049702700000000000000004526D">Terminate and dump core<sup class="pcalibre1 pcalibre2 calibre8">a</sup></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004526E" id="P700049702700000000000000004526E">Floating-point exception</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004526F" id="P700049702700000000000000004526F">9</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045270" id="P7000497027000000000000000045270">SIGKILL</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045271" id="P7000497027000000000000000045271">Terminate<sup class="pcalibre1 pcalibre2 calibre8">b</sup></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045272" id="P7000497027000000000000000045272">Kill program</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045273" id="P7000497027000000000000000045273">10</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045274" id="P7000497027000000000000000045274">SIGUSR1</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045275" id="P7000497027000000000000000045275">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045276" id="P7000497027000000000000000045276">User-defined signal 1</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045277" id="P7000497027000000000000000045277">11</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045278" id="P7000497027000000000000000045278">SIGSEGV</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045279" id="P7000497027000000000000000045279">Terminate and dump core<sup class="pcalibre1 pcalibre2 calibre8">a</sup></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004527A" id="P700049702700000000000000004527A">Invalid memory reference (seg fault)</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004527B" id="P700049702700000000000000004527B">12</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004527C" id="P700049702700000000000000004527C">SIGUSR2</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004527D" id="P700049702700000000000000004527D">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004527E" id="P700049702700000000000000004527E">User-defined signal 2</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004527F" id="P700049702700000000000000004527F">13</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045280" id="P7000497027000000000000000045280">SIGPIPE</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045281" id="P7000497027000000000000000045281">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045282" id="P7000497027000000000000000045282">Wrote to a pipe with no reader</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045283" id="P7000497027000000000000000045283">14</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045284" id="P7000497027000000000000000045284">SIGALRM</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045285" id="P7000497027000000000000000045285">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045286" id="P7000497027000000000000000045286">Timer signal from alarm function</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045287" id="P7000497027000000000000000045287">15</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045288" id="P7000497027000000000000000045288">SIGTERM</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045289" id="P7000497027000000000000000045289">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004528A" id="P700049702700000000000000004528A">Software termination signal</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004528B" id="P700049702700000000000000004528B">16</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004528C" id="P700049702700000000000000004528C">SIGSTKFLT</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004528D" id="P700049702700000000000000004528D">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004528E" id="P700049702700000000000000004528E">Stack fault on coprocessor</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004528F" id="P700049702700000000000000004528F">17</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045290" id="P7000497027000000000000000045290">SIGCHLD</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045291" id="P7000497027000000000000000045291">Ignore</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045292" id="P7000497027000000000000000045292">A child process has stopped or terminated</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045293" id="P7000497027000000000000000045293">18</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045294" id="P7000497027000000000000000045294">SIGCONT</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045295" id="P7000497027000000000000000045295">Ignore</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045296" id="P7000497027000000000000000045296">Continue process if stopped</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045297" id="P7000497027000000000000000045297">19</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045298" id="P7000497027000000000000000045298">SIGSTOP</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045299" id="P7000497027000000000000000045299">Stop until next SIGCONT<sup class="pcalibre1 pcalibre2 calibre8">b</sup></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004529A" id="P700049702700000000000000004529A">Stop signal not from terminal</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004529B" id="P700049702700000000000000004529B">20</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004529C" id="P700049702700000000000000004529C">SIGTSTP</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004529D" id="P700049702700000000000000004529D">Stop until next SIGCONT</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004529E" id="P700049702700000000000000004529E">Stop signal from terminal</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004529F" id="P700049702700000000000000004529F">21</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452A0" id="P70004970270000000000000000452A0">SIGTTIN</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452A1" id="P70004970270000000000000000452A1">Stop until next SIGCONT</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452A2" id="P70004970270000000000000000452A2">Background process read from terminal</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452A3" id="P70004970270000000000000000452A3">22</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452A4" id="P70004970270000000000000000452A4">SIGTTOU</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452A5" id="P70004970270000000000000000452A5">Stop until next SIGCONT</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452A6" id="P70004970270000000000000000452A6">Background process wrote to terminal</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452A7" id="P70004970270000000000000000452A7">23</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452A8" id="P70004970270000000000000000452A8">SIGURG</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452A9" id="P70004970270000000000000000452A9">Ignore</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452AA" id="P70004970270000000000000000452AA">Urgent condition on socket</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452AB" id="P70004970270000000000000000452AB">24</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452AC" id="P70004970270000000000000000452AC">SIGXCPU</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452AD" id="P70004970270000000000000000452AD">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452AE" id="P70004970270000000000000000452AE">CPU time limit exceeded</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452AF" id="P70004970270000000000000000452AF">25</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452B0" id="P70004970270000000000000000452B0">SIGXFSZ</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452B1" id="P70004970270000000000000000452B1">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452B2" id="P70004970270000000000000000452B2">File size limit exceeded</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452B3" id="P70004970270000000000000000452B3">26</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452B4" id="P70004970270000000000000000452B4">SIGVTALRM</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452B5" id="P70004970270000000000000000452B5">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452B6" id="P70004970270000000000000000452B6">Virtual timer expired</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452B7" id="P70004970270000000000000000452B7">27</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452B8" id="P70004970270000000000000000452B8">SIGPROF</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452B9" id="P70004970270000000000000000452B9">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452BA" id="P70004970270000000000000000452BA">Profiling timer expired</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452BB" id="P70004970270000000000000000452BB">28</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452BC" id="P70004970270000000000000000452BC">SIGWINCH</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452BD" id="P70004970270000000000000000452BD">Ignore</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452BE" id="P70004970270000000000000000452BE">Window size changed</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452BF" id="P70004970270000000000000000452BF">29</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452C0" id="P70004970270000000000000000452C0">SIGIO</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452C1" id="P70004970270000000000000000452C1">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452C2" id="P70004970270000000000000000452C2">I/O now possible on a descriptor</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452C3" id="P70004970270000000000000000452C3">30</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452C4" id="P70004970270000000000000000452C4">SIGPWR</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452C5" id="P70004970270000000000000000452C5">Terminate</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452C6" id="P70004970270000000000000000452C6">Power failure</td></tr>
</tbody>
</table>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000452C7" id="P70004970270000000000000000452C7"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000452C8" epub:type="title" id="P70004970270000000000000000452C8"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.26 </span>Linux signals.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452C9" id="P70004970270000000000000000452C9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000452CA" id="P70004970270000000000000000452CA"><span class="pcalibre1 pcalibre2 pcalibre41">Notes: </span>(a) Years ago, main memory was implemented with a technology known as <i class="pcalibre17 pcalibre2 pcalibre1">core memory.</i> “Dumping core” is a historical term that means writing an image of the code and data memory segments to disk, (b) This signal can be neither caught nor ignored.</p></div>
<div class="pcalibre1 pcalibre2 pcalibre54" data-uri="chapter08.xhtml#P70004970270000000000000000452CB" id="P70004970270000000000000000452CB"><p class="pcalibre1 pcalibre2 calibre15" data-uri="chapter08.xhtml#P70004970270000000000000000452CC" id="P70004970270000000000000000452CC">(<span class="pcalibre1 pcalibre21 pcalibre2">Source:</span> <code class="pcalibre1 pcalibre2 pcalibre110" data-uri="chapter08.xhtml#P70004970270000000000000000452CD" id="P70004970270000000000000000452CD">man 7 signal</code>. Data from the Linux Foundation.)</p></div>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452CE" id="P70004970270000000000000000452CE">A <i class="pcalibre17 pcalibre2 pcalibre1">signal</i> is a small message that notifies a process that an event of some type has occurred in the system. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006A30"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.26 </span></a>shows the 30 different types of signals that are supported on Linux systems.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452CF" id="P70004970270000000000000000452CF">Each signal type corresponds to some kind of system event. Low-level hardware exceptions are processed by the kernel's exception handlers and would not normally be visible to user processes. Signals provide a mechanism for exposing <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006AB8" epub:type="pagebreak" id="P7000497027000000000000000006AB8" title="758"></span>the occurrence of such exceptions to user processes. For example, if a process attempts to divide by zero, then the kernel sends it a SIGFPE signal (number 8). If a process executes an illegal instruction, the kernel sends it a SIGILL signal (number 4). If a process makes an illegal memory reference, the kernel sends it a SIGSEGV signal (number 11). Other signals correspond to higher-level software events in the kernel or in other user processes. For example, if you type Ctrl+C (i.e., press the Ctrl key and the ‘c’ key at the same time) while a process is running in the foreground, then the kernel sends a SIGINT (number 2) to each process in the foreground process group. A process can forcibly terminate another process by sending it a SIGKILL signal (number 9). When a child process terminates or stops, the kernel sends a SIGCHLD signal (number 17) to the parent.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006AB9" id="P7000497027000000000000000006AB9"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452D0" epub:type="title" id="P70004970270000000000000000452D0"><span class="pcalibre1 pcalibre21 pcalibre2">8.5.1  </span>Signal Terminology</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452D1" id="P70004970270000000000000000452D1">The transfer of a signal to a destination process occurs in two distinct steps:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452D2" id="P70004970270000000000000000452D2">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000452D3" id="P70004970270000000000000000452D3"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P70004970270000000000000000452D4" id="P70004970270000000000000000452D4"><span class="pcalibre1 pcalibre2 pcalibre41">Sending a signal. </span>The kernel <i class="pcalibre17 pcalibre2 pcalibre1">sends (delivers)</i> a signal to a destination process by updating some state in the context of the destination process. The signal is delivered for one of two reasons: (1) The kernel has detected a system event such as a divide-by-zero error or the termination of a child process. (2) A process has invoked the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452D5" id="P70004970270000000000000000452D5">kill</code> function (discussed in the next section) to explicitly request the kernel to send a signal to the destination process. A process can send a signal to itself.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000452D6" id="P70004970270000000000000000452D6"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P70004970270000000000000000452D7" id="P70004970270000000000000000452D7"><span class="pcalibre1 pcalibre2 pcalibre41">Receiving a signal. </span>A destination process <i class="pcalibre17 pcalibre2 pcalibre1">receives</i> a signal when it is forced by the kernel to react in some way to the delivery of the signal. The process can either ignore the signal, terminate, or <i class="pcalibre17 pcalibre2 pcalibre1">catch</i> the signal by executing a user-level function called a <i class="pcalibre17 pcalibre2 pcalibre1">signal handler.</i> <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006AC3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.27</span></a> shows the basic idea of a handler catching a signal.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452D8" id="P70004970270000000000000000452D8">A signal that has been sent but not yet received is called <i class="pcalibre17 pcalibre2 pcalibre1">spending signal.</i> At any point in time, there can be at most one pending signal of a particular type. If a process has a pending signal of type <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, then any subsequent signals of type <var class="pcalibre17 pcalibre2 pcalibre1">k</var> sent to that process are <i class="pcalibre17 pcalibre2 pcalibre1">not</i> queued; they are simply discarded. A process can selectively <i class="pcalibre17 pcalibre2 pcalibre1">block</i> the receipt of certain signals. When a signal is blocked, it can be</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006AC3" id="P7000497027000000000000000006AC3">
<img alt="A diagram illustrates steps in signal handling." class="pcalibre1 pcalibre2 pcalibre255" data-uri="P700049702700000000000000000B771" id="P70004970270000000000000000452D9" src="Images/chapter-07-image-16.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000452DA" id="P70004970270000000000000000452DA"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000452DB" epub:type="title" id="P70004970270000000000000000452DB"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.27 </span>Signal handling.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000452DC" id="P70004970270000000000000000452DC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000452DD" id="P70004970270000000000000000452DD">Receipt of a signal triggers a control transfer to a signal handler. After it finishes processing, the handler returns control to the interrupted program.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P7000497027000000000000000025606" id="P7000497027000000000000000025606">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452DE" id="P70004970270000000000000000452DE">Steps in interrupt handling are summarized below.</p>
<ol class="pcalibre75 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000452DF" id="P70004970270000000000000000452DF">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000452E0" id="P70004970270000000000000000452E0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000452E1" id="P70004970270000000000000000452E1">Signal received by process (arrow pointing down to I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000452E2" id="P70004970270000000000000000452E2"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000452E3" id="P70004970270000000000000000452E3">Control passes to signal handler (arrow pointing right from I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000452E4" id="P70004970270000000000000000452E4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000452E5" id="P70004970270000000000000000452E5">Signal handler runs (arrow pointing down)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000452E6" id="P70004970270000000000000000452E6"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000452E7" id="P70004970270000000000000000452E7">Signal handler returns to next instruction (arrow back to I<sub class="pcalibre1 pcalibre2 calibre14">next</sub>, below I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
</ol>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452E8" id="P70004970270000000000000000452E8"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006ACA" epub:type="pagebreak" id="P7000497027000000000000000006ACA" title="759"></span>delivered, but the resulting pending signal will not be received until the process unblocks the signal.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452E9" id="P70004970270000000000000000452E9">A pending signal is received at most once. For each process, the kernel maintains the set of pending signals in the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452EA" id="P70004970270000000000000000452EA">pending</code> bit vector, and the set of blocked signals in the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452EB" id="P70004970270000000000000000452EB">blocked</code> bit vector.<a class="pcalibre1 pcalibre2 pcalibre56 pcalibre16 pcalibre14 pcalibre15" epub:type="noteref" href="#P7000497027000000000000000006FED" id="r__P7000497027000000000000000006FED">1</a> The kernel sets bit <var class="pcalibre17 pcalibre2 pcalibre1">k</var> in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452EC" id="P70004970270000000000000000452EC">pending</code> whenever a signal of type <var class="pcalibre17 pcalibre2 pcalibre1">k</var> is delivered and clears bit <var class="pcalibre17 pcalibre2 pcalibre1">k</var> in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452ED" id="P70004970270000000000000000452ED">pending</code> whenever a signal of type <var class="pcalibre17 pcalibre2 pcalibre1">k</var> is received.</p><aside class="pcalibre2 pcalibre32 pcalibre57" data-uri="chapter08.xhtml#P7000497027000000000000000006FED" epub:type="footnote" id="P7000497027000000000000000006FED"><p class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre58 pcalibre2"><a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="#r__P7000497027000000000000000006FED">1. </a></span>Also known as the <i class="pcalibre17 pcalibre2 pcalibre1">signal mask.</i></p></aside>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006AD0" id="P7000497027000000000000000006AD0"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452EE" epub:type="title" id="P70004970270000000000000000452EE"><span class="pcalibre1 pcalibre21 pcalibre2">8.5.2  </span>Sending Signals</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452EF" id="P70004970270000000000000000452EF">Unix systems provide a number of mechanisms for sending signals to processes. All of the mechanisms rely on the notion of a <i class="pcalibre17 pcalibre2 pcalibre1">process group.</i></p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006AD3" id="P7000497027000000000000000006AD3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452F0" epub:type="title" id="P70004970270000000000000000452F0">Process Groups</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452F1" id="P70004970270000000000000000452F1">Every process belongs to exactly one <i class="pcalibre17 pcalibre2 pcalibre1">process group</i>, which is identified by a positive <i class="pcalibre17 pcalibre2 pcalibre1">integer process group ID.</i> The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452F2" id="P70004970270000000000000000452F2">getpgrp</code> function returns the process group ID of the current process.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000452F3" id="P70004970270000000000000000452F3">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452F4" id="P70004970270000000000000000452F4">
#include &lt;unistd.h&gt;
pid_t getpgrp(void);
				Returns: process group ID of calling process
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452F5" id="P70004970270000000000000000452F5">By default, a child process belongs to the same process group as its parent. A process can change the process group of itself or another process by using the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452F6" id="P70004970270000000000000000452F6">setpgid</code> function:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000452F7" id="P70004970270000000000000000452F7">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452F8" id="P70004970270000000000000000452F8">
#include &lt;unistd.h&gt;
int setpgid(pid_t pid, pid_t pgid);
				Returns: 0 on success, -1 on error
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452F9" id="P70004970270000000000000000452F9">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452FA" id="P70004970270000000000000000452FA">setpgid</code> function changes the process group of process <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452FB" id="P70004970270000000000000000452FB">pid</code> to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452FC" id="P70004970270000000000000000452FC">pgid</code>. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452FD" id="P70004970270000000000000000452FD">pid</code> is zero, the PID of the current process is used. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452FE" id="P70004970270000000000000000452FE">pgid</code> is zero, the PID of the process specified by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000452FF" id="P70004970270000000000000000452FF">pid</code> is used for the process group ID. For example, if process 15213 is the calling process, then</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045300" id="P7000497027000000000000000045300"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045301" id="P7000497027000000000000000045301">setpgid(0, 0);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045302" id="P7000497027000000000000000045302">creates a new process group whose process group ID is 15213, and adds process 15213 to this new group.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006AE7" id="P7000497027000000000000000006AE7"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045303" epub:type="title" id="P7000497027000000000000000045303"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006AE9" epub:type="pagebreak" id="P7000497027000000000000000006AE9" title="760"></span>Sending Signals with the <code class="pcalibre1 pcalibre2 calibre16" data-uri="chapter08.xhtml#P7000497027000000000000000045304" id="P7000497027000000000000000045304">/bin/kill</code> Program</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045305" id="P7000497027000000000000000045305">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045306" id="P7000497027000000000000000045306">/bin/kill</code> program sends an arbitrary signal to another process. For example, the command</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045307" id="P7000497027000000000000000045307"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045308" id="P7000497027000000000000000045308">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">/bin/kill -9 15213</i></code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045309" id="P7000497027000000000000000045309">sends signal 9 (SIGKILL) to process 15213. A negative PID causes the signal to be sent to every process in process group PID. For example, the command</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004530A" id="P700049702700000000000000004530A"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004530B" id="P700049702700000000000000004530B">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">/bin/kill -9 -15213</i></code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004530C" id="P700049702700000000000000004530C">sends a SIGKILL signal to every process in process group 15213. Note that we use the complete path <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004530D" id="P700049702700000000000000004530D">/bin/kill</code> here because some Unix shells have their own built-in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004530E" id="P700049702700000000000000004530E">kill</code> command.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006AF5" id="P7000497027000000000000000006AF5"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004530F" epub:type="title" id="P700049702700000000000000004530F">Sending Signals from the Keyboard</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045310" id="P7000497027000000000000000045310">Unix shells use the abstraction of a <i class="pcalibre17 pcalibre2 pcalibre1">job</i> to represent the processes that are created as a result of evaluating a single command line. At any point in time, there is at most one foreground job and zero or more background jobs. For example, typing</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045311" id="P7000497027000000000000000045311"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045312" id="P7000497027000000000000000045312">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">ls</i> / <i class="pcalibre17 pcalibre2 pcalibre1">sort</i></code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045313" id="P7000497027000000000000000045313">creates a foreground job consisting of two processes connected by a Unix pipe: one running the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045314" id="P7000497027000000000000000045314">ls</code> program, the other running the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045315" id="P7000497027000000000000000045315">sort</code> program. The shell creates a separate process group for each job. Typically, the process group ID is taken from one of the parent processes in the job. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006AFD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.28</span></a> shows a shell with one foreground job and two background jobs. The parent process in the foreground job has a PID of 20 and a process group ID of 20. The parent process has created two children, each of which are also members of process group 20.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006AFD" id="P7000497027000000000000000006AFD">
<img alt="A diagram illustrates foreground and background process groups." class="pcalibre1 pcalibre2 pcalibre256" data-uri="P700049702700000000000000000B772" id="P7000497027000000000000000045316" src="Images/chapter-07-image-17.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045317" id="P7000497027000000000000000045317"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045318" epub:type="title" id="P7000497027000000000000000045318"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.28 </span>Foreground and background process groups.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P7000497027000000000000000025642" id="P7000497027000000000000000025642">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045319" id="P7000497027000000000000000045319">A diagram shows lines from Shell (pid = 10, pgid = 10) leading to three boxes below:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter08.xhtml#P700049702700000000000000004531A" id="P700049702700000000000000004531A">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004531B" id="P700049702700000000000000004531B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004531C" id="P700049702700000000000000004531C">Foreground process group 20: a circle representing Foreground job (pid = 20, pgid = 20) leads to two circles representing child, one with pid = 21, pgid = 20, and the other pid = 22 and pgid = 20.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004531D" id="P700049702700000000000000004531D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004531E" id="P700049702700000000000000004531E">Background process group 32: a circle representing Background job #1 (pid = 32, pgid = 32)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004531F" id="P700049702700000000000000004531F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045320" id="P7000497027000000000000000045320">Background process group 40: a circle representing Background job #2 (pid = 40, pgid = 40)</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045321" id="P7000497027000000000000000045321"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006B02" epub:type="pagebreak" id="P7000497027000000000000000006B02" title="761"></span>Typing Ctrl+C at the keyboard causes the kernel to send a SIGINT signal to every process in the foreground process group. In the default case, the result is to terminate the foreground job. Similarly, typing Ctrl+Z causes the kernel to send a SIGTSTP signal to every process in the foreground process group. In the default case, the result is to stop (suspend) the foreground job.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006B03" id="P7000497027000000000000000006B03"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045322" epub:type="title" id="P7000497027000000000000000045322">Sending Signals with the <code class="pcalibre1 pcalibre2 calibre16" data-uri="chapter08.xhtml#P7000497027000000000000000045323" id="P7000497027000000000000000045323">kill</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045324" id="P7000497027000000000000000045324">Processes send signals to other processes (including themselves) by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045325" id="P7000497027000000000000000045325">kill</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045326" id="P7000497027000000000000000045326"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045327" id="P7000497027000000000000000045327">
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
int kill(pid_t pid, int sig);
				Returns: 0 if OK, -1 on error
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045328" id="P7000497027000000000000000045328">If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045329" id="P7000497027000000000000000045329">pid</code> is greater than zero, then the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004532A" id="P700049702700000000000000004532A">kill</code> function sends signal number <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004532B" id="P700049702700000000000000004532B">sig</code> to process <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004532C" id="P700049702700000000000000004532C">pid</code>. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004532D" id="P700049702700000000000000004532D">pid</code> is equal to zero, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004532E" id="P700049702700000000000000004532E">kill</code> sends signal <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004532F" id="P700049702700000000000000004532F">sig</code> to every process in the process group of the calling process, including the calling process itself. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045330" id="P7000497027000000000000000045330">pid</code> is less than zero, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045331" id="P7000497027000000000000000045331">kill</code> sends signal <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045332" id="P7000497027000000000000000045332">sig</code> to every process in process group <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045333" id="P7000497027000000000000000045333">|pid|</code> (the absolute value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045334" id="P7000497027000000000000000045334">pid</code>). <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006B18"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.29</span></a> shows an example of a parent that uses the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045335" id="P7000497027000000000000000045335">kill</code> function to send a SIGKILL signal to its child.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006B18" id="P7000497027000000000000000006B18">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045336" id="P7000497027000000000000000045336">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/kill.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045337" id="P7000497027000000000000000045337">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045338" id="P7000497027000000000000000045338">
1	#include "csapp.h"
2	
3	int main()
4	{
5		pid_t pid;
6	
7		/* Child sleeps until SIGKILL signal received, then dies */
8		if ((pid = Fork()) == 0) {
9			Pause(); /* Wait for a signal to arrive */
10			printf("control should never reach here!\n");
11			exit(0);
12		}
13	
14		/* Parent sends a SIGKILL signal to a child */
15		Kill(pid, SIGKILL);
16		exit(0);
17	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045339" id="P7000497027000000000000000045339">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/kill.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004533A" id="P700049702700000000000000004533A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004533B" epub:type="title" id="P700049702700000000000000004533B"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.29 </span>Using the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004533C" id="P700049702700000000000000004533C">kill</code> function to send a signal to a child.</h1></header>
</figcaption>
</figure>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006B20" id="P7000497027000000000000000006B20"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004533D" epub:type="title" id="P700049702700000000000000004533D"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006B22" epub:type="pagebreak" id="P7000497027000000000000000006B22" title="762"></span>Sending Signals with the <code class="pcalibre1 pcalibre2 calibre16" data-uri="chapter08.xhtml#P700049702700000000000000004533E" id="P700049702700000000000000004533E">alarm</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004533F" id="P700049702700000000000000004533F">A process can send SIGALRM signals to itself by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045340" id="P7000497027000000000000000045340">alarm</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045341" id="P7000497027000000000000000045341">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045342" id="P7000497027000000000000000045342">
#include &lt;unistd.h&gt;
unsigned int alarm(unsigned int secs);
				Returns: remaining seconds of previous alarm, or 0 if no previous alarm
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045343" id="P7000497027000000000000000045343">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045344" id="P7000497027000000000000000045344">alarm</code> function arranges for the kernel to send a SIGALRM signal to the calling process in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045345" id="P7000497027000000000000000045345">secs</code> seconds. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045346" id="P7000497027000000000000000045346">secs</code> is 0, then no new alarm is scheduled. In any event, the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045347" id="P7000497027000000000000000045347">alarm</code> cancels any pending alarms and returns the number of seconds remaining until any pending alarm was due to be delivered (had not this call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045348" id="P7000497027000000000000000045348">alarm</code> canceled it), or 0 if there were no pending alarms.</p>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006B2E" id="P7000497027000000000000000006B2E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045349" epub:type="title" id="P7000497027000000000000000045349"><span class="pcalibre1 pcalibre21 pcalibre2">8.5.3  </span>Receiving Signals</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004534A" id="P700049702700000000000000004534A">When the kernel switches a process <var class="pcalibre17 pcalibre2 pcalibre1">p</var> from kernel mode to user mode (e.g., returning from a system call or completing a context switch), it checks the set of unblocked pending signals (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004534B" id="P700049702700000000000000004534B">pending &amp; ~blocked</code>) for <i class="pcalibre17 pcalibre2 pcalibre1">p.</i> If this set is empty (the usual case), then the kernel passes control to the next instruction (<var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 calibre14">next</sub>) in the logical control flow of <i class="pcalibre17 pcalibre2 pcalibre1">p.</i> However, if the set is nonempty, then the kernel chooses some signal <var class="pcalibre17 pcalibre2 pcalibre1">k</var> in the set (typically the smallest <var class="pcalibre17 pcalibre2 pcalibre1">k</var>) and forces <var class="pcalibre17 pcalibre2 pcalibre1">p</var> to <i class="pcalibre17 pcalibre2 pcalibre1">receive</i> signal <i class="pcalibre17 pcalibre2 pcalibre1">k.</i> The receipt of the signal triggers some <i class="pcalibre17 pcalibre2 pcalibre1">action</i> by the process. Once the process completes the action, then control passes back to the next instruction (<var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 calibre14">next</sub>) in the logical control flow of <i class="pcalibre17 pcalibre2 pcalibre1">p.</i> Each signal type has a predefined <i class="pcalibre17 pcalibre2 pcalibre1">default action</i>, which is one of the following:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004534C" id="P700049702700000000000000004534C">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004534D" id="P700049702700000000000000004534D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004534E" id="P700049702700000000000000004534E">The process terminates.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004534F" id="P700049702700000000000000004534F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045350" id="P7000497027000000000000000045350">The process terminates and dumps core.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045351" id="P7000497027000000000000000045351"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045352" id="P7000497027000000000000000045352">The process stops (suspends) until restarted by a SIGCONT signal.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045353" id="P7000497027000000000000000045353"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045354" id="P7000497027000000000000000045354">The process ignores the signal.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045355" id="P7000497027000000000000000045355"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006A30"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.26 </span></a>shows the default actions associated with each type of signal. For example, the default action for the receipt of a SIGKILL is to terminate the receiving process. On the other hand, the default action for the receipt of a SIGCHLD is to ignore the signal. A process can modify the default action associated with a signal by using the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045356" id="P7000497027000000000000000045356">signal</code> function. The only exceptions are SIGSTOP and SIGKILL, whose default actions cannot be changed.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045357" id="P7000497027000000000000000045357">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045358" id="P7000497027000000000000000045358">
#include &lt;signal.h&gt;
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
				Returns: pointer to previous handler if OK, SIG_ERR on error (does not set errno)
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045359" id="P7000497027000000000000000045359"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006B40" epub:type="pagebreak" id="P7000497027000000000000000006B40" title="763"></span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004535A" id="P700049702700000000000000004535A">signal</code> function can change the action associated with a signal <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004535B" id="P700049702700000000000000004535B">signum</code> in one of three ways:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004535C" id="P700049702700000000000000004535C">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004535D" id="P700049702700000000000000004535D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004535E" id="P700049702700000000000000004535E">If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004535F" id="P700049702700000000000000004535F">handler</code> is SIG_IGN, then signals of type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045360" id="P7000497027000000000000000045360">signum</code> are ignored.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045361" id="P7000497027000000000000000045361"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045362" id="P7000497027000000000000000045362">If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045363" id="P7000497027000000000000000045363">handler</code> is SIG_DFL, then the action for signals of type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045364" id="P7000497027000000000000000045364">signum</code> reverts to the default action.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045365" id="P7000497027000000000000000045365"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045366" id="P7000497027000000000000000045366">Otherwise, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045367" id="P7000497027000000000000000045367">handler</code> is the address of a user-defined function, called a <i class="pcalibre17 pcalibre2 pcalibre1">signal handler</i>, that will be called whenever the process receives a signal of type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045368" id="P7000497027000000000000000045368">signum</code>. Changing the default action by passing the address of a handler to the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045369" id="P7000497027000000000000000045369">signal</code> function is known as <i class="pcalibre17 pcalibre2 pcalibre1">installing the handler.</i> The invocation of the handler is called <i class="pcalibre17 pcalibre2 pcalibre1">catching the signal.</i> The execution of the handler is referred to as <i class="pcalibre17 pcalibre2 pcalibre1">handling the signal.</i></p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004536A" id="P700049702700000000000000004536A">When a process catches a signal of type <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, the handler installed for signal <var class="pcalibre17 pcalibre2 pcalibre1">k</var> is invoked with a single integer argument set to <i class="pcalibre17 pcalibre2 pcalibre1">k.</i> This argument allows the same handler function to catch different types of signals.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004536B" id="P700049702700000000000000004536B">When the handler executes its <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004536C" id="P700049702700000000000000004536C">return</code> statement, control (usually) passes back to the instruction in the control flow where the process was interrupted by the receipt of the signal. We say “usually” because in some systems, interrupted system calls return immediately with an error.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004536D" id="P700049702700000000000000004536D"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006B55"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.30</span></a> shows a program that catches the SIGINT signal that is sent whenever the user types Ctrl+C at the keyboard. The default action for SIGINT</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006B55" id="P7000497027000000000000000006B55">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004536E" id="P700049702700000000000000004536E">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/sigint.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004536F" id="P700049702700000000000000004536F">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045370" id="P7000497027000000000000000045370">
1	#include "csapp.h"
2	
3	void sigint_handler(int sig) /* SIGINT handler */
4	{
5		printf("Caught SIGINT!\n");
6		exit(0);
7	}
8	
9	int main()
10	{
11		/* Install the SIGINT handler */
12		if (signal(SIGINT, sigint_handler) == SIG_ERR)
13			unix_error("signal error");
14	
15		pause(); /* Wait for the receipt of a signal */
16	
17		return 0;
18	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045371" id="P7000497027000000000000000045371">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/sigint.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045372" id="P7000497027000000000000000045372"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045373" epub:type="title" id="P7000497027000000000000000045373"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.30 </span>A program that uses a signal handler to catch a SIGINT signal.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006B5C" id="P7000497027000000000000000006B5C">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006B5D" epub:type="pagebreak" id="P7000497027000000000000000006B5D" title="764"></span><img alt="A diagram illustrates steps when handlers are interrupted by other handlers." class="pcalibre1 pcalibre2 calibre65" data-uri="P700049702700000000000000000B773" id="P7000497027000000000000000045374" src="Images/chapter-07-image-18.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045375" id="P7000497027000000000000000045375"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045376" epub:type="title" id="P7000497027000000000000000045376"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.31 </span>Handlers can be interrupted by other handlers.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P70004970270000000000000000256A1" id="P70004970270000000000000000256A1">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045377" id="P7000497027000000000000000045377">The steps in the diagram are summarized below.</p>
<ol class="pcalibre75 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045378" id="P7000497027000000000000000045378">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045379" id="P7000497027000000000000000045379"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004537A" id="P700049702700000000000000004537A">Program catches signal s (arrow under main program pointing down to I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004537B" id="P700049702700000000000000004537B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004537C" id="P700049702700000000000000004537C">Control passes to handler S (arrow pointing from I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub> to under Handler S)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004537D" id="P700049702700000000000000004537D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004537E" id="P700049702700000000000000004537E">Program catches signal t (arrow pointing down)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004537F" id="P700049702700000000000000004537F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045380" id="P7000497027000000000000000045380">Control passes to handler T (arrow from under Handler S to under Handler T, where another arrow points down)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045381" id="P7000497027000000000000000045381"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045382" id="P7000497027000000000000000045382">Handler T returns to handler S (arrow back to under Handler S, where another arrow points down)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045383" id="P7000497027000000000000000045383"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045384" id="P7000497027000000000000000045384">Handler S returns to main program (arrow to I<sub class="pcalibre1 pcalibre2 calibre14">next</sub> under I<sub class="pcalibre1 pcalibre2 calibre14">curr</sub>)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045385" id="P7000497027000000000000000045385"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045386" id="P7000497027000000000000000045386">Main program resumes (arrow down from I<sub class="pcalibre1 pcalibre2 calibre14">next</sub>)</p></li>
</ol>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045387" id="P7000497027000000000000000045387">is to immediately terminate the process. In this example, we modify the default behavior to catch the signal, print a message, and then terminate the process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045388" id="P7000497027000000000000000045388">Signal handlers can be interrupted by other handlers, as shown in <span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.31</span>. In this example, the main program catches signal <var class="pcalibre17 pcalibre2 pcalibre1">s</var>, which interrupts the main program and transfers control to handler <i class="pcalibre17 pcalibre2 pcalibre1">S.</i> While <var class="pcalibre17 pcalibre2 pcalibre1">S</var> is running, the program catches signal <var class="pcalibre17 pcalibre2 pcalibre1">t</var> ≠ <var class="pcalibre17 pcalibre2 pcalibre1">s</var>, which interrupts <var class="pcalibre17 pcalibre2 pcalibre1">S</var> and transfers control to handler <i class="pcalibre17 pcalibre2 pcalibre1">T.</i> When <var class="pcalibre17 pcalibre2 pcalibre1">T</var> returns, <var class="pcalibre17 pcalibre2 pcalibre1">S</var> resumes where it was interrupted. Eventually, <var class="pcalibre17 pcalibre2 pcalibre1">S</var> returns, transferring control back to the main program, which resumes where it left off.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006B63" epub:type="practice" id="P7000497027000000000000000006B63"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045389" epub:type="title" id="P7000497027000000000000000045389"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.7 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FDB">798</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P700049702700000000000000004538A" id="P700049702700000000000000004538A">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P700049702700000000000000004538B" id="P700049702700000000000000004538B"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P700049702700000000000000004538C" id="P700049702700000000000000004538C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004538D" id="P700049702700000000000000004538D">Write a program called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004538E" id="P700049702700000000000000004538E">snooze</code> that takes a single command-line argument, calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004538F" id="P700049702700000000000000004538F">snooze</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P7000497027000000000000000006993"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5</span></a> with this argument, and then terminates. Write your program so that the user can interrupt the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045390" id="P7000497027000000000000000045390">snooze</code> function by typing Ctrl+C at the keyboard. For example:</p></div>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045391" id="P7000497027000000000000000045391">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045392" id="P7000497027000000000000000045392">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./snooze 5</i>
<i class="pcalibre17 pcalibre2 pcalibre1">CTRL+C</i>		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">User hits Crtl+C after 3 seconds</i></b>
Slept for 3 of 5 secs.
linux&gt;
</code>
</pre>
</li>
</ol>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006B6E" id="P7000497027000000000000000006B6E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045393" epub:type="title" id="P7000497027000000000000000045393"><span class="pcalibre1 pcalibre21 pcalibre2">8.5.4  </span>Blocking and Unblocking Signals</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045394" id="P7000497027000000000000000045394">Linux provides implicit and explicit mechanisms for blocking signals:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045395" id="P7000497027000000000000000045395">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045396" id="P7000497027000000000000000045396"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045397" id="P7000497027000000000000000045397"><span class="pcalibre1 pcalibre2 pcalibre41">Implicit blocking mechanism. </span>By default, the kernel blocks any pending signals of the type currently being processed by a handler. For example, in <span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.31</span>, suppose the program has caught signal <var class="pcalibre17 pcalibre2 pcalibre1">s</var> and is currently running handler <i class="pcalibre17 pcalibre2 pcalibre1">S.</i> If another signal <var class="pcalibre17 pcalibre2 pcalibre1">s</var> is sent to the process, then <var class="pcalibre17 pcalibre2 pcalibre1">s</var> will become pending but will not be received until after handler <var class="pcalibre17 pcalibre2 pcalibre1">S</var> returns.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045398" id="P7000497027000000000000000045398"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045399" id="P7000497027000000000000000045399"><span class="pcalibre1 pcalibre2 pcalibre41">Explicit blocking mechanism. </span>Applications can explicitly block and unblock selected signals using the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004539A" id="P700049702700000000000000004539A">sigprocmask</code> function and its helpers.</p></li>
</ul>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004539B" id="P700049702700000000000000004539B">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004539C" id="P700049702700000000000000004539C">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006B79" epub:type="pagebreak" id="P7000497027000000000000000006B79" title="765"></span>#include &lt;signal.h&gt;

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
				Returns: 0 if OK, -1 on error
int sigismember(const sigset_t *set, int signum);
				Returns: 1 if member, 0 if not, -1 on error
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004539D" id="P700049702700000000000000004539D">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004539E" id="P700049702700000000000000004539E">sigprocmask</code> function changes the set of currently <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004539F" id="P700049702700000000000000004539F">blocked</code> signals (the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453A0" id="P70004970270000000000000000453A0">blocked</code> bit vector described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006AB9"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5.1</span></a>). The specific behavior depends on the value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453A1" id="P70004970270000000000000000453A1">how</code>:</p>
<blockquote class="pcalibre88 pcalibre87 pcalibre86" data-uri="chapter08.xhtml#P70004970270000000000000000453A2" id="P70004970270000000000000000453A2">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453A3" id="P70004970270000000000000000453A3">SIG_BLOCK. Add the signals in <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453A4" id="P70004970270000000000000000453A4">set</code> to blocked (<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453A5" id="P70004970270000000000000000453A5">blocked = blocked	|	set</code>).</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453A6" id="P70004970270000000000000000453A6">SIG_UNBLOCK. Remove the signals in <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453A7" id="P70004970270000000000000000453A7">set</code> from <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453A8" id="P70004970270000000000000000453A8">blocked (blocked = blocked &amp; -set)</code>.</p>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000453A9" id="P70004970270000000000000000453A9">SIG_SETMASK. <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453AA" id="P70004970270000000000000000453AA">blocked = set.</code></p>
</blockquote>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453AB" id="P70004970270000000000000000453AB">If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453AC" id="P70004970270000000000000000453AC">oldset</code> is non-NULL, the previous value of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453AD" id="P70004970270000000000000000453AD">blocked</code> bit vector is stored in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453AE" id="P70004970270000000000000000453AE">oldset</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453AF" id="P70004970270000000000000000453AF">Signal sets such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453B0" id="P70004970270000000000000000453B0">set</code> are manipulated using the following functions: The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453B1" id="P70004970270000000000000000453B1">sigemptyset</code> initializes <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453B2" id="P70004970270000000000000000453B2">set</code> to the empty set. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453B3" id="P70004970270000000000000000453B3">sigfillset</code> function adds every signal to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453B4" id="P70004970270000000000000000453B4">set</code>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453B5" id="P70004970270000000000000000453B5">sigaddset</code> function adds <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453B6" id="P70004970270000000000000000453B6">signum</code> to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453B7" id="P70004970270000000000000000453B7">set, sigdelset</code> deletes <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453B8" id="P70004970270000000000000000453B8">signum</code> from <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453B9" id="P70004970270000000000000000453B9">set</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453BA" id="P70004970270000000000000000453BA">sigismember</code> returns 1 if <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453BB" id="P70004970270000000000000000453BB">signum</code> is a member of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453BC" id="P70004970270000000000000000453BC">set</code>, and 0 if not.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453BD" id="P70004970270000000000000000453BD">For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006B9C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.32</span></a> shows how you would use <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453BE" id="P70004970270000000000000000453BE">sigprocmask</code> to temporarily block the receipt of SIGINT signals.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006B9C" id="P7000497027000000000000000006B9C">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000453BF" id="P70004970270000000000000000453BF">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453C0" id="P70004970270000000000000000453C0">
1	sigset_t mask, prev_mask;
2	
3	Sigemptyset(&amp;mask);
4	Sigaddset(&amp;mask, SIGINT);
5	
6	/* Block SIGINT and save previous blocked set */
7	Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);
8	⋮ // <i class="pcalibre17 pcalibre2 pcalibre1">Code region that will not be interrupted by SIGINT</i>
9	/* Restore previous blocked set, unblocking SIGINT */
10	Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL);
11	
</code>
</pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000453C1" id="P70004970270000000000000000453C1"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000453C2" epub:type="title" id="P70004970270000000000000000453C2"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.32 </span>Temporarily blocking a signal from being received.</h1></header>
</figcaption>
</figure>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006BA1" id="P7000497027000000000000000006BA1"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453C3" epub:type="title" id="P70004970270000000000000000453C3"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006BA3" epub:type="pagebreak" id="P7000497027000000000000000006BA3" title="766"></span><span class="pcalibre1 pcalibre21 pcalibre2">8.5.5  </span>Writing Signal Handlers</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453C4" id="P70004970270000000000000000453C4">Signal handling is one of the thornier aspects of Linux system-level programming. Handlers have several attributes that make them difficult to reason about: (1) Handlers run concurrently with the main program and share the same global variables, and thus can interfere with the main program and with other handlers. (2) The rules for how and when signals are received is often counterintuitive. (3) Different systems can have different signal-handling semantics.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453C5" id="P70004970270000000000000000453C5">In this section, we address these issues and give you some basic guidelines for writing safe, correct, and portable signal handlers.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006BA6" id="P7000497027000000000000000006BA6"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453C6" epub:type="title" id="P70004970270000000000000000453C6">Safe Signal Handling</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453C7" id="P70004970270000000000000000453C7">Signal handlers are tricky because they can run concurrently with the main program and with each other, as we saw in <span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.31</span>. If a handler and the main program access the same global data structure concurrently, then the results can be unpredictable and often fatal.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453C8" id="P70004970270000000000000000453C8">We will explore concurrent programming in detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">12</span></a>. Our aim here is to give you some conservative guidelines for writing handlers that are safe to run concurrently. If you ignore these guidelines, you run the risk of introducing subtle concurrency errors. With such errors, your program works correctly most of the time. However, when it fails, it fails in unpredictable and unrepeatable ways that are horrendously difficult to debug. Forewarned is forearmed!</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453C9" id="P70004970270000000000000000453C9">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000453CA" id="P70004970270000000000000000453CA"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P70004970270000000000000000453CB" id="P70004970270000000000000000453CB"><span class="pcalibre1 pcalibre2 pcalibre41">G0. Keep handlers as simple as possible. </span>The best way to avoid trouble is to keep your handlers as small and simple as possible. For example, the handler might simply set a global flag and return immediately; all processing associated with the receipt of the signal is performed by the main program, which periodically checks (and resets) the flag.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000453CC" id="P70004970270000000000000000453CC"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P70004970270000000000000000453CD" id="P70004970270000000000000000453CD"><span class="pcalibre1 pcalibre2 pcalibre41">G1. Call only async-signal-safe functions in your handlers. </span>A function that is <i class="pcalibre17 pcalibre2 pcalibre1">async-signal-safe</i>, or simply <i class="pcalibre17 pcalibre2 pcalibre1">safe</i>, has the property that it can be safely called from a signal handler, either because it is <i class="pcalibre17 pcalibre2 pcalibre1">reentrant</i> (e.g., accesses only local variables; see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008577.xhtml#P70004970270000000000000000085BA"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7.2</span></a>), or because it cannot be interrupted by a signal handler. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006BB5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.33 </span></a>lists the system-level functions that Linux guarantees to be safe. Notice that many popular functions, such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453CE" id="P70004970270000000000000000453CE">printf, sprintf, malloc</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453CF" id="P70004970270000000000000000453CF">exit</code>, are <i class="pcalibre17 pcalibre2 pcalibre1">not</i> on this list.</p>
<p class="pcalibre1 pcalibre2 pcalibre42" data-uri="chapter08.xhtml#P70004970270000000000000000453D0" id="P70004970270000000000000000453D0">The only safe way to generate output from a signal handler is to use the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453D1" id="P70004970270000000000000000453D1">write</code> function (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007899.xhtml#P7000497027000000000000000007899"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">10.1</span></a>). In particular, calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453D2" id="P70004970270000000000000000453D2">printf</code> or <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453D3" id="P70004970270000000000000000453D3">sprintf</code> is unsafe. To work around this unfortunate restriction, we have developed some safe functions, called the S<span class="pcalibre1 pcalibre29 pcalibre2">io</span> (Safe I/O) package, that you can use to print simple messages from signal handlers.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006BB5" id="P7000497027000000000000000006BB5">
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter08.xhtml#P70004970270000000000000000453D4" id="P70004970270000000000000000453D4">
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453D5" id="P70004970270000000000000000453D5"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006BB8" epub:type="pagebreak" id="P7000497027000000000000000006BB8" title="767"></span><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453D6" id="P70004970270000000000000000453D6">_Exit</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453D7" id="P70004970270000000000000000453D7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453D8" id="P70004970270000000000000000453D8">fexecve</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453D9" id="P70004970270000000000000000453D9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453DA" id="P70004970270000000000000000453DA">poll</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453DB" id="P70004970270000000000000000453DB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453DC" id="P70004970270000000000000000453DC">sigqueue</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453DD" id="P70004970270000000000000000453DD"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453DE" id="P70004970270000000000000000453DE">_exit</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453DF" id="P70004970270000000000000000453DF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453E0" id="P70004970270000000000000000453E0">fork</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453E1" id="P70004970270000000000000000453E1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453E2" id="P70004970270000000000000000453E2">posix_trace_event</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453E3" id="P70004970270000000000000000453E3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453E4" id="P70004970270000000000000000453E4">sigset</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453E5" id="P70004970270000000000000000453E5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453E6" id="P70004970270000000000000000453E6">abort</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453E7" id="P70004970270000000000000000453E7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453E8" id="P70004970270000000000000000453E8">f stat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453E9" id="P70004970270000000000000000453E9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453EA" id="P70004970270000000000000000453EA">pselect</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453EB" id="P70004970270000000000000000453EB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453EC" id="P70004970270000000000000000453EC">sigsuspend</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453ED" id="P70004970270000000000000000453ED"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453EE" id="P70004970270000000000000000453EE">accept</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453EF" id="P70004970270000000000000000453EF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453F0" id="P70004970270000000000000000453F0">fstatat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453F1" id="P70004970270000000000000000453F1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453F2" id="P70004970270000000000000000453F2">raise</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453F3" id="P70004970270000000000000000453F3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453F4" id="P70004970270000000000000000453F4">sleep</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453F5" id="P70004970270000000000000000453F5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453F6" id="P70004970270000000000000000453F6">access</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453F7" id="P70004970270000000000000000453F7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453F8" id="P70004970270000000000000000453F8">fsync</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453F9" id="P70004970270000000000000000453F9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453FA" id="P70004970270000000000000000453FA">read</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453FB" id="P70004970270000000000000000453FB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453FC" id="P70004970270000000000000000453FC">sockatmark</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453FD" id="P70004970270000000000000000453FD"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000453FE" id="P70004970270000000000000000453FE">aio_error</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000453FF" id="P70004970270000000000000000453FF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045400" id="P7000497027000000000000000045400">ftruncate</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045401" id="P7000497027000000000000000045401"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045402" id="P7000497027000000000000000045402">readlink</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045403" id="P7000497027000000000000000045403"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045404" id="P7000497027000000000000000045404">socket</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045405" id="P7000497027000000000000000045405"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045406" id="P7000497027000000000000000045406">aio_return</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045407" id="P7000497027000000000000000045407"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045408" id="P7000497027000000000000000045408">futimens</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045409" id="P7000497027000000000000000045409"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004540A" id="P700049702700000000000000004540A">readlinkat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004540B" id="P700049702700000000000000004540B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004540C" id="P700049702700000000000000004540C">socketpair</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004540D" id="P700049702700000000000000004540D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004540E" id="P700049702700000000000000004540E">aio_suspend</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004540F" id="P700049702700000000000000004540F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045410" id="P7000497027000000000000000045410">getegid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045411" id="P7000497027000000000000000045411"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045412" id="P7000497027000000000000000045412">recv</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045413" id="P7000497027000000000000000045413"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045414" id="P7000497027000000000000000045414">stat</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045415" id="P7000497027000000000000000045415"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045416" id="P7000497027000000000000000045416">alarm</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045417" id="P7000497027000000000000000045417"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045418" id="P7000497027000000000000000045418">geteuid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045419" id="P7000497027000000000000000045419"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004541A" id="P700049702700000000000000004541A">reevfrom</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004541B" id="P700049702700000000000000004541B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004541C" id="P700049702700000000000000004541C">symlink</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004541D" id="P700049702700000000000000004541D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004541E" id="P700049702700000000000000004541E">bind</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004541F" id="P700049702700000000000000004541F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045420" id="P7000497027000000000000000045420">getgid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045421" id="P7000497027000000000000000045421"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045422" id="P7000497027000000000000000045422">reevmsg</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045423" id="P7000497027000000000000000045423"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045424" id="P7000497027000000000000000045424">symlinkat</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045425" id="P7000497027000000000000000045425"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045426" id="P7000497027000000000000000045426">cfgetispeed</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045427" id="P7000497027000000000000000045427"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045428" id="P7000497027000000000000000045428">getgroups</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045429" id="P7000497027000000000000000045429"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004542A" id="P700049702700000000000000004542A">rename</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004542B" id="P700049702700000000000000004542B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004542C" id="P700049702700000000000000004542C">tcdrain</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004542D" id="P700049702700000000000000004542D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004542E" id="P700049702700000000000000004542E">cfgetospeed</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004542F" id="P700049702700000000000000004542F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045430" id="P7000497027000000000000000045430">getpeername</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045431" id="P7000497027000000000000000045431"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045432" id="P7000497027000000000000000045432">renameat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045433" id="P7000497027000000000000000045433"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045434" id="P7000497027000000000000000045434">tcflow</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045435" id="P7000497027000000000000000045435"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045436" id="P7000497027000000000000000045436">cfsetispeed</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045437" id="P7000497027000000000000000045437"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045438" id="P7000497027000000000000000045438">getpgrp</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045439" id="P7000497027000000000000000045439"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004543A" id="P700049702700000000000000004543A">rmdir</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004543B" id="P700049702700000000000000004543B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004543C" id="P700049702700000000000000004543C">tcflush</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004543D" id="P700049702700000000000000004543D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004543E" id="P700049702700000000000000004543E">cfsetospeed</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004543F" id="P700049702700000000000000004543F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045440" id="P7000497027000000000000000045440">getpid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045441" id="P7000497027000000000000000045441"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045442" id="P7000497027000000000000000045442">select</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045443" id="P7000497027000000000000000045443"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045444" id="P7000497027000000000000000045444">tcgetattr</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045445" id="P7000497027000000000000000045445"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045446" id="P7000497027000000000000000045446">chdir</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045447" id="P7000497027000000000000000045447"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045448" id="P7000497027000000000000000045448">getppid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045449" id="P7000497027000000000000000045449"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004544A" id="P700049702700000000000000004544A">sem_post</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004544B" id="P700049702700000000000000004544B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004544C" id="P700049702700000000000000004544C">tcgetpgrp</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004544D" id="P700049702700000000000000004544D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004544E" id="P700049702700000000000000004544E">chmod</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004544F" id="P700049702700000000000000004544F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045450" id="P7000497027000000000000000045450">getsockname</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045451" id="P7000497027000000000000000045451"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045452" id="P7000497027000000000000000045452">send</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045453" id="P7000497027000000000000000045453"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045454" id="P7000497027000000000000000045454">tcsendbreak</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045455" id="P7000497027000000000000000045455"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045456" id="P7000497027000000000000000045456">chown</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045457" id="P7000497027000000000000000045457"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045458" id="P7000497027000000000000000045458">getsockopt</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045459" id="P7000497027000000000000000045459"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004545A" id="P700049702700000000000000004545A">sendmsg</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004545B" id="P700049702700000000000000004545B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004545C" id="P700049702700000000000000004545C">tcsetattr</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004545D" id="P700049702700000000000000004545D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004545E" id="P700049702700000000000000004545E">clock_gettime</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004545F" id="P700049702700000000000000004545F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045460" id="P7000497027000000000000000045460">getuid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045461" id="P7000497027000000000000000045461"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045462" id="P7000497027000000000000000045462">sendto</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045463" id="P7000497027000000000000000045463"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045464" id="P7000497027000000000000000045464">tcsetpgrp</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045465" id="P7000497027000000000000000045465"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045466" id="P7000497027000000000000000045466">close</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045467" id="P7000497027000000000000000045467"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045468" id="P7000497027000000000000000045468">kill</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045469" id="P7000497027000000000000000045469"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004546A" id="P700049702700000000000000004546A">setgid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004546B" id="P700049702700000000000000004546B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004546C" id="P700049702700000000000000004546C">time</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004546D" id="P700049702700000000000000004546D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004546E" id="P700049702700000000000000004546E">connect</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004546F" id="P700049702700000000000000004546F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045470" id="P7000497027000000000000000045470">link</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045471" id="P7000497027000000000000000045471"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045472" id="P7000497027000000000000000045472">setpgid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045473" id="P7000497027000000000000000045473"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045474" id="P7000497027000000000000000045474">timer_getoverrun</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045475" id="P7000497027000000000000000045475"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045476" id="P7000497027000000000000000045476">creat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045477" id="P7000497027000000000000000045477"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045478" id="P7000497027000000000000000045478">linkat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045479" id="P7000497027000000000000000045479"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004547A" id="P700049702700000000000000004547A">setsid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004547B" id="P700049702700000000000000004547B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004547C" id="P700049702700000000000000004547C">timer_gettime</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004547D" id="P700049702700000000000000004547D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004547E" id="P700049702700000000000000004547E">dup</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004547F" id="P700049702700000000000000004547F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045480" id="P7000497027000000000000000045480">listen</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045481" id="P7000497027000000000000000045481"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045482" id="P7000497027000000000000000045482">setsockopt</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045483" id="P7000497027000000000000000045483"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045484" id="P7000497027000000000000000045484">timer_settime</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045485" id="P7000497027000000000000000045485"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045486" id="P7000497027000000000000000045486">dup2</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045487" id="P7000497027000000000000000045487"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045488" id="P7000497027000000000000000045488">lseek</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045489" id="P7000497027000000000000000045489"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004548A" id="P700049702700000000000000004548A">setuid</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004548B" id="P700049702700000000000000004548B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004548C" id="P700049702700000000000000004548C">times</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004548D" id="P700049702700000000000000004548D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004548E" id="P700049702700000000000000004548E">execl</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004548F" id="P700049702700000000000000004548F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045490" id="P7000497027000000000000000045490">lstat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045491" id="P7000497027000000000000000045491"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045492" id="P7000497027000000000000000045492">shutdown</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045493" id="P7000497027000000000000000045493"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045494" id="P7000497027000000000000000045494">umask</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045495" id="P7000497027000000000000000045495"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045496" id="P7000497027000000000000000045496">execle</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045497" id="P7000497027000000000000000045497"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045498" id="P7000497027000000000000000045498">mkdir</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045499" id="P7000497027000000000000000045499"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004549A" id="P700049702700000000000000004549A">sigaction</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004549B" id="P700049702700000000000000004549B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004549C" id="P700049702700000000000000004549C">uname</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004549D" id="P700049702700000000000000004549D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004549E" id="P700049702700000000000000004549E">execv</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004549F" id="P700049702700000000000000004549F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454A0" id="P70004970270000000000000000454A0">mkdirat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454A1" id="P70004970270000000000000000454A1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454A2" id="P70004970270000000000000000454A2">sigaddset</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454A3" id="P70004970270000000000000000454A3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454A4" id="P70004970270000000000000000454A4">unlink</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454A5" id="P70004970270000000000000000454A5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454A6" id="P70004970270000000000000000454A6">execve</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454A7" id="P70004970270000000000000000454A7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454A8" id="P70004970270000000000000000454A8">mkfifo</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454A9" id="P70004970270000000000000000454A9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454AA" id="P70004970270000000000000000454AA">sigdelset</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454AB" id="P70004970270000000000000000454AB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454AC" id="P70004970270000000000000000454AC">unlinkat</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454AD" id="P70004970270000000000000000454AD"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454AE" id="P70004970270000000000000000454AE">faecessat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454AF" id="P70004970270000000000000000454AF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454B0" id="P70004970270000000000000000454B0">mkfifoat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454B1" id="P70004970270000000000000000454B1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454B2" id="P70004970270000000000000000454B2">sigemptyset</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454B3" id="P70004970270000000000000000454B3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454B4" id="P70004970270000000000000000454B4">utime</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454B5" id="P70004970270000000000000000454B5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454B6" id="P70004970270000000000000000454B6">fchmod</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454B7" id="P70004970270000000000000000454B7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454B8" id="P70004970270000000000000000454B8">mknod</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454B9" id="P70004970270000000000000000454B9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454BA" id="P70004970270000000000000000454BA">sigfillset</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454BB" id="P70004970270000000000000000454BB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454BC" id="P70004970270000000000000000454BC">utimensat</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454BD" id="P70004970270000000000000000454BD"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454BE" id="P70004970270000000000000000454BE">fchmodat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454BF" id="P70004970270000000000000000454BF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454C0" id="P70004970270000000000000000454C0">mknodat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454C1" id="P70004970270000000000000000454C1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454C2" id="P70004970270000000000000000454C2">sigismember</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454C3" id="P70004970270000000000000000454C3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454C4" id="P70004970270000000000000000454C4">utimes</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454C5" id="P70004970270000000000000000454C5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454C6" id="P70004970270000000000000000454C6">fchown</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454C7" id="P70004970270000000000000000454C7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454C8" id="P70004970270000000000000000454C8">open</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454C9" id="P70004970270000000000000000454C9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454CA" id="P70004970270000000000000000454CA">signal</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454CB" id="P70004970270000000000000000454CB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454CC" id="P70004970270000000000000000454CC">wait</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454CD" id="P70004970270000000000000000454CD"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454CE" id="P70004970270000000000000000454CE">fchownat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454CF" id="P70004970270000000000000000454CF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454D0" id="P70004970270000000000000000454D0">openat</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454D1" id="P70004970270000000000000000454D1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454D2" id="P70004970270000000000000000454D2">sigpause</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454D3" id="P70004970270000000000000000454D3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454D4" id="P70004970270000000000000000454D4">waitpid</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454D5" id="P70004970270000000000000000454D5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454D6" id="P70004970270000000000000000454D6">fcntl</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454D7" id="P70004970270000000000000000454D7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454D8" id="P70004970270000000000000000454D8">pause</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454D9" id="P70004970270000000000000000454D9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454DA" id="P70004970270000000000000000454DA">sigpending</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454DB" id="P70004970270000000000000000454DB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454DC" id="P70004970270000000000000000454DC">write</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454DD" id="P70004970270000000000000000454DD"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454DE" id="P70004970270000000000000000454DE">fdatasync</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454DF" id="P70004970270000000000000000454DF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454E0" id="P70004970270000000000000000454E0">pipe</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454E1" id="P70004970270000000000000000454E1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454E2" id="P70004970270000000000000000454E2">sigprocmask</code></td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P70004970270000000000000000454E3" id="P70004970270000000000000000454E3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454E4" id="P70004970270000000000000000454E4"></code></td></tr>
</tbody>
</table>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000454E5" id="P70004970270000000000000000454E5"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000454E6" epub:type="title" id="P70004970270000000000000000454E6"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.33 </span>Async-signal-safe functions.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre54" data-uri="chapter08.xhtml#P70004970270000000000000000454E7" id="P70004970270000000000000000454E7"><p class="pcalibre1 pcalibre2 calibre15" data-uri="chapter08.xhtml#P70004970270000000000000000454E8" id="P70004970270000000000000000454E8">(<span class="pcalibre1 pcalibre21 pcalibre2">Source: </span><code class="pcalibre1 pcalibre2 pcalibre110" data-uri="chapter08.xhtml#P70004970270000000000000000454E9" id="P70004970270000000000000000454E9">man 7</code> signal. Data from the Linux Foundation.)</p></div>
</figcaption>
</figure>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000454EA" id="P70004970270000000000000000454EA">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454EB" id="P70004970270000000000000000454EB">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006CCF" epub:type="pagebreak" id="P7000497027000000000000000006CCF" title="768"></span>#include "csapp.h"
ssize_t sio_putl(long v);
ssize_t sio_puts(char s[]);
				Returns: number of bytes transferred if OK, -1 on error
void sio_error (char s []);
				Returns: nothing
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P70004970270000000000000000454EC" id="P70004970270000000000000000454EC">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454ED" id="P70004970270000000000000000454ED">sio_putl</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454EE" id="P70004970270000000000000000454EE">sio_puts</code> functions emit a long and a string, respectively, to standard output. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454EF" id="P70004970270000000000000000454EF">sio_error</code> function prints an error message and terminates.</p>
<p class="pcalibre1 pcalibre2 pcalibre42" data-uri="chapter08.xhtml#P70004970270000000000000000454F0" id="P70004970270000000000000000454F0"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006CE5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.34</span></a> shows the implementation of the S<span class="pcalibre1 pcalibre29 pcalibre2">io</span> package, which uses two private reentrant functions from <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454F1" id="P70004970270000000000000000454F1">csapp. c</code>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454F2" id="P70004970270000000000000000454F2">sio_strlen</code> function in line 3 returns the length of string <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454F3" id="P70004970270000000000000000454F3">s</code>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454F4" id="P70004970270000000000000000454F4">sio_ltoa</code> function in line 10, which is based on the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454F5" id="P70004970270000000000000000454F5">itoa</code> function from [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41C">61</a>], converts <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454F6" id="P70004970270000000000000000454F6">v</code> to its base <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454F7" id="P70004970270000000000000000454F7">b</code> string representation in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454F8" id="P70004970270000000000000000454F8">s</code>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454F9" id="P70004970270000000000000000454F9">_exit</code> function in line 17 is an async-signal-safe variant of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454FA" id="P70004970270000000000000000454FA">exit</code>.</p>
<p class="pcalibre1 pcalibre2 pcalibre42" data-uri="chapter08.xhtml#P70004970270000000000000000454FB" id="P70004970270000000000000000454FB"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006CED"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.35 </span></a>shows a safe version of the SIGINT handler from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006B55"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.30</span></a>.</p>
</li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000454FC" id="P70004970270000000000000000454FC"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P70004970270000000000000000454FD" id="P70004970270000000000000000454FD"><span class="pcalibre1 pcalibre2 pcalibre41"><i class="pcalibre17 pcalibre2 pcalibre1">G2. Save and restore</i> <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454FE" id="P70004970270000000000000000454FE">errno</code>. </span>Many of the Linux async-signal-safe functions set <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000454FF" id="P70004970270000000000000000454FF">errno</code> when they return with an error. Calling such functions inside a handler might interfere with other parts of the program that rely on <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045500" id="P7000497027000000000000000045500">errno</code>.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006CE5" id="P7000497027000000000000000006CE5">
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045501" id="P7000497027000000000000000045501">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/src/csapp.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045502" id="P7000497027000000000000000045502">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045503" id="P7000497027000000000000000045503">
1	ssize_t sio_puts(char s[]) /* Put string */
2	{
3		return write(STDOUT_FILENO, s, sio_strlen(s));
4	}
5	
6	ssize_t sio_putl(long v) /* Put long */
7	{
8		char s[128];
9	
10		sio_ltoa(v, s, 10); /* Based on K&amp;R itoa() */
11		return sio_puts(s);
12	}
13	
14	void sio_error(char s[]) /* Put error message and exit */
15	{
16		sio_puts(s);
17		_exit(1);
18	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045504" id="P7000497027000000000000000045504">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/src/csapp.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045505" id="P7000497027000000000000000045505"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045506" epub:type="title" id="P7000497027000000000000000045506"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.34 </span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045507" id="P7000497027000000000000000045507">S<span class="pcalibre1 pcalibre2 pcalibre84">io</span></code> (Safe I/O) package for signal handlers.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006CED" id="P7000497027000000000000000006CED">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045508" id="P7000497027000000000000000045508">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045509" id="P7000497027000000000000000045509">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006CF0" epub:type="pagebreak" id="P7000497027000000000000000006CF0" title="769"></span><i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/sigintsafe.c</i>
1	#include "csapp.h"
2	
3	void sigint_handler(int sig) /* Safe SIGINT handler */
4	{
5		Sio_puts("Caught SIGINT!\n");	/* Safe output */
6		_exit(0);	/* Safe exit */
7	}
<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/sigintsafe.c</i>
</code>
</pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004550A" id="P700049702700000000000000004550A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004550B" epub:type="title" id="P700049702700000000000000004550B"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.35 </span>A safe version of the SICINT handler from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006B55"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.30</span></a>.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P700049702700000000000000004550C" id="P700049702700000000000000004550C">The workaround is to save <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004550D" id="P700049702700000000000000004550D">errno</code> to a local variable on entry to the handler and restore it before the handler returns. Note that this is only necessary if the handler returns. It is not necessary if the handler terminates the process by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004550E" id="P700049702700000000000000004550E">_exit</code>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004550F" id="P700049702700000000000000004550F"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045510" id="P7000497027000000000000000045510"><span class="pcalibre1 pcalibre2 pcalibre41">G3. Protect accesses to shared global data structures by blocking all signals. </span>If a handler shares a global data structure with the main program or with other handlers, then your handlers and main program should temporarily block all signals while accessing (reading or writing) that data structure. The reason for this rule is that accessing a data structure <var class="pcalibre17 pcalibre2 pcalibre1">d</var> from the main program typically requires a sequence of instructions. If this instruction sequence is interrupted by a handler that accesses <var class="pcalibre17 pcalibre2 pcalibre1">d</var>, then the handler might find <var class="pcalibre17 pcalibre2 pcalibre1">d</var> in an inconsistent state, with unpredictable results. Temporarily blocking signals while you access <var class="pcalibre17 pcalibre2 pcalibre1">d</var> guarantees that a handler will not interrupt the instruction sequence.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045511" id="P7000497027000000000000000045511"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045512" id="P7000497027000000000000000045512"><span class="pcalibre1 pcalibre2 pcalibre41">G4. Declare global variables with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045513" id="P7000497027000000000000000045513">volatile</code>. </span>Consider a handler and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045514" id="P7000497027000000000000000045514">main</code> routine that share a global variable <i class="pcalibre17 pcalibre2 pcalibre1">g.</i> The handler updates <var class="pcalibre17 pcalibre2 pcalibre1">g</var>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045515" id="P7000497027000000000000000045515">main</code> periodically reads <i class="pcalibre17 pcalibre2 pcalibre1">g.</i> To an optimizing compiler, it would appear that the value of <var class="pcalibre17 pcalibre2 pcalibre1">g</var> never changes in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045516" id="P7000497027000000000000000045516">main</code>, and thus it would be safe to use a copy of <var class="pcalibre17 pcalibre2 pcalibre1">g</var> that is cached in a register to satisfy every reference to <i class="pcalibre17 pcalibre2 pcalibre1">g.</i> In this case, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045517" id="P7000497027000000000000000045517">main</code> function would never see the updated values from the handler.</p>
<p class="pcalibre1 pcalibre2 pcalibre42" data-uri="chapter08.xhtml#P7000497027000000000000000045518" id="P7000497027000000000000000045518">You can tell the compiler not to cache a variable by declaring it with the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045519" id="P7000497027000000000000000045519">volatile</code> type qualifier. For example:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004551A" id="P700049702700000000000000004551A"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004551B" id="P700049702700000000000000004551B">volatile int g;</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P700049702700000000000000004551C" id="P700049702700000000000000004551C">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004551D" id="P700049702700000000000000004551D">volatile</code> qualifier forces the compiler to read the value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004551E" id="P700049702700000000000000004551E">g</code> from memory each time it is referenced in the code. In general, as with any shared data structure, each access to a global variable should be protected by temporarily blocking signals.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004551F" id="P700049702700000000000000004551F"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045520" id="P7000497027000000000000000045520"><span class="pcalibre1 pcalibre2 pcalibre41">G5. Declare flags with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045521" id="P7000497027000000000000000045521">sig_atomic_t</code>. </span>In one common handler design, the handler records the receipt of the signal by writing to a global <i class="pcalibre17 pcalibre2 pcalibre1">flag.</i> The main program periodically reads the flag, responds to the signal, and <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006D09" epub:type="pagebreak" id="P7000497027000000000000000006D09" title="770"></span>clears the flag. For flags that are shared in this way, C provides an integer data type, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045522" id="P7000497027000000000000000045522">sig_atomic_t</code>, for which reads and writes are guaranteed to be <i class="pcalibre17 pcalibre2 pcalibre1">atomic</i> (uninterruptible) because they can be implemented with a single instruction:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045523" id="P7000497027000000000000000045523"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045524" id="P7000497027000000000000000045524">volatile sig_atomic_t flag;</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045525" id="P7000497027000000000000000045525">Since they can't be interrupted, you can safely read from and write to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045526" id="P7000497027000000000000000045526">sig_atomic_t</code> variables without temporarily blocking signals. Note that the guarantee of atomicity only applies to individual reads and writes. It does not apply to updates such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045527" id="P7000497027000000000000000045527">flag++</code> or <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045528" id="P7000497027000000000000000045528">flag = flag + 10</code>, which might require multiple instructions.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045529" id="P7000497027000000000000000045529">Keep in mind that the guidelines we have presented are conservative, in the sense that they are not always strictly necessary. For example, if you know that a handler can never modify <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004552A" id="P700049702700000000000000004552A">errno</code>, then you don't need to save and restore <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004552B" id="P700049702700000000000000004552B">errno</code>. Or if you can prove that no instance of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004552C" id="P700049702700000000000000004552C">printf</code> can ever be interrupted by a handler, then it is safe to call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004552D" id="P700049702700000000000000004552D">printf</code> from the handler. The same holds for accesses to shared global data structures. However, it is very difficult to prove such assertions in general. So we recommend that you take the conservative approach and follow the guidelines by keeping your handlers as simple as possible, calling safe functions, saving and restoring <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004552E" id="P700049702700000000000000004552E">errno</code>, protecting accesses to shared data structures, and using <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004552F" id="P700049702700000000000000004552F">volatile</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045530" id="P7000497027000000000000000045530">sig_atomic_t</code>.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006D19" id="P7000497027000000000000000006D19"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045531" epub:type="title" id="P7000497027000000000000000045531">Correct Signal Handling</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045532" id="P7000497027000000000000000045532">One of the nonintuitive aspects of signals is that pending signals are not queued. Because the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045533" id="P7000497027000000000000000045533">pending</code> bit vector contains exactly one bit for each type of signal, there can be at most one pending signal of any particular type. Thus, if two signals of type <var class="pcalibre17 pcalibre2 pcalibre1">k</var> are sent to a destination process while signal <var class="pcalibre17 pcalibre2 pcalibre1">k</var> is blocked because the destination process is currently executing a handler for signal <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, then the second signal is simply discarded; it is not queued. The key idea is that the existence of a pending signal merely indicates that <i class="pcalibre17 pcalibre2 pcalibre1">at least</i> one signal has arrived.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045534" id="P7000497027000000000000000045534">To see how this affects correctness, let's look at a simple application that is similar in nature to real programs such as shells and Web servers. The basic structure is that a parent process creates some children that run independently for a while and then terminate. The parent must reap the children to avoid leaving zombies in the system. But we also want the parent to be free to do other work while the children are running. So we decide to reap the children with a SIGCHLD handler, instead of explicitly waiting for the children to terminate. (Recall that the kernel sends a SIGCHLD signal to the parent whenever one of its children terminates or stops.)</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045535" id="P7000497027000000000000000045535"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006D1F"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.36 </span></a>shows our first attempt. The parent installs a SIGCHLD handler and then creates three children. In the meantime, the parent waits for a line of input from the terminal and then processes it. This processing is modeled by an infinite loop. When each child terminates, the kernel notifies the parent by sending it a SIGCHLD signal. The parent catches the SIGCHLD, reaps one child,</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006D1F" id="P7000497027000000000000000006D1F">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045536" id="P7000497027000000000000000045536"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006D21" epub:type="pagebreak" id="P7000497027000000000000000006D21" title="771"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/signal1. c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045537" id="P7000497027000000000000000045537">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045538" id="P7000497027000000000000000045538">
1	/* WARNING: This code is buggy! */
2	
3	void handlerl(int sig)
4	{
5		int olderrno = errno;
6	
7		if ((waitpid(-1, NULL, 0)) &lt; 0)
8			sio_error("waitpid error");
9		Sio_puts("Handler reaped child\n");
10		Sleep(1);
11		errno = olderrno;
12	}
13	
14	int main()
15	{
16		int i, n;
17		char buf [MAXBUF];
18	
19		if (signal(SIGCHLD, handler1) == SIG_ERR)
20			unix_error("signal error");
21	
22		/* Parent creates children */
23		for (i = 0; i &lt; 3; i++) {
24			if (Fork() == 0) {
25				printf ("Hello from child %d\n", (int)getpid());
26				exit(0);
27			}
28		}
29	
30		/* Parent waits for terminal input and then processes it */
31		if ((n = read(STDIN_FILENO, buf, sizeof(buf))) &lt; 0)
32			unix_error("read");
33	
34		printf("Parent processing input\n");
35		while (1)
36			;
37	
38		exit(0);
39	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045539" id="P7000497027000000000000000045539">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/signal1. c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004553A" id="P700049702700000000000000004553A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004553B" epub:type="title" id="P700049702700000000000000004553B"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.36 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004553C" id="P700049702700000000000000004553C">signal1</code>. This program is flawed because it assumes that signals are queued.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004553D" id="P700049702700000000000000004553D"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006D29" epub:type="pagebreak" id="P7000497027000000000000000006D29" title="772"></span>does some additional cleanup work (modeled by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004553E" id="P700049702700000000000000004553E">sleep</code> statement), and then returns.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004553F" id="P700049702700000000000000004553F">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045540" id="P7000497027000000000000000045540">signal1</code> program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006D1F"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.36 </span></a>seems fairly straightforward. When we run it on our Linux system, however, we get the following output:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045541" id="P7000497027000000000000000045541">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045542" id="P7000497027000000000000000045542">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./signal1</i>
Hello from child 14073
Hello from child 14074
Hello from child 14075
Handler reaped child
Handler reaped child
<i class="pcalibre17 pcalibre2 pcalibre1">CR</i>
Parent processing input
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045543" id="P7000497027000000000000000045543">From the output, we note that although three SIGCHLD signals were sent to the parent, only two of these signals were received, and thus the parent only reaped two children. If we suspend the parent process, we see that, indeed, child process 14075 was never reaped and remains a zombie (indicated by the string <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045544" id="P7000497027000000000000000045544">&lt;def unct&gt;</code> in the output of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045545" id="P7000497027000000000000000045545">ps</code> command):</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045546" id="P7000497027000000000000000045546">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045547" id="P7000497027000000000000000045547">
<i class="pcalibre17 pcalibre2 pcalibre1">Ctrl+Z</i>
Suspended
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">ps t</i>
PID TTY		STAT	TIME COMMAND
⋮
14072 pts/3	T	0:02./ signal1
14075 pts/3	Z	0:00 [signal1] &lt;defunct&gt;
14076 pts/3	R+	0:00 ps t
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045548" id="P7000497027000000000000000045548">What went wrong? The problem is that our code failed to account for the fact that signals are not queued. Here's what happened: The first signal is received and caught by the parent. While the handler is still processing the first signal, the second signal is delivered and added to the set of pending signals. However, since SIGCHLD signals are blocked by the SIGCHLD handler, the second signal is not received. Shortly thereafter, while the handler is still processing the first signal, the third signal arrives. Since there is already a pending SIGCHLD, this third SIGCHLD signal is discarded. Sometime later, after the handler has returned, the kernel notices that there is a pending SIGCHLD signal and forces the parent to receive the signal. The parent catches the signal and executes the handler a second time. After the handler finishes processing the second signal, there are no more pending SIGCHLD signals, and there never will be, because all knowledge of the third SIGCHLD has been lost. <i class="pcalibre17 pcalibre2 pcalibre1">The crucial lesson is that signals cannot be used to count the occurrence of events in other processes.</i></p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045549" id="P7000497027000000000000000045549">To fix the problem, we must recall that the existence of a pending signal only implies that at least one signal has been delivered since the last time the process received a signal of that type. So we must modify the SIGCHLD handler to reap</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006D36" id="P7000497027000000000000000006D36">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004554A" id="P700049702700000000000000004554A">------------------------------------------------------------------------------------------------------<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006D38" epub:type="pagebreak" id="P7000497027000000000000000006D38" title="773"></span><i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/signal2.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004554B" id="P700049702700000000000000004554B">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004554C" id="P700049702700000000000000004554C">
1	void handler2(int sig)
2	{
3		int olderrno = errno;
4	
5		while (waitpid(-1, NULL, 0) &gt; 0) {
6			Sio_puts("Handler reaped child\n");
7		}
8		if (errno != ECHILD)
9			Sio_error("waitpid error");
10		Sleep(1);
11		errno = olderrno;
12	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004554D" id="P700049702700000000000000004554D">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/signal2.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004554E" id="P700049702700000000000000004554E"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004554F" epub:type="title" id="P700049702700000000000000004554F"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.37 </span>signal2. An improved version of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006D1F"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.36 </span></a>that correctly accounts for the fact that signals are not queued.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045550" id="P7000497027000000000000000045550">as many zombie children as possible each time it is invoked. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006D36"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.37 </span></a>shows the modified SIGCHLD handler.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045551" id="P7000497027000000000000000045551">When we run <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045552" id="P7000497027000000000000000045552">signal2</code> on our Linux system, it now correctly reaps all of the zombie children:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045553" id="P7000497027000000000000000045553">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045554" id="P7000497027000000000000000045554">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./signal2</i>
Hello from child 15237
Hello from child 15238
Hello from child 15239
Handler reaped child
Handler reaped child
Handler reaped child
<i class="pcalibre17 pcalibre2 pcalibre1">CR</i>
Parent processing input
</code>
</pre>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006D43" epub:type="practice" id="P7000497027000000000000000006D43"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045555" epub:type="title" id="P7000497027000000000000000045555"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.8 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FE6">799</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P7000497027000000000000000045556" id="P7000497027000000000000000045556">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P7000497027000000000000000045557" id="P7000497027000000000000000045557"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045558" id="P7000497027000000000000000045558"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045559" id="P7000497027000000000000000045559">What is the output of the following program?</p></div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004555A" id="P700049702700000000000000004555A">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/signalprob0.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004555B" id="P700049702700000000000000004555B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004555C" id="P700049702700000000000000004555C">
1	volatile long counter = 2;
2	
3	void handler1(int sig)
4	{
5		sigset_t mask, prev_mask;
6	
7		Sigfillset(&amp;mask);
8		Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask); /* Block sigs */
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006D4C" epub:type="pagebreak" id="P7000497027000000000000000006D4C" title="774"></span>9		Sio_putl(--counter);
10		Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL); /* Restore sigs */
11	
12		_exit(0);
13	}
14
15	int main()
16	{
17		pid_t pid;
18		sigset_t mask, prev_mask;
19	
20		printf ("%ld", counter);
21		fflush(stdout);
22	
23		signal(SIGUSR1, handler1);
24		if ((pid = Fork()) == 0) {
25			while (1) ();
26		}
27		Kill(pid, SIGUSR1);
28		Waitpid(-1, NULL, 0);
29	
30		Sigfillset(&amp;mask);
31		Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask); /* Block sigs */
32		printf ("%ld", ++counter);
33		Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL); /* Restore sigs */
34	
35		exit(0);
36	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004555D" id="P700049702700000000000000004555D">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/signalprob0.c</i></p>
</li>
</ol>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006D4E" id="P7000497027000000000000000006D4E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004555E" epub:type="title" id="P700049702700000000000000004555E">Portable Signal Handling</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004555F" id="P700049702700000000000000004555F">Another ugly aspect of Unix signal handling is that different systems have different signal-handling semantics. For example:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045560" id="P7000497027000000000000000045560">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045561" id="P7000497027000000000000000045561"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045562" id="P7000497027000000000000000045562"><span class="pcalibre1 pcalibre2 pcalibre41">The semantics of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045563" id="P7000497027000000000000000045563">signal</code> function varies. </span>Some older Unix systems restore the action for signal <var class="pcalibre17 pcalibre2 pcalibre1">k</var> to its default after signal <var class="pcalibre17 pcalibre2 pcalibre1">k</var> has been caught by a handler. On these systems, the handler must explicitly reinstall itself, by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045564" id="P7000497027000000000000000045564">signal</code>, each time it runs.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045565" id="P7000497027000000000000000045565"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045566" id="P7000497027000000000000000045566"><span class="pcalibre1 pcalibre2 pcalibre41">System calls can be interrupted. </span>System calls such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045567" id="P7000497027000000000000000045567">read, wait</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045568" id="P7000497027000000000000000045568">accept</code> that can potentially block the process for a long period of time are called <i class="pcalibre17 pcalibre2 pcalibre1">slow system calls.</i> On some older versions of Unix, slow system calls that are interrupted when a handler catches a signal do not resume when the signal handler returns but instead return immediately to the user with an error condition and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045569" id="P7000497027000000000000000045569">errno</code> set to EINTR. On these systems, programmers must include code that manually restarts interrupted system calls.</p></li>
</ul>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006D5B" id="P7000497027000000000000000006D5B">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004556A" id="P700049702700000000000000004556A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006D5D" epub:type="pagebreak" id="P7000497027000000000000000006D5D" title="775"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/src/csapp.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004556B" id="P700049702700000000000000004556B">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004556C" id="P700049702700000000000000004556C">
1	handler_t *Signal(int signum, handler_t *handler)
2	{
3		struct sigaction action, old_action;
4	
5		action.sa_handler = handler;
6		sigemptyset(&amp;action.sa_mask); /* Block sigs of type being handled */
7		action.sa_flags = SA_RESTART; /* Restart syscalls if possible */
8	
9		if (sigaction(signum, feaction, &amp;old_action) &lt; 0)
10			unix_error("Signal error");
11		return (old_action.sa_handler);
12	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004556D" id="P700049702700000000000000004556D">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/src/csapp.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004556E" id="P700049702700000000000000004556E"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004556F" epub:type="title" id="P700049702700000000000000004556F"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.38 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045570" id="P7000497027000000000000000045570">Signal.</code> A wrapper for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045571" id="P7000497027000000000000000045571">sigaction</code> that provides portable signal handling on Posix-compliant systems.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045572" id="P7000497027000000000000000045572">To deal with these issues, the Posix standard defines the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045573" id="P7000497027000000000000000045573">sigaction</code> function, which allows users to clearly specify the signal-handling semantics they want when they install a handler.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045574" id="P7000497027000000000000000045574">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045575" id="P7000497027000000000000000045575">
#include &lt;signal.h&gt;
int sigaction(int signum, struct sigaction *act,
		struct sigaction *oldact);
					Returns: 0 if OK, -1 on error
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045576" id="P7000497027000000000000000045576">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045577" id="P7000497027000000000000000045577">sigaction</code> function is unwieldy because it requires the user to set the entries of a complicated structure. A cleaner approach, originally proposed by W. Richard Stevens [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>], is to define a wrapper function, called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045578" id="P7000497027000000000000000045578">Signal</code>, that calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045579" id="P7000497027000000000000000045579">sigaction</code> for us. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006D5B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.38 </span></a>shows the definition of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004557A" id="P700049702700000000000000004557A">Signal</code>, which is invoked in the same way as the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004557B" id="P700049702700000000000000004557B">signal</code> function.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004557C" id="P700049702700000000000000004557C">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004557D" id="P700049702700000000000000004557D">Signal</code> wrapper installs a signal handler with the following signal-handling semantics:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004557E" id="P700049702700000000000000004557E">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004557F" id="P700049702700000000000000004557F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045580" id="P7000497027000000000000000045580">Only signals of the type currently being processed by the handler are blocked.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045581" id="P7000497027000000000000000045581"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045582" id="P7000497027000000000000000045582">As with all signal implementations, signals are not queued.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045583" id="P7000497027000000000000000045583"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045584" id="P7000497027000000000000000045584">Interrupted system calls are automatically restarted whenever possible.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045585" id="P7000497027000000000000000045585"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045586" id="P7000497027000000000000000045586">Once the signal handler is installed, it remains installed until <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045587" id="P7000497027000000000000000045587">Signal</code> is called with a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045588" id="P7000497027000000000000000045588">handler</code> argument of either SIG_IGN or SIG_DFL.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045589" id="P7000497027000000000000000045589">We will use the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004558A" id="P700049702700000000000000004558A">Signal</code> wrapper in all of our code.</p>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006D7E" id="P7000497027000000000000000006D7E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004558B" epub:type="title" id="P700049702700000000000000004558B"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006D80" epub:type="pagebreak" id="P7000497027000000000000000006D80" title="776"></span><span class="pcalibre1 pcalibre21 pcalibre2">8.5.6  </span>Synchronizing Flows to Avoid Nasty Concurrency Bugs</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004558C" id="P700049702700000000000000004558C">The problem of how to program concurrent flows that read and write the same storage locations has challenged generations of computer scientists. In general, the number of potential interleavings of the flows is exponential in the number of instructions. Some of those interleavings will produce correct answers, and others will not. The fundamental problem is to somehow <i class="pcalibre17 pcalibre2 pcalibre1">synchronize</i> the concurrent flows so as to allow the largest set of feasible interleavings such that each of the feasible interleavings produces a correct answer.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004558D" id="P700049702700000000000000004558D">Concurrent programming is a deep and important problem that we will discuss in more detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">12</span></a>. However, we can use what you've learned about exceptional control flow in this chapter to give you a sense of the interesting intellectual challenges associated with concurrency. For example, consider the program in <span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.39</span>, which captures the structure of a typical Unix shell. The parent keeps track of its current children using entries in a global job list, with one entry per job. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004558E" id="P700049702700000000000000004558E">addjob</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004558F" id="P700049702700000000000000004558F">deletejob</code> functions add and remove entries from the job list.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045590" id="P7000497027000000000000000045590">After the parent creates a new child process, it adds the child to the job list. When the parent reaps a terminated (zombie) child in the SIGCHLD signal handler, it deletes the child from the job list.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045591" id="P7000497027000000000000000045591">At first glance, this code appears to be correct. Unfortunately, the following sequence of events is possible:</p>
<ol class="pcalibre1 calibre19 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045592" id="P7000497027000000000000000045592">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045593" id="P7000497027000000000000000045593"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045594" id="P7000497027000000000000000045594">The parent executes the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045595" id="P7000497027000000000000000045595">fork</code> function and the kernel schedules the newly created child to run instead of the parent.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045596" id="P7000497027000000000000000045596"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045597" id="P7000497027000000000000000045597">Before the parent is able to run again, the child terminates and becomes a zombie, causing the kernel to deliver a SIGCHLD signal to the parent.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045598" id="P7000497027000000000000000045598"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045599" id="P7000497027000000000000000045599">Later, when the parent becomes runnable again but before it is executed, the kernel notices the pending SIGCHLD and causes it to be received by running the signal handler in the parent.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004559A" id="P700049702700000000000000004559A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004559B" id="P700049702700000000000000004559B">The signal handler reaps the terminated child and calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004559C" id="P700049702700000000000000004559C">deletejob</code>, which does nothing because the parent has not added the child to the list yet.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004559D" id="P700049702700000000000000004559D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004559E" id="P700049702700000000000000004559E">After the handler completes, the kernel then runs the parent, which returns from <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004559F" id="P700049702700000000000000004559F">fork</code> and incorrectly adds the (nonexistent) child to the job list by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455A0" id="P70004970270000000000000000455A0">addj ob.</code></p></li>
</ol>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455A1" id="P70004970270000000000000000455A1">Thus, for some interleavings of the parent's main routine and signal-handling flows, it is possible for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455A2" id="P70004970270000000000000000455A2">deletejob</code> to be called before <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455A3" id="P70004970270000000000000000455A3">addjob</code>. This results in an incorrect entry on the job list, for a job that no longer exists and that will never be removed. On the other hand, there are also interleavings where events occur in the correct order. For example, if the kernel happens to schedule the parent to run when the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455A4" id="P70004970270000000000000000455A4">fork</code> call returns instead of the child, then the parent will correctly add the child to the job list before the child terminates and the signal handler removes the job from the list.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455A5" id="P70004970270000000000000000455A5">This is an example of a classic synchronization error known as a <i class="pcalibre17 pcalibre2 pcalibre1">race.</i> In this case, the race is between the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455A6" id="P70004970270000000000000000455A6">addjob</code> in the main routine and the call to</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006D9C" id="P7000497027000000000000000006D9C">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455A7" id="P70004970270000000000000000455A7"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006D9E" epub:type="pagebreak" id="P7000497027000000000000000006D9E" title="777"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/procmask1.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000455A8" id="P70004970270000000000000000455A8"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455A9" id="P70004970270000000000000000455A9">
1	/* WARNING: This code is buggy! */
2	void handler(int sig)
3	{
4		int olderrno = errno;
5		sigset_t mask_all, prev_all;
6		pid_t pid;
7	
8		Sigfillset(&amp;mask_all);
9		while ((pid = waitpid(-1, NULL, 0)) &gt; 0) { /* Reap a zombie child */
10			Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);
11			deletejob(pid); /* Delete the child from the job list */
12			Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL);
13		}
14		if (errno != ECHILD)
15			Sio_error("waitpid error");
16		errno = olderrno;
17	}
18	
19	int main(int argc, char **argv)
20	{
21		int pid;
22		sigset_t mask_all, prev_all;
23	
24		Sigfillset(&amp;mask_all);
25		Signal(SIGCHLD, handler);
26		initjobs(); /* Initialize the job list */
27	
28		while (1) {
29			if ((pid = Fork()) == 0) { /* Child process */
30				Execve("/bin/date", argv, NULL);
31			}
32			Sigprocmask(SIG_BL0CK, &amp;mask_all, &amp;prev_all); /* Parent process */
33			addjob(pid); /* Add the child to the job list */
34			Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL);
35		}
36		exit(0);
37	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455AA" id="P70004970270000000000000000455AA">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/procmask1.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000455AB" id="P70004970270000000000000000455AB"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000455AC" epub:type="title" id="P70004970270000000000000000455AC"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.39 </span>A shell program with a subtle synchronization error.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455AD" id="P70004970270000000000000000455AD"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000455AE" id="P70004970270000000000000000455AE">If the child terminates before the parent is able to run, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455AF" id="P70004970270000000000000000455AF">addjob</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455B0" id="P70004970270000000000000000455B0">deletejob</code> will be called in the wrong order.</p></div>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455B1" id="P70004970270000000000000000455B1"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006DA9" epub:type="pagebreak" id="P7000497027000000000000000006DA9" title="778"></span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455B2" id="P70004970270000000000000000455B2">deletejob</code> in the handler. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455B3" id="P70004970270000000000000000455B3">addjob</code> wins the race, then the answer is correct. If not, the answer is incorrect. Such errors are enormously difficult to debug because it is often impossible to test every interleaving. You might run the code a billion times without a problem, but then the next test results in an interleaving that triggers the race.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455B4" id="P70004970270000000000000000455B4"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006DC9"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.40 </span></a>shows one way to eliminate the race in <span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.39</span>. By blocking SIGCHLD signals before the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455B5" id="P70004970270000000000000000455B5">fork</code> and then unblocking them only after we have called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455B6" id="P70004970270000000000000000455B6">addjob</code>, we guarantee that the child will be reaped <i class="pcalibre17 pcalibre2 pcalibre1">after</i> it is added to the job list. Notice that children inherit the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455B7" id="P70004970270000000000000000455B7">blocked</code> set of their parents, so we must be careful to unblock the SIGCHLD signal in the child before calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455B8" id="P70004970270000000000000000455B8">execve</code>.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006DB1" id="P7000497027000000000000000006DB1"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455B9" epub:type="title" id="P70004970270000000000000000455B9"><span class="pcalibre1 pcalibre21 pcalibre2">8.5.7  </span>Explicitly Waiting for Signals</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455BA" id="P70004970270000000000000000455BA">Sometimes a main program needs to explicitly wait for a certain signal handler to run. For example, when a Linux shell creates a foreground job, it must wait for the job to terminate and be reaped by the SIGCHLD handler before accepting the next user command.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455BB" id="P70004970270000000000000000455BB"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006DD6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.41 </span></a>shows the basic idea. The parent installs handlers for SIGINT and SIGCHLD and then enters an infinite loop. It blocks SIGCHLD to avoid the race between parent and child that we discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006D7E"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5.6</span></a>. After creating the child, it resets <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455BC" id="P70004970270000000000000000455BC">pid</code> to zero, unblocks SIGCHLD, and then waits in a spin loop for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455BD" id="P70004970270000000000000000455BD">pid</code> to become nonzero. After the child terminates, the handler reaps it and assigns its nonzero PID to the global <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455BE" id="P70004970270000000000000000455BE">pid</code> variable. This terminates the spin loop, and the parent continues with additional work before starting the next iteration.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455BF" id="P70004970270000000000000000455BF">While this code is correct, the spin loop is wasteful of processor resources. We might be tempted to fix this by inserting a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455C0" id="P70004970270000000000000000455C0">pause</code> in the body of the spin loop:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000455C1" id="P70004970270000000000000000455C1">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455C2" id="P70004970270000000000000000455C2">
while (!pid) /* Race! */
pause ();
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455C3" id="P70004970270000000000000000455C3">Notice that we still need a loop because <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455C4" id="P70004970270000000000000000455C4">pause</code> might be interrupted by the receipt of one or more SIGINT signals. However, this code has a serious race condition: if the SIGCHLD is received after the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455C5" id="P70004970270000000000000000455C5">while</code> test but before the pause, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455C6" id="P70004970270000000000000000455C6">pause</code> will sleep forever.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455C7" id="P70004970270000000000000000455C7">Another option is to replace the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455C8" id="P70004970270000000000000000455C8">pause</code> with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455C9" id="P70004970270000000000000000455C9">sleep</code>:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000455CA" id="P70004970270000000000000000455CA">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455CB" id="P70004970270000000000000000455CB">
while (!pid) /* Too slow! */
sleep(1);
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455CC" id="P70004970270000000000000000455CC">While correct, this code is too slow. If the signal is received after the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455CD" id="P70004970270000000000000000455CD">while</code> and before the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455CE" id="P70004970270000000000000000455CE">sleep</code>, the program must wait a (relatively) long time before it can check the loop termination condition again. Using a higher-resolution sleep function such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455CF" id="P70004970270000000000000000455CF">nanosleep</code> isn't acceptable, either, because there is no good rule for determining the sleep interval. Make it too small and the loop is too wasteful. Make it too high and the program is too slow.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006DC9" id="P7000497027000000000000000006DC9">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455D0" id="P70004970270000000000000000455D0"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006DCB" epub:type="pagebreak" id="P7000497027000000000000000006DCB" title="779"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/procmask2.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000455D1" id="P70004970270000000000000000455D1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455D2" id="P70004970270000000000000000455D2">
1	void handler(int sig)
2	{
3		int olderrno = errno;
4		sigset_t mask_all, prev_all;
5		pid_t pid;
6	
7		Sigfillset(&amp;mask_all);
8		while ((pid = waitpid(-1, NULL, 0)) &gt; 0) { /* Reap a zombie child */
9			Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);
10			deletejob(pid); /* Delete the child from the job list */
11			Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL);
12		}
13		if (errno != ECHILD)
14			Sio_error("waitpid error");
15		errno = olderrno; 
16	}
17	
18	int main(int argc, char **argv)
19	{
20		int pid;
21		sigset_t mask_all, mask_one, prev_one;
22	
23		Sigfillset(&amp;mask_all);
24		Sigemptyset(&amp;mask_one);
25		Sigaddset(&amp;mask_one, SIGCHLD);
26		Signal(SIGCHLD, handler);
27		initjobs(); /* Initialize the job list */
28	
29		while (1) {
30			Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); /* Block SIGCHLD */
31			if ((pid = Fork()) == 0) { /* Child process */
32				Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); /* Unblock SIGCHLD */
33				Execve("/bin/date", argv, NULL);
34			}
35			Sigprocmask(SIG_BLOCK, &amp;mask_all, NULL); /* Parent process */
36			addjob(pid); /* Add the child to the job list */
37			Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); /* Unblock SIGCHLD */
38		}
39		exit(0);
40	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455D3" id="P70004970270000000000000000455D3">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/procmask2.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000455D4" id="P70004970270000000000000000455D4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000455D5" epub:type="title" id="P70004970270000000000000000455D5"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.40 </span>Using <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455D6" id="P70004970270000000000000000455D6">sigprocmask</code> to synchronize processes.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455D7" id="P70004970270000000000000000455D7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000455D8" id="P70004970270000000000000000455D8">In this example, the parent ensures that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455D9" id="P70004970270000000000000000455D9">addjob</code> executes before the corresponding <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455DA" id="P70004970270000000000000000455DA">deletejob</code>.
</p></div>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006DD6" id="P7000497027000000000000000006DD6">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455DB" id="P70004970270000000000000000455DB"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006DD8" epub:type="pagebreak" id="P7000497027000000000000000006DD8" title="780"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitforsignal.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000455DC" id="P70004970270000000000000000455DC">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455DD" id="P70004970270000000000000000455DD">
1	#include "csapp.h"
2	
3	volatile sig_atomic_t pid;
4	
5	void sigchld_handler(int s)
6	{
7		int olderrno = errno;
8		pid = waitpid(-1, NULL, 0);
9		errno = olderrno;
10	}
11	
12	void sigint_handler(int s)
13	{
14	}
15	
16	int main(int arge, char **argv)
17	{
18		sigset_t mask, prev;
19	
20		Signal(SIGCHLD, sigchld_handler);
21		Signal(SIGINT, sigintjiandler);
22		Sigemptyset(&amp;mask);
23		Sigaddset(&amp;mask, SIGCHLD);
24	
25		while (1) {
26			Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); /* Block SIGCHLD */
27			if (Fork() == 0) /* Child */
28				exit(0);
29	
30			/* Parent */
31			pid = 0;
32			Sigprocmask(SIG_SETMASK, &amp;prev, NULL); /* Unblock SIGCHLD */
33	
34			/* Wait for SIGCHLD to be received (wasteful) */
35			while (!pid)
36				;
37	
38			/* Do some work after receiving SIGCHLD */
39			printf(".");
40		}
41		exit(0);
42	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455DE" id="P70004970270000000000000000455DE">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitforsignal.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P70004970270000000000000000455DF" id="P70004970270000000000000000455DF"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P70004970270000000000000000455E0" epub:type="title" id="P70004970270000000000000000455E0"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.41 </span>Waiting for a signal with a spin loop. </h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455E1" id="P70004970270000000000000000455E1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000455E2" id="P70004970270000000000000000455E2">This code is correct, but the spin loop is wasteful.</p></div>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455E3" id="P70004970270000000000000000455E3"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006DE1" epub:type="pagebreak" id="P7000497027000000000000000006DE1" title="781"></span>The proper solution is to use sigsuspend.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000455E4" id="P70004970270000000000000000455E4"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455E5" id="P70004970270000000000000000455E5">
#include &lt;signal.h&gt;
int sigsuspend(const sigset_t *mask);
				Returns: -1
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455E6" id="P70004970270000000000000000455E6">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455E7" id="P70004970270000000000000000455E7">sigsuspend</code> function temporarily replaces the current blocked set with mask and then suspends the process until the receipt of a signal whose action is either to run a handler or to terminate the process. If the action is to terminate, then the process terminates without returning from <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455E8" id="P70004970270000000000000000455E8">sigsuspend</code>. If the action is to run a handler, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455E9" id="P70004970270000000000000000455E9">sigsuspend</code> returns after the handler returns, restoring the blocked set to its state when <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455EA" id="P70004970270000000000000000455EA">sigsuspend</code> was called.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455EB" id="P70004970270000000000000000455EB">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455EC" id="P70004970270000000000000000455EC">sigsuspend</code> function is equivalent to an <i class="pcalibre17 pcalibre2 pcalibre1">atomic</i> (uninterruptible) version of the following:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000455ED" id="P70004970270000000000000000455ED">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455EE" id="P70004970270000000000000000455EE">
1	sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);
2	pause();
3	sigprocmask(SIG_SETMASK, &amp;prev, NULL);
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455EF" id="P70004970270000000000000000455EF">The atomic property guarantees that the calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455F0" id="P70004970270000000000000000455F0">sigprocmask</code> (line 1) and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455F1" id="P70004970270000000000000000455F1">pause</code> (line 2) occur together, without being interrupted. This eliminates the potential race where a signal is received after the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455F2" id="P70004970270000000000000000455F2">sigprocmask</code> and before the call to pause.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455F3" id="P70004970270000000000000000455F3"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006DFA.xhtml#P7000497027000000000000000006DFF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.42 </span></a>shows how we would use <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455F4" id="P70004970270000000000000000455F4">sigsuspend</code> to replace the spin loop in <span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.41</span>. Before each call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455F5" id="P70004970270000000000000000455F5">sigsuspend</code>, SIGCHLD is blocked. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455F6" id="P70004970270000000000000000455F6">sigsuspend</code> temporarily unblocks SIGCHLD, and then sleeps until the parent catches a signal. Before returning, it restores the original blocked set, which blocks SIGCHLD again. If the parent caught a SIGINT, then the loop test succeeds and the next iteration calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455F7" id="P70004970270000000000000000455F7">sigsuspend</code> again. If the parent caught a SIGCHLD, then the loop test fails and we exit the loop. At this point, SIGCHLD is blocked, and so we can optionally unblock SIGCHLD. This might be useful in a real shell with background jobs that need to be reaped.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455F8" id="P70004970270000000000000000455F8">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455F9" id="P70004970270000000000000000455F9">sigsuspend</code> version is less wasteful than the original spin loop, avoids the race introduced by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455FA" id="P70004970270000000000000000455FA">pause</code>, and is more efficient than <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455FB" id="P70004970270000000000000000455FB">sleep</code>.</p>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>8.6 Nonlocal Jumps</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000006DFA"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P70004970270000000000000000455FC" epub:type="title" id="P70004970270000000000000000455FC"><span class="pcalibre1 pcalibre21 pcalibre2">8.6 </span>Nonlocal Jumps</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455FD" id="P70004970270000000000000000455FD">C provides a form of user-level exceptional control flow, called a <i class="pcalibre17 pcalibre2 pcalibre1">nonlocal jump</i>, that transfers control directly from one function to another currently executing function without having to go through the normal call-and-return sequence. Nonlocal jumps are provided by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455FE" id="P70004970270000000000000000455FE">setjmp</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000455FF" id="P70004970270000000000000000455FF">longjmp</code> functions.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006DFF" id="P7000497027000000000000000006DFF">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045600" id="P7000497027000000000000000045600"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006E01" epub:type="pagebreak" id="P7000497027000000000000000006E01" title="782"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/sigsuspend.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045601" id="P7000497027000000000000000045601">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045602" id="P7000497027000000000000000045602">
1	#include "csapp.h"
2	
3	volatile sig_atomic_t pid;
4	
5	void sigchld_handler(int s)
6	{
7		int olderrno = errno;
8		pid = Waitpid(-1, NULL, 0);
9		errno = olderrno;
10	}
11	
12	void sigint_handler(int s)
13	{
14	}
15	
16	int main(int argc, char **argv)
17	{
18		sigset_t mask, prev;
19	
20		Signal(SIGCHLD, sigchldjiandler);
21		Signal(SIGINT, sigint_handler);
22		Sigemptyset(&amp;mask);
23		Sigaddset(&amp;mask, SIGCHLD);
24	
25		while (1) {
26			Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); /* Block SIGCHLD */
27			if (Fork() == 0) /* Child */
28				exit(0);
29	
30			/* Wait for SIGCHLD to be received */
31			pid = 0;
32			while (!pid)
33				sigsuspend(&amp;prev);
34	
35			/* Optionally unblock SIGCHLD */
36			Sigprocmask(SIG_SETMASK, &amp;prev, NULL);
37	
38			/* Do some work after receiving SIGCHLD */
39			printf (".");
40		}
41		exit(0);
42	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045603" id="P7000497027000000000000000045603">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/sigsuspend.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045604" id="P7000497027000000000000000045604"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045605" epub:type="title" id="P7000497027000000000000000045605"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.42 </span>Waiting for a signal with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045606" id="P7000497027000000000000000045606">sigsuspend</code>.</h1></header>
</figcaption>
</figure>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045607" id="P7000497027000000000000000045607">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045608" id="P7000497027000000000000000045608">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006E0A" epub:type="pagebreak" id="P7000497027000000000000000006E0A" title="783"></span>#include &lt;setjmp.h&gt;
int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);
				Returns: 0 from set jmp, nonzero from longjmps
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045609" id="P7000497027000000000000000045609">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004560A" id="P700049702700000000000000004560A">setjmp</code> function saves the current <i class="pcalibre17 pcalibre2 pcalibre1">calling environment</i> in the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004560B" id="P700049702700000000000000004560B">env</code> buffer, for later use by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004560C" id="P700049702700000000000000004560C">longjmp</code>, and returns 0. The calling environment includes the program counter, stack pointer, and general-purpose registers. For subtle reasons beyond our scope, the value that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004560D" id="P700049702700000000000000004560D">setjmp</code> returns should not be assigned to a variable:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004560E" id="P700049702700000000000000004560E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004560F" id="P700049702700000000000000004560F">rc = setjmp(env); /* Wrong! */</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045610" id="P7000497027000000000000000045610">However, it can be safely used as a test in a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045611" id="P7000497027000000000000000045611">switch</code> or conditional statement [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41E">62</a>].</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045612" id="P7000497027000000000000000045612">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045613" id="P7000497027000000000000000045613">
#include &lt;setjmp.h&gt;
void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);
Never returns
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045614" id="P7000497027000000000000000045614">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045615" id="P7000497027000000000000000045615">longjmp</code> function restores the calling environment from the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045616" id="P7000497027000000000000000045616">env</code> buffer and then triggers a return from the most recent <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045617" id="P7000497027000000000000000045617">setjmp</code> call that initialized <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045618" id="P7000497027000000000000000045618">env</code>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045619" id="P7000497027000000000000000045619">setjmp</code> then returns with the nonzero return value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004561A" id="P700049702700000000000000004561A">retval</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004561B" id="P700049702700000000000000004561B">The interactions between <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004561C" id="P700049702700000000000000004561C">setjmp</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004561D" id="P700049702700000000000000004561D">longjmp</code> can be confusing at first glance. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004561E" id="P700049702700000000000000004561E">setjmp</code> function is called once but returns <i class="pcalibre17 pcalibre2 pcalibre1">multiple times:</i> once when the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004561F" id="P700049702700000000000000004561F">setjmp</code> is first called and the calling environment is stored in the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045620" id="P7000497027000000000000000045620">env</code> buffer, and once for each corresponding <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045621" id="P7000497027000000000000000045621">longjmp</code> call. On the other hand, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045622" id="P7000497027000000000000000045622">longjmp</code> function is called once but never returns.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045623" id="P7000497027000000000000000045623">An important application of nonlocal jumps is to permit an immediate return from a deeply nested function call, usually as a result of detecting some error condition. If an error condition is detected deep in a nested function call, we can use a nonlocal jump to return directly to a common localized error handler instead of laboriously unwinding the call stack.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045624" id="P7000497027000000000000000045624"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006E32"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.43 </span></a>shows an example of how this might work. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045625" id="P7000497027000000000000000045625">main</code> routine first calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045626" id="P7000497027000000000000000045626">setjmp</code> to save the current calling environment, and then calls function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045627" id="P7000497027000000000000000045627">foo</code>, which in turn calls function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045628" id="P7000497027000000000000000045628">bar</code>. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045629" id="P7000497027000000000000000045629">foo</code> or <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004562A" id="P700049702700000000000000004562A">bar</code> encounter an error, they return immediately from the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004562B" id="P700049702700000000000000004562B">setjmp</code> via a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004562C" id="P700049702700000000000000004562C">longjmp</code> call. The nonzero return value of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004562D" id="P700049702700000000000000004562D">setjmp</code> indicates the error type, which can then be decoded and handled in one place in the code.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004562E" id="P700049702700000000000000004562E">The feature of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004562F" id="P700049702700000000000000004562F">longjmp</code> that allows it to skip up through all intermediate calls can have unintended consequences. For example, if some data structures were allocated in the intermediate function calls with the intention to deallocate them at the end of the function, the deallocation code gets skipped, thus creating a memory leak.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006E32" id="P7000497027000000000000000006E32">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045630" id="P7000497027000000000000000045630"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006E34" epub:type="pagebreak" id="P7000497027000000000000000006E34" title="784"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/setjmp.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045631" id="P7000497027000000000000000045631">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045632" id="P7000497027000000000000000045632">
1	#include "csapp.h"
2	
3	jmp_buf buf;
4	
5	int error1 = 0;
6	int error2 = 1;
7	
8	void foo(void), bar(void);
9	
10	int main()
11	{
12		switch(setjmp(buf)) {
13		case 0:
14			foo();
15			break;
16		case 1:
17			printf("Detected an error1 condition in foo\n");
18			break;
19		case 2:
20			printf("Detected an error2 condition in foo\n");
21			break;
22		default:
23			printf("Unknown error condition in foo\n");
24		}
25		exit(0);
26	}
27	
28	/* Deeply nested function foo */
29	void foo(void)
30	{
31		if (error1)
32			longjmp(buf, 1);
33		bar();
34	}
35	
36	void bar void)
37	{
38		if (error2)
39			longjmp(buf, 2);
40	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045633" id="P7000497027000000000000000045633">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/setjmp.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045634" id="P7000497027000000000000000045634"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045635" epub:type="title" id="P7000497027000000000000000045635"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.43 </span>Nonlocal jump example.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045636" id="P7000497027000000000000000045636"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045637" id="P7000497027000000000000000045637">This example shows the framework for using nonlocal jumps to recover from error conditions in deeply nested functions without having to unwind the entire stack.
</p></div>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006E3C" id="P7000497027000000000000000006E3C">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045638" id="P7000497027000000000000000045638"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006E3E" epub:type="pagebreak" id="P7000497027000000000000000006E3E" title="785"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/restart.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045639" id="P7000497027000000000000000045639"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004563A" id="P700049702700000000000000004563A">
1	#include "csapp.h"
2	
3	sigjmp_buf buf;
4	
5	void handler(int sig)
6	{
7		siglongjmp(buf, 1);
8	}
9	
10	int main()
11	{
12		if (!sigsetjmp(buf, 1)) {
13			Signal(SIGINT, handler);
14			Sio_puts("starting\n");
15		}
16		else
17			Sio_puts("restarting\n");
18	
19		while(1) {
20			Sleep (1);
21			Sio_puts("processing...\n");
22		}
23		exit(0); /* Control never reaches here */
24	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004563B" id="P700049702700000000000000004563B">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/restart.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004563C" id="P700049702700000000000000004563C"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004563D" epub:type="title" id="P700049702700000000000000004563D"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.44 </span>A program that uses nonlocal jumps to restart itself when the user types Ctrl+C.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004563E" id="P700049702700000000000000004563E">Another important application of nonlocal jumps is to branch out of a signal handler to a specific code location, rather than returning to the instruction that was interrupted by the arrival of the signal. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006E3C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.44 </span></a>shows a simple program that illustrates this basic technique. The program uses signals and nonlocal jumps to do a soft restart whenever the user types Ctrl+C at the keyboard. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004563F" id="P700049702700000000000000004563F">sigsetjmp</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045640" id="P7000497027000000000000000045640">siglongjmp</code> functions are versions of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045641" id="P7000497027000000000000000045641">setjmp</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045642" id="P7000497027000000000000000045642">longjmp</code> that can be used by signal handlers.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045643" id="P7000497027000000000000000045643">The initial call to the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045644" id="P7000497027000000000000000045644">sigsetjmp</code> function saves the calling environment and signal context (including the pending and blocked signal vectors) when the program first starts. The main routine then enters an infinite processing loop. When the user types Ctrl+C, the kernel sends a SIGINT signal to the process, which catches it. Instead of returning from the signal handler, which would pass control back to the interrupted processing loop, the handler performs a nonlocal jump back to the beginning of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045645" id="P7000497027000000000000000045645">main</code> program. When we run the program on our system, we get the following output:</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045646" id="P7000497027000000000000000045646"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter08.xhtml#P7000497027000000000000000045647" epub:type="title" id="P7000497027000000000000000045647"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006E4E" epub:type="pagebreak" id="P7000497027000000000000000006E4E" title="786"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Software exceptions in C++ and Java</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045648" id="P7000497027000000000000000045648">The exception mechanisms provided by C++ and Java are higher-level, more structured versions of the C <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045649" id="P7000497027000000000000000045649">setjmp</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004564A" id="P700049702700000000000000004564A">longjmp</code> functions. You can think of a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004564B" id="P700049702700000000000000004564B">catch</code> clause inside a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004564C" id="P700049702700000000000000004564C">try</code> statement as being akin to a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004564D" id="P700049702700000000000000004564D">setjmp</code> function. Similarly, a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004564E" id="P700049702700000000000000004564E">throw</code> statement is similar to a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004564F" id="P700049702700000000000000004564F">longjmp</code> function.</p>
</aside>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045650" id="P7000497027000000000000000045650">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045651" id="P7000497027000000000000000045651">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./restart</i>
starting
processing...
processing...
<i class="pcalibre17 pcalibre2 pcalibre1">Ctrl+C</i>
restarting
processing...
<i class="pcalibre17 pcalibre2 pcalibre1">Ctrl+C</i>
restarting
processing...
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045652" id="P7000497027000000000000000045652">There a couple of interesting things about this program. First, To avoid a race, we must install the handler <i class="pcalibre17 pcalibre2 pcalibre1">after</i> we call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045653" id="P7000497027000000000000000045653">sigsetjmp</code>. If not, we would run the risk of the handler running before the initial call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045654" id="P7000497027000000000000000045654">sigsetjmp</code> sets up the calling environment for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045655" id="P7000497027000000000000000045655">siglongjmp</code>. Second, you might have noticed that the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045656" id="P7000497027000000000000000045656">sigsetjmp</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045657" id="P7000497027000000000000000045657">siglongjmp</code> functions are not on the list of async-signal-safe functions in <span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.33</span>. The reason is that in general <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045658" id="P7000497027000000000000000045658">siglongjmp</code> can jump into arbitrary code, so we must be careful to call only safe functions in any code reachable from a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045659" id="P7000497027000000000000000045659">siglongjmp</code>. In our example, we call the safe <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004565A" id="P700049702700000000000000004565A">sio_puts</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004565B" id="P700049702700000000000000004565B">sleep</code> functions. The unsafe <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004565C" id="P700049702700000000000000004565C">exit</code> function is unreachable.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>8.7 Tools for Manipulating Processes</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000006E64"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P700049702700000000000000004565D" epub:type="title" id="P700049702700000000000000004565D"><span class="pcalibre1 pcalibre21 pcalibre2">8.7 </span>Tools for Manipulating Processes</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004565E" id="P700049702700000000000000004565E">Linux systems provide a number of useful tools for monitoring and manipulating processes:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004565F" id="P700049702700000000000000004565F">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045660" id="P7000497027000000000000000045660"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045661" id="P7000497027000000000000000045661"><span class="pcalibre1 pcalibre29 pcalibre2">strace</span>. Prints a trace of each system call invoked by a running program and its children. It is a fascinating tool for the curious student. Compile your program with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045662" id="P7000497027000000000000000045662">-static</code> to get a cleaner trace without a lot of output related to shared libraries.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045663" id="P7000497027000000000000000045663"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045664" id="P7000497027000000000000000045664"><span class="pcalibre1 pcalibre29 pcalibre2">ps</span>. Lists processes (including zombies) currently in the system.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045665" id="P7000497027000000000000000045665"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045666" id="P7000497027000000000000000045666"><span class="pcalibre1 pcalibre29 pcalibre2">top</span>. Prints information about the resource usage of current processes.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045667" id="P7000497027000000000000000045667"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P7000497027000000000000000045668" id="P7000497027000000000000000045668"><span class="pcalibre1 pcalibre29 pcalibre2">pmap</span>. Displays the memory map of a process.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045669" id="P7000497027000000000000000045669"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter08.xhtml#P700049702700000000000000004566A" id="P700049702700000000000000004566A"><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004566B" id="P700049702700000000000000004566B">/proc</code>. A virtual filesystem that exports the contents of numerous kernel data structures in an ASCII text form that can be read by user programs. For example, type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004566C" id="P700049702700000000000000004566C">cat /proc/loadavg</code> to see the current load average on your Linux system.</p></li>
</ul>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>8.8 Summary </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000006E75"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P700049702700000000000000004566D" epub:type="title" id="P700049702700000000000000004566D"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006E77" epub:type="pagebreak" id="P7000497027000000000000000006E77" title="787"></span><span class="pcalibre1 pcalibre21 pcalibre2">8.8 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary </span></h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004566E" id="P700049702700000000000000004566E">Exceptional control flow (ECF) occurs at all levels of a computer system and is a basic mechanism for providing concurrency in a computer system.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004566F" id="P700049702700000000000000004566F">At the hardware level, exceptions are abrupt changes in the control flow that are triggered by events in the processor. The control flow passes to a software handler, which does some processing and then returns control to the interrupted control flow.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045670" id="P7000497027000000000000000045670">There are four different types of exceptions: interrupts, faults, aborts, and traps. Interrupts occur asynchronously (with respect to any instructions) when an external I/O device such as a timer chip or a disk controller sets the interrupt pin on the processor chip. Control returns to the instruction following the faulting instruction. Faults and aborts occur synchronously as the result of the execution of an instruction. Fault handlers restart the faulting instruction, while abort handlers never return control to the interrupted flow. Finally, traps are like function calls that are used to implement the system calls that provide applications with controlled entry points into the operating system code.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045671" id="P7000497027000000000000000045671">At the operating system level, the kernel uses ECF to provide the fundamental notion of a process. A process provides applications with two important abstractions: (1) logical control flows that give each program the illusion that it has exclusive use of the processor, and (2) private address spaces that provide the illusion that each program has exclusive use of the main memory.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045672" id="P7000497027000000000000000045672">At the interface between the operating system and applications, applications can create child processes, wait for their child processes to stop or terminate, run new programs, and catch signals from other processes. The semantics of signal handling is subtle and can vary from system to system. However, mechanisms exist on Posix-compliant systems that allow programs to clearly specify the expected signal-handling semantics.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045673" id="P7000497027000000000000000045673">Finally, at the application level, C programs can use nonlocal jumps to bypass the normal call/return stack discipline and branch directly from one function to another.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Bibliographic Notes </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000006E7E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045674" epub:type="title" id="P7000497027000000000000000045674"><span class="pcalibre1 pcalibre21 pcalibre2">Bibliographic Notes </span></h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045675" id="P7000497027000000000000000045675">Kerrisk is the essential reference for all aspects of programming in the Linux environment [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41E">62</a>]. The Intel ISA specification contains a detailed discussion of exceptions and interrupts on Intel processors [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B406">50</a>]. Operating systems texts [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B470">102</a>, <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B478">106</a>, <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B486">113</a>] contain additional information on exceptions, processes, and signals. The classic work by W. Richard Stevens [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B482">111</a>] is a valuable and highly readable description of how to work with processes and signals from application programs. Bovet and Cesati [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3B6">11</a>] give a wonderfully clear description of the Linux kernel, including details of the process and signal implementations.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Homework Problems </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" epub:type="practice" id="P7000497027000000000000000006E81"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045676" epub:type="title" id="P7000497027000000000000000045676"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006E83" epub:type="pagebreak" id="P7000497027000000000000000006E83" title="788"></span><span class="pcalibre1 pcalibre21 pcalibre2">Homework Problems </span></h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006E84" id="P7000497027000000000000000006E84"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045677" epub:type="title" id="P7000497027000000000000000045677"><span class="pcalibre1 pcalibre21 pcalibre2">8.9 </span>♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045678" id="P7000497027000000000000000045678">Consider four processes with the following starting and ending times:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter08.xhtml#P7000497027000000000000000045679" id="P7000497027000000000000000045679">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2"><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P700049702700000000000000004567A" id="P700049702700000000000000004567A">Process</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P700049702700000000000000004567B" id="P700049702700000000000000004567B">Start time</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P700049702700000000000000004567C" id="P700049702700000000000000004567C">End time</th></tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004567D" id="P700049702700000000000000004567D">A</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004567E" id="P700049702700000000000000004567E">5</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004567F" id="P700049702700000000000000004567F">7</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045680" id="P7000497027000000000000000045680">B</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045681" id="P7000497027000000000000000045681">2</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045682" id="P7000497027000000000000000045682">4</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045683" id="P7000497027000000000000000045683">C</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045684" id="P7000497027000000000000000045684">3</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045685" id="P7000497027000000000000000045685">6</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045686" id="P7000497027000000000000000045686">D</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045687" id="P7000497027000000000000000045687">1</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045688" id="P7000497027000000000000000045688">8</td></tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045689" id="P7000497027000000000000000045689">For each pair of processes, indicate whether they run concurrently (Y) or not (N):</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter08.xhtml#P700049702700000000000000004568A" id="P700049702700000000000000004568A">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2"><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P700049702700000000000000004568B" id="P700049702700000000000000004568B">Process pair	</th><th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter08.xhtml#P700049702700000000000000004568C" id="P700049702700000000000000004568C">Concurrent?</th></tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004568D" id="P700049702700000000000000004568D">AB	</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004568E" id="P700049702700000000000000004568E"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P700049702700000000000000004568F" id="P700049702700000000000000004568F">AC</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045690" id="P7000497027000000000000000045690"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045691" id="P7000497027000000000000000045691">AD</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045692" id="P7000497027000000000000000045692"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045693" id="P7000497027000000000000000045693">BC</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045694" id="P7000497027000000000000000045694"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045695" id="P7000497027000000000000000045695">BD</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045696" id="P7000497027000000000000000045696"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045697" id="P7000497027000000000000000045697">CD</td><td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045698" id="P7000497027000000000000000045698"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
</tbody>
</table>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006EA7" id="P7000497027000000000000000006EA7"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045699" epub:type="title" id="P7000497027000000000000000045699"><span class="pcalibre1 pcalibre21 pcalibre2">8.10 </span>♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P700049702700000000000000004569A" id="P700049702700000000000000004569A">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P700049702700000000000000004569B" id="P700049702700000000000000004569B"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P700049702700000000000000004569C" id="P700049702700000000000000004569C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004569D" id="P700049702700000000000000004569D">In this chapter, we have introduced some functions with unusual call and return behaviors: <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004569E" id="P700049702700000000000000004569E">setjmp, longjmp, execve</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004569F" id="P700049702700000000000000004569F">fork</code>. Match each function with one of the following behaviors:</p></div>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter08.xhtml#P70004970270000000000000000456A0" id="P70004970270000000000000000456A0">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456A1" id="P70004970270000000000000000456A1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456A2" id="P70004970270000000000000000456A2">Called once, returns twice</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456A3" id="P70004970270000000000000000456A3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456A4" id="P70004970270000000000000000456A4">Called once, never returns</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456A5" id="P70004970270000000000000000456A5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456A6" id="P70004970270000000000000000456A6">Called once, returns one or more times</p></li>
</ol>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006EB6" id="P7000497027000000000000000006EB6"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456A7" epub:type="title" id="P70004970270000000000000000456A7"><span class="pcalibre1 pcalibre21 pcalibre2">8.11 </span>♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P70004970270000000000000000456A8" id="P70004970270000000000000000456A8">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P70004970270000000000000000456A9" id="P70004970270000000000000000456A9"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000456AA" id="P70004970270000000000000000456AA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456AB" id="P70004970270000000000000000456AB">How many “hello” output lines does this program print?</p></div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456AC" id="P70004970270000000000000000456AC">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob1.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456AD" id="P70004970270000000000000000456AD">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456AE" id="P70004970270000000000000000456AE">
1	#include "csapp.h"
2	
3	int main()
4	{
5		int i;
6	
7		for (i = 0; i &lt; 2; i++)
8			Fork();
9		printf("hello\n");
10		exit(0);
11	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456AF" id="P70004970270000000000000000456AF">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob1.c</i></p>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006EC0" id="P7000497027000000000000000006EC0"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456B0" epub:type="title" id="P70004970270000000000000000456B0"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006EC2" epub:type="pagebreak" id="P7000497027000000000000000006EC2" title="789"></span><span class="pcalibre1 pcalibre21 pcalibre2">8.12 </span>♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P70004970270000000000000000456B1" id="P70004970270000000000000000456B1">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P70004970270000000000000000456B2" id="P70004970270000000000000000456B2"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000456B3" id="P70004970270000000000000000456B3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456B4" id="P70004970270000000000000000456B4">How many “hello” output lines does this program print?</p></div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456B5" id="P70004970270000000000000000456B5">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob4.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456B6" id="P70004970270000000000000000456B6">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456B7" id="P70004970270000000000000000456B7">
1	#include "csapp.h"
2	
3	void doit()
4	{
5		Fork();
6		Fork();
7		printf("hello\n");
8		return;
9	}
10	
11	int main()
12	{
13		doit();
14		printf("hello\n");
15		exit(0);
16	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456B8" id="P70004970270000000000000000456B8">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob4.c</i></p>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006ECB" id="P7000497027000000000000000006ECB"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456B9" epub:type="title" id="P70004970270000000000000000456B9"><span class="pcalibre1 pcalibre21 pcalibre2">8.13 </span>♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P70004970270000000000000000456BA" id="P70004970270000000000000000456BA">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P70004970270000000000000000456BB" id="P70004970270000000000000000456BB"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000456BC" id="P70004970270000000000000000456BC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456BD" id="P70004970270000000000000000456BD">What is one possible output of the following program?</p></div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456BE" id="P70004970270000000000000000456BE">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob3.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456BF" id="P70004970270000000000000000456BF">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456C0" id="P70004970270000000000000000456C0">
1	#include "csapp.h"
2	
3	int main()
4	
5		int x = 3;
6	
7		if (Fork() != 0)
8			printf ("x=%d\n", ++x);
9	
10		printf ("x=%d\n", --x);
11		exit(0);
12	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456C1" id="P70004970270000000000000000456C1">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob3.c</i></p>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006ED5" id="P7000497027000000000000000006ED5"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456C2" epub:type="title" id="P70004970270000000000000000456C2"><span class="pcalibre1 pcalibre21 pcalibre2">8.14 </span>♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P70004970270000000000000000456C3" id="P70004970270000000000000000456C3">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P70004970270000000000000000456C4" id="P70004970270000000000000000456C4"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000456C5" id="P70004970270000000000000000456C5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456C6" id="P70004970270000000000000000456C6">How many “hello” output lines does this program print?</p></div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456C7" id="P70004970270000000000000000456C7">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob5.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456C8" id="P70004970270000000000000000456C8">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456C9" id="P70004970270000000000000000456C9">
1	#include "csapp.h"
2	
3	void doit()
4	{
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006EDE" epub:type="pagebreak" id="P7000497027000000000000000006EDE" title="790"></span>5		if (Fork() == 0) {
6			Fork();
7			printf("hello\n");
8			exit(0);
9		}
10		return;
11	}
12	
13	int main()
14	{
15		doit();
16		printf("hello\n");
17		exit(0);
18	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456CA" id="P70004970270000000000000000456CA">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob5.c</i></p>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006EE0" id="P7000497027000000000000000006EE0"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456CB" epub:type="title" id="P70004970270000000000000000456CB"><span class="pcalibre1 pcalibre21 pcalibre2">8.15 </span>♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P70004970270000000000000000456CC" id="P70004970270000000000000000456CC">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P70004970270000000000000000456CD" id="P70004970270000000000000000456CD"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000456CE" id="P70004970270000000000000000456CE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456CF" id="P70004970270000000000000000456CF">How many “hello” lines does this program print?</p></div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456D0" id="P70004970270000000000000000456D0">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob6.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456D1" id="P70004970270000000000000000456D1">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456D2" id="P70004970270000000000000000456D2">
1	#include "csapp.h"
2	
3	void doit()
4	{
5		if (Fork() == 0) {
6			Fork();
7			printf("hello\n");
8			return;
9		}
10		return;
11	}
12	
13	int main()
14	{
15		doit();
16		printf("hello\n");
17		exit(0);
18	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456D3" id="P70004970270000000000000000456D3">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob6.c</i></p>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006EEA" id="P7000497027000000000000000006EEA"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456D4" epub:type="title" id="P70004970270000000000000000456D4"><span class="pcalibre1 pcalibre21 pcalibre2">8.16 </span>♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P70004970270000000000000000456D5" id="P70004970270000000000000000456D5">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P70004970270000000000000000456D6" id="P70004970270000000000000000456D6"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000456D7" id="P70004970270000000000000000456D7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456D8" id="P70004970270000000000000000456D8">What is the output of the following program?</p></div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456D9" id="P70004970270000000000000000456D9">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob7.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456DA" id="P70004970270000000000000000456DA">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456DB" id="P70004970270000000000000000456DB">
1	#include "csapp.h"
2	int counter = 1;
3	
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006EF3" epub:type="pagebreak" id="P7000497027000000000000000006EF3" title="791"></span>4	int main()
5	{
6		if (fork() == 0) {
7			counter--;
8			exit(0);
9		}
10		else {
11			Wait(NULL);
12			printf("counter = %d\n", ++counter);
13		}
14		exit(0);
15	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456DC" id="P70004970270000000000000000456DC">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob7.c</i></p>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006EF5" id="P7000497027000000000000000006EF5"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456DD" epub:type="title" id="P70004970270000000000000000456DD"><span class="pcalibre1 pcalibre21 pcalibre2">8.17 </span>♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P70004970270000000000000000456DE" id="P70004970270000000000000000456DE">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P70004970270000000000000000456DF" id="P70004970270000000000000000456DF"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000456E0" id="P70004970270000000000000000456E0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456E1" id="P70004970270000000000000000456E1">Enumerate all of the possible outputs of the program in Practice <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P7000497027000000000000000006971"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.4</span></a>.</p></div>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006EFB" id="P7000497027000000000000000006EFB"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456E2" epub:type="title" id="P70004970270000000000000000456E2"><span class="pcalibre1 pcalibre21 pcalibre2">8.18 </span>♦♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P70004970270000000000000000456E3" id="P70004970270000000000000000456E3">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P70004970270000000000000000456E4" id="P70004970270000000000000000456E4"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000456E5" id="P70004970270000000000000000456E5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456E6" id="P70004970270000000000000000456E6">Consider the following program:</p></div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456E7" id="P70004970270000000000000000456E7">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob2.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456E8" id="P70004970270000000000000000456E8"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456E9" id="P70004970270000000000000000456E9">
1	#include "csapp.h"
2	
3	void end(void)
4	{
5		printf("2"); fflush(stdout);
6	}
7	
8	int main()
9	{
10		if (Fork() == 0)
11			atexit(end);
12		if (Fork() == 0) {
13			printf("0"); fflush(stdout);
14		}
15		else {
16			printf("1"); fflush(stdout);
17		}
18		exit(0);
19	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456EA" id="P70004970270000000000000000456EA">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob2.c</i></p>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456EB" id="P70004970270000000000000000456EB">Determine which of the following outputs are possible. <span class="pcalibre1 pcalibre2 pcalibre41">Note: </span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456EC" id="P70004970270000000000000000456EC">atexit</code> function takes a pointer to a function and adds it to a list of functions (initially empty) that will be called when the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456ED" id="P70004970270000000000000000456ED">exit</code> function is called.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter08.xhtml#P70004970270000000000000000456EE" id="P70004970270000000000000000456EE">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456EF" id="P70004970270000000000000000456EF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456F0" id="P70004970270000000000000000456F0">112002</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456F1" id="P70004970270000000000000000456F1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456F2" id="P70004970270000000000000000456F2">211020</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456F3" id="P70004970270000000000000000456F3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456F4" id="P70004970270000000000000000456F4"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006F0F" epub:type="pagebreak" id="P7000497027000000000000000006F0F" title="792"></span>102120</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456F5" id="P70004970270000000000000000456F5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456F6" id="P70004970270000000000000000456F6">122001</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456F7" id="P70004970270000000000000000456F7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456F8" id="P70004970270000000000000000456F8">100212</p></li>
</ol>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006F14" id="P7000497027000000000000000006F14"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000456F9" epub:type="title" id="P70004970270000000000000000456F9"><span class="pcalibre1 pcalibre21 pcalibre2">8.19 </span>♦♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P70004970270000000000000000456FA" id="P70004970270000000000000000456FA">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P70004970270000000000000000456FB" id="P70004970270000000000000000456FB"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P70004970270000000000000000456FC" id="P70004970270000000000000000456FC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456FD" id="P70004970270000000000000000456FD">How many lines of output does the following function print? Give your answer as a function of <i class="pcalibre17 pcalibre2 pcalibre1">n.</i> Assume <var class="pcalibre17 pcalibre2 pcalibre1">n</var> ≥ 1.</p></div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P70004970270000000000000000456FE" id="P70004970270000000000000000456FE">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob8.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000456FF" id="P70004970270000000000000000456FF">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045700" id="P7000497027000000000000000045700">
1	void foo(int n)
2	{
3		int i;
4	
5		for (i = 0; i &lt; n; i++)
6			Fork();
7		printf("hello\n");
8		exit(0);
9	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045701" id="P7000497027000000000000000045701">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob8.c</i></p>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006F1E" id="P7000497027000000000000000006F1E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045702" epub:type="title" id="P7000497027000000000000000045702"><span class="pcalibre1 pcalibre21 pcalibre2">8.20 </span>♦♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P7000497027000000000000000045703" id="P7000497027000000000000000045703">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P7000497027000000000000000045704" id="P7000497027000000000000000045704"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045705" id="P7000497027000000000000000045705"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045706" id="P7000497027000000000000000045706">Use <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045707" id="P7000497027000000000000000045707">execve</code> to write a program called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045708" id="P7000497027000000000000000045708">myls</code> whose behavior is identical to the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045709" id="P7000497027000000000000000045709">/bin/ls</code> program. Your program should accept the same command-line arguments, interpret the identical environment variables, and produce the identical output.</p>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004570A" id="P700049702700000000000000004570A">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004570B" id="P700049702700000000000000004570B">ls</code> program gets the width of the screen from the COLUMNS environment variable. If COLUMNS is unset, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004570C" id="P700049702700000000000000004570C">ls</code> assumes that the screen is 80 columns wide. Thus, you can check your handling of the environment variables by setting the COLUMNS environment to something less than 80:</p></div>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004570D" id="P700049702700000000000000004570D">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004570E" id="P700049702700000000000000004570E">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">setenv COLUMNS 40</i>
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./myls</i>
⋮ <i class="pcalibre17 pcalibre2 pcalibre1">// Output is 40 columns wide</i>
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">unsetenv COLUMNS</i>
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./myls</i>
⋮ <i class="pcalibre17 pcalibre2 pcalibre1">// Output is now 80 columns wide</i>
</code>
</pre>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006F2C" id="P7000497027000000000000000006F2C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004570F" epub:type="title" id="P700049702700000000000000004570F"><span class="pcalibre1 pcalibre21 pcalibre2">8.21 </span>♦♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P7000497027000000000000000045710" id="P7000497027000000000000000045710">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P7000497027000000000000000045711" id="P7000497027000000000000000045711"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045712" id="P7000497027000000000000000045712"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045713" id="P7000497027000000000000000045713">What are the possible output sequences from the following program?</p></div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045714" id="P7000497027000000000000000045714">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitprob3.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045715" id="P7000497027000000000000000045715"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045716" id="P7000497027000000000000000045716">
1	int main()
2	{
3		if (fork() == 0) {
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006F35" epub:type="pagebreak" id="P7000497027000000000000000006F35" title="793"></span>4			printf("a"); fflush(stdout);
5			exit(0);
6		}
7		else {
8			printf("b"); fflush(stdout);
9			waitpidC-1, NULL, 0);
10		}
11		printf("c"); fflush(stdout);
12		exit(0);
13	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045717" id="P7000497027000000000000000045717">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitprob3.c</i></p>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006F37" id="P7000497027000000000000000006F37"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045718" epub:type="title" id="P7000497027000000000000000045718"><span class="pcalibre1 pcalibre21 pcalibre2">8.22 </span>♦♦♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P7000497027000000000000000045719" id="P7000497027000000000000000045719">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P700049702700000000000000004571A" id="P700049702700000000000000004571A"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P700049702700000000000000004571B" id="P700049702700000000000000004571B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004571C" id="P700049702700000000000000004571C">Write your own version of the Unix <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004571D" id="P700049702700000000000000004571D">system</code> function</p></div>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004571E" id="P700049702700000000000000004571E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004571F" id="P700049702700000000000000004571F">int mysystem(char *command);</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045720" id="P7000497027000000000000000045720">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045721" id="P7000497027000000000000000045721">mysystem</code> function executes <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045722" id="P7000497027000000000000000045722">command</code> by invoking <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045723" id="P7000497027000000000000000045723">/bin/sh -c command</code>, and then returns after <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045724" id="P7000497027000000000000000045724">command</code> has completed. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045725" id="P7000497027000000000000000045725">command</code> exits normally (by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045726" id="P7000497027000000000000000045726">exit</code> function or executing a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045727" id="P7000497027000000000000000045727">return</code> statement), then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045728" id="P7000497027000000000000000045728">mysystem</code> returns the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045729" id="P7000497027000000000000000045729">command</code> exit status. For example, if <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004572A" id="P700049702700000000000000004572A">command</code> terminates by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004572B" id="P700049702700000000000000004572B">exit (8)</code>, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004572C" id="P700049702700000000000000004572C">mysystem</code> returns the value 8. Otherwise, if <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004572D" id="P700049702700000000000000004572D">command</code> terminates abnormally, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004572E" id="P700049702700000000000000004572E">mysystem</code> returns the status returned by the shell.</p>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006F4F" id="P7000497027000000000000000006F4F"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004572F" epub:type="title" id="P700049702700000000000000004572F"><span class="pcalibre1 pcalibre21 pcalibre2">8.23 </span>♦♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P7000497027000000000000000045730" id="P7000497027000000000000000045730">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P7000497027000000000000000045731" id="P7000497027000000000000000045731"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045732" id="P7000497027000000000000000045732"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045733" id="P7000497027000000000000000045733">One of your colleagues is thinking of using signals to allow a parent process to count events that occur in a child process. The idea is to notify the parent each time an event occurs by sending it a signal and letting the parent's signal handler increment a global <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045734" id="P7000497027000000000000000045734">counter</code> variable, which the parent can then inspect after the child has terminated. However, when he runs the test program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006F68"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.45 </span></a>on his system, he discovers that when the parent calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045735" id="P7000497027000000000000000045735">printf, counter</code> always has a value of 2, even though the child has sent five signals to the parent. Perplexed, he comes to you for help. Can you explain the bug?</p></div>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006F57" id="P7000497027000000000000000006F57"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045736" epub:type="title" id="P7000497027000000000000000045736"><span class="pcalibre1 pcalibre21 pcalibre2">8.24 </span>♦♦♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P7000497027000000000000000045737" id="P7000497027000000000000000045737">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P7000497027000000000000000045738" id="P7000497027000000000000000045738"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045739" id="P7000497027000000000000000045739"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004573A" id="P700049702700000000000000004573A">Modify the program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P7000497027000000000000000006957"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.18 </span></a>so that the following two conditions are met:</p>
<ol class="pcalibre1 calibre19 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004573B" id="P700049702700000000000000004573B">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004573C" id="P700049702700000000000000004573C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004573D" id="P700049702700000000000000004573D">Each child terminates abnormally after attempting to write to a location in the read-only text segment.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004573E" id="P700049702700000000000000004573E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004573F" id="P700049702700000000000000004573F">The parent prints output that is identical (except for the PIDs) to the following:</p></li>
</ol>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045740" id="P7000497027000000000000000045740">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045741" id="P7000497027000000000000000045741">
child 12255 terminated by signal 11: Segmentation fault
child 12254 terminated by signal 11: Segmentation fault
</code>
</pre>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045742" id="P7000497027000000000000000045742">
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045743" id="P7000497027000000000000000045743"><span class="pcalibre1 pcalibre2 pcalibre41">Hint: </span>Read the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045744" id="P7000497027000000000000000045744">man</code> page for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045745" id="P7000497027000000000000000045745">psignal</code> (3).</p>
</div>
</div>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006F68" id="P7000497027000000000000000006F68">
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045746" id="P7000497027000000000000000045746"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006F6A" epub:type="pagebreak" id="P7000497027000000000000000006F6A" title="794"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/counterprob.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045747" id="P7000497027000000000000000045747">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045748" id="P7000497027000000000000000045748">
1	#include "csapp.h"
2	
3	int counter = 0;
4	
5	void handler(int sig)
6	{
7		counter++;
8		sleep(1); /* Do some work in the handler */
9		return;
10	}
11	
12	int main()
13	{
14		int i;
15	
16		Signal(SIGUSR2, handler);
17	
18		if (Fork() == 0) { /* Child */
19			for (i = 0; i &lt; 5; i++) {
20				KilKgetppid(), SIGUSR2);
21				printf("sent SIGUSR2 to parent\n");
22			}
23			exit(0);
24		}
25	
26		Wait (NULL);
27		printf("counter=%d\n", counter);
28		exit(0);
29	}
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045749" id="P7000497027000000000000000045749">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/counterprob.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004574A" id="P700049702700000000000000004574A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004574B" epub:type="title" id="P700049702700000000000000004574B"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006F68"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.45 </span></a>Counter program referenced in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006F4F"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">8.23</span></a>.</h1></header>
</figcaption>
</figure>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006F70" id="P7000497027000000000000000006F70"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004574C" epub:type="title" id="P700049702700000000000000004574C"><span class="pcalibre1 pcalibre21 pcalibre2">8.25 </span>♦♦♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P700049702700000000000000004574D" id="P700049702700000000000000004574D">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P700049702700000000000000004574E" id="P700049702700000000000000004574E"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P700049702700000000000000004574F" id="P700049702700000000000000004574F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045750" id="P7000497027000000000000000045750">Write a version of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045751" id="P7000497027000000000000000045751">fgets</code> function, called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045752" id="P7000497027000000000000000045752">tfgets</code>, that times out after 5 seconds. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045753" id="P7000497027000000000000000045753">tfgets</code> function accepts the same inputs as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045754" id="P7000497027000000000000000045754">fgets</code>. If the user doesn't type an input line within 5 seconds, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045755" id="P7000497027000000000000000045755">tfgets</code> returns NULL. Otherwise, it returns a pointer to the input line.</p></div>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006F7B" id="P7000497027000000000000000006F7B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045756" epub:type="title" id="P7000497027000000000000000045756"><span class="pcalibre1 pcalibre21 pcalibre2">8.26 </span>♦♦♦♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter08.xhtml#P7000497027000000000000000045757" id="P7000497027000000000000000045757">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter08.xhtml#P7000497027000000000000000045758" id="P7000497027000000000000000045758"><div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000045759" id="P7000497027000000000000000045759"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004575A" id="P700049702700000000000000004575A">Using the example in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P7000497027000000000000000006A09"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.23 </span></a>as a starting point, write a shell program that supports job control. Your shell should have the following features:</p></div>
<ul class="pcalibre1 pcalibre2 pcalibre117" data-uri="chapter08.xhtml#P700049702700000000000000004575B" id="P700049702700000000000000004575B">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004575C" id="P700049702700000000000000004575C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004575D" id="P700049702700000000000000004575D">The command line typed by the user consists of a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004575E" id="P700049702700000000000000004575E">name</code> and zero or more arguments, all separated by one or more spaces. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004575F" id="P700049702700000000000000004575F">name</code> is a built-in command, the <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006F86" epub:type="pagebreak" id="P7000497027000000000000000006F86" title="795"></span>shell handles it immediately and waits for the next command line. Otherwise, the shell assumes that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045760" id="P7000497027000000000000000045760">name</code> is an executable file, which it loads and runs in the context of an initial child process (job). The process group ID for the job is identical to the PID of the child.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045761" id="P7000497027000000000000000045761"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045762" id="P7000497027000000000000000045762">Each job is identified by either a process ID (PID) or a job ID (JID), which is a small arbitrary positive integer assigned by the shell. JIDs are denoted on the command line by the prefix ‘%’. For example, ‘%5’ denotes JID 5, and ‘5’ denotes PID 5.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045763" id="P7000497027000000000000000045763"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045764" id="P7000497027000000000000000045764">If the command line ends with an ampersand, then the shell runs the job in the background. Otherwise, the shell runs the job in the foreground.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045765" id="P7000497027000000000000000045765"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045766" id="P7000497027000000000000000045766">Typing Ctrl+C (Ctrl+Z) causes the kernel to send a SIGINT (SIGTSTP) signal to your shell, which then forwards it to every process in the foreground process group.<a class="pcalibre1 pcalibre2 pcalibre56 pcalibre16 pcalibre14 pcalibre15" epub:type="noteref" href="#P7000497027000000000000000006FEF" id="r__P7000497027000000000000000006FEF">2</a></p><aside class="pcalibre2 pcalibre32 pcalibre57" data-uri="chapter08.xhtml#P7000497027000000000000000006FEF" epub:type="footnote" id="P7000497027000000000000000006FEF"><p class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre58 pcalibre2"><a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="#r__P7000497027000000000000000006FEF">2. </a></span>Note that this is a simplification of the way that real shells work. With real shells, the kernel responds to Ctrl+C (Ctrl+Z) by sending SIGINT (SIGTSTP) directly to each process in the terminal foreground process group. The shell manages the membership of this group using the <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457B9" id="P70004970270000000000000000457B9">tcsetpgrp</code> function, and manages the attributes of the terminal using the <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457BA" id="P70004970270000000000000000457BA">tcsetattr</code> function, both of which are outside the scope of this book. See [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41E">62</a>] for details.</p></aside></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045767" id="P7000497027000000000000000045767"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045768" id="P7000497027000000000000000045768">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045769" id="P7000497027000000000000000045769">jobs</code> built-in command lists all background jobs.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004576A" id="P700049702700000000000000004576A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004576B" id="P700049702700000000000000004576B">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004576C" id="P700049702700000000000000004576C">bg</code> <i class="pcalibre17 pcalibre2 pcalibre1">job</i> built-in command restarts <i class="pcalibre17 pcalibre2 pcalibre1">job</i> by sending it a SIGCONT signal and then runs it in the background. The <i class="pcalibre17 pcalibre2 pcalibre1">job</i> argument can be either a PID or a JID.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004576D" id="P700049702700000000000000004576D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004576E" id="P700049702700000000000000004576E">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004576F" id="P700049702700000000000000004576F">fg</code> <i class="pcalibre17 pcalibre2 pcalibre1">job</i> built-in command restarts <i class="pcalibre17 pcalibre2 pcalibre1">job</i> by sending it a SIGCONT signal and then runs it in the foreground.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045770" id="P7000497027000000000000000045770"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045771" id="P7000497027000000000000000045771">The shell reaps all of its zombie children. If any job terminates because it receives a signal that was not caught, then the shell prints a message to the terminal with the job's PID and a description of the offending signal.</p></li>
</ul>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045772" id="P7000497027000000000000000045772"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FA2"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.46 </span></a>shows an example shell session.</p>
</li>
</ol>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Solutions to Practice Problems </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000006F9A"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045773" epub:type="title" id="P7000497027000000000000000045773"><span class="pcalibre1 pcalibre21 pcalibre2">Solutions to Practice Problems </span></h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006F9C" id="P7000497027000000000000000006F9C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045774" epub:type="title" id="P7000497027000000000000000045774"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000067D4.xhtml#P70004970270000000000000000067F6"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.1 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000067D4.xhtml#P70004970270000000000000000067F5">734</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045775" id="P7000497027000000000000000045775">Processes A and B are concurrent with respect to each other, as are B and C, because their respective executions overlap—that is, one process starts before the other finishes. Processes A and C are not concurrent because their executions do not overlap; A finishes before C begins.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006F9F" id="P7000497027000000000000000006F9F"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045776" epub:type="title" id="P7000497027000000000000000045776"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P70004970270000000000000000068C8"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.2 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000685D.xhtml#P70004970270000000000000000068CA">743</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045777" id="P7000497027000000000000000045777">In our example program in <span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.15</span>, the parent and child execute disjoint sets of instructions. However, in this program, the parent and child execute nondisjoint sets of instructions, which is possible because the parent and child have identical code segments. This can be a difficult conceptual hurdle, so be sure you understand the solution to this problem. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006FA8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.47</span></a> shows the process graph.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006FA2" id="P7000497027000000000000000006FA2">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045778" id="P7000497027000000000000000045778">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045779" id="P7000497027000000000000000045779">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006FA5" epub:type="pagebreak" id="P7000497027000000000000000006FA5" title="796"></span>linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./shell</i>					<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Run your shell program</i></b>
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;bogus</i>
bogus: Command not found.			<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Execve can't find executable</i></b>
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;foo 10</i>
Job 5035 terminated by signal: Interrupt	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">User types Ctrl+C</i></b>
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;foo 100 &amp;</i>
[1] 5036 foo 100 &amp;
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;foo 200 &amp;</i>
[2] 5037 foo 200 &amp;
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;jobs</i>
[1] 5036 Running foo 100 &amp;
[2] 5037 Running foo 200 &amp;
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;fg %1</i>
Job [1] 5036 stopped by signal: Stopped		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">User types Ctrl+Z</i></b>
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;jobs</i>
[1] 5036 Stopped foo 100 &amp;
[2] 5037 Running foo 200 &amp;
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;bg 5035</i>
5035: No such process
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;bg 5036</i>
[1] 5036 foo 100 &amp;
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;/bin/kill 5036</i>
Job 5036 terminated by signal: Terminated
&gt; <i class="pcalibre17 pcalibre2 pcalibre1">fg %2</i>						<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Wait for fg job to finish</i></b>
<i class="pcalibre17 pcalibre2 pcalibre1">&gt;quit</i>
linux&gt;						<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Back to the Unix shell</i></b>
</code>
</pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004577A" id="P700049702700000000000000004577A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004577B" epub:type="title" id="P700049702700000000000000004577B"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.46 </span>Sample shell session for <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006E81.xhtml#P7000497027000000000000000006F7B"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">8.26</span></a>.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006FA8" id="P7000497027000000000000000006FA8">
<img alt="A diagram illustrates a process graph." class="pcalibre1 pcalibre2 pcalibre250" data-uri="P700049702700000000000000000B775" id="P700049702700000000000000004577C" src="Images/chapter-07-image-19.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P700049702700000000000000004577D" id="P700049702700000000000000004577D"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P700049702700000000000000004577E" epub:type="title" id="P700049702700000000000000004577E"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.47 </span>Process graph for Practice <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P70004970270000000000000000068C8"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">8.2</span></a>.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P7000497027000000000000000025AAA" id="P7000497027000000000000000025AAA">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004577F" id="P700049702700000000000000004577F">A process graph has an arrow x==1 from main to fork, which splits to Child and Parent. Child has arrows to printf p1: x=2 to printf p1: x=1 to exit. Parent has arrows to printf p2: x=0 to exit.</p>
</details>
</figcaption>
</figure>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter08.xhtml#P7000497027000000000000000045780" id="P7000497027000000000000000045780">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045781" id="P7000497027000000000000000045781"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045782" id="P7000497027000000000000000045782">The key idea here is that the child executes both <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045783" id="P7000497027000000000000000045783">printf</code> statements. After the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045784" id="P7000497027000000000000000045784">fork</code> returns, it executes the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045785" id="P7000497027000000000000000045785">printf</code> in line 6. Then it falls out of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045786" id="P7000497027000000000000000045786">if</code> statement and executes the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045787" id="P7000497027000000000000000045787">printf</code> in line 7. Here is the output produced by the child:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000045788" id="P7000497027000000000000000045788">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045789" id="P7000497027000000000000000045789">
p1: x=2
p2: x=1
</code>
</pre>
</li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004578A" id="P700049702700000000000000004578A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004578B" id="P700049702700000000000000004578B">The parent executes only the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004578C" id="P700049702700000000000000004578C">printf</code> in line 7:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004578D" id="P700049702700000000000000004578D">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004578E" id="P700049702700000000000000004578E">p2: x=0</code>
</pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006FBB" id="P7000497027000000000000000006FBB">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006FBC" epub:type="pagebreak" id="P7000497027000000000000000006FBC" title="797"></span><img alt="A diagram illustrates a process graph." class="calibre66 pcalibre1 pcalibre2" data-uri="P700049702700000000000000000B776" id="P700049702700000000000000004578F" src="Images/chapter-07-image-20.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045790" id="P7000497027000000000000000045790"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045791" epub:type="title" id="P7000497027000000000000000045791"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.48 </span>Process graph for Practice <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P700049702700000000000000000692F"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">8.3</span></a>.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P7000497027000000000000000025ABE" id="P7000497027000000000000000025ABE">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045792" id="P7000497027000000000000000045792">A process graph has an arrow from main to fork that splits to printf a and printf b. Arrows from printf a flow to printf c and exit. Arrows from this exit and from printf b flow to waitpid, then printf c and exit.</p>
</details>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter08.xhtml#P7000497027000000000000000006FC0" id="P7000497027000000000000000006FC0">
<img alt="A diagram illustrates a process graph." class="pcalibre1 pcalibre2 pcalibre257" data-uri="P700049702700000000000000000B777" id="P7000497027000000000000000045793" src="Images/chapter-07-image-21.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter08.xhtml#P7000497027000000000000000045794" id="P7000497027000000000000000045794"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter08.xhtml#P7000497027000000000000000045795" epub:type="title" id="P7000497027000000000000000045795"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.49 </span>Process graph for Practice <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P7000497027000000000000000006971"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">8.4</span></a>.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter08.xhtml#P7000497027000000000000000025AC3" id="P7000497027000000000000000025AC3">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000045796" id="P7000497027000000000000000045796">A process graph has an arrow from main to printf Hello to fork, that splits to printf 1 and printf 0. Arrows from printf 1 flow to printf Byte and exit(2). Arrows from this exit and from printf 0 flow to waitpid, then printf 2, printf Bye, and exit.</p>
</details>
</figcaption>
</figure>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006FC4" id="P7000497027000000000000000006FC4"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045797" epub:type="title" id="P7000497027000000000000000045797"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P700049702700000000000000000692F"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.3 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000685D.xhtml#P7000497027000000000000000006908">745</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045798" id="P7000497027000000000000000045798">We know that the sequences <i class="pcalibre17 pcalibre2 pcalibre1">acbc, abcc</i>, and <i class="pcalibre17 pcalibre2 pcalibre1">bacc</i> are possible because they correspond to topological sorts of the process graph (<span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.48</span>). However, sequences such as <i class="pcalibre17 pcalibre2 pcalibre1">bcac</i> and <i class="pcalibre17 pcalibre2 pcalibre1">cbca</i> do not correspond to any topological sort and thus are not feasible.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006FC7" id="P7000497027000000000000000006FC7"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000045799" epub:type="title" id="P7000497027000000000000000045799"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P7000497027000000000000000006971"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.4 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000685D.xhtml#P700049702700000000000000000696D">748</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter08.xhtml#P700049702700000000000000004579A" id="P700049702700000000000000004579A">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004579B" id="P700049702700000000000000004579B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004579C" id="P700049702700000000000000004579C">We can determine the number of lines of output by simply counting the number of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P700049702700000000000000004579D" id="P700049702700000000000000004579D">printf</code> vertices in the process graph (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006FC0"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.49</span></a>). In this case, there are six such vertices, and thus the program will print six lines of output.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P700049702700000000000000004579E" id="P700049702700000000000000004579E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P700049702700000000000000004579F" id="P700049702700000000000000004579F">Any output sequence corresponding to a topological sort of the graph is possible. For example: <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457A0" id="P70004970270000000000000000457A0">Hello, 1,0, Bye, 2, Bye</code> is possible.</p>
</li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006FD0" id="P7000497027000000000000000006FD0"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457A1" epub:type="title" id="P70004970270000000000000000457A1"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P7000497027000000000000000006993"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000685D.xhtml#P700049702700000000000000000698E">750</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457A2" id="P70004970270000000000000000457A2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/snooze.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000457A3" id="P70004970270000000000000000457A3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457A4" id="P70004970270000000000000000457A4">
1	unsigned int snooze(unsigned int sees) {
2	unsigned int rc = sleep(secs);
3	
4	printf("Slept for %d of %d secs.\n", secs-rc, secs);
5	return re;
6	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457A5" id="P70004970270000000000000000457A5">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/snooze.c</i></p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006FD6" id="P7000497027000000000000000006FD6"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457A6" epub:type="title" id="P70004970270000000000000000457A6"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000685D.xhtml#P70004970270000000000000000069E5"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.6 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000685D.xhtml#P70004970270000000000000000069D3">752</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457A7" id="P70004970270000000000000000457A7">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/myecho.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000457A8" id="P70004970270000000000000000457A8">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457A9" id="P70004970270000000000000000457A9">
1	#include "csapp.h"
2	
3	int main (int argc, char *argv[], char *envp [])
4	{
5		int i;
6	
7		printf("Command-line arguments:\n");
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006FDB" epub:type="pagebreak" id="P7000497027000000000000000006FDB" title="798"></span>8		for (i=0; argv[i] != NULL; i++)
9			printf(" argv[%2d]: %s\n", i, argv[i]);
10	
11		printf("\n");
12		printf("Environment variables:\n");
13		for (i=0; envp[i] != NULL; i++)
14			printf (" envp[%2d]: %s\n", i, envp[i]);
15	
16		exit(0);
17	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457AA" id="P70004970270000000000000000457AA">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/myecho.c</i></p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006FDD" id="P7000497027000000000000000006FDD"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457AB" epub:type="title" id="P70004970270000000000000000457AB"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006A2D.xhtml#P7000497027000000000000000006B63"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.7 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006A2D.xhtml#P7000497027000000000000000006B5D">764</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457AC" id="P70004970270000000000000000457AC">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457AD" id="P70004970270000000000000000457AD">sleep</code> function returns prematurely whenever the sleeping process receives a signal that is not ignored. But since the default action upon receipt of a SIGINT is to terminate the process (<span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.26</span>), we must install a SIGINT handler to allow the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457AE" id="P70004970270000000000000000457AE">sleep</code> function to return. The handler simply catches the SIGNAL and returns control to the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457AF" id="P70004970270000000000000000457AF">sleep</code> function, which returns immediately.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457B0" id="P70004970270000000000000000457B0">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/snooze.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P70004970270000000000000000457B1" id="P70004970270000000000000000457B1">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457B2" id="P70004970270000000000000000457B2">
1	#include "csapp.h"
2	
3	/* SIGINT handler */
4	void handler(int sig)
5	{
6		return; /* Catch the signal and return */
7	}
8	
9	unsigned int snooze(unsigned int secs) {
10		unsigned int rc = sleep(secs);
11	
12		printf ("Slept for %d of %d secs.\n", secs-rc, sees);
13		return rc;
14	}
15	
16	int main(int argc, char **argv) {
17	
18		if (argc != 2) {
19			fprintf (stderr, "usage: %s &lt;secs&gt;\n", argv[0]);
20			exit(0);
21		}
22	
23		if (signal(SIGINT, handler) == SIG_ERR) /* Install SIGINT */
24			unix_error("signal error\n"); /* handler */
25		(void) snooze (atoi (argv [1]));
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006FE6" epub:type="pagebreak" id="P7000497027000000000000000006FE6" title="799"></span>26		exit(0);
27	}
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457B3" id="P70004970270000000000000000457B3">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/snooze.c</i></p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000006FE8" id="P7000497027000000000000000006FE8"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457B4" epub:type="title" id="P70004970270000000000000000457B4"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006A2D.xhtml#P7000497027000000000000000006D43"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.8 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006A2D.xhtml#P7000497027000000000000000006D38">773</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457B5" id="P70004970270000000000000000457B5">This program prints the string 213, which is the shorthand name of the CS:APP course at Carnegie Mellon. The parent starts by printing ‘2’, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter08.xhtml#P70004970270000000000000000457B6" id="P70004970270000000000000000457B6">fork</code>s the child, which spins in an infinite loop. The parent then sends a signal to the child and waits for it to terminate. The child catches the signal (interrupting the infinite loop), decrements the counter (from an initial value of 2), prints ‘1’, and then terminates. After the parent reaps the child, it increments the counter (from an initial value of 2), prints ‘3’, and terminates.<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006FEC" epub:type="pagebreak" id="P7000497027000000000000000006FEC" title="800"></span></p>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Chapter 12 Concurrent Programming</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" epub:type="chapter" id="P7000497027000000000000000008060"><header class="pcalibre1 pcalibre2 pcalibre48"><h1 class="pcalibre1 pcalibre2 pcalibre49" data-uri="chapter12.xhtml#P7000497027000000000000000046B6B" epub:type="title" id="P7000497027000000000000000046B6B"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008062" epub:type="pagebreak" id="P7000497027000000000000000008062" title="971"></span><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre50 pcalibre2">12 </span>Concurrent Programming</h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" id="d9e172027">
<nav class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000046B6C" epub:type="toc" id="P7000497027000000000000000046B6C">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046B6D" id="P7000497027000000000000000046B6D">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B6E" id="P7000497027000000000000000046B6E">
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B6F" id="P7000497027000000000000000046B6F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B70" id="P7000497027000000000000000046B70"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008097.xhtml#P7000497027000000000000000008097"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.1 </span>Concurrent Programming with Processes </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">973</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B71" id="P7000497027000000000000000046B71"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B72" id="P7000497027000000000000000046B72"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP70004970270000000000000000080DE.xhtml#P70004970270000000000000000080DE"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.2 </span>Concurrent Programming with I/O Multiplexing </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">977</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B73" id="P7000497027000000000000000046B73"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B74" id="P7000497027000000000000000046B74"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000817D.xhtml#P700049702700000000000000000817D"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3 </span>Concurrent Programming with Threads </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">985</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B75" id="P7000497027000000000000000046B75"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B76" id="P7000497027000000000000000046B76"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000821D.xhtml#P700049702700000000000000000821D"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.4 </span>Shared Variables in Threaded Programs </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">992</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B77" id="P7000497027000000000000000046B77"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B78" id="P7000497027000000000000000046B78"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000827E.xhtml#P700049702700000000000000000827E"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.5 </span>Synchronizing Threads with Semaphores </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">995</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B79" id="P7000497027000000000000000046B79"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B7A" id="P7000497027000000000000000046B7A"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000849B.xhtml#P700049702700000000000000000849B"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.6 </span>Using Threads for Parallelism </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1013</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B7B" id="P7000497027000000000000000046B7B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B7C" id="P7000497027000000000000000046B7C"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008577.xhtml#P7000497027000000000000000008577"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.7 </span>Other Concurrency Issues </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1020</span></a></p></li>
</ol></div>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046B7D" id="P7000497027000000000000000046B7D">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B7E" id="P7000497027000000000000000046B7E">
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B7F" id="P7000497027000000000000000046B7F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B80" id="P7000497027000000000000000046B80"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008670.xhtml#P7000497027000000000000000008670"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.8 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary</span> </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1030</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B81" id="P7000497027000000000000000046B81"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B82" id="P7000497027000000000000000046B82"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008676.xhtml#P7000497027000000000000000008676"><span class="pcalibre1 pcalibre2" epub:type="title">Bibliographic Notes </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1030</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B83" id="P7000497027000000000000000046B83"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B84" id="P7000497027000000000000000046B84"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000867A"><span class="pcalibre1 pcalibre2" epub:type="title">Homework Problems </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1031</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B85" id="P7000497027000000000000000046B85"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B86" id="P7000497027000000000000000046B86"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000875E.xhtml#P700049702700000000000000000875E"><span class="pcalibre1 pcalibre2" epub:type="title">Solutions to Practice Problems </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1036</span></a></p></li>
</ol></div>
</nav>
<section class="pcalibre1 pcalibre2 pcalibre51" data-uri="chapter12.xhtml#P7000497027000000000000000046B87" epub:type="introduction" id="P7000497027000000000000000046B87">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B88" id="P7000497027000000000000000046B88"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008080" epub:type="pagebreak" id="P7000497027000000000000000008080" title="972"></span>As we learned in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">8</span></a>, logical control flows are <i class="pcalibre17 pcalibre2 pcalibre1">concurrent</i> if they overlap in time. This general phenomenon, known as <i class="pcalibre17 pcalibre2 pcalibre1">concurrency</i>, shows up at many different levels of a computer system. Hardware exception handlers, processes, and Linux signal handlers are all familiar examples.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B89" id="P7000497027000000000000000046B89">Thus far, we have treated concurrency mainly as a mechanism that the operating system kernel uses to run multiple application programs. But concurrency is not just limited to the kernel. It can play an important role in application programs as well. For example, we have seen how Linux signal handlers allow applications to respond to asynchronous events such as the user typing Ctrl+C or the program accessing an undefined area of virtual memory. Application-level concurrency is useful in other ways as well:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B8A" id="P7000497027000000000000000046B8A">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B8B" id="P7000497027000000000000000046B8B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B8C" id="P7000497027000000000000000046B8C"><span class="pcalibre1 pcalibre2 pcalibre41">Accessing slow I/O devices. </span>When an application is waiting for data to arrive from a slow I/O device such as a disk, the kernel keeps the CPU busy by running other processes. Individual applications can exploit concurrency in a similar way by overlapping useful work with I/O requests.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B8D" id="P7000497027000000000000000046B8D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B8E" id="P7000497027000000000000000046B8E"><span class="pcalibre1 pcalibre2 pcalibre41">Interacting with humans. </span>People who interact with computers demand the ability to perform multiple tasks at the same time. For example, they might want to resize a window while they are printing a document. Modern windowing systems use concurrency to provide this capability. Each time the user requests some action (say, by clicking the mouse), a separate concurrent logical flow is created to perform the action.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B8F" id="P7000497027000000000000000046B8F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B90" id="P7000497027000000000000000046B90"><span class="pcalibre1 pcalibre2 pcalibre41">Reducing latency by deferring work. </span>Sometimes, applications can use concurrency to reduce the latency of certain operations by deferring other operations and performing them concurrently. For example, a dynamic storage allocator might reduce the latency of individual free operations by deferring coalescing to a concurrent "coalescing" flow that runs at a lower priority, soaking up spare CPU cycles as they become available.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B91" id="P7000497027000000000000000046B91"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B92" id="P7000497027000000000000000046B92"><span class="pcalibre1 pcalibre2 pcalibre41">Servicing multiple network clients. </span>The iterative network servers that we studied in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007B7A.xhtml#P7000497027000000000000000007B7A"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">11</span></a> are unrealistic because they can only service one client at a time. Thus, a single slow client can deny service to every other client. For a real server that might be expected to service hundreds or thousands of clients per second, it is not acceptable to allow one slow client to deny service to the others. A better approach is to build a <i class="pcalibre17 pcalibre2 pcalibre1">concurrent server</i> that creates a separate logical flow for each client. This allows the server to service multiple clients concurrently and precludes slow clients from monopolizing the server.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B93" id="P7000497027000000000000000046B93"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B94" id="P7000497027000000000000000046B94"><span class="pcalibre1 pcalibre2 pcalibre41">Computing in parallel on multi-core machines. </span>Many modern systems are equipped with multi-core processors that contain multiple CPUs. Applications that are partitioned into concurrent flows often run faster on multi-core machines than on uniprocessor machines because the flows execute in parallel rather than being interleaved.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B95" id="P7000497027000000000000000046B95">Applications that use application-level concurrency are known as <i class="pcalibre17 pcalibre2 pcalibre1">concurrent programs</i>. Modern operating systems provide three basic approaches for building concurrent programs:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B96" id="P7000497027000000000000000046B96">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B97" id="P7000497027000000000000000046B97"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B98" id="P7000497027000000000000000046B98"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008091" epub:type="pagebreak" id="P7000497027000000000000000008091" title="973"></span><span class="pcalibre1 pcalibre2 pcalibre41">Processes. </span>With this approach, each logical control flow is a process that is scheduled and maintained by the kernel. Since processes have separate virtual address spaces, flows that want to communicate with each other must use some kind of explicit <i class="pcalibre17 pcalibre2 pcalibre1">interprocess communication (IPC)</i> mechanism.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B99" id="P7000497027000000000000000046B99"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B9A" id="P7000497027000000000000000046B9A"><span class="pcalibre1 pcalibre2 pcalibre41">I/O multiplexing. </span>his is a form of concurrent programming where applications explicitly schedule their own logical flows in the context of a single process. Logical flows are modeled as state machines that the main program explicitly transitions from state to state as a result of data arriving on file descriptors. Since the program is a single process, all flows share the same address space.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B9B" id="P7000497027000000000000000046B9B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B9C" id="P7000497027000000000000000046B9C"><span class="pcalibre1 pcalibre2 pcalibre41">Threads. </span>Threads are logical flows that run in the context of a single process and are scheduled by the kernel. You can think of threads as a hybrid of the other two approaches, scheduled by the kernel like process flows and sharing the same virtual address space like I/O multiplexing flows.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B9D" id="P7000497027000000000000000046B9D">This chapter investigates these three different concurrent programming techniques. To keep our discussion concrete, we will work with the same motivating application throughout—a concurrent version of the iterative echo server from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E4C"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.9</span></a>.</p>
</section>
</section>
<!--EOF:P7000497027000000000000000008097-->
<!--EOF:P70004970270000000000000000080DE-->
<!--EOF:P700049702700000000000000000817D-->
<!--EOF:P700049702700000000000000000821D-->
<!--EOF:P700049702700000000000000000827E-->
<!--EOF:P700049702700000000000000000849B-->
<!--EOF:P7000497027000000000000000008577-->
<!--EOF:P7000497027000000000000000008670-->
<!--EOF:P7000497027000000000000000008676-->
<!--EOF:P700049702700000000000000000867A-->
<!--EOF:P700049702700000000000000000875E-->
</section></body></html>
