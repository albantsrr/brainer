<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Chapter 5 Optimizing Program Performance</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" epub:type="chapter" id="P7000497027000000000000000004893"><header class="pcalibre1 pcalibre2 pcalibre48"><h1 class="pcalibre1 pcalibre2 pcalibre49" data-uri="chapter05.xhtml#P7000497027000000000000000042FE6" epub:type="title" id="P7000497027000000000000000042FE6"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004895" epub:type="pagebreak" id="P7000497027000000000000000004895" title="495"></span><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre50 pcalibre2">5 </span>Optimizing Program Performance</h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" id="d9e105665">
<nav class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000042FE7" epub:type="toc" id="P7000497027000000000000000042FE7">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000042FE8" id="P7000497027000000000000000042FE8">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000042FE9" id="P7000497027000000000000000042FE9">
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FEA" id="P7000497027000000000000000042FEA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FEB" id="P7000497027000000000000000042FEB"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP70004970270000000000000000048D0.xhtml#P70004970270000000000000000048D0"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.1 </span>Capabilities and Limitations of Optimizing Compilers </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">498</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FEC" id="P7000497027000000000000000042FEC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FED" id="P7000497027000000000000000042FED"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000493B.xhtml#P700049702700000000000000000493B"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.2 </span>Expressing Program Performance </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">502</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FEE" id="P7000497027000000000000000042FEE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FEF" id="P7000497027000000000000000042FEF"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000496E.xhtml#P700049702700000000000000000496E"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.3 </span>Program Example </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">504</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FF0" id="P7000497027000000000000000042FF0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FF1" id="P7000497027000000000000000042FF1"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP70004970270000000000000000049CE.xhtml#P70004970270000000000000000049CE"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.4 </span>Eliminating Loop Inefficiencies </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">508</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FF2" id="P7000497027000000000000000042FF2"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FF3" id="P7000497027000000000000000042FF3"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000004A83.xhtml#P7000497027000000000000000004A83"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.5 </span>Reducing Procedure Calls </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">512</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FF4" id="P7000497027000000000000000042FF4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FF5" id="P7000497027000000000000000042FF5"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000004AB6.xhtml#P7000497027000000000000000004AB6"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.6 </span>Eliminating Unneeded Memory References </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">514</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FF6" id="P7000497027000000000000000042FF6"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FF7" id="P7000497027000000000000000042FF7"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004B6C"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.7 </span>Understanding Modern Processors </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">517</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FF8" id="P7000497027000000000000000042FF8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FF9" id="P7000497027000000000000000042FF9"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000004C94.xhtml#P7000497027000000000000000004C94"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.8 </span>Loop Unrolling </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">531</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FFA" id="P7000497027000000000000000042FFA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FFB" id="P7000497027000000000000000042FFB"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000004D16.xhtml#P7000497027000000000000000004D16"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.9 </span>Enhancing Parallelism </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">536</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FFC" id="P7000497027000000000000000042FFC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FFD" id="P7000497027000000000000000042FFD"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000004E68.xhtml#P7000497027000000000000000004E68"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.10 </span>Summary of Results for Optimizing Combining Code </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">547</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000042FFE" id="P7000497027000000000000000042FFE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000042FFF" id="P7000497027000000000000000042FFF"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000004E9A.xhtml#P7000497027000000000000000004E9A"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.11 </span>Some Limiting Factors </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">548</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000043000" id="P7000497027000000000000000043000"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043001" id="P7000497027000000000000000043001"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004F49"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.12 </span>Understanding Memory Performance </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">553</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000043002" id="P7000497027000000000000000043002"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043003" id="P7000497027000000000000000043003"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000004FF4.xhtml#P7000497027000000000000000004FF4"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.13 </span>Life in the Real World: Performance Improvement Techniques </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">561</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter05.xhtml#P7000497027000000000000000043004" id="P7000497027000000000000000043004"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043005" id="P7000497027000000000000000043005"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000500C.xhtml#P700049702700000000000000000500C"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.14 </span>Identifying and Eliminating Performance Bottlenecks </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">562</span></a></p></li>
</ol></div>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043006" id="P7000497027000000000000000043006">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043007" id="P7000497027000000000000000043007">
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter05.xhtml#P7000497027000000000000000043008" id="P7000497027000000000000000043008"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043009" id="P7000497027000000000000000043009"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000005082.xhtml#P7000497027000000000000000005082"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.15 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary</span> </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">568</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter05.xhtml#P700049702700000000000000004300A" id="P700049702700000000000000004300A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004300B" id="P700049702700000000000000004300B"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000508A.xhtml#P700049702700000000000000000508A"><span class="pcalibre1 pcalibre2" epub:type="title">Bibliographic Notes </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">569</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter05.xhtml#P700049702700000000000000004300C" id="P700049702700000000000000004300C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004300D" id="P700049702700000000000000004300D"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000005090.xhtml#P7000497027000000000000000005090"><span class="pcalibre1 pcalibre2" epub:type="title">Homework Problems </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">570</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter05.xhtml#P700049702700000000000000004300E" id="P700049702700000000000000004300E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004300F" id="P700049702700000000000000004300F"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP70004970270000000000000000050E4.xhtml#P70004970270000000000000000050E4"><span class="pcalibre1 pcalibre2" epub:type="title">Solutions to Practice Problems </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">573</span></a></p></li>
</ol>
</div>
</nav>
<section class="pcalibre1 pcalibre2 pcalibre51" data-uri="chapter05.xhtml#P7000497027000000000000000043010" epub:type="introduction" id="P7000497027000000000000000043010">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043011" id="P7000497027000000000000000043011"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P70004970270000000000000000048C1" epub:type="pagebreak" id="P70004970270000000000000000048C1" title="496"></span>The primary objective in writing a program must be to make it work correctly under all possible conditions. A program that runs fast but gives incorrect results serves no useful purpose. Programmers must write clear and concise code, not only so that they can make sense of it, but also so that others can read and understand the code during code reviews and when modifications are required later.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043012" id="P7000497027000000000000000043012">On the other hand, there are many occasions when making a program run fast is also an important consideration. If a program must process video frames or network packets in real time, then a slow-running program will not provide the needed functionality. When a computational task is so demanding that it requires days or weeks to execute, then making it run just 20% faster can have significant impact. In this chapter, we will explore how to make programs run faster via several different types of program optimization.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043013" id="P7000497027000000000000000043013">Writing an efficient program requires several types of activities. First, we must select an appropriate set of algorithms and data structures. Second, we must write source code that the compiler can effectively optimize to turn into efficient executable code. For this second part, it is important to understand the capabilities and limitations of optimizing compilers. Seemingly minor changes in how a program is written can make large differences in how well a compiler can optimize it. Some programming languages are more easily optimized than others. Some features of C, such as the ability to perform pointer arithmetic and casting, make it challenging for a compiler to optimize. Programmers can often write their programs in ways that make it easier for compilers to generate efficient code. A third technique for dealing with especially demanding computations is to divide a task into portions that can be computed in parallel, on some combination of multiple cores and multiple processors. We will defer this aspect of performance enhancement to <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">12</span></a>. Even when exploiting parallelism, it is important that each parallel thread execute with maximum performance, and so the material of this chapter remains relevant in any case.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043014" id="P7000497027000000000000000043014">In approaching program development and optimization, we must consider how the code will be used and what critical factors affect it. In general, programmers must make a trade-off between how easy a program is to implement and maintain, and how fast it runs. At an algorithmic level, a simple insertion sort can be programmed in a matter of minutes, whereas a highly efficient sort routine may take a day or more to implement and optimize. At the coding level, many low-level optimizations tend to reduce code readability and modularity, making the programs more susceptible to bugs and more difficult to modify or extend. For code that will be executed repeatedly in a performance-critical environment, extensive optimization may be appropriate. One challenge is to maintain some degree of elegance and readability in the code despite extensive transformations.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043015" id="P7000497027000000000000000043015">We describe a number of techniques for improving code performance. Ideally, a compiler would be able to take whatever code we write and generate the most efficient possible machine-level program having the specified behavior. Modern compilers employ sophisticated forms of analysis and optimization, and they keep getting better. Even the best compilers, however, can be thwarted by <i class="pcalibre17 pcalibre2 pcalibre1">optimization blockers</i>—aspects of the program's behavior that depend strongly on the execution <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P70004970270000000000000000048C6" epub:type="pagebreak" id="P70004970270000000000000000048C6" title="497"></span>environment. Programmers must assist the compiler by writing code that can be optimized readily.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043016" id="P7000497027000000000000000043016">The first step in optimizing a program is to eliminate unnecessary work, making the code perform its intended task as efficiently as possible. This includes eliminating unnecessary function calls, conditional tests, and memory references. These optimizations do not depend on any specific properties of the target machine.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043017" id="P7000497027000000000000000043017">To maximize the performance of a program, both the programmer and the compiler require a model of the target machine, specifying how instructions are processed and the timing characteristics of the different operations. For example, the compiler must know timing information to be able to decide whether it should use a multiply instruction or some combination of shifts and adds. Modern computers use sophisticated techniques to process a machine-level program, executing many instructions in parallel and possibly in a different order than they appear in the program. Programmers must understand how these processors work to be able to tune their programs for maximum speed. We present a high-level model of such a machine based on recent designs of Intel and AMD processors. We also devise a graphical <i class="pcalibre17 pcalibre2 pcalibre1">data-flow</i> notation to visualize the execution of instructions by the processor, with which we can predict program performance.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043018" id="P7000497027000000000000000043018">With this understanding of processor operation, we can take a second step in program optimization, exploiting the capability of processors to provide <i class="pcalibre17 pcalibre2 pcalibre1">instruction-level parallelism</i>, executing multiple instructions simultaneously. We cover several program transformations that reduce the data dependencies between different parts of a computation, increasing the degree of parallelism with which they can be executed.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043019" id="P7000497027000000000000000043019">We conclude the chapter by discussing issues related to optimizing large programs. We describe the use of code <i class="pcalibre17 pcalibre2 pcalibre1">profilers</i>—tools that measure the performance of different parts of a program. This analysis can help find inefficiencies in the code and identify the parts of the program on which we should focus our optimization efforts.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004301A" id="P700049702700000000000000004301A">In this presentation, we make code optimization look like a simple linear process of applying a series of transformations to the code in a particular order. In fact, the task is not nearly so straightforward. A fair amount of trial-and-error experimentation is required. This is especially true as we approach the later optimization stages, where seemingly small changes can cause major changes in performance and some very promising techniques prove ineffective. As we will see in the examples that follow, it can be difficult to explain exactly why a particular code sequence has a particular execution time. Performance can depend on many detailed features of the processor design for which we have relatively little documentation or understanding. This is another reason to try a number of different variations and combinations of techniques.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004301B" id="P700049702700000000000000004301B">Studying the assembly-code representation of a program is one of the most effective means for gaining an understanding of the compiler and how the generated code will run. A good strategy is to start by looking carefully at the code for the inner loops, identifying performance-reducing attributes such as excessive memory references and poor use of registers. Starting with the assembly code, we <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P70004970270000000000000000048CD" epub:type="pagebreak" id="P70004970270000000000000000048CD" title="498"></span>can also predict what operations will be performed in parallel and how well they will use the processor resources. As we will see, we can often determine the time (or at least a lower bound on the time) required to execute a loop by identifying <i class="pcalibre17 pcalibre2 pcalibre1">critical paths</i>, chains of data dependencies that form during repeated executions of a loop. We can then go back and modify the source code to try to steer the compiler toward more efficient implementations.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004301C" id="P700049702700000000000000004301C">Most major compilers, including <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>, are continually being updated and improved, especially in terms of their optimization abilities. One useful strategy is to do only as much rewriting of a program as is required to get it to the point where the compiler can then generate efficient code. By this means, we avoid compromising the readability, modularity, and portability of the code as much as if we had to work with a compiler of only minimal capabilities. Again, it helps to iteratively modify the code and analyze its performance both through measurements and by examining the generated assembly code.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004301D" id="P700049702700000000000000004301D">To novice programmers, it might seem strange to keep modifying the source code in an attempt to coax the compiler into generating efficient code, but this is indeed how many high-performance programs are written. Compared to the alternative of writing code in assembly language, this indirect approach has the advantage that the resulting code will still run on other machines, although perhaps not with peak performance.</p>
</section>
</section>
<!--EOF:P70004970270000000000000000048D0-->
<!--EOF:P700049702700000000000000000493B-->
<!--EOF:P700049702700000000000000000496E-->
<!--EOF:P70004970270000000000000000049CE-->
<!--EOF:P7000497027000000000000000004A83-->
<!--EOF:P7000497027000000000000000004AB6-->
<!--EOF:P7000497027000000000000000004B6C-->
<!--EOF:P7000497027000000000000000004C94-->
<!--EOF:P7000497027000000000000000004D16-->
<!--EOF:P7000497027000000000000000004E68-->
<!--EOF:P7000497027000000000000000004E9A-->
<!--EOF:P7000497027000000000000000004F49-->
<!--EOF:P7000497027000000000000000004FF4-->
<!--EOF:P700049702700000000000000000500C-->
<!--EOF:P7000497027000000000000000005082-->
<!--EOF:P700049702700000000000000000508A-->
<!--EOF:P7000497027000000000000000005090-->
<!--EOF:P70004970270000000000000000050E4-->
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.1 Capabilities and Limitations of Optimizing Compilers</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P70004970270000000000000000048D0"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P700049702700000000000000004301E" epub:type="title" id="P700049702700000000000000004301E"><span class="pcalibre1 pcalibre21 pcalibre2">5.1 </span>Capabilities and Limitations of Optimizing Compilers</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004301F" id="P700049702700000000000000004301F">Modern compilers employ sophisticated algorithms to determine what values are computed in a program and how they are used. They can then exploit opportunities to simplify expressions, to use a single computation in several different places, and to reduce the number of times a given computation must be performed. Most compilers, including <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>, provide users with some control over which optimizations they apply. As discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001DCE.xhtml#P7000497027000000000000000001DCE"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">3</span></a>, the simplest control is to specify the <i class="pcalibre17 pcalibre2 pcalibre1">optimization level.</i> For example, invoking <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>with the command-line option <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043020" id="P7000497027000000000000000043020">−0g</code> specifies that it should apply a basic set of optimizations.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043021" id="P7000497027000000000000000043021">Invoking <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>with option <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043022" id="P7000497027000000000000000043022">−01</code> or higher (e.g., <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043023" id="P7000497027000000000000000043023">−02</code> or <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043024" id="P7000497027000000000000000043024">−03</code>) will cause it to apply more extensive optimizations. These can further improve program performance, but they may expand the program size and they may make the program more difficult to debug using standard debugging tools. For our presentation, we will mostly consider code compiled with optimization level <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043025" id="P7000497027000000000000000043025">−01</code>, even though level <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043026" id="P7000497027000000000000000043026">−02</code> has become the accepted standard for most software projects that use <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>. We purposely limit the level of optimization to demonstrate how different ways of writing a function in C can affect the efficiency of the code generated by a compiler. We will find that we can write C code that, when compiled just with option <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043027" id="P7000497027000000000000000043027">−01</code>, vastly outperforms a more naive version compiled with the highest possible optimization levels.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043028" id="P7000497027000000000000000043028">Compilers must be careful to apply only <i class="pcalibre17 pcalibre2 pcalibre1">safe</i> optimizations to a program, meaning that the resulting program will have the exact same behavior as would an unoptimized version for all possible cases the program may encounter, up to the limits of the guarantees provided by the C language standards. Constraining <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P70004970270000000000000000048DC" epub:type="pagebreak" id="P70004970270000000000000000048DC" title="499"></span>the compiler to perform only safe optimizations eliminates possible sources of undesired run-time behavior, but it also means that the programmer must make more of an effort to write programs in a way that the compiler can then transform into efficient machine-level code. To appreciate the challenges of deciding which program transformations are safe or not, consider the following two procedures:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043029" id="P7000497027000000000000000043029"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004302A" id="P700049702700000000000000004302A">
1	void twiddlel(long *xp, long *yp)
2	{
3		*xp += *yp;
4		*xp += *yp;
5	}
6	
7	void twiddle2(long *xp, long *yp)
8	{
9		*xp += 2* *yp;
10	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004302B" id="P700049702700000000000000004302B">At first glance, both procedures seem to have identical behavior. They both add twice the value stored at the location designated by pointer <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004302C" id="P700049702700000000000000004302C">yp</code> to that designated by pointer <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004302D" id="P700049702700000000000000004302D">xp</code>. On the other hand, function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004302E" id="P700049702700000000000000004302E">twiddle2</code> is more efficient. It requires only three memory references (read <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004302F" id="P700049702700000000000000004302F">*xp</code>, read <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043030" id="P7000497027000000000000000043030">*yp</code>, write <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043031" id="P7000497027000000000000000043031">*xp</code>), whereas <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043032" id="P7000497027000000000000000043032">twiddle1</code> requires six (two reads of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043033" id="P7000497027000000000000000043033">*xp</code>, two reads of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043034" id="P7000497027000000000000000043034">*yp</code>, and two writes of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043035" id="P7000497027000000000000000043035">*xp</code>). Hence, if a compiler is given procedure <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043036" id="P7000497027000000000000000043036">twiddle1</code> to compile, one might think it could generate more efficient code based on the computations performed by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043037" id="P7000497027000000000000000043037">twiddle2</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043038" id="P7000497027000000000000000043038">Consider, however, the case in which <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043039" id="P7000497027000000000000000043039">xp</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004303A" id="P700049702700000000000000004303A">yp</code> are equal. Then function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004303B" id="P700049702700000000000000004303B">twiddle1</code> will perform the following computations:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004303C" id="P700049702700000000000000004303C"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004303D" id="P700049702700000000000000004303D">
3	*xp += *xp; /* Double value at xp */
4	*xp += *xp; /* Double value at xp */
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004303E" id="P700049702700000000000000004303E">The result will be that the value at <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004303F" id="P700049702700000000000000004303F">xp</code> will be increased by a factor of 4. On the other hand, function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043040" id="P7000497027000000000000000043040">twiddle2</code> will perform the following computation:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043041" id="P7000497027000000000000000043041"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043042" id="P7000497027000000000000000043042">
9	*xp += 2* *xp; /* Triple value at xp */
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043043" id="P7000497027000000000000000043043">The result will be that the value at <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043044" id="P7000497027000000000000000043044">xp</code> will be increased by a factor of 3. The compiler knows nothing about how <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043045" id="P7000497027000000000000000043045">twiddle1</code> will be called, and so it must assume that arguments <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043046" id="P7000497027000000000000000043046">xp</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043047" id="P7000497027000000000000000043047">yp</code> can be equal. It therefore cannot generate code in the style of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043048" id="P7000497027000000000000000043048">twiddle2</code> as an optimized version of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043049" id="P7000497027000000000000000043049">twiddle1</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004304A" id="P700049702700000000000000004304A">The case where two pointers may designate the same memory location is known as <i class="pcalibre17 pcalibre2 pcalibre1">memory aliasing.</i> In performing only safe optimizations, the compiler must assume that different pointers may be aliased. As another example, for a program with pointer variables <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004304B" id="P700049702700000000000000004304B">p</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004304C" id="P700049702700000000000000004304C">q</code>, consider the following code sequence:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004304D" id="P700049702700000000000000004304D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004304E" id="P700049702700000000000000004304E">
x = 1000; y = 3000;
*q = y; /* 3000 */
*p = x; /* 1000 */
t1 = *q; /* 1000 or 3000 */
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004304F" id="P700049702700000000000000004304F"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004904" epub:type="pagebreak" id="P7000497027000000000000000004904" title="500"></span>The value computed for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043050" id="P7000497027000000000000000043050">t1</code> depends on whether or not pointers <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043051" id="P7000497027000000000000000043051">p</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043052" id="P7000497027000000000000000043052">q</code> are aliased—if not, it will equal 3,000, but if so it will equal 1,000. This leads to one of the major <i class="pcalibre17 pcalibre2 pcalibre1">optimization blockers</i>, aspects of programs that can severely limit the opportunities for a compiler to generate optimized code. If a compiler cannot determine whether or not two pointers may be aliased, it must assume that either case is possible, limiting the set of possible optimizations.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004908" epub:type="practice" id="P7000497027000000000000000004908"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043053" epub:type="title" id="P7000497027000000000000000043053"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000005090.xhtml#P70004970270000000000000000050DD">573</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P7000497027000000000000000043054" id="P7000497027000000000000000043054">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P7000497027000000000000000043055" id="P7000497027000000000000000043055">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043056" id="P7000497027000000000000000043056"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043057" id="P7000497027000000000000000043057">The following problem illustrates the way memory aliasing can cause unexpected program behavior. Consider the following procedure to swap two values:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043058" id="P7000497027000000000000000043058"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043059" id="P7000497027000000000000000043059">
1	/* Swap value x at xp with value y at yp */
2	void swap(long *xp, long *yp)
3	{
4		*xp = *xp + *yp; /* x+y */
5		*yp = *xp - *yp; /* x+y-y = x */
6		*xp = *xp - *yp; /* x+y-x = y */
7	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004305A" id="P700049702700000000000000004305A">If this procedure is called with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004305B" id="P700049702700000000000000004305B">xp</code> equal to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004305C" id="P700049702700000000000000004305C">yp</code>, what effect will it have?</p></div></li>
</ol>
</section>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004305D" id="P700049702700000000000000004305D">A second optimization blocker is due to function calls. As an example, consider the following two procedures:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004305E" id="P700049702700000000000000004305E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004305F" id="P700049702700000000000000004305F">
1	long f();
2	
3	long func1() {
4		return f ()+ f ()+ f ()+ f () ;
5	}
6	
7	long func2() {
8		return 4*f();
9	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043060" id="P7000497027000000000000000043060">It might seem at first that both compute the same result, but with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043061" id="P7000497027000000000000000043061">func2</code> calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043062" id="P7000497027000000000000000043062">f</code> only once, whereas <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043063" id="P7000497027000000000000000043063">func1</code> calls it four times. It is tempting to generate code in the style of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043064" id="P7000497027000000000000000043064">func2</code> when given <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043065" id="P7000497027000000000000000043065">func1</code> as the source.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043066" id="P7000497027000000000000000043066">Consider, however, the following code for f:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043067" id="P7000497027000000000000000043067"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043068" id="P7000497027000000000000000043068">
1	long counter = 0;
2	
3	long f() {
4		return counter++;
5	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043069" id="P7000497027000000000000000043069">This function has a <i class="pcalibre17 pcalibre2 pcalibre1">side effect</i>—it modifies some part of the global program state. Changing the number of times it gets called changes the program behavior. In</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000004920" id="P7000497027000000000000000004920"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter05.xhtml#P700049702700000000000000004306A" epub:type="title" id="P700049702700000000000000004306A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004922" epub:type="pagebreak" id="P7000497027000000000000000004922" title="501"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Optimizing function calls by inline substitution</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P700049702700000000000000004306B" id="P700049702700000000000000004306B">Code involving function calls can be optimized by a process known as <i class="pcalibre17 pcalibre2 pcalibre1">inline substitution</i> (or simply "inlining"), where the function call is replaced by the code for the body of the function. For example, we can expand the code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004306C" id="P700049702700000000000000004306C">func1</code> by substituting four instantiations of function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004306D" id="P700049702700000000000000004306D">f</code>:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004306E" id="P700049702700000000000000004306E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004306F" id="P700049702700000000000000004306F">
1	/* Result of inlining f in func1 */
2	long func1in() {
3		long t = counter++; /* +0 */
4		t += counter++; /* +1 */
5		t += counter++; /* +2 */
6		t += counter++; /* +3 */
7		return t;
8	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043070" id="P7000497027000000000000000043070">This transformation both reduces the overhead of the function calls and allows further optimization of the expanded code. For example, the compiler can consolidate the updates of global variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043071" id="P7000497027000000000000000043071">counter</code> in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043072" id="P7000497027000000000000000043072">func1</code> in to generate an optimized version of the function:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043073" id="P7000497027000000000000000043073"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043074" id="P7000497027000000000000000043074">
1	/* Optimization of inlined code */
2	long func1opt() {
3		long t = 4 * counter + 6;
4		counter += 4;
5		return t;
6	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043075" id="P7000497027000000000000000043075">This code faithfully reproduces the behavior of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043076" id="P7000497027000000000000000043076">func1</code> for this particular definition of function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043077" id="P7000497027000000000000000043077">f</code>.</p>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043078" id="P7000497027000000000000000043078">Recent versions of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>attempt this form of optimization, either when directed to with the command-line option <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043079" id="P7000497027000000000000000043079">-finline</code> or for optimization level <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004307A" id="P700049702700000000000000004307A">−01</code> and higher. Unfortunately, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>only attempts inlining for functions defined within a single file. That means it will not be applied in the common case where a set of library functions is defined in one file but invoked by functions in other files.</p>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004307B" id="P700049702700000000000000004307B">There are times when it is best to prevent a compiler from performing inline substitution. One is when the code will be evaluated using a symbolic debugger, such as <span class="pcalibre1 pcalibre29 pcalibre2">gdb</span>, as described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002E6D.xhtml#P7000497027000000000000000002EC0"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.10.2</span></a>. If a function call has been optimized away via inline substitution, then any attempt to trace or set a breakpoint for that call will fail. The second is when evaluating the performance of a program by profiling, as is discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000500C.xhtml#P700049702700000000000000000500F"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14.1</span></a>. Calls to functions that have been eliminated by inline substitution will not be profiled correctly.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004307C" id="P700049702700000000000000004307C">particular, a call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004307D" id="P700049702700000000000000004307D">func1</code> would return 0 + 1 + 2 + 3 = 6, whereas a call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004307E" id="P700049702700000000000000004307E">func2</code> would return 4 · 0 = 0, assuming both started with global variable counter set to zero.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004307F" id="P700049702700000000000000004307F">Most compilers do not try to determine whether a function is free of side effects and hence is a candidate for optimizations such as those attempted in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043080" id="P7000497027000000000000000043080">func2</code>. Instead, the compiler assumes the worst case and leaves function calls intact.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043081" id="P7000497027000000000000000043081"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P700049702700000000000000000493A" epub:type="pagebreak" id="P700049702700000000000000000493A" title="502"></span>Among compilers, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>is considered adequate, but not exceptional, in terms of its optimization capabilities. It performs basic optimizations, but it does not perform the radical transformations on programs that more "aggressive" compilers do. As a consequence, programmers using <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>must put more effort into writing programs in a way that simplifies the compiler's task of generating efficient code.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.2 Expressing Program Performance</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000493B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043082" epub:type="title" id="P7000497027000000000000000043082"><span class="pcalibre1 pcalibre21 pcalibre2">5.2 </span>Expressing Program Performance</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043083" id="P7000497027000000000000000043083">We introduce the metric <i class="pcalibre17 pcalibre2 pcalibre1">cycles per element</i>, abbreviated CPE, to express program performance in a way that can guide us in improving the code. CPE measurements help us understand the loop performance of an iterative program at a detailed level. It is appropriate for programs that perform a repetitive computation, such as processing the pixels in an image or computing the elements in a matrix product.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043084" id="P7000497027000000000000000043084">The sequencing of activities by a processor is controlled by a clock providing a regular signal of some frequency, usually expressed in <i class="pcalibre17 pcalibre2 pcalibre1">gigahertz</i> (GHz), billions of cycles per second. For example, when product literature characterizes a system as a "4 GHz" processor, it means that the processor clock runs at 4.0 × 10<sup class="pcalibre1 pcalibre2 pcalibre85">−9</sup> cycles per second. The time required for each clock cycle is given by the reciprocal of the clock frequency. These typically are expressed in <i class="pcalibre17 pcalibre2 pcalibre1">nanoseconds</i> (1 nanosecond is 10<sup class="pcalibre1 pcalibre2 pcalibre85">−9</sup> seconds) or <i class="pcalibre17 pcalibre2 pcalibre1">picoseconds</i> (1 picosecond is 10<sup class="pcalibre1 pcalibre2 pcalibre85">−12</sup> seconds). For example, the period of a 4 GHz clock can be expressed as either 0.25 nanoseconds or 250 picoseconds. From a programmer's perspective, it is more instructive to express measurements in clock cycles rather than nanoseconds or picoseconds. That way, the measurements express how many instructions are being executed rather than how fast the clock runs.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043085" id="P7000497027000000000000000043085">Many procedures contain a loop that iterates over a set of elements. For example, functions <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043086" id="P7000497027000000000000000043086">psum1</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043087" id="P7000497027000000000000000043087">psum2</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004949"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1</span></a> both compute the <i class="pcalibre17 pcalibre2 pcalibre1">prefix sum</i> of a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. For a vector <span class="pcalibre1 inlineequation pcalibre2"><m:math altimg="../images/ch05-1.png" altimg-height="16" altimg-width="139" alttext="" data-uri="" display="inline"><m:mrow><m:mover accent="true"><m:mi>a</m:mi><m:mo>→</m:mo></m:mover><m:mo>=</m:mo><m:mrow><m:mo>〈</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mtext> </m:mtext><m:mo>,</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow><m:mo>〉</m:mo></m:mrow></m:mrow></m:math></span>, the prefix sum <span class="pcalibre1 inlineequation pcalibre2"><m:math altimg="../images/ch05-2.png" altimg-height="21" altimg-width="201" alttext="" data-uri="" display="inline"><m:mrow><m:mover accent="true"><m:mi>p</m:mi><m:mo>→</m:mo></m:mover><m:mo>=</m:mo><m:mrow><m:mo>〈</m:mo><m:mrow><m:msub><m:mi>p</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>p</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mtext> </m:mtext><m:mo>,</m:mo><m:msub><m:mi>p</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow><m:mo>〉</m:mo></m:mrow></m:mrow></m:math> </span>is defined as</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter05.xhtml#P7000497027000000000000000043088" id="P7000497027000000000000000043088">
<m:math altimg="../images/ch05-3.png" altimg-height="51" altimg-width="236" alttext="" data-uri="" display="block"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>p</m:mi><m:mn>0</m:mn></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>p</m:mi><m:mi>i</m:mi></m:msub><m:mo>=</m:mo><m:msub><m:mi>p</m:mi><m:mrow><m:mi>i</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mi>i</m:mi></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:mn>1</m:mn><m:mo>&lt;</m:mo><m:mi>i</m:mi><m:mo>&lt;</m:mo><m:mi>n</m:mi></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
<span class="pcalibre1 pcalibre76 pcalibre2">(5.1)</span>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043089" id="P7000497027000000000000000043089">Function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004308A" id="P700049702700000000000000004308A">psum1</code> computes one element of the result vector per iteration. Function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004308B" id="P700049702700000000000000004308B">psum2</code> uses a technique known as <i class="pcalibre17 pcalibre2 pcalibre1">loop unrolling</i> to compute two elements per iteration. We will explore the benefits of loop unrolling later in this chapter. (See Problems 5.11,5.12, and 5.19 for more about analyzing and optimizing the prefix-sum computation.)</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004308C" id="P700049702700000000000000004308C">The time required by such a procedure can be characterized as a constant plus a factor proportional to the number of elements processed. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004951"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.2</span></a> shows a plot of the number of clock cycles required by the two functions for a range of values of <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. Using a <i class="pcalibre17 pcalibre2 pcalibre1">least squares fit</i>, we find that the run times (in clock cycles) for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004308D" id="P700049702700000000000000004308D">psum1</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004308E" id="P700049702700000000000000004308E">psum2</code> can be approximated by the equations 368 + 9.0<var class="pcalibre17 pcalibre2 pcalibre1">n</var> and 368 + 6.0<var class="pcalibre17 pcalibre2 pcalibre1">n</var>, respectively. These equations indicate an overhead of 368 cycles due to the timing code and to initiate the procedure, set up the loop, and complete the</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004949" id="P7000497027000000000000000004949">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004308F" id="P700049702700000000000000004308F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043090" id="P7000497027000000000000000043090">
<span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter05.xhtml#P700049702700000000000000000494C" epub:type="pagebreak" id="P700049702700000000000000000494C" title="503"></span>1	/* Compute prefix sum of vector a */
2	void pum1(float a[], float p[], long n)
3	{
4		long i;
5		p[0] = a[0];
6		for (i = 1; i &lt; n; i++)
7			p[i] = p[i-1] + a[i];
8	}
9	
10	void psum2(float a[], float p[], long n)
11	{
12		long i;
13		p[0] = a[0];
14		for (i = 1; i &lt; n-1; i+=2) {
15			float mid_val = p[i-1] + a[i];
16			p[i] = mid_val;
17			p[i+1] = mid_val + a[i+1];
18 }
19	/* For even n, finish remaining element */
20	if (i &lt; n)
21			p[i] = p[i-1] + a[i];
22	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043091" id="P7000497027000000000000000043091"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043092" epub:type="title" id="P7000497027000000000000000043092"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.1 </span>Prefix-sum functions.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043093" id="P7000497027000000000000000043093"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043094" id="P7000497027000000000000000043094">These functions provide examples for how we express program performance.</p></div></figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004951" id="P7000497027000000000000000004951">
<img alt="A graph of cycles versus elements shows two lines, the higher representing psum1 with slope = 9 and the lower representing psum2 with slope = 6." class="pcalibre1 pcalibre2 calibre43" data-uri="P700049702700000000000000000B70D" id="P7000497027000000000000000043095" src="Images/chapter-05-image-01.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043096" id="P7000497027000000000000000043096"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043097" epub:type="title" id="P7000497027000000000000000043097"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.2 </span>Performance of prefix-sum functions.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043098" id="P7000497027000000000000000043098"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043099" id="P7000497027000000000000000043099">The slope of the lines indicates the number of clock cycles per element (CPE).</p></div></figcaption></figure>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000004957" id="P7000497027000000000000000004957"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter05.xhtml#P700049702700000000000000004309A" epub:type="title" id="P700049702700000000000000004309A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004959" epub:type="pagebreak" id="P7000497027000000000000000004959" title="504"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>What is a least squares fit?</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P700049702700000000000000004309B" id="P700049702700000000000000004309B">For a set of data points (<var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">y</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>),. . . (<i class="pcalibre17 pcalibre2 pcalibre1">x<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i>, <i class="pcalibre17 pcalibre2 pcalibre1">y<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i>), we often try to draw a line that best approximates the X-Y trend represented by these data. With a least squares fit, we look for a line of the form <i class="pcalibre17 pcalibre2 pcalibre1">y = mx</i> + <var class="pcalibre17 pcalibre2 pcalibre1">b</var> that minimizes the following error measure:</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter05.xhtml#P700049702700000000000000004309C" id="P700049702700000000000000004309C">
<m:math altimg="../images/ch05-4.png" altimg-height="34" altimg-width="184" alttext="" data-uri="" display="block"><m:mrow><m:mi>E</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>m</m:mi><m:mo>,</m:mo><m:mi>b</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:munder><m:mo>∑</m:mo><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mi>n</m:mi></m:mrow></m:munder><m:mrow><m:msup><m:mrow><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>m</m:mi><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>+</m:mo><m:mi>b</m:mi><m:mo>-</m:mo><m:msub><m:mi>y</m:mi><m:mi>i</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow><m:mn>2</m:mn></m:msup></m:mrow></m:mrow></m:math>
</div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004309D" id="P700049702700000000000000004309D">An algorithm for computing <var class="pcalibre17 pcalibre2 pcalibre1">m</var> and <var class="pcalibre17 pcalibre2 pcalibre1">b</var> can be derived by finding the derivatives of <i class="pcalibre17 pcalibre2 pcalibre1">E(m, b)</i> with respect to <var class="pcalibre17 pcalibre2 pcalibre1">m</var> and <var class="pcalibre17 pcalibre2 pcalibre1">b</var> and setting them to 0.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004309E" id="P700049702700000000000000004309E">procedure, plus a linear factor of 6.0 or 9.0 cycles per element. For large values of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> (say, greater than 200), the run times will be dominated by the linear factors. We refer to the coefficients in these terms as the effective number of cycles per element. We prefer measuring the number of cycles per <i class="pcalibre17 pcalibre2 pcalibre1">element</i> rather than the number of cycles per <i class="pcalibre17 pcalibre2 pcalibre1">iteration</i>, because techniques such as loop unrolling allow us to use fewer iterations to complete the computation, but our ultimate concern is how fast the procedure will run for a given vector length. We focus our efforts on minimizing the CPE for our computations. By this measure, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004309F" id="P700049702700000000000000004309F">psum2</code>, with a CPE of 6.0, is superior to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430A0" id="P70004970270000000000000000430A0">psum1</code>, with a CPE of 9.0.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004960" epub:type="practice" id="P7000497027000000000000000004960"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430A1" epub:type="title" id="P70004970270000000000000000430A1"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.2 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000005090.xhtml#P70004970270000000000000000050DD">573</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P70004970270000000000000000430A2" id="P70004970270000000000000000430A2">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P70004970270000000000000000430A3" id="P70004970270000000000000000430A3">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430A4" id="P70004970270000000000000000430A4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000430A5" id="P70004970270000000000000000430A5">Later in this chapter we will start with a single function and generate many different variants that preserve the function's behavior, but with different performance characteristics. For three of these variants, we found that the run times (in clock cycles) can be approximated by the following functions:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430A6" id="P70004970270000000000000000430A6">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000430A7" id="P70004970270000000000000000430A7"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000430A8" id="P70004970270000000000000000430A8">Version 1: 60 + 35<var class="pcalibre17 pcalibre2 pcalibre1">n</var></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000430A9" id="P70004970270000000000000000430A9"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000430AA" id="P70004970270000000000000000430AA">Version 2: 136 + 4<var class="pcalibre17 pcalibre2 pcalibre1">n</var></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000430AB" id="P70004970270000000000000000430AB"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000430AC" id="P70004970270000000000000000430AC">Version 3: 157 + 1.25<var class="pcalibre17 pcalibre2 pcalibre1">n</var></p></li>
</ul>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000430AD" id="P70004970270000000000000000430AD">For what values of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> would each version be the fastest of the three? Remember that <var class="pcalibre17 pcalibre2 pcalibre1">n</var> will always be an integer.</p></div></li>
</ol>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.3 Program Example</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000496E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P70004970270000000000000000430AE" epub:type="title" id="P70004970270000000000000000430AE"><span class="pcalibre1 pcalibre21 pcalibre2">5.3 </span>Program Example</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430AF" id="P70004970270000000000000000430AF">To demonstrate how an abstract program can be systematically transformed into more efficient code, we will use a running example based on the vector data structure shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004971"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.3</span></a>. A vector is represented with two blocks of memory: the header and the data array. The header is a structure declared as follows:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004971" id="P7000497027000000000000000004971">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004972" epub:type="pagebreak" id="P7000497027000000000000000004972" title="505"></span>
<img alt="A diagram shows a box with two elements: len on top and data below. An arrow from data points to a series of boxes numbered 0, 1, 2,..., len minus 1." class="calibre44 pcalibre1 pcalibre2" data-uri="P700049702700000000000000000B70E" id="P70004970270000000000000000430B0" src="Images/chapter-05-image-02.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000430B1" id="P70004970270000000000000000430B1"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000430B2" epub:type="title" id="P70004970270000000000000000430B2"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.3 </span>Vector abstract data type.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430B3" id="P70004970270000000000000000430B3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000430B4" id="P70004970270000000000000000430B4">A vector is represented by header information plus an array of designated length.</p></div></figcaption></figure>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000430B5" id="P70004970270000000000000000430B5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430B6" id="P70004970270000000000000000430B6">
-----------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/opt/vec.h</i>
1	/* Create abstract data type for vector */
2	typedef struct {
3		long len;
4		data_t *data;
5	} vec_rec, *vec_ptr;
-----------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/opt/vec.h</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430B7" id="P70004970270000000000000000430B7">The declaration uses <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430B8" id="P70004970270000000000000000430B8">data_t</code> to designate the data type of the underlying elements. In our evaluation, we measured the performance of our code for integer (C <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430B9" id="P70004970270000000000000000430B9">int</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430BA" id="P70004970270000000000000000430BA">long</code>), and floating-point (C <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430BB" id="P70004970270000000000000000430BB">float</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430BC" id="P70004970270000000000000000430BC">double</code>) data. We do this by compiling and running the program separately for different type declarations, such as the following for data type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430BD" id="P70004970270000000000000000430BD">long</code>:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000430BE" id="P70004970270000000000000000430BE"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430BF" id="P70004970270000000000000000430BF">
typedef long data_t;
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430C0" id="P70004970270000000000000000430C0">We allocate the data array block to store the vector elements as an array of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430C1" id="P70004970270000000000000000430C1">len</code> objects of type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430C2" id="P70004970270000000000000000430C2">data_t</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430C3" id="P70004970270000000000000000430C3"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004991"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.4</span></a> shows some basic procedures for generating vectors, accessing vector elements, and determining the length of a vector. An important feature to note is that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430C4" id="P70004970270000000000000000430C4">get_vec_element</code>, the vector access routine, performs bounds checking for every vector reference. This code is similar to the array representations used in many other languages, including Java. Bounds checking reduces the chances of program error, but it can also slow down program execution.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430C5" id="P70004970270000000000000000430C5">As an optimization example, consider the code shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000499B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.5</span></a>, which combines all of the elements in a vector into a single value according to some operation. By using different definitions of compile-time constants <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430C6" id="P70004970270000000000000000430C6">IDENT</code> and OP, the code can be recompiled to perform different operations on the data. In particular, using the declarations</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000430C7" id="P70004970270000000000000000430C7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430C8" id="P70004970270000000000000000430C8">
#define IDENT 0
#define OP +
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430C9" id="P70004970270000000000000000430C9">it sums the elements of the vector. Using the declarations</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000430CA" id="P70004970270000000000000000430CA"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430CB" id="P70004970270000000000000000430CB">
#define IDENT 1
#define OP *
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430CC" id="P70004970270000000000000000430CC">it computes the product of the vector elements.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430CD" id="P70004970270000000000000000430CD">In our presentation, we will proceed through a series of transformations of the code, writing different versions of the combining function. To gauge progress,</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004991" id="P7000497027000000000000000004991">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000430CE" id="P70004970270000000000000000430CE"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430CF" id="P70004970270000000000000000430CF">
<span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter05.xhtml#P7000497027000000000000000004994" epub:type="pagebreak" id="P7000497027000000000000000004994" title="506"></span>1	/* Create vector of specified length */
2	vec_ptr new_vec(long len)
3	{
4		/* Allocate header structure */
5		vec_ptr result = (vec_ptr) malloc(sizeof(vec_rec));
6		data_t *data = NULL;
7		if (!result)
8			return NULL; /* Couldn't allocate storage */
9		result-&gt;len = len;
10		/* Allocate array */
11		if (len &gt; 0) {
12			data = (data_t *)calloc(len, sizeof(data_t));
13			if (!data) {
14				free((void *) result);
15				return NULL; /* Couldn't allocate storage */
16			}
17		}
18		/* Data will either be NULL or allocated array */
19		result-&gt;data = data;
20		return result;
21	}
22	
23	/*
24	* Retrieve vector element and store at dest.
25	* Return 0 (out of bounds) or 1 (successful)
26	*/
27	int get_vec_element(vec_ptr v, long index, data_t *dest)
28	{
29		if (index &lt; 0 | | index &gt;= v-&gt;len)
30			return 0;
31		*dest = v-&gt;data [index];
32		return 1 ;
33	}
34	
35	/* Return length of vector */
36	long vec_length(vec_ptr v)
37	{
38		return v-&gt;len;
39	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000430D0" id="P70004970270000000000000000430D0"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000430D1" epub:type="title" id="P70004970270000000000000000430D1"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.4 </span>Implementation of vector abstract data type.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430D2" id="P70004970270000000000000000430D2"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000430D3" id="P70004970270000000000000000430D3">In the actual program, data type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430D4" id="P70004970270000000000000000430D4">data_t</code> is declared to be <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430D5" id="P70004970270000000000000000430D5">int, long, float, or double.</code></p></div></figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P700049702700000000000000000499B" id="P700049702700000000000000000499B">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000430D6" id="P70004970270000000000000000430D6"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430D7" id="P70004970270000000000000000430D7">
<span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter05.xhtml#P700049702700000000000000000499E" epub:type="pagebreak" id="P700049702700000000000000000499E" title="507"></span>1	/* Implementation with maximum use of data abstraction */
2	void combinel(vec_ptr v, data_t *dest)
3	{
4		long i;
5	
6		*dest = IDENT;
7		for (i = 0; i &lt; vec_length(v); i++) {
8			data_t val;
9			get_vec_element(v, i, &amp;val);
10			*dest = *dest OP val;
11		}
12	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000430D8" id="P70004970270000000000000000430D8"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000430D9" epub:type="title" id="P70004970270000000000000000430D9"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.5 </span>Initial implementation of combining operation.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430DA" id="P70004970270000000000000000430DA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000430DB" id="P70004970270000000000000000430DB">Using different declarations of identity element <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430DC" id="P70004970270000000000000000430DC">IDENT</code> and combining operation <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430DD" id="P70004970270000000000000000430DD">OP</code>, we can measure the routine for different operations.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430DE" id="P70004970270000000000000000430DE">we measured the CPE performance of the functions on a machine with an Intel Core i7 Haswell processor, which we refer to as our <i class="pcalibre17 pcalibre2 pcalibre1">reference machine.</i> Some characteristics of this processor were given in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001E06.xhtml#P7000497027000000000000000001E06"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.1</span></a>. These measurements characterize performance in terms of how the programs run on just one particular machine, and so there is no guarantee of comparable performance on other combinations of machine and compiler. However, we have compared the results with those for a number of different compiler/processor combinations, and we have found them generally consistent with those presented here.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430DF" id="P70004970270000000000000000430DF">As we proceed through a set of transformations, we will find that many lead to only minimal performance gains, while others have more dramatic effects. Determining which combinations of transformations to apply is indeed part of the "black art" of writing fast code. Some combinations that do not provide measurable benefits are indeed ineffective, while others are important as ways to enable further optimizations by the compiler. In our experience, the best approach involves a combination of experimentation and analysis: repeatedly attempting different approaches, performing measurements, and examining the assembly-code representations to identify underlying performance bottlenecks.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430E0" id="P70004970270000000000000000430E0">As a starting point, the following table shows CPE measurements for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430E1" id="P70004970270000000000000000430E1">combine1</code> running on our reference machine, with different combinations of operation (addition or multiplication) and data type (long integer and double-precision floating-point). Our experiments with many different programs showed that operations on 32-bit and 64-bit integers have identical performance, with the exception of code involving division operations. Similarly, we found identical performance for programs operating on single- or double-precision floating-point data. In our tables, we will therefore show only separate results for integer data and for floating-point data.</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P70004970270000000000000000430E2" id="P70004970270000000000000000430E2">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000430E3" id="P70004970270000000000000000430E3"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000430E4" id="P70004970270000000000000000430E4"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000430E5" id="P70004970270000000000000000430E5"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000430E6" id="P70004970270000000000000000430E6"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P70004970270000000000000000049AE" epub:type="pagebreak" id="P70004970270000000000000000049AE" title="508"></span>Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000430E7" id="P70004970270000000000000000430E7">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000430E8" id="P70004970270000000000000000430E8">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000430E9" id="P70004970270000000000000000430E9">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000430EA" id="P70004970270000000000000000430EA">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000430EB" id="P70004970270000000000000000430EB">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000430EC" id="P70004970270000000000000000430EC">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000430ED" id="P70004970270000000000000000430ED">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000430EE" id="P70004970270000000000000000430EE">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430EF" id="P70004970270000000000000000430EF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430F0" id="P70004970270000000000000000430F0">combine1</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430F1" id="P70004970270000000000000000430F1">507</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430F2" id="P70004970270000000000000000430F2">Abstract unoptimized</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430F3" id="P70004970270000000000000000430F3">22.68</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430F4" id="P70004970270000000000000000430F4">20.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430F5" id="P70004970270000000000000000430F5">19.98</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430F6" id="P70004970270000000000000000430F6">20.18</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430F7" id="P70004970270000000000000000430F7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430F8" id="P70004970270000000000000000430F8">combine1</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430F9" id="P70004970270000000000000000430F9">507</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430FA" id="P70004970270000000000000000430FA">Abstract <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000430FB" id="P70004970270000000000000000430FB">−01</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430FC" id="P70004970270000000000000000430FC">10.12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430FD" id="P70004970270000000000000000430FD">10.12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430FE" id="P70004970270000000000000000430FE">10.17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000430FF" id="P70004970270000000000000000430FF">11.14</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043100" id="P7000497027000000000000000043100">We can see that our measurements are somewhat imprecise. The more likely CPE number for integer sum is 23.00, rather than 22.68, while the number for integer product is likely 20.0 instead of 20.02. Rather than "fudging" our numbers to make them look good, we will present the measurements we actually obtained. There are many factors that complicate the task of reliably measuring the precise number of clock cycles required by some code sequence. It helps when examining these numbers to mentally round the results up or down by a few hundredths of a clock cycle.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043101" id="P7000497027000000000000000043101">The unoptimized code provides a direct translation of the C code into machine code, often with obvious inefficiencies. By simply giving the command-line option <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043102" id="P7000497027000000000000000043102">−01</code>, we enable a basic set of optimizations. As can be seen, this significantly improves the program performance—more than a factor of 2—with no effort on behalf of the programmer. In general, it is good to get into the habit of enabling some level of optimization. (Similar performance results were obtained with optimization level <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043103" id="P7000497027000000000000000043103">−0g</code>.) For the remainder of our measurements, we use optimization levels <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043104" id="P7000497027000000000000000043104">−01</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043105" id="P7000497027000000000000000043105">−02</code> when generating and measuring our programs.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.4 Eliminating Loop Inefficiencies</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P70004970270000000000000000049CE"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043106" epub:type="title" id="P7000497027000000000000000043106"><span class="pcalibre1 pcalibre21 pcalibre2">5.4 </span>Eliminating Loop Inefficiencies</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043107" id="P7000497027000000000000000043107">Observe that procedure <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043108" id="P7000497027000000000000000043108">combine1</code>, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000496E.xhtml#P700049702700000000000000000499B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.5</span></a>, calls function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043109" id="P7000497027000000000000000043109">vec_length</code> as the test condition of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004310A" id="P700049702700000000000000004310A">for</code> loop. Recall from our discussion of how to translate code containing loops into machine-level programs (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P700049702700000000000000000265F"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.6.7</span></a>) that the test condition must be evaluated on every iteration of the loop. On the other hand, the length of the vector does not change as the loop proceeds. We could therefore compute the vector length only once and use this value in our test condition.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004310B" id="P700049702700000000000000004310B"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000049F6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.6</span></a> shows a modified version called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004310C" id="P700049702700000000000000004310C">combine2</code>. It calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004310D" id="P700049702700000000000000004310D">vec_length</code> at the beginning and assigns the result to a local variable length. This transformation has noticeable effect on the overall performance for some data types and operations, and minimal or even none for others. In any case, this transformation is required to eliminate inefficiencies that would become bottlenecks as we attempt further optimizations.</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P700049702700000000000000004310E" id="P700049702700000000000000004310E">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004310F" id="P700049702700000000000000004310F"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043110" id="P7000497027000000000000000043110"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043111" id="P7000497027000000000000000043111"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043112" id="P7000497027000000000000000043112">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043113" id="P7000497027000000000000000043113">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043114" id="P7000497027000000000000000043114">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043115" id="P7000497027000000000000000043115">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043116" id="P7000497027000000000000000043116">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043117" id="P7000497027000000000000000043117">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043118" id="P7000497027000000000000000043118">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043119" id="P7000497027000000000000000043119">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004311A" id="P700049702700000000000000004311A">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004311B" id="P700049702700000000000000004311B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004311C" id="P700049702700000000000000004311C">combine1</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004311D" id="P700049702700000000000000004311D">507	Abstract <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004311E" id="P700049702700000000000000004311E">−01</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004311F" id="P700049702700000000000000004311F">10.12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043120" id="P7000497027000000000000000043120">10.12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043121" id="P7000497027000000000000000043121">10.17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043122" id="P7000497027000000000000000043122">11.14</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043123" id="P7000497027000000000000000043123"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043124" id="P7000497027000000000000000043124">combine2</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043125" id="P7000497027000000000000000043125">509</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043126" id="P7000497027000000000000000043126">Move <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043127" id="P7000497027000000000000000043127">vec_length</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043128" id="P7000497027000000000000000043128">7.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043129" id="P7000497027000000000000000043129">9.03</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004312A" id="P700049702700000000000000004312A">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004312B" id="P700049702700000000000000004312B">11.03</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004312C" id="P700049702700000000000000004312C">This optimization is an instance of a general class of optimizations known as <i class="pcalibre17 pcalibre2 pcalibre1">code motion.</i> They involve identifying a computation that is performed multiple</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P70004970270000000000000000049F6" id="P70004970270000000000000000049F6">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004312D" id="P700049702700000000000000004312D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004312E" id="P700049702700000000000000004312E">
<span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter05.xhtml#P70004970270000000000000000049F9" epub:type="pagebreak" id="P70004970270000000000000000049F9" title="509"></span>1	/* Move call to vec_length out of loop */
2	void combine2(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6	
7		*dest = IDENT;
8		for (i = 0; i &lt; length; i++) {
9			data_t val;
10			get_vec_element(v, i, &amp;val);
11			*dest = *dest OP val;
12		}
13	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P700049702700000000000000004312F" id="P700049702700000000000000004312F"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043130" epub:type="title" id="P7000497027000000000000000043130"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.6 </span>Improving the efficiency of the loop test.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043131" id="P7000497027000000000000000043131"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043132" id="P7000497027000000000000000043132">By moving the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043133" id="P7000497027000000000000000043133">vec_length</code> out of the loop test, we eliminate the need to execute it on every iteration.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043134" id="P7000497027000000000000000043134">times, (e.g., within a loop), but such that the result of the computation will not change. We can therefore move the computation to an earlier section of the code that does not get evaluated as often. In this case, we moved the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043135" id="P7000497027000000000000000043135">vec_length</code> from within the loop to just before the loop.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043136" id="P7000497027000000000000000043136">Optimizing compilers attempt to perform code motion. Unfortunately, as discussed previously, they are typically very cautious about making transformations that change where or how many times a procedure is called. They cannot reliably detect whether or not a function will have side effects, and so they assume that it might. For example, if <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043137" id="P7000497027000000000000000043137">vec_length</code> had some side effect, then <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043138" id="P7000497027000000000000000043138">combine1</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043139" id="P7000497027000000000000000043139">combine2</code> could have different behaviors. To improve the code, the programmer must often help the compiler by explicitly performing code motion.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004313A" id="P700049702700000000000000004313A">As an extreme example of the loop inefficiency seen in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004313B" id="P700049702700000000000000004313B">combine1</code>, consider the procedure <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004313C" id="P700049702700000000000000004313C">lower1</code> shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004A11"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.7</span></a>. This procedure is styled after routines submitted by several students as part of a network programming project. Its purpose is to convert all of the uppercase letters in a string to lowercase. The procedure steps through the string, converting each uppercase character to lowercase. The case conversion involves shifting characters in the range `A' to `Z' to the range `a' to `z'.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004313D" id="P700049702700000000000000004313D">The library function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004313E" id="P700049702700000000000000004313E">strlen</code> is called as part of the loop test of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004313F" id="P700049702700000000000000004313F">lower1</code>. Although <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043140" id="P7000497027000000000000000043140">strlen</code> is typically implemented with special x86 string-processing instructions, its overall execution is similar to the simple version that is also shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004A11"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.7</span></a>. Since strings in C are null-terminated character sequences, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043141" id="P7000497027000000000000000043141">strlen</code> can only determine the length of a string by stepping through the sequence until it hits a null character. For a string of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043142" id="P7000497027000000000000000043142">strlen</code> takes time proportional to <i class="pcalibre17 pcalibre2 pcalibre1">n.</i> Since <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043143" id="P7000497027000000000000000043143">strlen</code> is called in each of the <var class="pcalibre17 pcalibre2 pcalibre1">n</var> iterations of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043144" id="P7000497027000000000000000043144">lower1</code>, the overall run time of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043145" id="P7000497027000000000000000043145">lower1</code> is quadratic in the string length, proportional to <var class="pcalibre17 pcalibre2 pcalibre1">n</var><sup class="pcalibre1 pcalibre2 pcalibre85">2</sup>.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004A11" id="P7000497027000000000000000004A11">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043146" id="P7000497027000000000000000043146"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043147" id="P7000497027000000000000000043147">
<span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter05.xhtml#P7000497027000000000000000004A14" epub:type="pagebreak" id="P7000497027000000000000000004A14" title="510"></span>1	/* Convert string to lowercase: slow */
2	void lower1(char *s)
3	{
4		long i;
5	
6		for (i = 0; i &lt; strlen(s); i++)
7			if (s[i] &gt;= `A' &amp;&amp; s[i] &lt;= `Z')
8				s[i] -= (`A' - `a');
9	}
10	
11	/* Convert string to lowercase: faster */
12	void lower2(char *s)
13	{
14		long i;
15		long len = strlen(s);
16	
17		for (i = 0; i &lt; len; i++)
18			if (s[i] &gt;= `A' &amp;&amp; s[i] &lt;= `Z')
19				s[i] -= (`A' - `a');
20	}
21	
22	/* Sample implementation of library function strlen */
23	/* Compute length of string */
24	size_t strlen(const char *s)
25	{
26		long length = 0;
27		while (*s != `\0') {
28				s++;
29				length++;
30		}
31		return length;
32	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043148" id="P7000497027000000000000000043148"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043149" epub:type="title" id="P7000497027000000000000000043149"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.7 </span>Lowercase conversion routines.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004314A" id="P700049702700000000000000004314A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004314B" id="P700049702700000000000000004314B">The two procedures have radically different performance.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004314C" id="P700049702700000000000000004314C">This analysis is confirmed by actual measurements of the functions for different length strings, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004A1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.8</span></a> (and using the library version of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004314D" id="P700049702700000000000000004314D">strlen</code>). The graph of the run time for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004314E" id="P700049702700000000000000004314E">lower1</code> rises steeply as the string length increases (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004A1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.8(a)</span></a>). <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004A1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.8(b)</span></a> shows the run times for seven different lengths (not the same as shown in the graph), each of which is a power of 2. Observe that for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004314F" id="P700049702700000000000000004314F">lower1</code> each doubling of the string length causes a quadrupling of the run time. This is a clear indicator of a quadratic run time. For a string of length 1,048,576, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043150" id="P7000497027000000000000000043150">lower1</code> requires over 17 minutes of CPU time.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004A1E" id="P7000497027000000000000000004A1E">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004A1F" epub:type="pagebreak" id="P7000497027000000000000000004A1F" title="511"></span>
<img alt="A graph and table depict CPU seconds versus string length for lower1 and lower2." class="pcalibre1 pcalibre2 pcalibre190" data-uri="P700049702700000000000000000B710" id="P7000497027000000000000000043151" src="Images/chapter-05-image-03.png"/>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P7000497027000000000000000043152" id="P7000497027000000000000000043152">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" colspan="8" data-uri="chapter05.xhtml#P7000497027000000000000000043153" id="P7000497027000000000000000043153">String length</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043154" id="P7000497027000000000000000043154">Function</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043155" id="P7000497027000000000000000043155">16,384</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043156" id="P7000497027000000000000000043156">32,768</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043157" id="P7000497027000000000000000043157">65,536</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043158" id="P7000497027000000000000000043158">131,072</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043159" id="P7000497027000000000000000043159">262,144</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004315A" id="P700049702700000000000000004315A">524,288</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004315B" id="P700049702700000000000000004315B">1,048,576</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004315C" id="P700049702700000000000000004315C"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004315D" id="P700049702700000000000000004315D">lower1</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004315E" id="P700049702700000000000000004315E">0.26</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004315F" id="P700049702700000000000000004315F">1.03</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043160" id="P7000497027000000000000000043160">4.10</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043161" id="P7000497027000000000000000043161">16.41</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043162" id="P7000497027000000000000000043162">65.62</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043163" id="P7000497027000000000000000043163">262.48</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043164" id="P7000497027000000000000000043164">1,049.89</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043165" id="P7000497027000000000000000043165"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043166" id="P7000497027000000000000000043166">lower2</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043167" id="P7000497027000000000000000043167">0.0000</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043168" id="P7000497027000000000000000043168">0.0001</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043169" id="P7000497027000000000000000043169">0.0001</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004316A" id="P700049702700000000000000004316A">0.0003</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004316B" id="P700049702700000000000000004316B">0.0005</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004316C" id="P700049702700000000000000004316C">0.0010</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004316D" id="P700049702700000000000000004316D">0.0020</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="8" data-uri="chapter05.xhtml#P700049702700000000000000004316E" id="P700049702700000000000000004316E">(b)</td>
</tr>
</tbody>
</table>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P700049702700000000000000004316F" id="P700049702700000000000000004316F"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043170" epub:type="title" id="P7000497027000000000000000043170"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.8 </span>Comparative performance of lowercase conversion routines.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043171" id="P7000497027000000000000000043171"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043172" id="P7000497027000000000000000043172">The original code <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043173" id="P7000497027000000000000000043173">lower1</code> has a quadratic run time due to an inefficient loop structure. The modified code <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043174" id="P7000497027000000000000000043174">lower2</code> has a linear run time.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P7000497027000000000000000023453" id="P7000497027000000000000000023453">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre118" data-uri="chapter05.xhtml#P7000497027000000000000000043175" id="P7000497027000000000000000043175">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043176" id="P7000497027000000000000000043176"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043177" id="P7000497027000000000000000043177">A graph of GPU seconds versus string length shows lower1 increasing exponentially and lower2 remaining nearly horizontal around 0 cpu seconds.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043178" id="P7000497027000000000000000043178"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043179" id="P7000497027000000000000000043179">A table depicts the data in the graph:</p></li>
</ol>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P700049702700000000000000004317A" id="P700049702700000000000000004317A">
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004317B" id="P700049702700000000000000004317B">Function</td>
<td class="pcalibre1 pcalibre2 calibre7" colspan="7" data-uri="chapter05.xhtml#P700049702700000000000000004317C" id="P700049702700000000000000004317C">String length</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004317D" id="P700049702700000000000000004317D">16,384</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004317E" id="P700049702700000000000000004317E">32,768</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004317F" id="P700049702700000000000000004317F">65,536</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043180" id="P7000497027000000000000000043180">131,072</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043181" id="P7000497027000000000000000043181">262,144</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043182" id="P7000497027000000000000000043182">524,288</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043183" id="P7000497027000000000000000043183">1,048,576</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043184" id="P7000497027000000000000000043184">Lower1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043185" id="P7000497027000000000000000043185">0.26</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043186" id="P7000497027000000000000000043186">1.03</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043187" id="P7000497027000000000000000043187">4.10</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043188" id="P7000497027000000000000000043188">16.41</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043189" id="P7000497027000000000000000043189">65.62</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004318A" id="P700049702700000000000000004318A">262.48</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004318B" id="P700049702700000000000000004318B">1,049.89</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004318C" id="P700049702700000000000000004318C">Lower2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004318D" id="P700049702700000000000000004318D">0.0000</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004318E" id="P700049702700000000000000004318E">0.0001</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004318F" id="P700049702700000000000000004318F">0.0001</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043190" id="P7000497027000000000000000043190">0.0003</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043191" id="P7000497027000000000000000043191">0.0005</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043192" id="P7000497027000000000000000043192">0.0010</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043193" id="P7000497027000000000000000043193">0.0020</td>
</tr>
</tbody>
</table>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043194" id="P7000497027000000000000000043194">Function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043195" id="P7000497027000000000000000043195">lower2</code> shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004A11"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.7</span></a> is identical to that of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043196" id="P7000497027000000000000000043196">lower1</code>, except that we have moved the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043197" id="P7000497027000000000000000043197">strlen</code> out of the loop. The performance improves dramatically. For a string length of 1,048,576, the function requires just 2.0 milliseconds—over 500,000 times faster than <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043198" id="P7000497027000000000000000043198">lower1</code>. Each doubling of the string length causes a doubling of the run time—a clear indicator of linear run time. For longer strings, the run-time improvement will be even greater.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043199" id="P7000497027000000000000000043199">In an ideal world, a compiler would recognize that each call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004319A" id="P700049702700000000000000004319A">strlen</code> in the loop test will return the same result, and thus the call could be moved out of the loop. This would require a very sophisticated analysis, since <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004319B" id="P700049702700000000000000004319B">strlen</code> checks the elements of the string and these values are changing as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004319C" id="P700049702700000000000000004319C">lower1</code> proceeds. The compiler would need to detect that even though the characters within the string are changing, none are being set from nonzero to zero, or vice versa. Such an analysis is well beyond the ability of even the most sophisticated compilers, even if they employ inlining, and so programmers must do such transformations themselves.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004319D" id="P700049702700000000000000004319D">This example illustrates a common problem in writing programs, in which a seemingly trivial piece of code has a hidden asymptotic inefficiency. One would not expect a lowercase conversion routine to be a limiting factor in a program's performance. Typically, programs are tested and analyzed on small data sets, for which the performance of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004319E" id="P700049702700000000000000004319E">lower1</code> is adequate. When the program is ultimately <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004A4F" epub:type="pagebreak" id="P7000497027000000000000000004A4F" title="512"></span>deployed, however, it is entirely possible that the procedure could be applied to strings of over one million characters. All of a sudden this benign piece of code has become a major performance bottleneck. By contrast, the performance of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004319F" id="P700049702700000000000000004319F">lower2</code> will be adequate for strings of arbitrary length. Stories abound of major programming projects in which problems of this sort occur. Part of the job of a competent programmer is to avoid ever introducing such asymptotic inefficiency.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004A51" epub:type="practice" id="P7000497027000000000000000004A51"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431A0" epub:type="title" id="P70004970270000000000000000431A0"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.3 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000005090.xhtml#P70004970270000000000000000050DD">573</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P70004970270000000000000000431A1" id="P70004970270000000000000000431A1">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P70004970270000000000000000431A2" id="P70004970270000000000000000431A2">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431A3" id="P70004970270000000000000000431A3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000431A4" id="P70004970270000000000000000431A4">Consider the following functions:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000431A5" id="P70004970270000000000000000431A5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431A6" id="P70004970270000000000000000431A6">
long min(long x, long y) { return x &lt; y ? x : y; }
long max(long x, long y) { return x &lt; y ? y : x; }
void incr(long *xp, long v) { *xp += v; }
long square(long x) { return x*x; }
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000431A7" id="P70004970270000000000000000431A7">The following three code fragments call these functions:</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter05.xhtml#P70004970270000000000000000431A8" id="P70004970270000000000000000431A8">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000431A9" id="P70004970270000000000000000431A9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000431AA" id="P70004970270000000000000000431AA"></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000431AB" id="P70004970270000000000000000431AB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431AC" id="P70004970270000000000000000431AC">for (i = min(x, y); i &lt; max(x, y); incr(&amp;i, 1))
    t += square(i);
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000431AD" id="P70004970270000000000000000431AD"> </p>
</li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000431AE" id="P70004970270000000000000000431AE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000431AF" id="P70004970270000000000000000431AF"></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000431B0" id="P70004970270000000000000000431B0"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431B1" id="P70004970270000000000000000431B1">for (i = max(x, y) - 1; i &gt;= min(x, y); incr(&amp;i, −1))
    t += square(i);
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000431B2" id="P70004970270000000000000000431B2"> </p>
</li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000431B3" id="P70004970270000000000000000431B3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000431B4" id="P70004970270000000000000000431B4"></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000431B5" id="P70004970270000000000000000431B5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431B6" id="P70004970270000000000000000431B6">long low = min(x, y);
long high = max(x, y);</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000431B7" id="P70004970270000000000000000431B7"> </p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000431B8" id="P70004970270000000000000000431B8"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431B9" id="P70004970270000000000000000431B9">for (i = low; i &lt; high; incr(&amp;i, 1))
    t += square(i);
</code></pre>
</li></ol>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000431BA" id="P70004970270000000000000000431BA">Assume <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431BB" id="P70004970270000000000000000431BB">x</code> equals 10 and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431BC" id="P70004970270000000000000000431BC">y</code> equals 100. Fill in the following table indicating the number of times each of the four functions is called in code fragments A–C:</p></div></li>
</ol>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P70004970270000000000000000431BD" id="P70004970270000000000000000431BD">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431BE" id="P70004970270000000000000000431BE">Code</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431BF" id="P70004970270000000000000000431BF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431C0" id="P70004970270000000000000000431C0">min</code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431C1" id="P70004970270000000000000000431C1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431C2" id="P70004970270000000000000000431C2">max</code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431C3" id="P70004970270000000000000000431C3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431C4" id="P70004970270000000000000000431C4">incr</code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431C5" id="P70004970270000000000000000431C5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431C6" id="P70004970270000000000000000431C6">square</code></th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431C7" id="P70004970270000000000000000431C7">A.</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431C8" id="P70004970270000000000000000431C8">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431C9" id="P70004970270000000000000000431C9">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431CA" id="P70004970270000000000000000431CA">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431CB" id="P70004970270000000000000000431CB">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431CC" id="P70004970270000000000000000431CC">B.</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431CD" id="P70004970270000000000000000431CD">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431CE" id="P70004970270000000000000000431CE">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431CF" id="P70004970270000000000000000431CF">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431D0" id="P70004970270000000000000000431D0">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431D1" id="P70004970270000000000000000431D1">C.</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431D2" id="P70004970270000000000000000431D2">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431D3" id="P70004970270000000000000000431D3">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431D4" id="P70004970270000000000000000431D4">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431D5" id="P70004970270000000000000000431D5">_____</td>
</tr>
</tbody>
</table>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.5 Reducing Procedure Calls</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000004A83"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P70004970270000000000000000431D6" epub:type="title" id="P70004970270000000000000000431D6"><span class="pcalibre1 pcalibre21 pcalibre2">5.5 </span>Reducing Procedure Calls</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431D7" id="P70004970270000000000000000431D7">As we have seen, procedure calls can incur overhead and also block most forms of program optimization. We can see in the code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431D8" id="P70004970270000000000000000431D8">combine2</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000049CE.xhtml#P70004970270000000000000000049F6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.6</span></a>) that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431D9" id="P70004970270000000000000000431D9">get_vec_element</code> is called on every loop iteration to retrieve the next vector element. This function checks the vector index <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431DA" id="P70004970270000000000000000431DA">i</code> against the loop bounds with every vector reference, a clear source of inefficiency. Bounds checking might be a useful feature when dealing with arbitrary array accesses, but a simple analysis of the code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431DB" id="P70004970270000000000000000431DB">combine2</code> shows that all references will be valid.<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004A8D" epub:type="pagebreak" id="P7000497027000000000000000004A8D" title="513"></span></p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004A8A" id="P7000497027000000000000000004A8A">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431DC" id="P70004970270000000000000000431DC">---------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/opt/vec.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000431DD" id="P70004970270000000000000000431DD"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431DE" id="P70004970270000000000000000431DE">
1	data_t *get_vec_start(vec_ptr v)
2	{
3		return v-&gt;data;
4	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431DF" id="P70004970270000000000000000431DF">---------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/opt/vec.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000431E0" id="P70004970270000000000000000431E0"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431E1" id="P70004970270000000000000000431E1">
1	/* Direct access to vector data */
2	void combine3(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		data_t *data = get_vec_start(v); 
7
8		*dest = IDENT;
9		for (i = 0; i &lt; length; i++) {
10			*dest = *dest OP data[i];
11		}
12	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000431E2" id="P70004970270000000000000000431E2"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000431E3" epub:type="title" id="P70004970270000000000000000431E3"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.9 </span>Eliminating function calls within the loop.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431E4" id="P70004970270000000000000000431E4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000431E5" id="P70004970270000000000000000431E5">The resulting code does not show a performance gain, but it enables additional optimizations.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431E6" id="P70004970270000000000000000431E6">Suppose instead that we add a function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431E7" id="P70004970270000000000000000431E7">get_vec_start</code> to our abstract data type. This function returns the starting address of the data array, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004A8A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.9</span></a>. We could then write the procedure shown as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431E8" id="P70004970270000000000000000431E8">combine3</code> in this figure, having no function calls in the inner loop. Rather than making a function call to retrieve each vector element, it accesses the array directly. A purist might say that this transformation seriously impairs the program modularity. In principle, the user of the vector abstract data type should not even need to know that the vector contents are stored as an array, rather than as some other data structure such as a linked list. A more pragmatic programmer would argue that this transformation is a necessary step toward achieving high-performance results.</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P70004970270000000000000000431E9" id="P70004970270000000000000000431E9">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431EA" id="P70004970270000000000000000431EA"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431EB" id="P70004970270000000000000000431EB"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431EC" id="P70004970270000000000000000431EC"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000431ED" id="P70004970270000000000000000431ED">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000431EE" id="P70004970270000000000000000431EE">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431EF" id="P70004970270000000000000000431EF">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431F0" id="P70004970270000000000000000431F0">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431F1" id="P70004970270000000000000000431F1">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431F2" id="P70004970270000000000000000431F2">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431F3" id="P70004970270000000000000000431F3">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431F4" id="P70004970270000000000000000431F4">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000431F5" id="P70004970270000000000000000431F5">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431F6" id="P70004970270000000000000000431F6"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431F7" id="P70004970270000000000000000431F7">combine2</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431F8" id="P70004970270000000000000000431F8">509</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431F9" id="P70004970270000000000000000431F9">Move <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000431FA" id="P70004970270000000000000000431FA">vec_length</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431FB" id="P70004970270000000000000000431FB">7.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431FC" id="P70004970270000000000000000431FC">9.03</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431FD" id="P70004970270000000000000000431FD">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431FE" id="P70004970270000000000000000431FE">11.03</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000431FF" id="P70004970270000000000000000431FF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043200" id="P7000497027000000000000000043200">combine3</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043201" id="P7000497027000000000000000043201">513</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043202" id="P7000497027000000000000000043202">Direct data access</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043203" id="P7000497027000000000000000043203">7.17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043204" id="P7000497027000000000000000043204">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043205" id="P7000497027000000000000000043205">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043206" id="P7000497027000000000000000043206">11.03</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043207" id="P7000497027000000000000000043207">Surprisingly, there is no apparent performance improvement. Indeed, the performance for integer sum has gotten slightly worse. Evidently, other operations in the inner loop are forming a bottleneck that limits the performance more than the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043208" id="P7000497027000000000000000043208">get_vec_element</code>. We will return to this function later (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004E9A.xhtml#P7000497027000000000000000004ED1"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">5.11.2</span></a>) and see why the repeated bounds checking by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043209" id="P7000497027000000000000000043209">combine2</code> does not incur a performance penalty. For now, we can view this transformation as one of a series of steps that will ultimately lead to greatly improved performance.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.6 Eliminating Unneeded Memory References</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000004AB6"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P700049702700000000000000004320A" epub:type="title" id="P700049702700000000000000004320A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004AB8" epub:type="pagebreak" id="P7000497027000000000000000004AB8" title="514"></span><span class="pcalibre1 pcalibre21 pcalibre2">5.6 </span>Eliminating Unneeded Memory References</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004320B" id="P700049702700000000000000004320B">The code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004320C" id="P700049702700000000000000004320C">combine3</code> accumulates the value being computed by the combining operation at the location designated by the pointer <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004320D" id="P700049702700000000000000004320D">dest</code>. This attribute can be seen by examining the assembly code generated for the inner loop of the compiled code. We show here the x86-64 code generated for data type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004320E" id="P700049702700000000000000004320E">double</code> and with multiplication as the combining operation:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004320F" id="P700049702700000000000000004320F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043210" id="P7000497027000000000000000043210">
	<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of combine3. data_t = double, OP = *</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">dest in %rbx, data+i in %rdx, data+length in %rax</i>
1	. L17:				<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	   vmovsd (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043211" id="P7000497027000000000000000043211">%rbx</code>), %xmm0		  <i class="pcalibre17 pcalibre2 pcalibre1">Read product from dest</i>
3	   vmulsd (%rdx), %xmm0, %xmm0	  <i class="pcalibre17 pcalibre2 pcalibre1">Multiply product by data[i]</i>
4	   vmovsd %xmm0, (%rbx)		  <i class="pcalibre17 pcalibre2 pcalibre1">Store product at dest</i>
5	   addq $8, %rdx		  <i class="pcalibre17 pcalibre2 pcalibre1">Increment data+i</i>
6	   cmpq %rax, %rdx		  <i class="pcalibre17 pcalibre2 pcalibre1">Compare to data+length</i>
7	   jne .L17			  <i class="pcalibre17 pcalibre2 pcalibre1">If !=, goto</i> loop
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043212" id="P7000497027000000000000000043212">We see in this loop code that the address corresponding to pointer <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043213" id="P7000497027000000000000000043213">dest</code> is held in register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043214" id="P7000497027000000000000000043214">%rbx</code>. It has also transformed the code to maintain a pointer to the <var class="pcalibre17 pcalibre2 pcalibre1">i</var>th data element in register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043215" id="P7000497027000000000000000043215">%rdx</code>, shown in the annotations as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043216" id="P7000497027000000000000000043216">data+i</code>. This pointer is incremented by 8 on every iteration. The loop termination is detected by comparing this pointer to one stored in register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043217" id="P7000497027000000000000000043217">%rax</code>. We can see that the accumulated value is read from and written to memory on each iteration. This reading and writing is wasteful, since the value read from <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043218" id="P7000497027000000000000000043218">dest</code> at the beginning of each iteration should simply be the value written at the end of the previous iteration.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043219" id="P7000497027000000000000000043219">We can eliminate this needless reading and writing of memory by rewriting the code in the style of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004321A" id="P700049702700000000000000004321A">combine4</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004AD0"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.10</span></a>. We introduce a temporary variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004321B" id="P700049702700000000000000004321B">acc</code> that is used in the loop to accumulate the computed value. The result is stored at <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004321C" id="P700049702700000000000000004321C">dest</code> only after the loop has been completed. As the assembly code that follows shows, the compiler can now use register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004321D" id="P700049702700000000000000004321D">%xmm0</code> to hold the accumulated value. Compared to the loop in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004321E" id="P700049702700000000000000004321E">combine3</code>, we have reduced the memory operations per iteration from two reads and one write to just a single read.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004321F" id="P700049702700000000000000004321F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043220" id="P7000497027000000000000000043220">
	<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of combine4. data_t = double, OP = *</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">acc in %xmm0, data+i in %rdx, data+length in %rax</i>
1	.L25:				<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	  vmulsd (%rdx), %xmm0, %xmm0	  <i class="pcalibre17 pcalibre2 pcalibre1">Multiply acc by data[i]</i>
3	  addq $8, %rdx			  <i class="pcalibre17 pcalibre2 pcalibre1">Increment data+i</i>
4	  cmpq %rax, %rdx		  <i class="pcalibre17 pcalibre2 pcalibre1">Compare to data+length</i>
5	  jne .L25			  <i class="pcalibre17 pcalibre2 pcalibre1">If !=, goto</i> loop
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043221" id="P7000497027000000000000000043221">We see a significant improvement in program performance, as shown in the following table:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004AD0" id="P7000497027000000000000000004AD0">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043222" id="P7000497027000000000000000043222"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043223" id="P7000497027000000000000000043223">
<span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter05.xhtml#P7000497027000000000000000004AD3" epub:type="pagebreak" id="P7000497027000000000000000004AD3" title="515"></span>1	/* Accumulate result in local variable */
2	void combine4(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		data_t *data = get_vec_start(v);
7		data_t acc = IDENT;
8	
9		for (i = 0; i &lt; length; i++) {
10			acc = acc OP data[i];
11		}
12		*dest = acc;
13	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043224" id="P7000497027000000000000000043224"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043225" epub:type="title" id="P7000497027000000000000000043225"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.10 </span>Accumulating result in temporary.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043226" id="P7000497027000000000000000043226"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043227" id="P7000497027000000000000000043227">Holding the accumulated value in local variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043228" id="P7000497027000000000000000043228">acc</code> (short for "accumulator") eliminates the need to retrieve it from memory and write back the updated value on every loop iteration.</p></div></figcaption></figure>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P7000497027000000000000000043229" id="P7000497027000000000000000043229">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004322A" id="P700049702700000000000000004322A"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004322B" id="P700049702700000000000000004322B"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004322C" id="P700049702700000000000000004322C"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004322D" id="P700049702700000000000000004322D">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004322E" id="P700049702700000000000000004322E">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004322F" id="P700049702700000000000000004322F">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043230" id="P7000497027000000000000000043230">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043231" id="P7000497027000000000000000043231">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043232" id="P7000497027000000000000000043232">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043233" id="P7000497027000000000000000043233">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043234" id="P7000497027000000000000000043234">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043235" id="P7000497027000000000000000043235">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043236" id="P7000497027000000000000000043236"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043237" id="P7000497027000000000000000043237">combine3</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043238" id="P7000497027000000000000000043238">513</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043239" id="P7000497027000000000000000043239">Direct data access</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004323A" id="P700049702700000000000000004323A">7.17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004323B" id="P700049702700000000000000004323B">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004323C" id="P700049702700000000000000004323C">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004323D" id="P700049702700000000000000004323D">11.03</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004323E" id="P700049702700000000000000004323E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004323F" id="P700049702700000000000000004323F">combine4</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043240" id="P7000497027000000000000000043240">515</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043241" id="P7000497027000000000000000043241">Accumulate in temporary</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043242" id="P7000497027000000000000000043242">1.27</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043243" id="P7000497027000000000000000043243">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043244" id="P7000497027000000000000000043244">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043245" id="P7000497027000000000000000043245">5.01</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043246" id="P7000497027000000000000000043246">All of our times improve by factors ranging from 2.2× to 5.7×, with the integer addition case dropping to just 1.27 clock cycles per element.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043247" id="P7000497027000000000000000043247">Again, one might think that a compiler should be able to automatically transform the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043248" id="P7000497027000000000000000043248">combine3</code> code shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004A83.xhtml#P7000497027000000000000000004A8A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.9</span></a> to accumulate the value in a register, as it does with the code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043249" id="P7000497027000000000000000043249">combine4</code> shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004AD0"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.10</span></a>. In fact, however, the two functions can have different behaviors due to memory aliasing. Consider, for example, the case of integer data with multiplication as the operation and 1 as the identity element. Let <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004324A" id="P700049702700000000000000004324A">v</code> = [2, 3, 5] be a vector of three elements and consider the following two function calls:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004324B" id="P700049702700000000000000004324B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004324C" id="P700049702700000000000000004324C">
combine3(v, get_vec_start(v) + 2);
combine4(v, get_vec_start(v) + 2);
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004324D" id="P700049702700000000000000004324D">That is, we create an alias between the last element of the vector and the destination for storing the result. The two functions would then execute as follows:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P700049702700000000000000004324E" id="P700049702700000000000000004324E">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004324F" id="P700049702700000000000000004324F">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043250" id="P7000497027000000000000000043250">Initial</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043251" id="P7000497027000000000000000043251">Before loop</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043252" id="P7000497027000000000000000043252"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043253" id="P7000497027000000000000000043253">i</code> =0</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043254" id="P7000497027000000000000000043254"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043255" id="P7000497027000000000000000043255">i</code> =1</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043256" id="P7000497027000000000000000043256"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043257" id="P7000497027000000000000000043257">i</code> =2</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043258" id="P7000497027000000000000000043258">Final</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043259" id="P7000497027000000000000000043259"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004325A" id="P700049702700000000000000004325A">combine3</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004325B" id="P700049702700000000000000004325B">[2, 3, 5]</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004325C" id="P700049702700000000000000004325C">[2, 3, 1]</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004325D" id="P700049702700000000000000004325D">[2, 3, 2]</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004325E" id="P700049702700000000000000004325E">[2, 3, 6]</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004325F" id="P700049702700000000000000004325F">[2, 3, 36]</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043260" id="P7000497027000000000000000043260">[2, 3, 36]</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043261" id="P7000497027000000000000000043261"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043262" id="P7000497027000000000000000043262">combine4</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043263" id="P7000497027000000000000000043263">[2, 3, 5]</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043264" id="P7000497027000000000000000043264">[2, 3, 5]</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043265" id="P7000497027000000000000000043265">[2, 3, 5]</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043266" id="P7000497027000000000000000043266">[2, 3, 5]</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043267" id="P7000497027000000000000000043267">[2, 3, 5]</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043268" id="P7000497027000000000000000043268">[2, 3, 30]</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043269" id="P7000497027000000000000000043269"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004B1A" epub:type="pagebreak" id="P7000497027000000000000000004B1A" title="516"></span>As shown previously, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004326A" id="P700049702700000000000000004326A">combine3</code> accumulates its result at the destination, which in this case is the final vector element. This value is therefore set first to 1, then to 2 · 1 = 2, and then to 3 · 2 = 6. On the last iteration, this value is then multiplied by itself to yield a final value of 36. For the case of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004326B" id="P700049702700000000000000004326B">combine4</code>, the vector remains unchanged until the end, when the final element is set to the computed result 1 · 2 · 3 · 5 = 30.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004326C" id="P700049702700000000000000004326C">Of course, our example showing the distinction between <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004326D" id="P700049702700000000000000004326D">combine3</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004326E" id="P700049702700000000000000004326E">combine4</code> is highly contrived. One could argue that the behavior of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004326F" id="P700049702700000000000000004326F">combine4</code> more closely matches the intention of the function description. Unfortunately, a compiler cannot make a judgment about the conditions under which a function might be used and what the programmer's intentions might be. Instead, when given <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043270" id="P7000497027000000000000000043270">combine3</code> to compile, the conservative approach is to keep reading and writing memory, even though this is less efficient.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004B22" epub:type="practice" id="P7000497027000000000000000004B22"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043271" epub:type="title" id="P7000497027000000000000000043271"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.4 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P70004970270000000000000000050F8">574</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P7000497027000000000000000043272" id="P7000497027000000000000000043272">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P7000497027000000000000000043273" id="P7000497027000000000000000043273">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043274" id="P7000497027000000000000000043274"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043275" id="P7000497027000000000000000043275">When we use <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>to compile <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043276" id="P7000497027000000000000000043276">combine3</code> with command-line option <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043277" id="P7000497027000000000000000043277">−02</code>, we get code with substantially better CPE performance than with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043278" id="P7000497027000000000000000043278">−01</code>:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P7000497027000000000000000043279" id="P7000497027000000000000000043279">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004327A" id="P700049702700000000000000004327A"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004327B" id="P700049702700000000000000004327B"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004327C" id="P700049702700000000000000004327C"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004327D" id="P700049702700000000000000004327D">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004327E" id="P700049702700000000000000004327E">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004327F" id="P700049702700000000000000004327F">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043280" id="P7000497027000000000000000043280">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043281" id="P7000497027000000000000000043281">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043282" id="P7000497027000000000000000043282">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043283" id="P7000497027000000000000000043283">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043284" id="P7000497027000000000000000043284">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043285" id="P7000497027000000000000000043285">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043286" id="P7000497027000000000000000043286"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043287" id="P7000497027000000000000000043287">combine3</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043288" id="P7000497027000000000000000043288">513</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043289" id="P7000497027000000000000000043289">Compiled <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004328A" id="P700049702700000000000000004328A">−01</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004328B" id="P700049702700000000000000004328B">7.17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004328C" id="P700049702700000000000000004328C">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004328D" id="P700049702700000000000000004328D">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004328E" id="P700049702700000000000000004328E">11.03</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004328F" id="P700049702700000000000000004328F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043290" id="P7000497027000000000000000043290">combine3</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043291" id="P7000497027000000000000000043291">513</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043292" id="P7000497027000000000000000043292">Compiled <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043293" id="P7000497027000000000000000043293">−02</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043294" id="P7000497027000000000000000043294">1.60</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043295" id="P7000497027000000000000000043295">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043296" id="P7000497027000000000000000043296">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043297" id="P7000497027000000000000000043297">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043298" id="P7000497027000000000000000043298"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043299" id="P7000497027000000000000000043299">combine4</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004329A" id="P700049702700000000000000004329A">515</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004329B" id="P700049702700000000000000004329B">Accumulate in temporary</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004329C" id="P700049702700000000000000004329C">1.27</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004329D" id="P700049702700000000000000004329D">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004329E" id="P700049702700000000000000004329E">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004329F" id="P700049702700000000000000004329F">5.01</td>
</tr>
</tbody>
</table>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432A0" id="P70004970270000000000000000432A0">We achieve performance comparable to that for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432A1" id="P70004970270000000000000000432A1">combine4</code>, except for the case of integer sum, but even it improves significantly. On examining the assembly code generated by the compiler, we find an interesting variant for the inner loop:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432A2" id="P70004970270000000000000000432A2"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432A3" id="P70004970270000000000000000432A3">
	<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of combine3. data_t = double, OP = *. Compiled −02</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">dest in %rbx, data+i in %rdx, data+length in %rax</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">Accumulated product in %xmm0</i>
1	.L22:				<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	  vmulsd (%rdx), %xmm0, %xmm0	<i class="pcalibre17 pcalibre2 pcalibre1">Multiply product by data[i]</i>
3	  addq $8, %rdx			<i class="pcalibre17 pcalibre2 pcalibre1">Increment data+i</i>
4	  cmpq %rax, %rdx		<i class="pcalibre17 pcalibre2 pcalibre1">Compare to data+length</i>
5	  vmovsd %xmm0, (%rbx)		<i class="pcalibre17 pcalibre2 pcalibre1">Store product at dest</i>
6	  jne .L22			<i class="pcalibre17 pcalibre2 pcalibre1">If !=, goto</i> loop
</code></pre>
</div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P70004970270000000000000000432A4" id="P70004970270000000000000000432A4">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000432A5" id="P70004970270000000000000000432A5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432A6" id="P70004970270000000000000000432A6">We can compare this to the version created with optimization level 1:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432A7" id="P70004970270000000000000000432A7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432A8" id="P70004970270000000000000000432A8">
	<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of combine3. data_t = double, OP = *. Compiled −01</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">dest in %rbx, data+i in %rdx, data+length in %rax</i>
1	.L17:				<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	  vmovsd (%rbx), %xmm0		  <i class="pcalibre17 pcalibre2 pcalibre1">Read product from dest</i>
3	  vmulsd (%rdx), %xmm0, %xmm0	  <i class="pcalibre17 pcalibre2 pcalibre1">Multiply product by data[i]</i>
4	  vmovsd %xmm0, (%rbx)		  <i class="pcalibre17 pcalibre2 pcalibre1">Store product at dest</i>
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004B5B" epub:type="pagebreak" id="P7000497027000000000000000004B5B" title="517"></span>5	  addq $8, %rdx			  <i class="pcalibre17 pcalibre2 pcalibre1">Increment data+i</i>
6	  cmpq %rax, %rdx		  <i class="pcalibre17 pcalibre2 pcalibre1">Compare to data+length</i>
7	  jne .L17			  <i class="pcalibre17 pcalibre2 pcalibre1">If !=, goto</i> loop
</code></pre>
</div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P70004970270000000000000000432A9" id="P70004970270000000000000000432A9">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000432AA" id="P70004970270000000000000000432AA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432AB" id="P70004970270000000000000000432AB">We see that, besides some reordering of instructions, the only difference is that the more optimized version does not contain the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432AC" id="P70004970270000000000000000432AC">vmovsd</code> implementing the read from the location designated by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432AD" id="P70004970270000000000000000432AD">dest</code> (line 2).</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter05.xhtml#P70004970270000000000000000432AE" id="P70004970270000000000000000432AE">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432AF" id="P70004970270000000000000000432AF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432B0" id="P70004970270000000000000000432B0">How does the role of register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432B1" id="P70004970270000000000000000432B1">%xmm0</code> differ in these two loops?</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432B2" id="P70004970270000000000000000432B2"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432B3" id="P70004970270000000000000000432B3">Will the more optimized version faithfully implement the C code of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432B4" id="P70004970270000000000000000432B4">combine3</code>, including when there is memory aliasing between <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432B5" id="P70004970270000000000000000432B5">dest</code> and the vector data?</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432B6" id="P70004970270000000000000000432B6"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432B7" id="P70004970270000000000000000432B7">Either explain why this optimization preserves the desired behavior, or give an example where it would produce different results than the less optimized code.</p></li>
</ol></div></li>
</ol>
</section>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432B8" id="P70004970270000000000000000432B8">With this final transformation, we reached a point where we require just 1.25-5 clock cycles for each element to be computed. This is a considerable improvement over the original 9-11 cycles when we first enabled optimization. We would now like to see just what factors are constraining the performance of our code and how we can improve things even further.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.7 Understanding Modern Processors</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000004B6C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P70004970270000000000000000432B9" epub:type="title" id="P70004970270000000000000000432B9"><span class="pcalibre1 pcalibre21 pcalibre2">5.7 </span>Understanding Modern Processors</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432BA" id="P70004970270000000000000000432BA">Up to this point, we have applied optimizations that did not rely on any features of the target machine. They simply reduced the overhead of procedure calls and eliminated some of the critical "optimization blockers" that cause difficulties for optimizing compilers. As we seek to push the performance further, we must consider optimizations that exploit the <i class="pcalibre17 pcalibre2 pcalibre1">microarchitecture</i> of the processor—that is, the underlying system design by which a processor executes instructions. Getting every last bit of performance requires a detailed analysis of the program as well as code generation tuned for the target processor. Nonetheless, we can apply some basic optimizations that will yield an overall performance improvement on a large class of processors. The detailed performance results we report here may not hold for other machines, but the general principles of operation and optimization apply to a wide variety of machines.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432BB" id="P70004970270000000000000000432BB">To understand ways to improve performance, we require a basic understanding of the microarchitectures of modern processors. Due to the large number of transistors that can be integrated onto a single chip, modern microprocessors employ complex hardware that attempts to maximize program performance. One result is that their actual operation is far different from the view that is perceived by looking at machine-level programs. At the code level, it appears as if instructions are executed one at a time, where each instruction involves fetching values from registers or memory, performing an operation, and storing results back to a register or memory location. In the actual processor, a number of instructions <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004B70" epub:type="pagebreak" id="P7000497027000000000000000004B70" title="518"></span>are evaluated simultaneously, a phenomenon referred to as <i class="pcalibre17 pcalibre2 pcalibre1">instruction-level parallelism</i>. In some designs, there can be 100 or more instructions "in flight." Elaborate mechanisms are employed to make sure the behavior of this parallel execution exactly captures the sequential semantic model required by the machine-level program. This is one of the remarkable feats of modern microprocessors: they employ complex and exotic microarchitectures, in which multiple instructions can be executed in parallel, while presenting an operational view of simple sequential instruction execution.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432BC" id="P70004970270000000000000000432BC">Although the detailed design of a modern microprocessor is well beyond the scope of this book, having a general idea of the principles by which they operate suffices to understand how they achieve instruction-level parallelism. We will find that two different lower bounds characterize the maximum performance of a program. The <i class="pcalibre17 pcalibre2 pcalibre1">latency bound</i> is encountered when a series of operations must be performed in strict sequence, because the result of one operation is required before the next one can begin. This bound can limit program performance when the data dependencies in the code limit the ability of the processor to exploit instruction-level parallelism. The <i class="pcalibre17 pcalibre2 pcalibre1">throughput bound</i> characterizes the raw computing capacity of the processor's functional units. This bound becomes the ultimate limit on program performance.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004B72" id="P7000497027000000000000000004B72"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432BD" epub:type="title" id="P70004970270000000000000000432BD"><span class="pcalibre1 pcalibre21 pcalibre2">5.7.1 </span>Overall Operation</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432BE" id="P70004970270000000000000000432BE"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004B76"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.11</span></a> shows a very simplified view of a modern microprocessor. Our hypothetical processor design is based loosely on the structure of recent Intel processors. These processors are described in the industry as being <i class="pcalibre17 pcalibre2 pcalibre1">superscalar</i>, which means they can perform multiple operations on every clock cycle and <i class="pcalibre17 pcalibre2 pcalibre1">out of order</i>, meaning that the order in which instructions execute need not correspond to their ordering in the machine-level program. The overall design has two main parts: the <i class="pcalibre17 pcalibre2 pcalibre1">instruction control unit</i> (ICU), which is responsible for reading a sequence of instructions from memory and generating from these a set of primitive operations to perform on program data, and the <i class="pcalibre17 pcalibre2 pcalibre1">execution unit</i> (EU), which then executes these operations. Compared to the simple <i class="pcalibre17 pcalibre2 pcalibre1">in-order</i> pipeline we studied in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000003A76.xhtml#P7000497027000000000000000003A76"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">4</span></a>, out-of-order processors require far greater and more complex hardware, but they are better at achieving higher degrees of instruction-level parallelism.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432BF" id="P70004970270000000000000000432BF">The ICU reads the instructions from an <i class="pcalibre17 pcalibre2 pcalibre1">instruction cache</i>—a special high-speed memory containing the most recently accessed instructions. In general, the ICU fetches well ahead of the currently executing instructions, so that it has enough time to decode these and send operations down to the EU. One problem, however, is that when a program hits a branch,<a class="pcalibre1 pcalibre2 pcalibre56 pcalibre16 pcalibre14 pcalibre15" epub:type="noteref" href="#P7000497027000000000000000005188" id="r__P7000497027000000000000000005188">1</a> there are two possible directions the program might go. The branch can be <i class="pcalibre17 pcalibre2 pcalibre1">taken</i>, with control passing to the branch target. Alternatively, the branch can be <i class="pcalibre17 pcalibre2 pcalibre1">not taken</i>, with control passing to the next</p><aside class="pcalibre2 pcalibre32 pcalibre57" data-uri="chapter05.xhtml#P7000497027000000000000000005188" epub:type="footnote" id="P7000497027000000000000000005188"><p class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre58 pcalibre2"><a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="#r__P7000497027000000000000000005188">1. </a></span>We use the term "branch" specifically to refer to conditional jump instructions. Other instructions that can transfer control to multiple destinations, such as procedure return and indirect jumps, provide similar challenges for the processor.</p></aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004B76" id="P7000497027000000000000000004B76">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004B77" epub:type="pagebreak" id="P7000497027000000000000000004B77" title="519"></span>
<img alt="A block diagram depicts interactions between instruction control unit and execution unit." class="pcalibre1 pcalibre2 pcalibre191" data-uri="P700049702700000000000000000B711" id="P70004970270000000000000000432C0" src="Images/chapter-05-image-04.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000432C1" id="P70004970270000000000000000432C1"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000432C2" epub:type="title" id="P70004970270000000000000000432C2"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.11 </span>Block diagram of an out-of-order processor.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000432C3" id="P70004970270000000000000000432C3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432C4" id="P70004970270000000000000000432C4">The instruction control unit is responsible for reading instructions from memory and generating a sequence of primitive operations. The execution unit then performs the operations and indicates whether the branches were correctly predicted.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P70004970270000000000000000235A4" id="P70004970270000000000000000235A4">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432C5" id="P70004970270000000000000000432C5">The components of the instruction control unit and execution unit are summarized below.</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter05.xhtml#P70004970270000000000000000432C6" id="P70004970270000000000000000432C6">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432C7" id="P70004970270000000000000000432C7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432C8" id="P70004970270000000000000000432C8">Instruction control unit: the register file, within the retirement unit, sends output to instruction decode. The instruction cache receives address from fetch control and sends instructions to instruction decode.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432C9" id="P70004970270000000000000000432C9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432CA" id="P70004970270000000000000000432CA">Execution unit: the following function units interact with operation results: branch, arithmetic operations (two), load, and store. Load and store send and receive data between the data cache.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432CB" id="P70004970270000000000000000432CB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432CC" id="P70004970270000000000000000432CC">Operations from instruction decode are sent to the function units, and are also sent back to the retirement unit. Register updates are sent from operation results to the retirement unit. From branch, prediction ok? Is sent to the retirement unit and fetch control.</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432CD" id="P70004970270000000000000000432CD">instruction in the instruction sequence. Modern processors employ a technique known as <i class="pcalibre17 pcalibre2 pcalibre1">branch prediction</i>, in which they guess whether or not a branch will be taken and also predict the target address for the branch. Using a technique known as <i class="pcalibre17 pcalibre2 pcalibre1">speculative execution</i>, the processor begins fetching and decoding instructions at where it predicts the branch will go, and even begins executing these operations before it has been determined whether or not the branch prediction was correct. If it later determines that the branch was predicted incorrectly, it resets the state to that at the branch point and begins fetching and executing instructions in the other direction. The block labeled "Fetch control" incorporates branch prediction to perform the task of determining which instructions to fetch.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432CE" id="P70004970270000000000000000432CE">The <i class="pcalibre17 pcalibre2 pcalibre1">instruction decoding</i> logic takes the actual program instructions and converts them into a set of primitive <i class="pcalibre17 pcalibre2 pcalibre1">operations</i> (sometimes referred to as <i class="pcalibre17 pcalibre2 pcalibre1">micro-operations</i>). Each of these operations performs some simple computational task such as adding two numbers, reading data from memory, or writing data to memory. For machines with complex instructions, such as x86 processors, an instruction <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004B7F" epub:type="pagebreak" id="P7000497027000000000000000004B7F" title="520"></span>can be decoded into multiple operations. The details of how instructions are decoded into sequences of operations varies between machines, and this information is considered highly proprietary. Fortunately, we can optimize our programs without knowing the low-level details of a particular machine implementation.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432CF" id="P70004970270000000000000000432CF">In a typical x86 implementation, an instruction that only operates on registers, such as</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432D0" id="P70004970270000000000000000432D0"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432D1" id="P70004970270000000000000000432D1">
addq %rax,%rdx
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432D2" id="P70004970270000000000000000432D2">is converted into a single operation. On the other hand, an instruction involving one or more memory references, such as</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432D3" id="P70004970270000000000000000432D3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432D4" id="P70004970270000000000000000432D4">
addq %rax,8(%rdx)
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432D5" id="P70004970270000000000000000432D5">yields multiple operations, separating the memory references from the arithmetic operations. This particular instruction would be decoded as three operations: one to <i class="pcalibre17 pcalibre2 pcalibre1">load</i> a value from memory into the processor, one to add the loaded value to the value in register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432D6" id="P70004970270000000000000000432D6">%eax</code>, and one to <i class="pcalibre17 pcalibre2 pcalibre1">store</i> the result back to memory. The decoding splits instructions to allow a division of labor among a set of dedicated hardware units. These units can then execute the different parts of multiple instructions in parallel.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432D7" id="P70004970270000000000000000432D7">The EU receives operations from the instruction fetch unit. Typically, it can receive a number of them on each clock cycle. These operations are dispatched to a set of <i class="pcalibre17 pcalibre2 pcalibre1">functional units</i> that perform the actual operations. These functional units are specialized to handle different types of operations.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432D8" id="P70004970270000000000000000432D8">Reading and writing memory is implemented by the load and store units. The load unit handles operations that read data from the memory into the processor. This unit has an adder to perform address computations. Similarly, the store unit handles operations that write data from the processor to the memory. It also has an adder to perform address computations. As shown in the figure, the load and store units access memory via a <i class="pcalibre17 pcalibre2 pcalibre1">data cache</i>, a high-speed memory containing the most recently accessed data values.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432D9" id="P70004970270000000000000000432D9">With speculative execution, the operations are evaluated, but the final results are not stored in the program registers or data memory until the processor can be certain that these instructions should actually have been executed. Branch operations are sent to the EU, not to determine where the branch should go, but rather to determine whether or not they were predicted correctly. If the prediction was incorrect, the EU will discard the results that have been computed beyond the branch point. It will also signal the branch unit that the prediction was incorrect and indicate the correct branch destination. In this case, the branch unit begins fetching at the new location. As we saw in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.6.6</span></a>, such a <i class="pcalibre17 pcalibre2 pcalibre1">misprediction</i> incurs a significant cost in performance. It takes a while before the new instructions can be fetched, decoded, and sent to the functional units.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432DA" id="P70004970270000000000000000432DA"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004B76"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.11</span></a> indicates that the different functional units are designed to perform different operations. Those labeled as performing "arithmetic operations" are typically specialized to perform different combinations of integer and floating-point operations. As the number of transistors that can be integrated onto a single <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004B8C" epub:type="pagebreak" id="P7000497027000000000000000004B8C" title="521"></span>microprocessor chip has grown over time, successive models of microprocessors have increased the total number of functional units, the combinations of operations each unit can perform, and the performance of each of these units. The arithmetic units are intentionally designed to be able to perform a variety of different operations, since the required operations vary widely across different programs. For example, some programs might involve many integer operations, while others require many floating-point operations. If one functional unit were specialized to perform integer operations while another could only perform floating-point operations, then none of these programs would get the full benefit of having multiple functional units.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432DB" id="P70004970270000000000000000432DB">For example, our Intel Core i7 Has well reference machine has eight functional units, numbered 0−7. Here is a partial list of each one's capabilities:</p>
<ol class="pcalibre1 calibre19 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432DC" id="P70004970270000000000000000432DC" start="0">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432DD" id="P70004970270000000000000000432DD"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432DE" id="P70004970270000000000000000432DE">Integer arithmetic, floating-point multiplication, integer and floating-point division, branches</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432DF" id="P70004970270000000000000000432DF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432E0" id="P70004970270000000000000000432E0">Integer arithmetic, floating-point addition, integer multiplication, floating-point multiplication</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432E1" id="P70004970270000000000000000432E1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432E2" id="P70004970270000000000000000432E2">Load, address computation</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432E3" id="P70004970270000000000000000432E3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432E4" id="P70004970270000000000000000432E4">Load, address computation</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432E5" id="P70004970270000000000000000432E5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432E6" id="P70004970270000000000000000432E6">Store</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432E7" id="P70004970270000000000000000432E7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432E8" id="P70004970270000000000000000432E8">Integer arithmetic</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432E9" id="P70004970270000000000000000432E9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432EA" id="P70004970270000000000000000432EA">Integer arithmetic, branches</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000432EB" id="P70004970270000000000000000432EB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432EC" id="P70004970270000000000000000432EC">Store address computation</p></li>
</ol>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432ED" id="P70004970270000000000000000432ED">In the above list, "integer arithmetic" refers to basic operations, such as addition, bitwise operations, and shifting. Multiplication and division require more specialized resources. We see that a store operation requires two functional units—one to compute the store address and one to actually store the data. We will discuss the mechanics of store (and load) operations in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004F49"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432EE" id="P70004970270000000000000000432EE">We can see that this combination of functional units has the potential to perform multiple operations of the same type simultaneously. It has four units capable of performing integer operations, two that can perform load operations, and two that can perform floating-point multiplication. We will later see the impact these resources have on the maximum performance our programs can achieve.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432EF" id="P70004970270000000000000000432EF">Within the ICU, the <i class="pcalibre17 pcalibre2 pcalibre1">retirement unit</i> keeps track of the ongoing processing and makes sure that it obeys the sequential semantics of the machine-level program. Our figure shows a <i class="pcalibre17 pcalibre2 pcalibre1">register file</i> containing the integer, floating-point, and, more recently, SSE and AVX registers as part of the retirement unit, because this unit controls the updating of these registers. As an instruction is decoded, information about it is placed into a first-in, first-out queue. This information remains in the queue until one of two outcomes occurs. First, once the operations for the instruction have completed and any branch points leading to this instruction are confirmed as having been correctly predicted, the instruction can be <i class="pcalibre17 pcalibre2 pcalibre1">retired</i>, with any updates to the program registers being made. If some branch point leading to this instruction was mispredicted, on the other hand, the instruction will be</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000004BA2" id="P7000497027000000000000000004BA2"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter05.xhtml#P70004970270000000000000000432F0" epub:type="title" id="P70004970270000000000000000432F0"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004BA4" epub:type="pagebreak" id="P7000497027000000000000000004BA4" title="522"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>The history of out-of-order processing</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000432F1" id="P70004970270000000000000000432F1">Out-of-order processing was first implemented in the Control Data Corporation 6600 processor in 1964. Instructions were processed by 10 different functional units, each of which could be operated independently. In its day, this machine, with a clock rate of 10 MHz, was considered the premium machine for scientific computing.</p>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000432F2" id="P70004970270000000000000000432F2">IBM first implemented out-of-order processing with the IBM 360/91 processor in 1966, but just to execute the floating-point instructions. For around 25 years, out-of-order processing was considered an exotic technology, found only in machines striving for the highest possible performance, until IBM reintroduced it in the RS/6000 line of workstations in 1990. This design became the basis for the IBM/Motorola PowerPC line, with the model 601, introduced in 1993, becoming the first single-chip microprocessor to use out-of-order processing. Intel introduced out-of-order processing with its PentiumPro model in 1995, with an underlying microarchitecture similar to that of our reference machine.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432F3" id="P70004970270000000000000000432F3"><i class="pcalibre17 pcalibre2 pcalibre1">flushed</i>, discarding any results that may have been computed. By this means, mispredictions will not alter the program state.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432F4" id="P70004970270000000000000000432F4">As we have described, any updates to the program registers occur only as instructions are being retired, and this takes place only after the processor can be certain that any branches leading to this instruction have been correctly predicted. To expedite the communication of results from one instruction to another, much of this information is exchanged among the execution units, shown in the figure as "Operation results." As the arrows in the figure show, the execution units can send results directly to each other. This is a more elaborate form of the data-forwarding techniques we incorporated into our simple processor design in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000041EB_split_000.xhtml#P7000497027000000000000000004251"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">4.5.5</span></a>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000432F5" id="P70004970270000000000000000432F5">The most common mechanism for controlling the communication of operands among the execution units is called <i class="pcalibre17 pcalibre2 pcalibre1">register renaming</i>. When an instruction that updates register <var class="pcalibre17 pcalibre2 pcalibre1">r</var> is decoded, a <i class="pcalibre17 pcalibre2 pcalibre1">tag t</i> is generated giving a unique identifier to the result of the operation. An entry <i class="pcalibre17 pcalibre2 pcalibre1">(r, t)</i> is added to a table maintaining the association between program register <var class="pcalibre17 pcalibre2 pcalibre1">r</var> and tag <var class="pcalibre17 pcalibre2 pcalibre1">t</var> for an operation that will update this register. When a subsequent instruction using register <var class="pcalibre17 pcalibre2 pcalibre1">r</var> as an operand is decoded, the operation sent to the execution unit will contain <var class="pcalibre17 pcalibre2 pcalibre1">t</var> as the source for the operand value. When some execution unit completes the first operation, it generates a result <i class="pcalibre17 pcalibre2 pcalibre1">(v, t)</i>, indicating that the operation with tag <var class="pcalibre17 pcalibre2 pcalibre1">t</var> produced value <var class="pcalibre17 pcalibre2 pcalibre1">v</var>. Any operation waiting for <var class="pcalibre17 pcalibre2 pcalibre1">t</var> as a source will then use <var class="pcalibre17 pcalibre2 pcalibre1">v</var> as the source value, a form of data forwarding. By this mechanism, values can be forwarded directly from one operation to another, rather than being written to and read from the register file, enabling the second operation to begin as soon as the first has completed. The renaming table only contains entries for registers having pending write operations. When a decoded instruction requires a register <var class="pcalibre17 pcalibre2 pcalibre1">r</var>, and there is no tag associated with this register, the operand is retrieved directly from the register file. With register renaming, an entire sequence of operations can be performed speculatively, even though the registers are updated only after the processor is certain of the branch outcomes.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004BAA" id="P7000497027000000000000000004BAA">
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P70004970270000000000000000432F6" id="P70004970270000000000000000432F6">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000432F7" id="P70004970270000000000000000432F7"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="3" data-uri="chapter05.xhtml#P70004970270000000000000000432F8" id="P70004970270000000000000000432F8"><span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter05.xhtml#P7000497027000000000000000004BAE" epub:type="pagebreak" id="P7000497027000000000000000004BAE" title="523"></span>Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="3" data-uri="chapter05.xhtml#P70004970270000000000000000432F9" id="P70004970270000000000000000432F9">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000432FA" id="P70004970270000000000000000432FA">Operation</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000432FB" id="P70004970270000000000000000432FB">Latency</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000432FC" id="P70004970270000000000000000432FC">Issue</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000432FD" id="P70004970270000000000000000432FD">Capacity</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000432FE" id="P70004970270000000000000000432FE">Latency</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000432FF" id="P70004970270000000000000000432FF">Issue</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043300" id="P7000497027000000000000000043300">Capacity</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043301" id="P7000497027000000000000000043301">Addition</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043302" id="P7000497027000000000000000043302">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043303" id="P7000497027000000000000000043303">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043304" id="P7000497027000000000000000043304">4</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043305" id="P7000497027000000000000000043305">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043306" id="P7000497027000000000000000043306">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043307" id="P7000497027000000000000000043307">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043308" id="P7000497027000000000000000043308">Multiplication</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043309" id="P7000497027000000000000000043309">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004330A" id="P700049702700000000000000004330A">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004330B" id="P700049702700000000000000004330B">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004330C" id="P700049702700000000000000004330C">5</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004330D" id="P700049702700000000000000004330D">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004330E" id="P700049702700000000000000004330E">2</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004330F" id="P700049702700000000000000004330F">Division</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043310" id="P7000497027000000000000000043310">3−30</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043311" id="P7000497027000000000000000043311">3−30</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043312" id="P7000497027000000000000000043312">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043313" id="P7000497027000000000000000043313">3−15</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043314" id="P7000497027000000000000000043314">3−15</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043315" id="P7000497027000000000000000043315">1</td>
</tr>
</tbody>
</table>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043316" id="P7000497027000000000000000043316"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043317" epub:type="title" id="P7000497027000000000000000043317"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.12 </span>Latency, issue time, and capacity characteristics of reference machine operations.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043318" id="P7000497027000000000000000043318"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043319" id="P7000497027000000000000000043319">Latency indicates the total number of clock cycles required to perform the actual operations, while issue time indicates the minimum number of cycles between two independent operations. The capacity indicates how many of these operations can be issued simultaneously. The times for division depend on the data values.</p></div></figcaption></figure>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004BD0" id="P7000497027000000000000000004BD0"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004331A" epub:type="title" id="P700049702700000000000000004331A"><span class="pcalibre1 pcalibre21 pcalibre2">5.7.2 </span>Functional Unit Performance</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004331B" id="P700049702700000000000000004331B"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004BAA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a> documents the performance of some of the arithmetic operations for our Intel Core i7 Haswell reference machine, determined by both measurements and by reference to Intel literature [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B404">49</a>]. These timings are typical for other processors as well. Each operation is characterized by its <i class="pcalibre17 pcalibre2 pcalibre1">latency</i>, meaning the total time required to perform the operation, the <i class="pcalibre17 pcalibre2 pcalibre1">issue time</i>, meaning the minimum number of clock cycles between two independent operations of the same type, and the <i class="pcalibre17 pcalibre2 pcalibre1">capacity</i>, indicating the number of functional units capable of performing that operation.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004331C" id="P700049702700000000000000004331C">We see that the latencies increase in going from integer to floating-point operations. We see also that the addition and multiplication operations all have issue times of 1, meaning that on each clock cycle, the processor can start a new one of these operations. This short issue time is achieved through the use of <i class="pcalibre17 pcalibre2 pcalibre1">pipelining</i>. A pipelined function unit is implemented as a series of <i class="pcalibre17 pcalibre2 pcalibre1">stages</i>, each of which performs part of the operation. For example, a typical floating-point adder contains three stages (and hence the three-cycle latency): one to process the exponent values, one to add the fractions, and one to round the result. The arithmetic operations can proceed through the stages in close succession rather than waiting for one operation to complete before the next begins. This capability can be exploited only if there are successive, logically independent operations to be performed. Functional units with issue times of 1 cycle are said to be <i class="pcalibre17 pcalibre2 pcalibre1">fully pipelined:</i> they can start a new operation every clock cycle. Operations with capacity greater than 1 arise due to the capabilities of the multiple functional units, as was described earlier for the reference machine.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004331D" id="P700049702700000000000000004331D">We see also that the divider (used for integer and floating-point division, as well as floating-point square root) is not pipelined—its issue time equals its latency. What this means is that the divider must perform a complete division before it can begin anew one. We also see that the latencies and issue times for division are given as ranges, because some combinations of dividend and divisor require more steps than others. The long latency and issue times of division make it a comparatively costly operation.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004331E" id="P700049702700000000000000004331E"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004BD6" epub:type="pagebreak" id="P7000497027000000000000000004BD6" title="524"></span>A more common way of expressing issue time is to specify the maximum <i class="pcalibre17 pcalibre2 pcalibre1">throughput</i> of the unit, defined as the reciprocal of the issue time. A fully pipelined functional unit has a maximum throughput of 1 operation per clock cycle, while units with higher issue times have lower maximum throughput. Having multiple functional units can increase throughput even further. For an operation with capacity <var class="pcalibre17 pcalibre2 pcalibre1">C</var> and issue time <var class="pcalibre17 pcalibre2 pcalibre1">I</var>, the processor can potentially achieve a throughput of <i class="pcalibre17 pcalibre2 pcalibre1">C/I</i> operations per clock cycle. For example, our reference machine is capable of performing floating-point multiplication operations at a rate of 2 per clock cycle. We will see how this capability can be exploited to increase program performance.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004331F" id="P700049702700000000000000004331F">Circuit designers can create functional units with wide ranges of performance characteristics. Creating a unit with short latency or with pipelining requires more hardware, especially for more complex functions such as multiplication and floating-point operations. Since there is only a limited amount of space for these units on the microprocessor chip, CPU designers must carefully balance the number of functional units and their individual performance to achieve optimal overall performance. They evaluate many different benchmark programs and dedicate the most resources to the most critical operations. As <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004BAA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a> indicates, integer multiplication and floating-point multiplication and addition were considered important operations in the design of the Core i7 Haswell processor, even though a significant amount of hardware is required to achieve the low latencies and high degree of pipelining shown. On the other hand, division is relatively infrequent and difficult to implement with either short latency or full pipelining.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043320" id="P7000497027000000000000000043320">The latencies, issue times, and capacities of these arithmetic operations can affect the performance of our combining functions. We can express these effects in terms of two fundamental bounds on the CPE values:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P7000497027000000000000000043321" id="P7000497027000000000000000043321">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043322" id="P7000497027000000000000000043322"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043323" id="P7000497027000000000000000043323">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043324" id="P7000497027000000000000000043324">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043325" id="P7000497027000000000000000043325">Bound</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043326" id="P7000497027000000000000000043326">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043327" id="P7000497027000000000000000043327">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043328" id="P7000497027000000000000000043328">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043329" id="P7000497027000000000000000043329">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004332A" id="P700049702700000000000000004332A">Latency</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004332B" id="P700049702700000000000000004332B">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004332C" id="P700049702700000000000000004332C">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004332D" id="P700049702700000000000000004332D">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004332E" id="P700049702700000000000000004332E">5.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004332F" id="P700049702700000000000000004332F">Throughput</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043330" id="P7000497027000000000000000043330">0.50</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043331" id="P7000497027000000000000000043331">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043332" id="P7000497027000000000000000043332">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043333" id="P7000497027000000000000000043333">0.50</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043334" id="P7000497027000000000000000043334">The <i class="pcalibre17 pcalibre2 pcalibre1">latency bound</i> gives a minimum value for the CPE for any function that must perform the combining operation in a strict sequence. The <i class="pcalibre17 pcalibre2 pcalibre1">throughput bound</i> gives a minimum bound for the CPE based on the maximum rate at which the functional units can produce results. For example, since there is only one integer multiplier, and it has an issue time of 1 clock cycle, the processor cannot possibly sustain a rate of more than 1 multiplication per clock cycle. On the other hand, with four functional units capable of performing integer addition, the processor can potentially sustain a rate of 4 operations per cycle. Unfortunately, the need to read elements from memory creates an additional throughput bound. The two load units limit the processor to reading at most 2 data values per clock cycle, yielding a throughput bound of 0.50. We will demonstrate the effect of both the latency and throughput bounds with different versions of the combining functions.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004BED" id="P7000497027000000000000000004BED"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043335" epub:type="title" id="P7000497027000000000000000043335"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004BEF" epub:type="pagebreak" id="P7000497027000000000000000004BEF" title="525"></span><span class="pcalibre1 pcalibre21 pcalibre2">5.7.3 </span>An Abstract Model of Processor Operation</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043336" id="P7000497027000000000000000043336">As a tool for analyzing the performance of a machine-level program executing on a modern processor, we will use a <i class="pcalibre17 pcalibre2 pcalibre1">data-flow</i> representation of programs, a graphical notation showing how the data dependencies between the different operations constrain the order in which they are executed. These constraints then lead to <i class="pcalibre17 pcalibre2 pcalibre1">critical paths</i> in the graph, putting a lower bound on the number of clock cycles required to execute a set of machine instructions.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043337" id="P7000497027000000000000000043337">Before proceeding with the technical details, it is instructive to examine the CPE measurements obtained for function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043338" id="P7000497027000000000000000043338">combine4</code>, our fastest code up to this point:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P7000497027000000000000000043339" id="P7000497027000000000000000043339">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004333A" id="P700049702700000000000000004333A"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004333B" id="P700049702700000000000000004333B"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004333C" id="P700049702700000000000000004333C"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004333D" id="P700049702700000000000000004333D">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004333E" id="P700049702700000000000000004333E">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004333F" id="P700049702700000000000000004333F">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043340" id="P7000497027000000000000000043340">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043341" id="P7000497027000000000000000043341">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043342" id="P7000497027000000000000000043342">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043343" id="P7000497027000000000000000043343">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043344" id="P7000497027000000000000000043344">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043345" id="P7000497027000000000000000043345">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043346" id="P7000497027000000000000000043346"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043347" id="P7000497027000000000000000043347">combine4</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043348" id="P7000497027000000000000000043348">515</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043349" id="P7000497027000000000000000043349">Accumulate in temporary</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004334A" id="P700049702700000000000000004334A">1.27</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004334B" id="P700049702700000000000000004334B">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004334C" id="P700049702700000000000000004334C">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004334D" id="P700049702700000000000000004334D">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="3" data-uri="chapter05.xhtml#P700049702700000000000000004334E" id="P700049702700000000000000004334E">Latency bound</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004334F" id="P700049702700000000000000004334F">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043350" id="P7000497027000000000000000043350">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043351" id="P7000497027000000000000000043351">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043352" id="P7000497027000000000000000043352">5.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="3" data-uri="chapter05.xhtml#P7000497027000000000000000043353" id="P7000497027000000000000000043353">Throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043354" id="P7000497027000000000000000043354">0.50</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043355" id="P7000497027000000000000000043355">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043356" id="P7000497027000000000000000043356">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043357" id="P7000497027000000000000000043357">0.50</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043358" id="P7000497027000000000000000043358">We can see that these measurements match the latency bound for the processor, except for the case of integer addition. This is not a coincidence—it indicates that the performance of these functions is dictated by the latency of the sum or product computation being performed. Computing the product or sum of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> elements requires around <i class="pcalibre17 pcalibre2 pcalibre1">L · n</i> + <var class="pcalibre17 pcalibre2 pcalibre1">K</var> clock cycles, where <var class="pcalibre17 pcalibre2 pcalibre1">L</var> is the latency of the combining operation and <var class="pcalibre17 pcalibre2 pcalibre1">K</var> represents the overhead of calling the function and initiating and terminating the loop. The CPE is therefore equal to the latency bound <var class="pcalibre17 pcalibre2 pcalibre1">L</var>.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004C13" id="P7000497027000000000000000004C13"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043359" epub:type="title" id="P7000497027000000000000000043359">From Machine-Level Code to Data-Flow Graphs</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004335A" id="P700049702700000000000000004335A">Our data-flow representation of programs is informal. We use it as a way to visualize how the data dependencies in a program dictate its performance. We present the data-flow notation by working with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004335B" id="P700049702700000000000000004335B">combine4</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004AB6.xhtml#P7000497027000000000000000004AD0"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.10</span></a>) as an example. We focus just on the computation performed by the loop, since this is the dominating factor in performance for large vectors. We consider the case of data type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004335C" id="P700049702700000000000000004335C">double</code> with multiplication as the combining operation. Other combinations of data type and operation yield similar code. The compiled code for this loop consists of four instructions, with registers <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004335D" id="P700049702700000000000000004335D">%rdx</code> holding a pointer to the <var class="pcalibre17 pcalibre2 pcalibre1">i</var>th element of array data, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004335E" id="P700049702700000000000000004335E">%rax</code> holding a pointer to the end of the array, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004335F" id="P700049702700000000000000004335F">%xmm0</code> holding the accumulated value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043360" id="P7000497027000000000000000043360">acc</code>.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043361" id="P7000497027000000000000000043361"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043362" id="P7000497027000000000000000043362">
	<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of combine4. data_t = double, OP = *</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">acc in %xmm0, data+i in %rdx, data+length in %rax</i>
1	.L25:				<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	  vmulsd (%rdx), %xmm0, %xmm0	  <i class="pcalibre17 pcalibre2 pcalibre1">Multiply acc by data[i]</i>
3	  addq $8, %rdx			  <i class="pcalibre17 pcalibre2 pcalibre1">Increment data+i</i>
4	  cmpq %rax, %rdx		  <i class="pcalibre17 pcalibre2 pcalibre1">Compare to data+length</i>
5	  jne .L25			  <i class="pcalibre17 pcalibre2 pcalibre1">If !=, goto</i> loop
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004C1E" id="P7000497027000000000000000004C1E">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004C1F" epub:type="pagebreak" id="P7000497027000000000000000004C1F" title="526"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for combine4." class="pcalibre1 pcalibre2 pcalibre192" data-uri="P700049702700000000000000000B712" id="P7000497027000000000000000043363" src="Images/chapter-05-image-05.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043364" id="P7000497027000000000000000043364"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043365" epub:type="title" id="P7000497027000000000000000043365"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13 </span>Graphical representation of inner-loop code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043366" id="P7000497027000000000000000043366">combine4</code></h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043367" id="P7000497027000000000000000043367"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043368" id="P7000497027000000000000000043368">Instructions are dynamically translated into one or two operations, each of which receives values from other operations or from registers and produces values for other operations and for registers. We show the target of the final instruction as the label loop. It jumps to the first instruction shown.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P7000497027000000000000000023649" id="P7000497027000000000000000023649">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043369" id="P7000497027000000000000000043369">A diagram has two rows of boxes, each with %rax, %rdx, and %rmm0, with output from top %rax to bottom %rax. A column of boxes includes the five operations summarized below, from top to bottom:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter05.xhtml#P700049702700000000000000004336A" id="P700049702700000000000000004336A">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004336B" id="P700049702700000000000000004336B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004336C" id="P700049702700000000000000004336C">load: receives input from top %rdx; sends output to mul below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004336D" id="P700049702700000000000000004336D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004336E" id="P700049702700000000000000004336E">mul: receives input from load, with the two together representing vmulsd (%rdx), %rmm0, %rmm0; receives input from top %rmm0</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004336F" id="P700049702700000000000000004336F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043370" id="P7000497027000000000000000043370">add (addq $8, %rdx): receives input from top %rdx and sends output to bottom %rmm0</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043371" id="P7000497027000000000000000043371"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043372" id="P7000497027000000000000000043372">cmp (cmpq %rax, %rdx): receives input from add above and top %rax; sends output to jne below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043373" id="P7000497027000000000000000043373"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043374" id="P7000497027000000000000000043374">jne (jne loop); receives input from cmp above and top %rax</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043375" id="P7000497027000000000000000043375">As <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> indicates, with our hypothetical processor design, the four instructions are expanded by the instruction decoder into a series of five <i class="pcalibre17 pcalibre2 pcalibre1">operations</i>, with the initial multiplication instruction being expanded into a load operation to read the source operand from memory, and a mul operation to perform the multiplication.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043376" id="P7000497027000000000000000043376">As a step toward generating a data-flow graph representation of the program, the boxes and lines along the left-hand side of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> show how the registers are used and updated by the different operations, with the boxes along the top representing the register values at the beginning of the loop, and those along the bottom representing the values at the end. For example, register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043377" id="P7000497027000000000000000043377">%rax</code> is only used as a source value by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043378" id="P7000497027000000000000000043378">cmp</code> operation, and so the register has the same value at the end of the loop as at the beginning. Register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043379" id="P7000497027000000000000000043379">%rdx</code>, on the other hand, is both used and updated within the loop. Its initial value is used by the load and add operations; its new value is generated by the add operation, which is then used by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004337A" id="P700049702700000000000000004337A">cmp</code> operation. Register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004337B" id="P700049702700000000000000004337B">%xmm0</code> is also updated within the loop by the mul operation, which first uses the initial value as a source value.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004337C" id="P700049702700000000000000004337C">Some of the operations in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> produce values that do not correspond to registers. We show these as arcs between operations on the right-hand side. The load operation reads a value from memory and passes it directly to the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004337D" id="P700049702700000000000000004337D">mul</code> operation. Since these two operations arise from decoding a single <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004337E" id="P700049702700000000000000004337E">vmulsd</code> instruction, there is no register associated with the intermediate value passing between them. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004337F" id="P700049702700000000000000004337F">cmp</code> operation updates the condition codes, and these are then tested by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043380" id="P7000497027000000000000000043380">jne</code> operation.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043381" id="P7000497027000000000000000043381">For a code segment forming a loop, we can classify the registers that are accessed into four categories:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004C33" id="P7000497027000000000000000004C33">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004C34" epub:type="pagebreak" id="P7000497027000000000000000004C34" title="527"></span>
<img alt="A diagram depicts two data-flow graphs for combine4." class="pcalibre1 pcalibre2 pcalibre193" data-uri="P700049702700000000000000000B713" id="P7000497027000000000000000043382" src="Images/chapter-05-image-06.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043383" id="P7000497027000000000000000043383"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043384" epub:type="title" id="P7000497027000000000000000043384"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14 </span>Abstracting <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043385" id="P7000497027000000000000000043385">combine4</code> operations as a data-flow graph.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043386" id="P7000497027000000000000000043386"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043387" id="P7000497027000000000000000043387">We rearrange the operators of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.13</span></a> to more clearly show the data dependencies (a), and then further show only those operations that use values from one iteration to produce new values for the next (b).</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P7000497027000000000000000023669" id="P7000497027000000000000000023669">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre141" data-uri="chapter05.xhtml#P7000497027000000000000000043388" id="P7000497027000000000000000043388">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043389" id="P7000497027000000000000000043389"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004338A" id="P700049702700000000000000004338A">Data flows from top %rmm0 to mul to bottom %rmm0; from top %rax to cmp to jne; from top %rdx to load and add. From load, data is sent to mul and bottom %rmm0. From add, data is sent to bottom %rdx and to cmp, sent to jne.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004338B" id="P700049702700000000000000004338B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004338C" id="P700049702700000000000000004338C">Operations within data[i]: data flows from top %rmm0 to mul to bottom %rmm0; from top %rdx to load and add, with load leading to mul and add leading to bottom %rdx.</p></li>
</ol>
</details>
</figcaption></figure>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004338D" id="P700049702700000000000000004338D">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004338E" id="P700049702700000000000000004338E"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P700049702700000000000000004338F" id="P700049702700000000000000004338F"><span class="pcalibre1 pcalibre2 pcalibre41">Read-only. </span>These are used as source values, either as data or to compute memory addresses, but they are not modified within the loop. The only read only register for the loop in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043390" id="P7000497027000000000000000043390">combine4</code> is <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043391" id="P7000497027000000000000000043391">%rax</code>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043392" id="P7000497027000000000000000043392"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043393" id="P7000497027000000000000000043393"><span class="pcalibre1 pcalibre2 pcalibre41">Write-only. </span>These are used as the destinations of data-movement operations. There are no such registers in this loop.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043394" id="P7000497027000000000000000043394"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043395" id="P7000497027000000000000000043395"><span class="pcalibre1 pcalibre2 pcalibre41">Local. </span>These are updated and used within the loop, but there is no dependency from one iteration to another. The condition code registers are examples for this loop: they are updated by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043396" id="P7000497027000000000000000043396">cmp</code> operation and used by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043397" id="P7000497027000000000000000043397">jne</code> operation, but this dependency is contained within individual iterations.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043398" id="P7000497027000000000000000043398"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043399" id="P7000497027000000000000000043399"><span class="pcalibre1 pcalibre2 pcalibre41">Loop. </span>These are used both as source values and as destinations for the loop, with the value generated in one iteration being used in another. We can see that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004339A" id="P700049702700000000000000004339A">%rdx</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004339B" id="P700049702700000000000000004339B">%xmm0</code> are loop registers for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004339C" id="P700049702700000000000000004339C">combine4</code>, corresponding to program values <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004339D" id="P700049702700000000000000004339D">data+i</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004339E" id="P700049702700000000000000004339E">acc</code>.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004339F" id="P700049702700000000000000004339F">As we will see, the chains of operations between loop registers determine the performance-limiting data dependencies.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433A0" id="P70004970270000000000000000433A0"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14</span></a> shows further refinements of the graphical representation of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a>, with a goal of showing only those operations and data dependencies that affect the program execution time. We see in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14(a)</span></a> that we rearranged the operators to show more clearly the flow of data from the source registers at the top (both read-only and loop registers) and to the destination registers at the bottom (both write-only and loop registers).</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433A1" id="P70004970270000000000000000433A1">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14(a)</span></a>, we also color operators white if they are not part of some chain of dependencies between loop registers. For this example, the comparison (cmp) and branch (jne) operations do not directly affect the flow of data in the program. We assume that the instruction control unit predicts that branch will be taken, and hence the program will continue looping. The purpose of the compare and branch operations is to test the branch condition and notify the ICU if it is <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004C50" epub:type="pagebreak" id="P7000497027000000000000000004C50" title="528"></span>not taken. We assume this checking can be done quickly enough that it does not slow down the processor.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433A2" id="P70004970270000000000000000433A2">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14(b)</span></a>, we have eliminated the operators that were colored white on the left, and we have retained only the loop registers. What we have left is an abstract template showing the data dependencies that form among loop registers due to one iteration of the loop. We can see in this diagram that there are two data dependencies from one iteration to the next. Along one side, we see the dependencies between successive values of program value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433A3" id="P70004970270000000000000000433A3">acc</code>, stored in register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433A4" id="P70004970270000000000000000433A4">%xmm0</code>. The loop computes a new value for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433A5" id="P70004970270000000000000000433A5">acc</code> by multiplying the old value by a data element, generated by the load operation. Along the other side, we see the dependencies between successive values of the pointer to the <var class="pcalibre17 pcalibre2 pcalibre1">i</var>th data element. On each iteration, the old value is used as the address for the load operation, and it is also incremented by the add operation to compute its new value.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433A6" id="P70004970270000000000000000433A6"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C57"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15</span></a> shows the data-flow representation of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> iterations by the inner loop of function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433A7" id="P70004970270000000000000000433A7">combine4</code>. This graph was obtained by simply replicating the template shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14(b)</span></a><var class="pcalibre17 pcalibre2 pcalibre1">n</var>times.Wecan see that the program has two chains of data</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004C57" id="P7000497027000000000000000004C57">
<img alt="A diagram shows a critical path extending through mul operations from data[0] to data[1] to data[n minus 2] to data[n minus 1]." class="pcalibre194 pcalibre1 pcalibre2" data-uri="P700049702700000000000000000B714" id="P70004970270000000000000000433A8" src="Images/chapter-05-image-07.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000433A9" id="P70004970270000000000000000433A9"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000433AA" epub:type="title" id="P70004970270000000000000000433AA"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15 </span>Data-flow representation of computation by <var class="pcalibre17 pcalibre2 pcalibre1">n</var> iterations of the inner loop of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433AB" id="P70004970270000000000000000433AB">combine4</code>.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433AC" id="P70004970270000000000000000433AC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433AD" id="P70004970270000000000000000433AD">The sequence of multiplication operations forms a critical path that limits program performance.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433AE" id="P70004970270000000000000000433AE"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004C5F" epub:type="pagebreak" id="P7000497027000000000000000004C5F" title="529"></span>dependencies, corresponding to the updating of program values <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433AF" id="P70004970270000000000000000433AF">acc</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433B0" id="P70004970270000000000000000433B0">data+i</code> with operations mul and add, respectively. Given that floating-point multiplication has a latency of 5 cycles, while integer addition has a latency of 1 cycle, we can see that the chain on the left will form a <i class="pcalibre17 pcalibre2 pcalibre1">critical path</i>, requiring 5<var class="pcalibre17 pcalibre2 pcalibre1">n</var> cycles to execute. The chain on the right would require only <var class="pcalibre17 pcalibre2 pcalibre1">n</var> cycles to execute, and so it does not limit the program performance.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433B1" id="P70004970270000000000000000433B1"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C57"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15</span></a> demonstrates why we achieved a CPE equal to the latency bound of 5 cycles for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433B2" id="P70004970270000000000000000433B2">combine4</code>, when performing floating-point multiplication. When executing the function, the floating-point multiplier becomes the limiting resource. The other operations required during the loop—manipulating and testing pointer value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433B3" id="P70004970270000000000000000433B3">data+i</code> and reading data from memory—proceed in parallel with the multiplication. As each successive value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433B4" id="P70004970270000000000000000433B4">acc</code> is computed, it is fed back around to compute the next value, but this will not occur until 5 cycles later.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433B5" id="P70004970270000000000000000433B5">The flow for other combinations of data type and operation are identical to those shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C57"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15</span></a>, but with a different data operation forming the chain of data dependencies shown on the left. For all of the cases where the operation has a latency <var class="pcalibre17 pcalibre2 pcalibre1">L</var> greater than 1, we see that the measured CPE is simply <var class="pcalibre17 pcalibre2 pcalibre1">L</var>, indicating that this chain forms the performance-limiting critical path.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004C67" id="P7000497027000000000000000004C67"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433B6" epub:type="title" id="P70004970270000000000000000433B6">Other Performance Factors</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433B7" id="P70004970270000000000000000433B7">For the case of integer addition, on the other hand, our measurements of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433B8" id="P70004970270000000000000000433B8">combine4</code> show a CPE of 1.27, slower than the CPE of 1.00 we would predict based on the chains of dependencies formed along either the left- or the right-hand side of the graph of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C57"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15</span></a>. This illustrates the principle that the critical paths in a data-flow representation provide only a <i class="pcalibre17 pcalibre2 pcalibre1">lower</i> bound on how many cycles a program will require. Other factors can also limit performance, including the total number of functional units available and the number of data values that can be passed among the functional units on any given step. For the case of integer addition as the combining operation, the data operation is sufficiently fast that the rest of the operations cannot supply data fast enough. Determining exactly why the program requires 1.27 cycles per element would require a much more detailed knowledge of the hardware design than is publicly available.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433B9" id="P70004970270000000000000000433B9">To summarize our performance analysis of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433BA" id="P70004970270000000000000000433BA">combine4</code>: our abstract data-flow representation of program operation showed that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433BB" id="P70004970270000000000000000433BB">combine4</code> has a critical path of length <i class="pcalibre17 pcalibre2 pcalibre1">L · n</i> caused by the successive updating of program value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433BC" id="P70004970270000000000000000433BC">acc</code>, and this path limits the CPE to at least <var class="pcalibre17 pcalibre2 pcalibre1">L</var>. This is indeed the CPE we measure for all cases except integer addition, which has a measured CPE of 1.27 rather than the CPE of 1.00 we would expect from the critical path length.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433BD" id="P70004970270000000000000000433BD">It may seem that the latency bound forms a fundamental limit on how fast our combining operations can be performed. Our next task will be to restructure the operations to enhance instruction-level parallelism. We want to transform the program in such a way that our only limitation becomes the throughput bound, yielding CPEs below or close to 1.00.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004C70" epub:type="practice" id="P7000497027000000000000000004C70"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433BE" epub:type="title" id="P70004970270000000000000000433BE"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004C72" epub:type="pagebreak" id="P7000497027000000000000000004C72" title="530"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.5 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005127">575</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P70004970270000000000000000433BF" id="P70004970270000000000000000433BF">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P70004970270000000000000000433C0" id="P70004970270000000000000000433C0">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000433C1" id="P70004970270000000000000000433C1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433C2" id="P70004970270000000000000000433C2">Supposewewishtowriteafunctiontoevaluateapolynomial, where a polynomial of degree <var class="pcalibre17 pcalibre2 pcalibre1">n</var> is defined to have a set of coefficients <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">0</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, . . ., <i class="pcalibre17 pcalibre2 pcalibre1">a<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i>. For a value <var class="pcalibre17 pcalibre2 pcalibre1">x</var>, we evaluate the polynomial by computing</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter05.xhtml#P70004970270000000000000000433C3" id="P70004970270000000000000000433C3">
<m:math altimg="../images/ch05-5.png" altimg-height="17" altimg-width="183" alttext="" data-uri="" display="block"><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mi>x</m:mi><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mn>2</m:mn></m:msub><m:msup><m:mi>x</m:mi><m:mn>2</m:mn></m:msup><m:mo>+</m:mo><m:mo>…</m:mo><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mi>n</m:mi></m:msub><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup></m:mrow></m:math>
<span class="pcalibre1 pcalibre76 pcalibre2">(5.2)</span>
</div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433C4" id="P70004970270000000000000000433C4">This evaluation can be implemented by the following function, having as arguments an array of coefficients a, a value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433C5" id="P70004970270000000000000000433C5">x</code>, and the polynomial degree <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433C6" id="P70004970270000000000000000433C6">degree</code> (the value <var class="pcalibre17 pcalibre2 pcalibre1">n</var> in Equation 5.2). In this function, we compute both the successive terms of the equation and the successive powers of <var class="pcalibre17 pcalibre2 pcalibre1">x</var> within a single loop:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000433C7" id="P70004970270000000000000000433C7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433C8" id="P70004970270000000000000000433C8">
1	double poly(double a[], double x, long degree)
2	{
3		long i;
4		double result = a[0];
5		double xpwr = x; /* Equals x⁁i at start of loop */
6		for (i = 1; i &lt;= degree; i++) {
7			result += a[i] * xpwr;
8			xpwr = x * xpwr;
9		}
10		return result;
11	}
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter05.xhtml#P70004970270000000000000000433C9" id="P70004970270000000000000000433C9">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000433CA" id="P70004970270000000000000000433CA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433CB" id="P70004970270000000000000000433CB">For degree <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, how many additions and how many multiplications does this code perform?</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000433CC" id="P70004970270000000000000000433CC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433CD" id="P70004970270000000000000000433CD">On our reference machine, with arithmetic operations having the latencies shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004BAA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a>, we measure the CPE for this function to be 5.00. Explain how this CPE arises based on the data dependencies formed between iterations due to the operations implementing lines 7-8 of the function.</p></li>
</ol></div></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004C82" epub:type="practice" id="P7000497027000000000000000004C82"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433CE" epub:type="title" id="P70004970270000000000000000433CE"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.6 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005127">575</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P70004970270000000000000000433CF" id="P70004970270000000000000000433CF">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P70004970270000000000000000433D0" id="P70004970270000000000000000433D0">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000433D1" id="P70004970270000000000000000433D1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433D2" id="P70004970270000000000000000433D2">Let us continue exploring ways to evaluate polynomials, as described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C70"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.5</span></a>. We can reduce the number of multiplications in evaluating a polynomial by applying <i class="pcalibre17 pcalibre2 pcalibre1">Horner's method</i>, named after British mathematician William G. Horner (1786-1837). The idea is to repeatedly factor out the powers of <var class="pcalibre17 pcalibre2 pcalibre1">x</var> to get the following evaluation:</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter05.xhtml#P70004970270000000000000000433D3" id="P70004970270000000000000000433D3">
<m:math altimg="../images/ch05-6.png" altimg-height="13" altimg-width="280" alttext="" data-uri="" display="block"><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>+</m:mo><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mo>+</m:mo><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mn>2</m:mn></m:msub><m:mo>+</m:mo><m:mo>…</m:mo><m:mo>+</m:mo><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mi>n</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:mi>x</m:mi><m:msub><m:mi>a</m:mi><m:mi>n</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>…</m:mo></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:math>
<span class="pcalibre1 pcalibre76 pcalibre2">(5.3)</span>
</div>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433D4" id="P70004970270000000000000000433D4">Using Horner's method, we can implement polynomial evaluation using the following code:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000433D5" id="P70004970270000000000000000433D5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433D6" id="P70004970270000000000000000433D6">
1	/* Apply Horner's method */
2	double polyh(double a[], double x, long degree)
3	{
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004C8C" epub:type="pagebreak" id="P7000497027000000000000000004C8C" title="531"></span>4		long i;
5		double result = a[degree];
6		for (i = degree-1; i &gt;= 0; i−)
7			result = a[i] + x*result;
8		return result;
9	}
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter05.xhtml#P70004970270000000000000000433D7" id="P70004970270000000000000000433D7">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000433D8" id="P70004970270000000000000000433D8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433D9" id="P70004970270000000000000000433D9">For degree <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, how many additions and how many multiplications does this code perform?</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000433DA" id="P70004970270000000000000000433DA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433DB" id="P70004970270000000000000000433DB">On our reference machine, with the arithmetic operations having the latencies shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004BAA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a>, we measure the CPE for this function to be 8.00. Explain how this CPE arises based on the data dependencies formed between iterations due to the operations implementing line 7 of the function.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000433DC" id="P70004970270000000000000000433DC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433DD" id="P70004970270000000000000000433DD">Explain how the function shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C70"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.5</span></a> can run faster, even though it requires more operations.</p></li>
</ol></div></li>
</ol>
</section>
</section>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.8 Loop Unrolling</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000004C94"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P70004970270000000000000000433DE" epub:type="title" id="P70004970270000000000000000433DE"><span class="pcalibre1 pcalibre21 pcalibre2">5.8 </span>Loop Unrolling</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433DF" id="P70004970270000000000000000433DF">Loop unrolling is a program transformation that reduces the number of iterations for a loop by increasing the number of elements computed on each iteration. We saw an example of this with the function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433E0" id="P70004970270000000000000000433E0">psum2</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000493B.xhtml#P7000497027000000000000000004949"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1</span></a>), where each iteration computes two elements of the prefix sum, thereby halving the total number of iterations required. Loop unrolling can improve performance in two ways. First, it reduces the number of operations that do not contribute directly to the program result, such as loop indexing and conditional branching. Second, it exposes ways in which we can further transform the code to reduce the number of operations in the critical paths of the overall computation. In this section, we will examine simple loop unrolling, without any further transformations.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433E1" id="P70004970270000000000000000433E1"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C9D"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.16</span></a> shows a version of our combining code using what we will refer to as "2 × 1 loop unrolling." The first loop steps through the array two elements at a time. That is, the loop index <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433E2" id="P70004970270000000000000000433E2">i</code> is incremented by 2 on each iteration, and the combining operation is applied to array elements <var class="pcalibre17 pcalibre2 pcalibre1">i</var> and <var class="pcalibre17 pcalibre2 pcalibre1">i</var> + 1 in a single iteration.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433E3" id="P70004970270000000000000000433E3">In general, the vector length will not be a multiple of 2. We want our code to work correctly for arbitrary vector lengths. We account for this requirement in two ways. First, we make sure the first loop does not overrun the array bounds. For a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, we set the loop limit to be <var class="pcalibre17 pcalibre2 pcalibre1">n</var> − 1. We are then assured that the loop will only be executed when the loop index <var class="pcalibre17 pcalibre2 pcalibre1">i</var> satisfies <var class="pcalibre17 pcalibre2 pcalibre1">i</var> &lt; <var class="pcalibre17 pcalibre2 pcalibre1">n</var> − 1, and hence the maximum array index <var class="pcalibre17 pcalibre2 pcalibre1">i</var> + 1 will satisfy <var class="pcalibre17 pcalibre2 pcalibre1">i</var> + 1 &lt; (<var class="pcalibre17 pcalibre2 pcalibre1">n</var> − 1) + 1 = <var class="pcalibre17 pcalibre2 pcalibre1">n</var>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433E4" id="P70004970270000000000000000433E4">We can generalize this idea to unroll a loop by any factor <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, yielding <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 <i class="pcalibre17 pcalibre2 pcalibre1">loop unrolling.</i> To do so, we set the upper limit to be <var class="pcalibre17 pcalibre2 pcalibre1">n</var> − <var class="pcalibre17 pcalibre2 pcalibre1">k</var> + 1 and within the loop apply the combining operation to elements <var class="pcalibre17 pcalibre2 pcalibre1">i</var> through <var class="pcalibre17 pcalibre2 pcalibre1">i</var> + <var class="pcalibre17 pcalibre2 pcalibre1">k</var> − 1. Loop index <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433E5" id="P70004970270000000000000000433E5">i</code> is incremented by <var class="pcalibre17 pcalibre2 pcalibre1">k</var> in each iteration. The maximum array index <var class="pcalibre17 pcalibre2 pcalibre1">i</var> + <var class="pcalibre17 pcalibre2 pcalibre1">k</var> − 1 will then be less than <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. We include the second loop to step through the final few elements of the vector one at a time. The body of this loop will be executed between 0 and <var class="pcalibre17 pcalibre2 pcalibre1">k</var> − 1 times. For <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 2, we could use a simple conditional statement</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004C9D" id="P7000497027000000000000000004C9D">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004C9E" epub:type="pagebreak" id="P7000497027000000000000000004C9E" title="532"></span>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000433E6" id="P70004970270000000000000000433E6"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433E7" id="P70004970270000000000000000433E7">
1	/* 2 x 1 loop unrolling */
2	void combine5(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		long limit = length-1;
7		data_t *data = get_vec_start(v);
8		data_t acc = IDENT; 9
10		/* Combine 2 elements at a time */
11		for (i = 0; i &lt; limit; i+=2) {
12			<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433E8" id="P70004970270000000000000000433E8">acc</code> = (acc OP data[i]) OP data[i+1];
13		}
14	
15		/* Finish any remaining elements */
16		for (;i &lt; length; i++) {
17			acc = acc OP data[i];
18		}
19		*dest = acc;
20	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000433E9" id="P70004970270000000000000000433E9"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000433EA" epub:type="title" id="P70004970270000000000000000433EA"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.16 </span>Applying 2 × 1 loop unrolling.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433EB" id="P70004970270000000000000000433EB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433EC" id="P70004970270000000000000000433EC">This transformation can reduce the effect of loop overhead.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433ED" id="P70004970270000000000000000433ED">to optionally add a final iteration, as we did with the function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433EE" id="P70004970270000000000000000433EE">psum2</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000493B.xhtml#P7000497027000000000000000004949"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1</span></a>). For <var class="pcalibre17 pcalibre2 pcalibre1">k</var> &gt; 2, the finishing cases are better expressed with a loop, and so we adopt this programming convention for <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 2 as well. We refer to this transformation as "<var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 loop unrolling," since we unroll by a factor of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> but accumulate values in a single variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433EF" id="P70004970270000000000000000433EF">acc</code>.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004CA9" epub:type="practice" id="P7000497027000000000000000004CA9"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433F0" epub:type="title" id="P70004970270000000000000000433F0"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.7 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005127">575</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P70004970270000000000000000433F1" id="P70004970270000000000000000433F1">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P70004970270000000000000000433F2" id="P70004970270000000000000000433F2">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000433F3" id="P70004970270000000000000000433F3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000433F4" id="P70004970270000000000000000433F4">Modify the code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433F5" id="P70004970270000000000000000433F5">combine5</code> to unroll the loop by a factor <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 5.</p></div></li>
</ol>
</section>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433F6" id="P70004970270000000000000000433F6">When we measure the performance of unrolled code for unrolling factors <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 2 (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000433F7" id="P70004970270000000000000000433F7">combine5</code>) and <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 3, we get the following results:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P70004970270000000000000000433F8" id="P70004970270000000000000000433F8">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000433F9" id="P70004970270000000000000000433F9"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000433FA" id="P70004970270000000000000000433FA"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000433FB" id="P70004970270000000000000000433FB"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000433FC" id="P70004970270000000000000000433FC">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000433FD" id="P70004970270000000000000000433FD">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000433FE" id="P70004970270000000000000000433FE">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000433FF" id="P70004970270000000000000000433FF">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043400" id="P7000497027000000000000000043400">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043401" id="P7000497027000000000000000043401">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043402" id="P7000497027000000000000000043402">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043403" id="P7000497027000000000000000043403">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043404" id="P7000497027000000000000000043404">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043405" id="P7000497027000000000000000043405"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043406" id="P7000497027000000000000000043406">combine4</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043407" id="P7000497027000000000000000043407">515</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043408" id="P7000497027000000000000000043408">No unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043409" id="P7000497027000000000000000043409">1.27</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004340A" id="P700049702700000000000000004340A">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004340B" id="P700049702700000000000000004340B">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004340C" id="P700049702700000000000000004340C">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004340D" id="P700049702700000000000000004340D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004340E" id="P700049702700000000000000004340E">combine5</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004340F" id="P700049702700000000000000004340F">532</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043410" id="P7000497027000000000000000043410">2 × 1 unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043411" id="P7000497027000000000000000043411">1.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043412" id="P7000497027000000000000000043412">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043413" id="P7000497027000000000000000043413">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043414" id="P7000497027000000000000000043414">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043415" id="P7000497027000000000000000043415">3 × 1 unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043416" id="P7000497027000000000000000043416">1.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043417" id="P7000497027000000000000000043417">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043418" id="P7000497027000000000000000043418">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043419" id="P7000497027000000000000000043419">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004341A" id="P700049702700000000000000004341A">Latency bound</td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004341B" id="P700049702700000000000000004341B">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004341C" id="P700049702700000000000000004341C">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004341D" id="P700049702700000000000000004341D">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004341E" id="P700049702700000000000000004341E">5.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004341F" id="P700049702700000000000000004341F">Throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043420" id="P7000497027000000000000000043420">0.50</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043421" id="P7000497027000000000000000043421">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043422" id="P7000497027000000000000000043422">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043423" id="P7000497027000000000000000043423">0.50</td>
</tr>
</tbody>
</table>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004CDE" id="P7000497027000000000000000004CDE">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004CDF" epub:type="pagebreak" id="P7000497027000000000000000004CDF" title="533"></span>
<img alt="A graph depicts CPE versus unrolling factor k." class="pcalibre195 pcalibre2 pcalibre1" data-uri="P700049702700000000000000000B716" id="P7000497027000000000000000043424" src="Images/chapter-05-image-08.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043425" id="P7000497027000000000000000043425"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043426" epub:type="title" id="P7000497027000000000000000043426"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.17 </span>CPE performance for different degrees of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 loop unrolling.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043427" id="P7000497027000000000000000043427"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043428" id="P7000497027000000000000000043428">Only integer addition improves with this transformation.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P700049702700000000000000002370B" id="P700049702700000000000000002370B">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043429" id="P7000497027000000000000000043429">A graph of CPE versus unrolling factor k has four lines: double * horizontal at 5 CPE, double + and long * each horizontal at CPE 3, and long +  from around 1.5 CPE at 1 unrolling factor k and then horizontal at CPE 1 for unrolling factor k 2 and greater.</p>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004342A" id="P700049702700000000000000004342A">We see that the CPE for integer addition improves, achieving the latency bound of 1.00. This result can be attributed to the benefits of reducing loop overhead operations. By reducing the number of overhead operations relative to the number of additions required to compute the vector sum, we can reach the point where the 1-cycle latency of integer addition becomes the performance-limiting factor. On the other hand, none of the other cases improve—they are already at their latency bounds. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004CDE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.17</span></a> shows CPE measurements when unrolling the loop by up to a factor of 10. We see that the trends we observed for unrolling by 2 and 3 continue—none go below their latency bounds.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004342B" id="P700049702700000000000000004342B">To understand why <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 unrolling cannot improve performance beyond the latency bound, let us examine the machine-level code for the inner loop of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004342C" id="P700049702700000000000000004342C">combine5</code>, having <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 2. The following code gets generated when type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004342D" id="P700049702700000000000000004342D">data_t</code> is double, and the operation is multiplication:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004342E" id="P700049702700000000000000004342E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004342F" id="P700049702700000000000000004342F">
	<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of combine5. data_t = double, OP = *</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">i in %rdx, data %rax, limit in %rbx, acc in %xmm0</i>
1	.L35:					<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	  vmulsd (%rax,%rdx,8), %xmm0, %xmm0	  <i class="pcalibre17 pcalibre2 pcalibre1">Multiply acc by data[i]</i>
3	  vmulsd 8(%rax,%rdx,8), %xmm0, %xmm0	  <i class="pcalibre17 pcalibre2 pcalibre1">Multiply acc by data[i+1]</i>
4	  addq $2, %rdx				  <i class="pcalibre17 pcalibre2 pcalibre1">Increment i by 2</i>
5	  cmpq %rdx, %rbp			  <i class="pcalibre17 pcalibre2 pcalibre1">Compare to limit:i</i>
6	  jg .L35				  <i class="pcalibre17 pcalibre2 pcalibre1">If &gt;, goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">loop</b>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043430" id="P7000497027000000000000000043430">We can see that <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>uses a more direct translation of the array referencing seen in the C code, compared to the pointer-based code generated for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043431" id="P7000497027000000000000000043431">combine4</code>.<a class="pcalibre1 pcalibre2 pcalibre56 pcalibre16 pcalibre14 pcalibre15" epub:type="noteref" href="#P700049702700000000000000000518A" id="r__P700049702700000000000000000518A">2</a> Loop index <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043432" id="P7000497027000000000000000043432">i</code> is held in register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043433" id="P7000497027000000000000000043433">%rdx</code>, and the address of data is held in register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043434" id="P7000497027000000000000000043434">%rax</code>. As before, the accumulated value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043435" id="P7000497027000000000000000043435">acc</code> is held in vector register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043436" id="P7000497027000000000000000043436">%xmm0</code>. The loop unrolling leads to two <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043437" id="P7000497027000000000000000043437">vmulsd</code> instructions—one to add <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043438" id="P7000497027000000000000000043438">data[i]</code> to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043439" id="P7000497027000000000000000043439">acc</code>, and</p><aside class="pcalibre2 pcalibre32 pcalibre57" data-uri="chapter05.xhtml#P700049702700000000000000000518A" epub:type="footnote" id="P700049702700000000000000000518A"><p class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre58 pcalibre2"><a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="#r__P700049702700000000000000000518A">2. </a></span>The <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>optimizer operates by generating multiple variants of a function and then choosing one that it predicts will yield the best performance and smallest code size. As a consequence, small changes in the source code can yield widely varying forms of machine code. We have found that the choice of pointer-based or array-based code has no impact on the performance of programs running on our reference machine.</p></aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004CF5" id="P7000497027000000000000000004CF5">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004CF6" epub:type="pagebreak" id="P7000497027000000000000000004CF6" title="534"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for combine5." class="calibre45 pcalibre2 pcalibre1" data-uri="P700049702700000000000000000B717" id="P700049702700000000000000004343A" src="Images/chapter-05-image-09.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P700049702700000000000000004343B" id="P700049702700000000000000004343B"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P700049702700000000000000004343C" epub:type="title" id="P700049702700000000000000004343C"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.18 </span>Graphical representation of inner-loop code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004343D" id="P700049702700000000000000004343D">combine5</code>.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P700049702700000000000000004343E" id="P700049702700000000000000004343E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004343F" id="P700049702700000000000000004343F">Each iteration has two <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043440" id="P7000497027000000000000000043440">vmulsd</code> instructions, each of which is translated into a load and a mul operation.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P7000497027000000000000000023724" id="P7000497027000000000000000023724">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043441" id="P7000497027000000000000000043441">A diagram has two rows of boxes, each with %rax, %rbp, %rdx, and %rmm0, with output from top %rax and %rbp to bottom %rax and %rbp, respectively. A column of boxes includes the seven operations summarized below, from top to bottom:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter05.xhtml#P7000497027000000000000000043442" id="P7000497027000000000000000043442">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043443" id="P7000497027000000000000000043443"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043444" id="P7000497027000000000000000043444">First load: receives input from top %rax and %rdx; sends output to mul below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043445" id="P7000497027000000000000000043445"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043446" id="P7000497027000000000000000043446">First mul: receives input from load, with the two together representing vmulsd (%rax, %rdx, 8), %rmm0, %rmm0; receives input from top %rmm0 and sends output to second mul below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043447" id="P7000497027000000000000000043447"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043448" id="P7000497027000000000000000043448">Second load: receives input from top %rax and %rdx; sends output to mul below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043449" id="P7000497027000000000000000043449"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004344A" id="P700049702700000000000000004344A">Second mul: receives input from second load, with the two together representing vmulsd 8(%rax, %rdx, 8), %rmm0, %rmm0; receives input from mul above and sends output to bottom %rmm0</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004344B" id="P700049702700000000000000004344B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004344C" id="P700049702700000000000000004344C">add (addq $2, %rdx): receives input from top %rdx and sends output to bottom %rdx</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004344D" id="P700049702700000000000000004344D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004344E" id="P700049702700000000000000004344E">cmp (cmpq %rdx, %rbp): receives input from add above and top %rbp; sends output to jg below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004344F" id="P700049702700000000000000004344F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043450" id="P7000497027000000000000000043450">jg (jg loop): receives input from cmp above and top %rbp</p></li>
</ul>
</details>
</figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004CFE" id="P7000497027000000000000000004CFE">
<img alt="A diagram depicts two data-flow graphs for combine5." class="pcalibre1 calibre46 pcalibre2" data-uri="P700049702700000000000000000B718" id="P7000497027000000000000000043451" src="Images/chapter-05-image-10.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043452" id="P7000497027000000000000000043452"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043453" epub:type="title" id="P7000497027000000000000000043453"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.19 </span>Abstracting <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043454" id="P7000497027000000000000000043454">combine5</code> operations as a data-flow graph.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043455" id="P7000497027000000000000000043455"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043456" id="P7000497027000000000000000043456">We rearrange, simplify, and abstract the representation of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004CF5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.18</span></a> to show the data dependencies between successive iterations (a). We see that each iteration must perform two multiplications in sequence (b).</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P700049702700000000000000002373B" id="P700049702700000000000000002373B">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre141" data-uri="chapter05.xhtml#P7000497027000000000000000043457" id="P7000497027000000000000000043457">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043458" id="P7000497027000000000000000043458"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043459" id="P7000497027000000000000000043459">Data flows from top %rmm0 to first mul then second mul to bottom %rmm0; from top %rax to each load, each to each mul then %rmm0; from top %rbp to cmp to jg; from top %rdx to each load and add, from which data is sent to bottom %rdx and to cmp.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004345A" id="P700049702700000000000000004345A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004345B" id="P700049702700000000000000004345B">Data flows from top %rmm0 and %rdx to those below, with the first load and mul within data [i] and bottom load and mul, as well as add, within data [i+1].</p></li>
</ol>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004345C" id="P700049702700000000000000004345C">the second to add <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004345D" id="P700049702700000000000000004345D">data[i+1]</code> to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004345E" id="P700049702700000000000000004345E">acc</code>. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004CF5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.18</span></a> shows a graphical representation of this code. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004345F" id="P700049702700000000000000004345F">vmulsd</code> instructions each get translated into two operations: one to load an array element from memory and one to multiply this value by the accumulated value. We see here that register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043460" id="P7000497027000000000000000043460">%xmm0</code> gets read and written twice in each execution of the loop. We can rearrange, simplify, and abstract this graph, following the process shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004CFE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.19(a)</span></a>, to obtain the template shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004CFE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.19(b)</span></a>. We then replicate this template <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 times to show the computation for a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, obtaining the data-flow representation</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004D0A" id="P7000497027000000000000000004D0A">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004D0B" epub:type="pagebreak" id="P7000497027000000000000000004D0B" title="535"></span>
<img alt="A diagram shows a critical path extending through mul operations in three groups: data[0] and data[1], data[2] and data[3], ad data[n minus 2] and data[n minus 1]." class="pcalibre1 pcalibre196 pcalibre2" data-uri="P700049702700000000000000000B719" id="P7000497027000000000000000043461" src="Images/chapter-05-image-11.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043462" id="P7000497027000000000000000043462"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043463" epub:type="title" id="P7000497027000000000000000043463"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.20 </span>Data-flow representation of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043464" id="P7000497027000000000000000043464">combine5</code> operating on a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043465" id="P7000497027000000000000000043465"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043466" id="P7000497027000000000000000043466">Even though the loop has been unrolled by a factor of 2, there are still <var class="pcalibre17 pcalibre2 pcalibre1">n</var> mul operations along the critical path.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043467" id="P7000497027000000000000000043467">shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D0A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.20</span></a>. We see here that there is still a critical path of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> mul operations in this graph—there are half as many iterations, but each iteration has two multiplication operations in sequence. Since the critical path was the limiting factor for the performance of the code without loop unrolling, it remains so with <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 loop unrolling.</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000004D13" id="P7000497027000000000000000004D13"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter05.xhtml#P7000497027000000000000000043468" epub:type="title" id="P7000497027000000000000000043468"><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Getting the compiler to unroll loops</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043469" id="P7000497027000000000000000043469">Loop unrolling can easily be performed by a compiler. Many compilers do this as part of their collection of optimizations. <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>will perform some forms of loop unrolling when invoked with optimization level 3 or higher.</p>
</aside>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.9 Enhancing Parallelism</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000004D16"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P700049702700000000000000004346A" epub:type="title" id="P700049702700000000000000004346A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004D18" epub:type="pagebreak" id="P7000497027000000000000000004D18" title="536"></span><span class="pcalibre1 pcalibre21 pcalibre2">5.9 </span>Enhancing Parallelism</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004346B" id="P700049702700000000000000004346B">At this point, our functions have hit the bounds imposed by the latencies of the arithmetic units. As we have noted, however, the functional units performing addition and multiplication are all fully pipelined, meaning that they can start new operations every clock cycle, and some of the operations can be performed by multiple functional units. The hardware has the potential to perform multiplications and additions at a much higher rate, but our code cannot take advantage of this capability, even with loop unrolling, since we are accumulating the value as a single variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004346C" id="P700049702700000000000000004346C">acc</code>. We cannot compute a new value for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004346D" id="P700049702700000000000000004346D">acc</code> until the preceding computation has completed. Even though the functional unit computing a new value for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004346E" id="P700049702700000000000000004346E">acc</code> can start a new operation every clock cycle, it will only start one every <var class="pcalibre17 pcalibre2 pcalibre1">L</var> cycles, where <var class="pcalibre17 pcalibre2 pcalibre1">L</var> is the latency of the combining operation. We will now investigate ways to break this sequential dependency and get performance better than the latency bound.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004D1D" id="P7000497027000000000000000004D1D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004346F" epub:type="title" id="P700049702700000000000000004346F"><span class="pcalibre1 pcalibre21 pcalibre2">5.9.1 </span>Multiple Accumulators</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043470" id="P7000497027000000000000000043470">For a combining operation that is associative and commutative, such as integer addition or multiplication, we can improve performance by splitting the set of combining operations into two or more parts and combining the results at the end. For example, let <var class="pcalibre17 pcalibre2 pcalibre1">P<sub class="pcalibre1 pcalibre2 calibre14">n</sub></var> denote the product of elements <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">0</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, . . ., <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14"><var class="pcalibre17 pcalibre2 pcalibre1">n</var>−1</sub>:</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter05.xhtml#P7000497027000000000000000043471" id="P7000497027000000000000000043471">
<m:math altimg="../images/ch05-7.png" altimg-height="45" altimg-width="67" alttext="" data-uri="" display="block"><m:mrow><m:msub><m:mi>p</m:mi><m:mi>n</m:mi></m:msub><m:mo>=</m:mo><m:munderover><m:mo>∏</m:mo><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mrow><m:msub><m:mi>a</m:mi><m:mi>i</m:mi></m:msub></m:mrow></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043472" id="P7000497027000000000000000043472">Assuming <var class="pcalibre17 pcalibre2 pcalibre1">n</var> is even, we can also write this as <i class="pcalibre17 pcalibre2 pcalibre1">P<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i> = <i class="pcalibre17 pcalibre2 pcalibre1">PE<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i> × <i class="pcalibre17 pcalibre2 pcalibre1">PO<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i>, where <var class="pcalibre17 pcalibre2 pcalibre1">PE<sub class="pcalibre1 pcalibre2 calibre14">n</sub></var> is the product of the elements with even indices, and <var class="pcalibre17 pcalibre2 pcalibre1">PO<sub class="pcalibre1 pcalibre2 calibre14">n</sub></var> is the product of the elements with odd indices:</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter05.xhtml#P7000497027000000000000000043473" id="P7000497027000000000000000043473">
<m:math altimg="../images/ch05-8.png" altimg-height="105" altimg-width="113" alttext="" data-uri="" display="block"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi>P</m:mi><m:msub><m:mi>E</m:mi><m:mi>n</m:mi></m:msub></m:mrow></m:mtd><m:mtd columnalign="left"><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mrow><m:mstyle displaystyle="true"><m:munderover><m:mo>∏</m:mo><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>/</m:mo><m:mn>2</m:mn><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>2</m:mn><m:mi>i</m:mi></m:mrow></m:msub></m:mrow></m:mstyle></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi>P</m:mi><m:msub><m:mi>O</m:mi><m:mi>n</m:mi></m:msub></m:mrow></m:mtd><m:mtd columnalign="left"><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mrow><m:mstyle displaystyle="true"><m:munderover><m:mo>∏</m:mo><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>/</m:mo><m:mn>2</m:mn><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>2</m:mn><m:mi>i</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:mstyle></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043474" id="P7000497027000000000000000043474"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D29"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.21</span></a> shows code that uses this method. It uses both two-way loop unrolling, to combine more elements per iteration, and two-way parallelism, accumulating elements with even indices in variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043475" id="P7000497027000000000000000043475">acc0</code> and elements with odd indices in variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043476" id="P7000497027000000000000000043476">acc1</code>. We therefore refer to this as "2 × 2 loop unrolling." As before, we include a second loop to accumulate any remaining array elements for the case where the vector length is not a multiple of 2. We then apply the combining operation to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043477" id="P7000497027000000000000000043477">acc0</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043478" id="P7000497027000000000000000043478">acc1</code> to compute the final result.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043479" id="P7000497027000000000000000043479">Comparing loop unrolling alone to loop unrolling with two-way parallelism, we obtain the following performance:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004D29" id="P7000497027000000000000000004D29">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004347A" id="P700049702700000000000000004347A"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004347B" id="P700049702700000000000000004347B">
<span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter05.xhtml#P7000497027000000000000000004D2C" epub:type="pagebreak" id="P7000497027000000000000000004D2C" title="537"></span>1	/* 2 x 2 loop unrolling */
2	void combine6(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		long limit = length-1;
7		data_t *data = get_vec_start(v);
8		data_t acc0 = IDENT;
9		data_t acc1 = IDENT;
10	
11		/* Combine 2 elements at a time */
12		for (i = 0; i &lt; limit; i+=2) {
13			acc0 = acc0 OP data[i];
14			acc1 = acc1 OP data[i+1];
15		}
16
17		/* Finish any remaining elements */
18		for (;i &lt; length; i++) {
19			acc0 = acc0 OP data[i];
20		}
21		*dest = acc0 OP acc1;
22	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P700049702700000000000000004347C" id="P700049702700000000000000004347C"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P700049702700000000000000004347D" epub:type="title" id="P700049702700000000000000004347D"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.21 </span>Applying 2 × 2 loop unrolling.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004347E" id="P700049702700000000000000004347E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004347F" id="P700049702700000000000000004347F">By maintaining multiple accumulators, this approach can make better use of the multiple functional units and their pipelining capabilities.</p></div></figcaption></figure>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P7000497027000000000000000043480" id="P7000497027000000000000000043480">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043481" id="P7000497027000000000000000043481"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043482" id="P7000497027000000000000000043482"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043483" id="P7000497027000000000000000043483"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043484" id="P7000497027000000000000000043484">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043485" id="P7000497027000000000000000043485">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043486" id="P7000497027000000000000000043486">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043487" id="P7000497027000000000000000043487">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043488" id="P7000497027000000000000000043488">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043489" id="P7000497027000000000000000043489">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004348A" id="P700049702700000000000000004348A">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004348B" id="P700049702700000000000000004348B">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004348C" id="P700049702700000000000000004348C">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004348D" id="P700049702700000000000000004348D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004348E" id="P700049702700000000000000004348E">combine4</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004348F" id="P700049702700000000000000004348F">515</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043490" id="P7000497027000000000000000043490">Accumulate in temporary</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043491" id="P7000497027000000000000000043491">1.27</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043492" id="P7000497027000000000000000043492">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043493" id="P7000497027000000000000000043493">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043494" id="P7000497027000000000000000043494">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043495" id="P7000497027000000000000000043495"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043496" id="P7000497027000000000000000043496">combine5</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043497" id="P7000497027000000000000000043497">532</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043498" id="P7000497027000000000000000043498">2 × 1 unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043499" id="P7000497027000000000000000043499">1.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004349A" id="P700049702700000000000000004349A">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004349B" id="P700049702700000000000000004349B">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004349C" id="P700049702700000000000000004349C">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004349D" id="P700049702700000000000000004349D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004349E" id="P700049702700000000000000004349E">combine6</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004349F" id="P700049702700000000000000004349F">537</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434A0" id="P70004970270000000000000000434A0">2 × 2 unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434A1" id="P70004970270000000000000000434A1">0.81</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434A2" id="P70004970270000000000000000434A2">1.51</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434A3" id="P70004970270000000000000000434A3">1.51</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434A4" id="P70004970270000000000000000434A4">2.51</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000434A5" id="P70004970270000000000000000434A5">Latency bound</td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434A6" id="P70004970270000000000000000434A6">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434A7" id="P70004970270000000000000000434A7">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434A8" id="P70004970270000000000000000434A8">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434A9" id="P70004970270000000000000000434A9">5.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000434AA" id="P70004970270000000000000000434AA">Throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434AB" id="P70004970270000000000000000434AB">0.50</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434AC" id="P70004970270000000000000000434AC">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434AD" id="P70004970270000000000000000434AD">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434AE" id="P70004970270000000000000000434AE">0.50</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434AF" id="P70004970270000000000000000434AF">We see that we have improved the performance for all cases, with integer product, floating-point addition, and floating-point multiplication improving by a factor of around 2, and integer addition improving somewhat as well. Most significantly, we have broken through the barrier imposed by the latency bound. The processor no longer needs to delay the start of one sum or product operation until the previous one has completed.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434B0" id="P70004970270000000000000000434B0">To understand the performance of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434B1" id="P70004970270000000000000000434B1">combine6</code>, we start with the code and operation sequence shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D63"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.22</span></a>. We can derive a template showing the</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004D63" id="P7000497027000000000000000004D63">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004D64" epub:type="pagebreak" id="P7000497027000000000000000004D64" title="538"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for combine6." class="pcalibre1 pcalibre2 pcalibre197" data-uri="P700049702700000000000000000B71A" id="P70004970270000000000000000434B2" src="Images/chapter-05-image-12.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000434B3" id="P70004970270000000000000000434B3"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000434B4" epub:type="title" id="P70004970270000000000000000434B4"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.22 </span>Graphical representation of inner-loop code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434B5" id="P70004970270000000000000000434B5">combine6</code>.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434B6" id="P70004970270000000000000000434B6"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434B7" id="P70004970270000000000000000434B7">Each iteration has two <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434B8" id="P70004970270000000000000000434B8">vmulsd</code> instructions, each of which is translated into a load and a mul operation.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P700049702700000000000000002379E" id="P700049702700000000000000002379E">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434B9" id="P70004970270000000000000000434B9">A diagram has two rows of boxes, each with %rax, %rbp, %rdx, %rmm0, and %rmm1, with output from top %rax and %rbp to bottom %rax and %rbp, respectively. A column of boxes includes the seven operations summarized below, from top to bottom:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter05.xhtml#P70004970270000000000000000434BA" id="P70004970270000000000000000434BA">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434BB" id="P70004970270000000000000000434BB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434BC" id="P70004970270000000000000000434BC">First load: receives input from top %rax and %rdx; sends output to mul below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434BD" id="P70004970270000000000000000434BD"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434BE" id="P70004970270000000000000000434BE">First mul: receives input from load, with the two together representing vmulsd (%rax, %rdx, 8), %rmm0, %rmm0; receives input from top %rmm0 and sends output to bottom %rmm0.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434BF" id="P70004970270000000000000000434BF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434C0" id="P70004970270000000000000000434C0">Second load: receives input from top %rax and %rdx; sends output to mul below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434C1" id="P70004970270000000000000000434C1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434C2" id="P70004970270000000000000000434C2">Second mul: receives input from second load, with the two together representing vmulsd 8(%rax, %rdx, 8), %rmm1, %rmm1; receives input from top %rmm1 and sends output to bottom %rmm1</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434C3" id="P70004970270000000000000000434C3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434C4" id="P70004970270000000000000000434C4">add (addq $2, %rdx): receives input from top %rdx and sends output to bottom %rdx and cmp</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434C5" id="P70004970270000000000000000434C5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434C6" id="P70004970270000000000000000434C6">cmp (cmpq %rdx, %rbp): receives input from add above and top %rbp; sends output to jg below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434C7" id="P70004970270000000000000000434C7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434C8" id="P70004970270000000000000000434C8">jg (jg loop): receives input from cmp above</p></li>
</ul>
</details>
</figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004D6C" id="P7000497027000000000000000004D6C">
<img alt="A diagram depicts two data-flow graphs for combine6." class="pcalibre1 pcalibre2 pcalibre198" data-uri="P700049702700000000000000000B71B" id="P70004970270000000000000000434C9" src="Images/chapter-05-image-13.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000434CA" id="P70004970270000000000000000434CA"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000434CB" epub:type="title" id="P70004970270000000000000000434CB"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.23 </span>Abstracting <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434CC" id="P70004970270000000000000000434CC">combine6</code> operations as a data-flow graph.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434CD" id="P70004970270000000000000000434CD"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434CE" id="P70004970270000000000000000434CE">We rearrange, simplify, and abstract the representation of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D63"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.22</span></a> to show the data dependencies between successive iterations (a). We see that there is no dependency between the two mul operations (b).</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P70004970270000000000000000237B5" id="P70004970270000000000000000237B5">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre141" data-uri="chapter05.xhtml#P70004970270000000000000000434CF" id="P70004970270000000000000000434CF">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434D0" id="P70004970270000000000000000434D0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434D1" id="P70004970270000000000000000434D1">Data flows from top %rmm0 to first mul to bottom %rmm0; from top %rax to each load, each to each mul then %rmm0 and %rmm1, respectively; from top %rmm1 to second mule and bottom %rmm1; from top %rbp to cmp to jg; from top %rdx to each load and add, from which data is sent to bottom %rdx and to cmp.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434D2" id="P70004970270000000000000000434D2"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434D3" id="P70004970270000000000000000434D3">Data flows from top top %rmm0 to first mul to %rmm0, from top %rmm1 to second mul to bottom %rmm1, and from top %rdx to each load as well as add to bottom %rdx. First load and mul are within data [i] and second load and mul and add within data [i+1].</p></li>
</ol>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434D4" id="P70004970270000000000000000434D4">data dependencies between iterations through the process shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D6C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.23</span></a>. As with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434D5" id="P70004970270000000000000000434D5">combine5</code>, the inner loop contains two <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434D6" id="P70004970270000000000000000434D6">vmulsd</code> operations, but these instructions translate into mul operations that read and write separate registers, with no data dependency between them (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D6C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.23(b)</span></a>). We then replicate this template <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 times (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D77"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.24</span></a>), modeling the execution of the function on a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. We see that we now have two critical paths, one corresponding to computing the product of even-numbered elements (program value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434D7" id="P70004970270000000000000000434D7">acc0</code>) and</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004D77" id="P7000497027000000000000000004D77">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004D78" epub:type="pagebreak" id="P7000497027000000000000000004D78" title="539"></span>
<img alt="A diagram shows critical paths through the each mul in data[0] and data[1], data[2] and data[3], and data[n minus 2] and data[n minus 1]." class="pcalibre1 pcalibre2 pcalibre199" data-uri="P700049702700000000000000000B71C" id="P70004970270000000000000000434D8" src="Images/chapter-05-image-14.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000434D9" id="P70004970270000000000000000434D9"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000434DA" epub:type="title" id="P70004970270000000000000000434DA"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.24 </span>Data-flow representation of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434DB" id="P70004970270000000000000000434DB">combine6</code> operating on a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434DC" id="P70004970270000000000000000434DC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434DD" id="P70004970270000000000000000434DD">We now have two critical paths, each containing <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 operations.</p></div>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434DE" id="P70004970270000000000000000434DE">one for the odd-numbered elements (program value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434DF" id="P70004970270000000000000000434DF">acc1</code>). Each of these critical paths contains only <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 operations, thus leading to a CPE of around 5.00/2 = 2.50. A similar analysis explains our observed CPE of around <var class="pcalibre17 pcalibre2 pcalibre1">L</var>/2 for operations with latency <var class="pcalibre17 pcalibre2 pcalibre1">L</var> for the different combinations of data type and combining operation. Operationally, the programs are exploiting the capabilities of the functional units to increase their utilization by a factor of 2. The only exception is for integer addition. We have reduced the CPE to below 1.0, but there is still too much loop overhead to achieve the theoretical limit of 0.50.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434E0" id="P70004970270000000000000000434E0">We can generalize the multiple accumulator transformation to unroll the loop by a factor of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> and accumulate <var class="pcalibre17 pcalibre2 pcalibre1">k</var> values in parallel, yielding <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × <i class="pcalibre17 pcalibre2 pcalibre1">k loop unrolling.</i> <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D82"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.25</span></a> demonstrates the effect of applying this transformation for values up to <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 10. We can see that, for sufficiently large values of <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, the program can</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004D82" id="P7000497027000000000000000004D82">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004D83" epub:type="pagebreak" id="P7000497027000000000000000004D83" title="540"></span>
<img alt="A graph depicts CPE versus unrolling factor k." class="pcalibre1 pcalibre2 calibre47" data-uri="P700049702700000000000000000B71D" id="P70004970270000000000000000434E1" src="Images/chapter-05-image-15.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000434E2" id="P70004970270000000000000000434E2"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000434E3" epub:type="title" id="P70004970270000000000000000434E3"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.25 </span>CPE performance of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × <var class="pcalibre17 pcalibre2 pcalibre1">k</var> loop unrolling.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000434E4" id="P70004970270000000000000000434E4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434E5" id="P70004970270000000000000000434E5">All of the CPEs improve with this transformation, achieving near or at their throughput bounds.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P70004970270000000000000000237CD" id="P70004970270000000000000000237CD">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434E6" id="P70004970270000000000000000434E6">The four sets of points plotted each decreasing in CPE with increasing rolling factor k, as summarized below.</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter05.xhtml#P70004970270000000000000000434E7" id="P70004970270000000000000000434E7">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434E8" id="P70004970270000000000000000434E8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434E9" id="P70004970270000000000000000434E9">Double *: from 5 CPE at 1 to about 0.5 CPE at 10</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434EA" id="P70004970270000000000000000434EA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434EB" id="P70004970270000000000000000434EB">Double + and long *: each from 3 CPE at 1 to steady around 1 CPE by 3</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000434EC" id="P70004970270000000000000000434EC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000434ED" id="P70004970270000000000000000434ED">Long +: from about 1.5 CPE at 1 to steady around 0.5 CPE by 5</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434EE" id="P70004970270000000000000000434EE">achieve nearly the throughput bounds for all cases. Integer addition achieves a CPE of 0.54 with <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 7, close to the throughput bound of 0.50 caused by the two load units. Integer multiplication and floating-point addition achieve CPEs of 1.01 when <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≥ 3, approaching the throughput bound of 1.00 set by their functional units. Floating-point multiplication achieves a CPE of 0.51 for <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≥ 10, approaching the throughput bound of 0.50 set by the two floating-point multipliers and the two load units. It is worth noting that our code is able to achieve nearly twice the throughput with floating-point multiplication as it can with floating-point addition, even though multiplication is a more complex operation.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434EF" id="P70004970270000000000000000434EF">In general, a program can achieve the throughput bound for an operation only when it can keep the pipelines filled for all of the functional units capable of performing that operation. For an operation with latency <var class="pcalibre17 pcalibre2 pcalibre1">L</var> and capacity <var class="pcalibre17 pcalibre2 pcalibre1">C</var>, this requires an unrolling factor <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≥ <i class="pcalibre17 pcalibre2 pcalibre1">C · L.</i> For example, floating-point multiplication has <var class="pcalibre17 pcalibre2 pcalibre1">C</var> = 2 and <var class="pcalibre17 pcalibre2 pcalibre1">L</var> = 5, necessitating an unrolling factor of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≥ 10. Floating-point addition has <var class="pcalibre17 pcalibre2 pcalibre1">C</var> = 1 and <var class="pcalibre17 pcalibre2 pcalibre1">L</var> = 3, achieving maximum throughput with <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≥ 3.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434F0" id="P70004970270000000000000000434F0">In performing the <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × <var class="pcalibre17 pcalibre2 pcalibre1">k</var> unrolling transformation, we must consider whether it preserves the functionality of the original function. We have seen in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000000279.xhtml#P7000497027000000000000000000279"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">2</span></a> that two's-complement arithmetic is commutative and associative, even when overflow occurs. Hence, for an integer data type, the result computed by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434F1" id="P70004970270000000000000000434F1">combine6</code> will be identical to that computed by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434F2" id="P70004970270000000000000000434F2">combine5</code> under all possible conditions. Thus, an optimizing compiler could potentially convert the code shown in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434F3" id="P70004970270000000000000000434F3">combine4</code> first to a two-way unrolled variant of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434F4" id="P70004970270000000000000000434F4">combine5</code> by loop unrolling, and then to that of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434F5" id="P70004970270000000000000000434F5">combine6</code> by introducing parallelism. Some compilers do either this or similar transformations to improve performance for integer data.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434F6" id="P70004970270000000000000000434F6">On the other hand, floating-point multiplication and addition are not associative. Thus, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434F7" id="P70004970270000000000000000434F7">combine5</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434F8" id="P70004970270000000000000000434F8">combine6</code> could produce different results due to rounding or overflow. Imagine, for example, a product computation in which all of the elements with even indices are numbers with very large absolute values, while those with odd indices are very close to 0.0. In such a case, product <i class="pcalibre17 pcalibre2 pcalibre1">PE<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i> might overflow, or <i class="pcalibre17 pcalibre2 pcalibre1">PO<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i> might underflow, even though computing product <i class="pcalibre17 pcalibre2 pcalibre1">P<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i> proceeds <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004D94" epub:type="pagebreak" id="P7000497027000000000000000004D94" title="541"></span>normally. In most real-life applications, however, such patterns are unlikely. Since most physical phenomena are continuous, numerical data tend to be reasonably smooth and well behaved. Even when there are discontinuities, they do not generally cause periodic patterns that lead to a condition such as that sketched earlier. It is unlikely that multiplying the elements in strict order gives fundamentally better accuracy than does multiplying two groups independently and then multiplying those products together. For most applications, achieving a performance gain of 2× outweighs the risk of generating different results for strange data patterns. Nevertheless, a program developer should check with potential users to see if there are particular conditions that may cause the revised algorithm to be unacceptable. Most compilers do not attempt such transformations with floating-point code, since they have no way to judge the risks of introducing transformations that can change the program behavior, no matter how small.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004D95" id="P7000497027000000000000000004D95"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434F9" epub:type="title" id="P70004970270000000000000000434F9"><span class="pcalibre1 pcalibre21 pcalibre2">5.9.2 </span>Reassociation Transformation</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434FA" id="P70004970270000000000000000434FA">We now explore another way to break the sequential dependencies and thereby improve performance beyond the latency bound. We saw that the <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 loop unrolling of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434FB" id="P70004970270000000000000000434FB">combine5</code> did not change the set of operations performed in combining the vector elements to form their sum or product. By a very small change in the code, however, we can fundamentally change the way the combining is performed, and also greatly increase the program performance.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434FC" id="P70004970270000000000000000434FC"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DDC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.26</span></a> shows a function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434FD" id="P70004970270000000000000000434FD">combine7</code> that differs from the unrolled code of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434FE" id="P70004970270000000000000000434FE">combine5</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004C94.xhtml#P7000497027000000000000000004C9D"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.16</span></a>) only in the way the elements are combined in the inner loop. In <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000434FF" id="P70004970270000000000000000434FF">combine5</code>, the combining is performed by the statement</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043500" id="P7000497027000000000000000043500"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043501" id="P7000497027000000000000000043501">
12	acc = (acc OP data[i]) OP data[i+1];
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043502" id="P7000497027000000000000000043502">while in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043503" id="P7000497027000000000000000043503">combine7</code> it is performed by the statement</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043504" id="P7000497027000000000000000043504"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043505" id="P7000497027000000000000000043505">
12	acc = acc OP (data[i] OP data[i+1]);
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043506" id="P7000497027000000000000000043506">differing only in how two parentheses are placed. We call this a <i class="pcalibre17 pcalibre2 pcalibre1">reassociation transformation</i>, because the parentheses shift the order in which the vector elements are combined with the accumulated value acc, yielding a form of loop unrolling we refer to as "2 × 1<var class="pcalibre17 pcalibre2 pcalibre1">a</var>."</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043507" id="P7000497027000000000000000043507">To an untrained eye, the two statements may seem essentially the same, but when we measure the CPE, we get a surprising result:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P7000497027000000000000000043508" id="P7000497027000000000000000043508">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043509" id="P7000497027000000000000000043509"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004350A" id="P700049702700000000000000004350A"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004350B" id="P700049702700000000000000004350B"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004350C" id="P700049702700000000000000004350C">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004350D" id="P700049702700000000000000004350D">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004350E" id="P700049702700000000000000004350E">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004350F" id="P700049702700000000000000004350F">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043510" id="P7000497027000000000000000043510">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043511" id="P7000497027000000000000000043511">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043512" id="P7000497027000000000000000043512">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043513" id="P7000497027000000000000000043513">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043514" id="P7000497027000000000000000043514">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043515" id="P7000497027000000000000000043515"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043516" id="P7000497027000000000000000043516">combine4</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043517" id="P7000497027000000000000000043517">515</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043518" id="P7000497027000000000000000043518">Accumulate in temporary</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043519" id="P7000497027000000000000000043519">1.27</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004351A" id="P700049702700000000000000004351A">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004351B" id="P700049702700000000000000004351B">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004351C" id="P700049702700000000000000004351C">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004351D" id="P700049702700000000000000004351D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004351E" id="P700049702700000000000000004351E">combine5</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004351F" id="P700049702700000000000000004351F">532</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043520" id="P7000497027000000000000000043520">2 × 1 unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043521" id="P7000497027000000000000000043521">1.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043522" id="P7000497027000000000000000043522">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043523" id="P7000497027000000000000000043523">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043524" id="P7000497027000000000000000043524">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043525" id="P7000497027000000000000000043525"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043526" id="P7000497027000000000000000043526">combine6</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043527" id="P7000497027000000000000000043527">537</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043528" id="P7000497027000000000000000043528">2 × 2 unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043529" id="P7000497027000000000000000043529">0.81</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004352A" id="P700049702700000000000000004352A">1.51</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004352B" id="P700049702700000000000000004352B">1.51</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004352C" id="P700049702700000000000000004352C">2.51</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004352D" id="P700049702700000000000000004352D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004352E" id="P700049702700000000000000004352E">combine7</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004352F" id="P700049702700000000000000004352F">542</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043530" id="P7000497027000000000000000043530">2 × 1<var class="pcalibre17 pcalibre2 pcalibre1">a</var> unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043531" id="P7000497027000000000000000043531">1.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043532" id="P7000497027000000000000000043532">1.51</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043533" id="P7000497027000000000000000043533">1.51</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043534" id="P7000497027000000000000000043534">2.51</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043535" id="P7000497027000000000000000043535">Latency bound</td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043536" id="P7000497027000000000000000043536">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043537" id="P7000497027000000000000000043537">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043538" id="P7000497027000000000000000043538">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043539" id="P7000497027000000000000000043539">5.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004353A" id="P700049702700000000000000004353A">Throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004353B" id="P700049702700000000000000004353B">0.50</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004353C" id="P700049702700000000000000004353C">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004353D" id="P700049702700000000000000004353D">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004353E" id="P700049702700000000000000004353E">0.50</td>
</tr>
</tbody>
</table>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004DDC" id="P7000497027000000000000000004DDC">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004353F" id="P700049702700000000000000004353F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043540" id="P7000497027000000000000000043540">
<span class="pcalibre1 pcalibre2 pcalibre123" data-uri="chapter05.xhtml#P7000497027000000000000000004DDF" epub:type="pagebreak" id="P7000497027000000000000000004DDF" title="542"></span>1	/* 2 x 1a loop unrolling */
2	void combine7(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		long limit = length-1;
7		data_t *data = get_vec_start(v);
8		data_t acc = IDENT; 9
10		/* Combine 2 elements at a time */
11		for (i = 0; i &lt; limit; i+=2) {
12			acc = acc OP (data[i] OP data[i+1]);
13		} 
14
15		/* Finish any remaining elements */
16		for (;i &lt; length; i++) {
17			acc = acc OP data[i];
18		}
19		*dest = acc;
20	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043541" id="P7000497027000000000000000043541"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043542" epub:type="title" id="P7000497027000000000000000043542"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.26 </span>Applying 2 × 1<var class="pcalibre17 pcalibre2 pcalibre1">a</var> unrolling.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043543" id="P7000497027000000000000000043543"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043544" id="P7000497027000000000000000043544">By reassociating the arithmetic, this approach increases the number of operations that can be performed in parallel.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043545" id="P7000497027000000000000000043545">The integer addition case matches the performance of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 unrolling (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043546" id="P7000497027000000000000000043546">combine5</code>), while the other three cases match the performance of the versions with parallel accumulators (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043547" id="P7000497027000000000000000043547">combine6</code>), doubling the performance relative to <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 unrolling. These cases have broken through the barrier imposed by the latency bound.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043548" id="P7000497027000000000000000043548"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DEE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.27</span></a> illustrates how the code for the inner loop of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043549" id="P7000497027000000000000000043549">combine7</code> (for the case of multiplication as the combining operation and double as data type) gets decoded into operations and the resulting data dependencies. We see that the load operations resulting from the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004354A" id="P700049702700000000000000004354A">vmovsd</code> and the first <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004354B" id="P700049702700000000000000004354B">vmulsd</code> instructions load vector elements <var class="pcalibre17 pcalibre2 pcalibre1">i</var> and <var class="pcalibre17 pcalibre2 pcalibre1">i</var> + 1 from memory, and the first mul operation multiplies them together. The second mul operation then multiples this result by the accumulated value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004354C" id="P700049702700000000000000004354C">acc</code>. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DF8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.28(a)</span></a> shows how we rearrange, refine, and abstract the operations of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DEE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.27</span></a> to get a template representing the data dependencies for one iteration (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DF8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.28(b)</span></a>). As with the templates for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004354D" id="P700049702700000000000000004354D">combine5</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004354E" id="P700049702700000000000000004354E">combine7</code>, we have two load and two mul operations, but only one of the mul operations forms a data-dependency chain between loop registers. When we then replicate this template <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 times to show the computations performed in multiplying <var class="pcalibre17 pcalibre2 pcalibre1">n</var> vector elements (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004E00"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.29</span></a>), we see that we only have <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 operations along the critical path. The first multiplication within each iteration can be performed without waiting for the accumulated value from the previous iteration. Thus, we reduce the minimum possible CPE by a factor of around 2.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004DEE" id="P7000497027000000000000000004DEE">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004DEF" epub:type="pagebreak" id="P7000497027000000000000000004DEF" title="543"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for combine7." class="pcalibre1 pcalibre2 calibre48" data-uri="P700049702700000000000000000B71E" id="P700049702700000000000000004354F" src="Images/chapter-05-image-16.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043550" id="P7000497027000000000000000043550"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043551" epub:type="title" id="P7000497027000000000000000043551"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.27 </span>Graphical representation of inner-loop code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043552" id="P7000497027000000000000000043552">combine7</code>.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043553" id="P7000497027000000000000000043553"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043554" id="P7000497027000000000000000043554">Each iteration gets decoded into similar operations as for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043555" id="P7000497027000000000000000043555">combine5</code> or <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043556" id="P7000497027000000000000000043556">combine6</code>, but with different data dependencies.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P700049702700000000000000002383F" id="P700049702700000000000000002383F">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043557" id="P7000497027000000000000000043557">A diagram has two rows of boxes, each with %rax, %rbp, %rdx, %rmm0, and %rmm1, with output from top %rax and %rbp to bottom %rax and %rbp, respectively. A column of boxes includes the seven operations summarized below, from top to bottom:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter05.xhtml#P7000497027000000000000000043558" id="P7000497027000000000000000043558">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043559" id="P7000497027000000000000000043559"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004355A" id="P700049702700000000000000004355A">First load (vmovsd (%rax, %rdx, 8) %rmm0): receives input from top %rax and %rdx; sends output to first mul below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004355B" id="P700049702700000000000000004355B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004355C" id="P700049702700000000000000004355C">Second load: receives input from top %rax and %rdx; sends output to first mul below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004355D" id="P700049702700000000000000004355D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004355E" id="P700049702700000000000000004355E">First mul: receives input from each load, with it and the second load together representing vmulsd 8(%rax, %rdx, 8), %rmm0, %rmm0; sends output to second mul</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004355F" id="P700049702700000000000000004355F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043560" id="P7000497027000000000000000043560">Second mul (vmulsd %rmm0, %rmm1, %rmm1): receives input from first mul and rop %rmm1 and sends output to bottom %rmm1</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043561" id="P7000497027000000000000000043561"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043562" id="P7000497027000000000000000043562">add (addq $2, %rdx): receives input from top %rdx and sends output to bottom %rdx and cmp</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043563" id="P7000497027000000000000000043563"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043564" id="P7000497027000000000000000043564">cmp (cmpq %rdx, %rbp): receives input from add above and top %rbp; sends output to jg below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043565" id="P7000497027000000000000000043565"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043566" id="P7000497027000000000000000043566">jg (jg loop): receives input from cmp above</p></li>
</ul>
</details>
</figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004DF8" id="P7000497027000000000000000004DF8">
<img alt="A diagram depicts two data-flow graphs for combine7." class="pcalibre200 pcalibre1 pcalibre2" data-uri="P700049702700000000000000000B71F" id="P7000497027000000000000000043567" src="Images/chapter-05-image-17.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043568" id="P7000497027000000000000000043568"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043569" epub:type="title" id="P7000497027000000000000000043569"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.28 </span>Abstracting <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004356A" id="P700049702700000000000000004356A">combine7</code> operations as a data-flow graph.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P700049702700000000000000004356B" id="P700049702700000000000000004356B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004356C" id="P700049702700000000000000004356C">We rearrange, simplify, and abstract the representation of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DEE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.27</span></a> to show the data dependencies between successive iterations. The upper mul operation multiplies two 2-vector elements with each other, while the lower one multiplies the result by loop variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004356D" id="P700049702700000000000000004356D">acc</code>.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P7000497027000000000000000023857" id="P7000497027000000000000000023857">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre141" data-uri="chapter05.xhtml#P700049702700000000000000004356E" id="P700049702700000000000000004356E">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004356F" id="P700049702700000000000000004356F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043570" id="P7000497027000000000000000043570">Data flows from top %rmm1 to second mul to bottom %rmm1; from top %rax to each load, each to first mul then second mul then bottom %rmm1; from top %rbp to cmp to jg; from top %rdx to each load and add, from which data is sent to bottom %rdx and to cmp.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043571" id="P7000497027000000000000000043571"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043572" id="P7000497027000000000000000043572">Data flows from top top %rmm1 to second mul to bottom %rmm1 and from top %rdx to each load, each to second mul then first mul, as well as add to bottom %rdx. The two loads are within data [i] and the two muls and add within data [i+1].</p></li>
</ol>
</details>
</figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004E00" id="P7000497027000000000000000004E00">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004E01" epub:type="pagebreak" id="P7000497027000000000000000004E01" title="544"></span>
<img alt="A diagram shows a critical paths through the second mul in groups data[0] and data[1], data[2] and data[3], and data[n minus 2] and data[n minus 1]." class="pcalibre201 pcalibre2 pcalibre1" data-uri="P700049702700000000000000000B720" id="P7000497027000000000000000043573" src="Images/chapter-05-image-18.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043574" id="P7000497027000000000000000043574"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043575" epub:type="title" id="P7000497027000000000000000043575"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.29 </span>Data-flow representation of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043576" id="P7000497027000000000000000043576">combine7</code> operating on a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043577" id="P7000497027000000000000000043577"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043578" id="P7000497027000000000000000043578">We have a single critical path, but it contains only <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 operations.</p></div>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043579" id="P7000497027000000000000000043579"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004E0A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.30</span></a> demonstrates the effect of applying the reassociation transformation to achieve what we refer to as <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1<i class="pcalibre17 pcalibre2 pcalibre1">a loop unrolling</i> for values up to <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 10. We can see that this transformation yields performance results similar to what is achieved by maintaining <var class="pcalibre17 pcalibre2 pcalibre1">k</var> separate accumulators with <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × <var class="pcalibre17 pcalibre2 pcalibre1">k</var> unrolling. In all cases, we come close to the throughput bounds imposed by the functional units.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004357A" id="P700049702700000000000000004357A">In performing the reassociation transformation, we once again change the order in which the vector elements will be combined together. For integer addition and multiplication, the fact that these operations are associative implies that this reordering will have no effect on the result. For the floating-point cases, we must once again assess whether this reassociation is likely to significantly affect</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004E0A" id="P7000497027000000000000000004E0A">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004E0B" epub:type="pagebreak" id="P7000497027000000000000000004E0B" title="545"></span>
<img alt="A graph depicts CPE versus unrolling factor k." class="pcalibre1 pcalibre2 calibre47" data-uri="P700049702700000000000000000B721" id="P700049702700000000000000004357B" src="Images/chapter-05-image-19.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P700049702700000000000000004357C" id="P700049702700000000000000004357C"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P700049702700000000000000004357D" epub:type="title" id="P700049702700000000000000004357D"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.30 </span>CPE performance for <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1<var class="pcalibre17 pcalibre2 pcalibre1">a</var> loop unrolling.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P700049702700000000000000004357E" id="P700049702700000000000000004357E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004357F" id="P700049702700000000000000004357F">All of the CPEs improve with this transformation, nearly approaching their throughput bounds.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P700049702700000000000000002386A" id="P700049702700000000000000002386A">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043580" id="P7000497027000000000000000043580">The four sets of points plotted each decreasing in CPE with increasing rolling factor k, as summarized below.</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter05.xhtml#P7000497027000000000000000043581" id="P7000497027000000000000000043581">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043582" id="P7000497027000000000000000043582"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043583" id="P7000497027000000000000000043583">Double *: from 5 CPE at 1 to about 0.5 CPE at 10</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043584" id="P7000497027000000000000000043584"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043585" id="P7000497027000000000000000043585">Double + and long *: each from 3 CPE at 1 to steady around 1 CPE by 3</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043586" id="P7000497027000000000000000043586"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043587" id="P7000497027000000000000000043587">Long +: from about 1.5 CPE at 1 to steady around 0.5 CPE by 5</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043588" id="P7000497027000000000000000043588">the outcome. We would argue that the difference would be immaterial for most applications.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043589" id="P7000497027000000000000000043589">In summary, a reassociation transformation can reduce the number of operations along the critical path in a computation, resulting in better performance by better utilizing the multiple functional units and their pipelining capabilities. Most compilers will not attempt any reassociations of floating-point operations, since these operations are not guaranteed to be associative. Current versions of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>do perform reassociations of integer operations, but not always with good effects. In general, we have found that unrolling a loop and accumulating multiple values in parallel is a more reliable way to achieve improved program performance.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004E13" epub:type="practice" id="P7000497027000000000000000004E13"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004358A" epub:type="title" id="P700049702700000000000000004358A"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.8 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005148">576</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P700049702700000000000000004358B" id="P700049702700000000000000004358B">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P700049702700000000000000004358C" id="P700049702700000000000000004358C">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P700049702700000000000000004358D" id="P700049702700000000000000004358D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004358E" id="P700049702700000000000000004358E">Consider the following function for computing the product of an array of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> double-precision numbers. We have unrolled the loop by a factor of 3.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004358F" id="P700049702700000000000000004358F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043590" id="P7000497027000000000000000043590">
double aprod(double a[], long n)
{
	long i;
	double x, y, z;
	double r = 1;
	for (i = 0; i &lt; n-2; i+= 3) {
		x = a[i]; y = a[i+1]; z = a[i+2];
		r = r * x * y * z; /* Product computation */
		}
	for (;i &lt; n; i++)
		r *= a[i];
	return r;
}
</code></pre>
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004E1B" epub:type="pagebreak" id="P7000497027000000000000000004E1B" title="546"></span>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043591" id="P7000497027000000000000000043591">For the line labeled "Product computation," we can use parentheses to create five different associations of the computation, as follows:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043592" id="P7000497027000000000000000043592"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043593" id="P7000497027000000000000000043593">
r = ((r * x) * y) * z; /* A1 */
r = (r * (x * y)) * z; /* A2 */
r = r * ((x * y) * z); /* A3 */
r = r * (x * (y * z)); /* A4 */
r = (r * x) * (y * z); /* A5 */
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043594" id="P7000497027000000000000000043594">Assume we run these functions on a machine where floating-point multiplication has a latency of 5 clock cycles. Determine the lower bound on the CPE set by the data dependencies of the multiplication. (<i class="pcalibre17 pcalibre2 pcalibre1">Hint:</i> It helps to draw a data-flow representation of how <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043595" id="P7000497027000000000000000043595">r</code> is computed on every iteration.)</p></div></li>
</ol>
</section>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000004E21" id="P7000497027000000000000000004E21"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter05.xhtml#P7000497027000000000000000043596" epub:type="title" id="P7000497027000000000000000043596"><span class="pcalibre1 pcalibre2 pcalibre34">Web Aside OPT:SIMD </span>Achieving greater parallelism with vector instructions</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043597" id="P7000497027000000000000000043597">As described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001E06.xhtml#P7000497027000000000000000001E06"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.1</span></a>, Intel introduced the SSE instructions in 1999, where SSE is the acronym for "streaming SIMD extensions" and, in turn, SIMD (pronounced "sim-dee") is the acronym for "single instruction, multiple data." The SSE capability has gone through multiple generations, with more recent versions being named <i class="pcalibre17 pcalibre2 pcalibre1">advanced vector extensions</i>, or AVX. The SIMD execution model involves operating on entire vectors of data within single instructions. These vectors are held in a special set of <i class="pcalibre17 pcalibre2 pcalibre1">vector registers</i>, named <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043598" id="P7000497027000000000000000043598">%ymm0-%ymm15</code>. Current AVX vector registers are 32 bytes long, and therefore each can hold eight 32-bit numbers or four 64-bit numbers, where the numbers can be either integer or floating-point values. AVX instructions can then perform vector operations on these registers, such as adding or multiplying eight or four sets of values in parallel. For example, if YMM register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043599" id="P7000497027000000000000000043599">%ymm0</code> contains eight single-precision floating-point numbers, which we denote <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">0</sub>, . . ., <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">7</sub>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004359A" id="P700049702700000000000000004359A">%rcx</code> contains the memory address of a sequence of eight single-precision floating-point numbers, which we denote <var class="pcalibre17 pcalibre2 pcalibre1">b</var><sub class="pcalibre1 pcalibre2 calibre14">0</sub>, . . ., <var class="pcalibre17 pcalibre2 pcalibre1">b</var><sub class="pcalibre1 pcalibre2 calibre14">7</sub>, then the instruction</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004359B" id="P700049702700000000000000004359B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004359C" id="P700049702700000000000000004359C">
vmulps (%rcs), %ymm0, %ymm1
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P700049702700000000000000004359D" id="P700049702700000000000000004359D">will read the eight values from memory and perform eight multiplications in parallel, computing <i class="pcalibre17 pcalibre2 pcalibre1">a<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i> ← <i class="pcalibre17 pcalibre2 pcalibre1">a<sub class="pcalibre1 pcalibre2 calibre14">i</sub> · b<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>, for 0 &lt; <var class="pcalibre17 pcalibre2 pcalibre1">i</var> ≤ 7 and storing the resulting eight products in vector register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004359E" id="P700049702700000000000000004359E">%ymm1</code>. We see that a single instruction is able to generate a computation over multiple data values, hence the term "SIMD."</p>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P700049702700000000000000004359F" id="P700049702700000000000000004359F"><span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>supports extensions to the C language that let programmers express a program in terms of vector operations that can be compiled into the vector instructions of AVX (as well as code based on the earlier SSE instructions). This coding style is preferable to writing code directly in assembly language, since <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>can also generate code for the vector instructions found on other processors.</p>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000435A0" id="P70004970270000000000000000435A0">Using a combination of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>instructions, loop unrolling, and multiple accumulators, we are able to achieve the following performance for our combining functions:</p>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000435A1" id="P70004970270000000000000000435A1"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004E2E" epub:type="pagebreak" id="P7000497027000000000000000004E2E" title="547"></span></p>
<table class="pcalibre1 informaltable pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000435A2" id="P70004970270000000000000000435A2">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435A3" id="P70004970270000000000000000435A3"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="4" data-uri="chapter05.xhtml#P70004970270000000000000000435A4" id="P70004970270000000000000000435A4">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="4" data-uri="chapter05.xhtml#P70004970270000000000000000435A5" id="P70004970270000000000000000435A5">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435A6" id="P70004970270000000000000000435A6"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000435A7" id="P70004970270000000000000000435A7">int</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000435A8" id="P70004970270000000000000000435A8">long</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000435A9" id="P70004970270000000000000000435A9">int</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000435AA" id="P70004970270000000000000000435AA">long</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435AB" id="P70004970270000000000000000435AB">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435AC" id="P70004970270000000000000000435AC">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435AD" id="P70004970270000000000000000435AD">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435AE" id="P70004970270000000000000000435AE">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435AF" id="P70004970270000000000000000435AF">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435B0" id="P70004970270000000000000000435B0">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435B1" id="P70004970270000000000000000435B1">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435B2" id="P70004970270000000000000000435B2">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435B3" id="P70004970270000000000000000435B3">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435B4" id="P70004970270000000000000000435B4">Scalar 10 × 10</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435B5" id="P70004970270000000000000000435B5">0.54</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435B6" id="P70004970270000000000000000435B6">1.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435B7" id="P70004970270000000000000000435B7">0.55</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435B8" id="P70004970270000000000000000435B8">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435B9" id="P70004970270000000000000000435B9">1.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435BA" id="P70004970270000000000000000435BA">0.51</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435BB" id="P70004970270000000000000000435BB">1.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435BC" id="P70004970270000000000000000435BC">0.52</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435BD" id="P70004970270000000000000000435BD">Scalar throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435BE" id="P70004970270000000000000000435BE">0.50</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435BF" id="P70004970270000000000000000435BF">0.50</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435C0" id="P70004970270000000000000000435C0">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435C1" id="P70004970270000000000000000435C1">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435C2" id="P70004970270000000000000000435C2">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435C3" id="P70004970270000000000000000435C3">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435C4" id="P70004970270000000000000000435C4">0.50</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435C5" id="P70004970270000000000000000435C5">0.50</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435C6" id="P70004970270000000000000000435C6">Vector 8 × 8</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435C7" id="P70004970270000000000000000435C7">0.05</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435C8" id="P70004970270000000000000000435C8">0.24</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435C9" id="P70004970270000000000000000435C9">0.13</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435CA" id="P70004970270000000000000000435CA">1.51</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435CB" id="P70004970270000000000000000435CB">0.12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435CC" id="P70004970270000000000000000435CC">0.08</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435CD" id="P70004970270000000000000000435CD">0.25</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435CE" id="P70004970270000000000000000435CE">0.16</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435CF" id="P70004970270000000000000000435CF">Vector throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435D0" id="P70004970270000000000000000435D0">0.06</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435D1" id="P70004970270000000000000000435D1">0.12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435D2" id="P70004970270000000000000000435D2">0.12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435D3" id="P70004970270000000000000000435D3">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435D4" id="P70004970270000000000000000435D4">0.12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435D5" id="P70004970270000000000000000435D5">0.06</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435D6" id="P70004970270000000000000000435D6">0.25</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435D7" id="P70004970270000000000000000435D7">0.12</td>
</tr>
</tbody>
</table>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000435D8" id="P70004970270000000000000000435D8">In this chart, the first set of numbers is for conventional, <i class="pcalibre17 pcalibre2 pcalibre1">scalar</i> code written in the style of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000435D9" id="P70004970270000000000000000435D9">combine6</code>, unrolling by a factor of 10 and maintaining 10 accumulators. The second set of numbers is for code written in a form that <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>can compile into AVX vector code. In addition to using vector operations, this version unrolls the main loop by a factor of 8 and maintains eight separate vector accumulators. We show results for both 32-bit and 64-bit numbers, since the vector instructions achieve 8-way parallelism in the first case, but only 4-way parallelism in the second.</p>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000435DA" id="P70004970270000000000000000435DA">We can see that the vector code achieves almost an eightfold improvement on the four 32-bit cases, and a fourfold improvement on three of the four 64-bit cases. Only the long integer multiplication code does not perform well when we attempt to express it in vector code. The AVX instruction set does not include one to do parallel multiplication of 64-bit integers, and so <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>cannot generate vector code for this case. Using vector instructions creates a new throughput bound for the combining operations. These are eight times lower for 32-bit operations and four times lower for 64-bit operations than the scalar limits. Our code comes close to achieving these bounds for several combinations of data type and operation.</p>
</aside>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.10 Summary of Results for Optimizing Combining Code</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000004E68"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P70004970270000000000000000435DB" epub:type="title" id="P70004970270000000000000000435DB"><span class="pcalibre1 pcalibre21 pcalibre2">5.10 </span>Summary of Results for Optimizing Combining Code</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000435DC" id="P70004970270000000000000000435DC">Our efforts at maximizing the performance of a routine that adds or multiplies the elements of a vector have clearly paid off. The following summarizes the results we obtain with <i class="pcalibre17 pcalibre2 pcalibre1">scalar</i> code, not making use of the vector parallelism provided by AVX vector instructions:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P70004970270000000000000000435DD" id="P70004970270000000000000000435DD">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435DE" id="P70004970270000000000000000435DE"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435DF" id="P70004970270000000000000000435DF"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435E0" id="P70004970270000000000000000435E0"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000435E1" id="P70004970270000000000000000435E1">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P70004970270000000000000000435E2" id="P70004970270000000000000000435E2">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435E3" id="P70004970270000000000000000435E3">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435E4" id="P70004970270000000000000000435E4">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435E5" id="P70004970270000000000000000435E5">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435E6" id="P70004970270000000000000000435E6">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435E7" id="P70004970270000000000000000435E7">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435E8" id="P70004970270000000000000000435E8">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000435E9" id="P70004970270000000000000000435E9">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435EA" id="P70004970270000000000000000435EA"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000435EB" id="P70004970270000000000000000435EB">combine1</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435EC" id="P70004970270000000000000000435EC">507</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435ED" id="P70004970270000000000000000435ED">Abstract <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000435EE" id="P70004970270000000000000000435EE">−01</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435EF" id="P70004970270000000000000000435EF">10.12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435F0" id="P70004970270000000000000000435F0">10.12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435F1" id="P70004970270000000000000000435F1">10.17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435F2" id="P70004970270000000000000000435F2">11.14</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435F3" id="P70004970270000000000000000435F3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000435F4" id="P70004970270000000000000000435F4">combine6</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435F5" id="P70004970270000000000000000435F5">537</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435F6" id="P70004970270000000000000000435F6">2 × 2 unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435F7" id="P70004970270000000000000000435F7">0.81</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435F8" id="P70004970270000000000000000435F8">1.51</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435F9" id="P70004970270000000000000000435F9">1.51</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435FA" id="P70004970270000000000000000435FA">2.51</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435FB" id="P70004970270000000000000000435FB">10 × 10 unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435FC" id="P70004970270000000000000000435FC">0.55</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435FD" id="P70004970270000000000000000435FD">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435FE" id="P70004970270000000000000000435FE">1.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000435FF" id="P70004970270000000000000000435FF">0.52</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043600" id="P7000497027000000000000000043600">Latency bound</td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043601" id="P7000497027000000000000000043601">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043602" id="P7000497027000000000000000043602">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043603" id="P7000497027000000000000000043603">3.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043604" id="P7000497027000000000000000043604">5.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043605" id="P7000497027000000000000000043605">Throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043606" id="P7000497027000000000000000043606">0.50</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043607" id="P7000497027000000000000000043607">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043608" id="P7000497027000000000000000043608">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043609" id="P7000497027000000000000000043609">0.50</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004360A" id="P700049702700000000000000004360A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004E99" epub:type="pagebreak" id="P7000497027000000000000000004E99" title="548"></span>By using multiple optimizations, we have been able to achieve CPEs close to the throughput bounds of 0.50 and 1.00, limited only by the capacities of the functional units. These represent 10−20× improvements on the original code. This has all been done using ordinary C code and a standard compiler. Rewriting the code to take advantage of the newer SIMD instructions yields additional performance gains of nearly 4× or 8×. For example, for single-precision multiplication, the CPE drops from the original value of 11.14 down to 0.06, an overall performance gain of over 180×. This example demonstrates that modern processors have considerable amounts of computing power, but we may need to coax this power out of them by writing our programs in very stylized ways.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.11 Some Limiting Factors</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000004E9A"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P700049702700000000000000004360B" epub:type="title" id="P700049702700000000000000004360B"><span class="pcalibre1 pcalibre21 pcalibre2">5.11 </span>Some Limiting Factors</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004360C" id="P700049702700000000000000004360C">We have seen that the critical path in a data-flow graph representation of a program indicates a fundamental lower bound on the time required to execute a program. That is, if there is some chain of data dependencies in a program where the sum of all of the latencies along that chain equals <var class="pcalibre17 pcalibre2 pcalibre1">T</var>, then the program will require at least <var class="pcalibre17 pcalibre2 pcalibre1">T</var> cycles to execute.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004360D" id="P700049702700000000000000004360D">We have also seen that the throughput bounds of the functional units also impose a lower bound on the execution time for a program. That is, assume that a program requires a total of <var class="pcalibre17 pcalibre2 pcalibre1">N</var> computations of some operation, that the microprocessor has <var class="pcalibre17 pcalibre2 pcalibre1">C</var> functional units capable of performing that operation, and that these units have an issue time of <var class="pcalibre17 pcalibre2 pcalibre1">I</var>. Then the program will require at least <i class="pcalibre17 pcalibre2 pcalibre1">N · I/C</i> cycles to execute.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004360E" id="P700049702700000000000000004360E">In this section, we will consider some other factors that limit the performance of programs on actual machines.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004E9F" id="P7000497027000000000000000004E9F"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004360F" epub:type="title" id="P700049702700000000000000004360F"><span class="pcalibre1 pcalibre21 pcalibre2">5.11.1 </span>Register Spilling</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043610" id="P7000497027000000000000000043610">The benefits of loop parallelism are limited by the ability to express the computation in assembly code. If a program has a degree of parallelism <var class="pcalibre17 pcalibre2 pcalibre1">P</var> that exceeds the number of available registers, then the compiler will resort to <i class="pcalibre17 pcalibre2 pcalibre1">spilling</i>, storing some of the temporary values in memory, typically by allocating space on the run-time stack. As an example, the following measurements compare the result of extending the multiple accumulator scheme of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043611" id="P7000497027000000000000000043611">combine6</code> to the cases of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 10 and <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 20:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P7000497027000000000000000043612" id="P7000497027000000000000000043612">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043613" id="P7000497027000000000000000043613"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043614" id="P7000497027000000000000000043614"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043615" id="P7000497027000000000000000043615"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043616" id="P7000497027000000000000000043616">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043617" id="P7000497027000000000000000043617">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043618" id="P7000497027000000000000000043618">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043619" id="P7000497027000000000000000043619">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004361A" id="P700049702700000000000000004361A">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004361B" id="P700049702700000000000000004361B">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004361C" id="P700049702700000000000000004361C">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004361D" id="P700049702700000000000000004361D">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004361E" id="P700049702700000000000000004361E">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004361F" id="P700049702700000000000000004361F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043620" id="P7000497027000000000000000043620">combine6</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043621" id="P7000497027000000000000000043621">537</td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043622" id="P7000497027000000000000000043622">10 × 10 unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043623" id="P7000497027000000000000000043623">0.55</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043624" id="P7000497027000000000000000043624">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043625" id="P7000497027000000000000000043625">1.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043626" id="P7000497027000000000000000043626">0.52</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043627" id="P7000497027000000000000000043627">20 × 20 unrolling</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043628" id="P7000497027000000000000000043628">0.83</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043629" id="P7000497027000000000000000043629">1.03</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004362A" id="P700049702700000000000000004362A">1.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004362B" id="P700049702700000000000000004362B">0.68</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004362C" id="P700049702700000000000000004362C">Throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7"></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004362D" id="P700049702700000000000000004362D">0.50</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004362E" id="P700049702700000000000000004362E">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004362F" id="P700049702700000000000000004362F">1.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043630" id="P7000497027000000000000000043630">0.50</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043631" id="P7000497027000000000000000043631"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004EC3" epub:type="pagebreak" id="P7000497027000000000000000004EC3" title="549"></span>We can see that none of the CPEs improve with this increased unrolling, and some even get worse. Modern x86-64 processors have 16 integer registers and can make use of the 16 YMM registers to store floating-point data. Once the number of loop variables exceeds the number of available registers, the program must allocate some on the stack.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043632" id="P7000497027000000000000000043632">As an example, the following snippet of code shows how accumulator <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043633" id="P7000497027000000000000000043633">acc0</code> is updated in the inner loop of the code with 10 × 10 unrolling:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043634" id="P7000497027000000000000000043634"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043635" id="P7000497027000000000000000043635">
<i class="pcalibre17 pcalibre2 pcalibre1">Updating of accumulator acc0 in 10 x 10 urolling</i>
vmulsd (%rdx), %xmm0, %xmm0	<i class="pcalibre17 pcalibre2 pcalibre1">acc0 *= data[i]</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043636" id="P7000497027000000000000000043636">We can see that the accumulator is kept in register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043637" id="P7000497027000000000000000043637">%xmm0</code>, and so the program can simply read <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043638" id="P7000497027000000000000000043638">data[i]</code> from memory and multiply it by this register.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043639" id="P7000497027000000000000000043639">The comparable part of the code for 20 × 20 unrolling has a much different form:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004363A" id="P700049702700000000000000004363A"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004363B" id="P700049702700000000000000004363B">
<i class="pcalibre17 pcalibre2 pcalibre1">Updating of accumulator acc0 in 20 x 20 unrolling</i>
vmovsd 40(%rsp), %xmm0
vmulsd (%rdx), %xmm0, %xmm0
vmovsd %xmm0, 40(%rsp)
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004363C" id="P700049702700000000000000004363C">The accumulator is kept as a local variable on the stack, at offset 40 from the stack pointer. The program must read both its value and the value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004363D" id="P700049702700000000000000004363D">data[i]</code> from memory, multiply them, and store the result back to memory.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004363E" id="P700049702700000000000000004363E">Once a compiler must resort to register spilling, any advantage of maintaining multiple accumulators will most likely be lost. Fortunately, x86-64 has enough registers that most loops will become throughput limited before this occurs.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004ED1" id="P7000497027000000000000000004ED1"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004363F" epub:type="title" id="P700049702700000000000000004363F"><span class="pcalibre1 pcalibre21 pcalibre2">5.11.2 </span>Branch Prediction and Misprediction Penalties</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043640" id="P7000497027000000000000000043640">We demonstrated via experiments in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.6.6</span></a> that a conditional branch can incur a significant <i class="pcalibre17 pcalibre2 pcalibre1">misprediction penalty</i> when the branch prediction logic does not correctly anticipate whether or not a branch will be taken. Now that we have learned something about how processors operate, we can understand where this penalty arises.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043641" id="P7000497027000000000000000043641">Modern processors work well ahead of the currently executing instructions, reading new instructions from memory and decoding them to determine what operations to perform on what operands. This <i class="pcalibre17 pcalibre2 pcalibre1">instruction pipelining</i> works well as long as the instructions follow in a simple sequence. When a branch is encountered, the processor must guess which way the branch will go. For the case of a conditional jump, this means predicting whether or not the branch will be taken. For an instruction such as an indirect jump (as we saw in the code to jump to an address specified by a jump table entry) or a procedure return, this means predicting the target address. In this discussion, we focus on conditional branches.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043642" id="P7000497027000000000000000043642">In a processor that employs <i class="pcalibre17 pcalibre2 pcalibre1">speculative execution</i>, the processor begins executing the instructions at the predicted branch target. It does this in a way that avoids modifying any actual register or memory locations until the actual outcome has been determined. If the prediction is correct, the processor can then <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004ED6" epub:type="pagebreak" id="P7000497027000000000000000004ED6" title="550"></span>"commit" the results of the speculatively executed instructions by storing them in registers or memory. If the prediction is incorrect, the processor must discard all of the speculatively executed results and restart the instruction fetch process at the correct location. The misprediction penalty is incurred in doing this, because the instruction pipeline must be refilled before useful results are generated.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043643" id="P7000497027000000000000000043643">We saw in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.6.6</span></a> that recent versions of x86 processors, including all processors capable of executing x86-64 programs, have <i class="pcalibre17 pcalibre2 pcalibre1">conditional move</i> instructions. <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>can generate code that uses these instructions when compiling conditional statements and expressions, rather than the more traditional realizations based on conditional transfers of control. The basic idea for translating into conditional moves is to compute the values along both branches of a conditional expression or statement and then use conditional moves to select the desired value. We saw in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000041EB_split_001.xhtml#P70004970270000000000000000043A8"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">4.5.7</span></a> that conditional move instructions can be implemented as part of the pipelined processing of ordinary instructions. There is no need to guess whether or not the condition will hold, and hence no penalty for guessing incorrectly.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043644" id="P7000497027000000000000000043644">How, then, can a C programmer make sure that branch misprediction penalties do not hamper a program's efficiency? Given the 19-cycle misprediction penalty we measured for the reference machine, the stakes are very high. There is no simple answer to this question, but the following general principles apply.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004ED9" id="P7000497027000000000000000004ED9"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043645" epub:type="title" id="P7000497027000000000000000043645">Do Not Be Overly Concerned about Predictable Branches</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043646" id="P7000497027000000000000000043646">We have seen that the effect of a mispredicted branch can be very high, but that does not mean that all program branches will slow a program down. In fact, the branch prediction logic found in modern processors is very good at discerning regular patterns and long-term trends for the different branch instructions. For example, the loop-closing branches in our combining routines would typically be predicted as being taken, and hence would only incur a misprediction penalty on the last time around.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043647" id="P7000497027000000000000000043647">As another example, consider the results we observed when shifting from <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043648" id="P7000497027000000000000000043648">combine2</code> to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043649" id="P7000497027000000000000000043649">combine3</code>, when we took the function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004364A" id="P700049702700000000000000004364A">get_vec_element</code> out of the inner loop of the function, as is reproduced below:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P700049702700000000000000004364B" id="P700049702700000000000000004364B">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004364C" id="P700049702700000000000000004364C"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004364D" id="P700049702700000000000000004364D"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004364E" id="P700049702700000000000000004364E"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P700049702700000000000000004364F" id="P700049702700000000000000004364F">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043650" id="P7000497027000000000000000043650">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043651" id="P7000497027000000000000000043651">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043652" id="P7000497027000000000000000043652">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043653" id="P7000497027000000000000000043653">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043654" id="P7000497027000000000000000043654">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043655" id="P7000497027000000000000000043655">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043656" id="P7000497027000000000000000043656">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043657" id="P7000497027000000000000000043657">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043658" id="P7000497027000000000000000043658"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043659" id="P7000497027000000000000000043659">combine2</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004365A" id="P700049702700000000000000004365A">509</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004365B" id="P700049702700000000000000004365B">Move <code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004365C" id="P700049702700000000000000004365C">vec_length</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004365D" id="P700049702700000000000000004365D">7.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004365E" id="P700049702700000000000000004365E">9.03</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004365F" id="P700049702700000000000000004365F">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043660" id="P7000497027000000000000000043660">11.03</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043661" id="P7000497027000000000000000043661"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043662" id="P7000497027000000000000000043662">combine3</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043663" id="P7000497027000000000000000043663">513</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043664" id="P7000497027000000000000000043664">Direct data access</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043665" id="P7000497027000000000000000043665">7.17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043666" id="P7000497027000000000000000043666">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043667" id="P7000497027000000000000000043667">9.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043668" id="P7000497027000000000000000043668">11.03</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043669" id="P7000497027000000000000000043669">The CPE did not improve, even though the transformation eliminated two conditionals on each iteration that check whether the vector index is within bounds. For this function, the checks always succeed, and hence they are highly predictable.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004366A" id="P700049702700000000000000004366A">As a way to measure the performance impact of bounds checking, consider the following combining code, where we have modified the inner loop of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004366B" id="P700049702700000000000000004366B">combine4</code> by replacing the access to the data element with the result of performing an inline substitution of the code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004366C" id="P700049702700000000000000004366C">get_vec_element</code>. We will call this new version <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004F02" epub:type="pagebreak" id="P7000497027000000000000000004F02" title="551"></span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004366D" id="P700049702700000000000000004366D">combine4b</code>. This code performs bounds checking and also references the vector elements through the vector data structure.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004366E" id="P700049702700000000000000004366E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004366F" id="P700049702700000000000000004366F">
1	/* Include bounds check in loop */
2	void combine4b(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		data_t acc = IDENT;
7	
8		for (i = 0; i &lt; length; i++) {
9			if (i &gt;= 0 &amp;&amp; i &lt; v-&gt;len) {
10				acc = acc OP v-&gt;data[i];
11			}
12		}
13		*dest = acc;
14	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043670" id="P7000497027000000000000000043670">We can then directly compare the CPE for the functions with and without bounds checking:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P7000497027000000000000000043671" id="P7000497027000000000000000043671">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043672" id="P7000497027000000000000000043672"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043673" id="P7000497027000000000000000043673"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043674" id="P7000497027000000000000000043674"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043675" id="P7000497027000000000000000043675">Integer</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter05.xhtml#P7000497027000000000000000043676" id="P7000497027000000000000000043676">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043677" id="P7000497027000000000000000043677">Function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043678" id="P7000497027000000000000000043678">Page</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043679" id="P7000497027000000000000000043679">Method</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004367A" id="P700049702700000000000000004367A">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004367B" id="P700049702700000000000000004367B">*</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004367C" id="P700049702700000000000000004367C">+</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004367D" id="P700049702700000000000000004367D">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004367E" id="P700049702700000000000000004367E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004367F" id="P700049702700000000000000004367F">combine4</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043680" id="P7000497027000000000000000043680">515</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043681" id="P7000497027000000000000000043681">No bounds checking</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043682" id="P7000497027000000000000000043682">1.27</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043683" id="P7000497027000000000000000043683">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043684" id="P7000497027000000000000000043684">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043685" id="P7000497027000000000000000043685">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043686" id="P7000497027000000000000000043686"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043687" id="P7000497027000000000000000043687">combine4b</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043688" id="P7000497027000000000000000043688">515</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043689" id="P7000497027000000000000000043689">Bounds checking</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004368A" id="P700049702700000000000000004368A">2.02</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004368B" id="P700049702700000000000000004368B">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004368C" id="P700049702700000000000000004368C">3.01</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004368D" id="P700049702700000000000000004368D">5.01</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004368E" id="P700049702700000000000000004368E">The version with bounds checking is slightly slower for the case of integer addition, but it achieves the same performance for the other three cases. The performance of these cases is limited by the latencies of their respective combining operations. The additional computation required to perform bounds checking can take place in parallel with the combining operations. The processor is able to predict the outcomes of these branches, and so none of this evaluation has much effect on the fetching and processing of the instructions that form the critical path in the program execution.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004F25" id="P7000497027000000000000000004F25"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004368F" epub:type="title" id="P700049702700000000000000004368F">Write Code Suitable for Implementation with Conditional Moves</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043690" id="P7000497027000000000000000043690">Branch prediction is only reliable for regular patterns. Many tests in a program are completely unpredictable, dependent on arbitrary features of the data, such as whether a number is negative or positive. For these, the branch prediction logic will do very poorly. For inherently unpredictable cases, program performance can be greatly enhanced if the compiler is able to generate code using conditional data transfers rather than conditional control transfers. This cannot be controlled directly by the C programmer, but some ways of expressing conditional behavior can be more directly translated into conditional moves than others.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043691" id="P7000497027000000000000000043691">We have found that <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>is able to generate conditional moves for code written in a more "functional" style, where we use conditional operations to compute <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004F29" epub:type="pagebreak" id="P7000497027000000000000000004F29" title="552"></span>values and then update the program state with these values, as opposed to a more "imperative" style, where we use conditionals to selectively update program state.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043692" id="P7000497027000000000000000043692">There are no strict rules for these two styles, and so we illustrate with an example. Suppose we are given two arrays of integers <var class="pcalibre17 pcalibre2 pcalibre1">a</var> and <var class="pcalibre17 pcalibre2 pcalibre1">b</var>, and at each position <var class="pcalibre17 pcalibre2 pcalibre1">i</var>, we want to set <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043693" id="P7000497027000000000000000043693">a[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> to the minimum of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043694" id="P7000497027000000000000000043694">a[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043695" id="P7000497027000000000000000043695">b[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043696" id="P7000497027000000000000000043696">b[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> to the maximum.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043697" id="P7000497027000000000000000043697">An imperative style of implementing this function is to check at each position <var class="pcalibre17 pcalibre2 pcalibre1">i</var> and swap the two elements if they are out of order:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043698" id="P7000497027000000000000000043698"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043699" id="P7000497027000000000000000043699">
1	/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */
2	void minmax1(long a[], long b[], long n) {
3		long i;
4		for (i = 0; i &lt; n; i++) {
5			if (a[i] &gt; b[i]) {
6				long t = a[i];
7				a[i] = b[i];
8				b[i] = t;
9			}
10		}
11	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004369A" id="P700049702700000000000000004369A">Our measurements for this function show a CPE of around 13.5 for random data and 2.5-3.5 for predictable data, an indication of a misprediction penalty of around 20 cycles.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004369B" id="P700049702700000000000000004369B">A functional style of implementing this function is to compute the minimum and maximum values at each position <var class="pcalibre17 pcalibre2 pcalibre1">i</var> and then assign these values to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004369C" id="P700049702700000000000000004369C">a[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004369D" id="P700049702700000000000000004369D">b[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code>, respectively:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004369E" id="P700049702700000000000000004369E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004369F" id="P700049702700000000000000004369F">
1	/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */
2	void minmax2(long a[], long b[], long n) {
3		long i;
4		for (i = 0; i &lt; n; i++) {
5			long min = a[i] &lt; b[i] ? a[i] : b[i];
6			long max = a[i] &lt; b[i] ? b[i] : a[i];
7			a[i] = min;
8			b[i] = max;
9		}
10	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436A0" id="P70004970270000000000000000436A0">Our measurements for this function show a CPE of around 4.0 regardless of whether the data are arbitrary or predictable. (We also examined the generated assembly code to make sure that it indeed uses conditional moves.)</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436A1" id="P70004970270000000000000000436A1">As discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.6.6</span></a>, not all conditional behavior can be implemented with conditional data transfers, and so there are inevitably cases where programmers cannot avoid writing code that will lead to conditional branches for which the processor will do poorly with its branch prediction. But, as we have shown, a little cleverness on the part of the programmer can sometimes make code more amenable to translation into conditional data transfers. This requires some amount <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004F3A" epub:type="pagebreak" id="P7000497027000000000000000004F3A" title="553"></span>of experimentation, writing different versions of the function and then examining the generated assembly code and measuring performance.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004F3B" epub:type="practice" id="P7000497027000000000000000004F3B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436A2" epub:type="title" id="P70004970270000000000000000436A2"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.9 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005148">576</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P70004970270000000000000000436A3" id="P70004970270000000000000000436A3">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P70004970270000000000000000436A4" id="P70004970270000000000000000436A4">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000436A5" id="P70004970270000000000000000436A5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436A6" id="P70004970270000000000000000436A6">The traditional implementation of the merge step of mergesort requires three loops [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B468">98</a>]:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436A7" id="P70004970270000000000000000436A7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436A8" id="P70004970270000000000000000436A8">
1	void merge(long src1[], long src2[], long dest[], long n) {
2		long i1 = 0;
3		long i2 = 0;
4		long id = 0;
5		while (i1 &lt; n &amp;&amp; i2 &lt; n) {
6			if (src1[i1] &lt; src2[i2])
7				dest[id++] = src1[i1++];
8			else
9				dest[id++] = src2[i2++];
10		}
11		while (i1 &lt; n)
12			dest[id++] = src1[i1++];
13		while (i2 &lt; n)
14			dest[id++] = src2[i2++];
15	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436A9" id="P70004970270000000000000000436A9">The branches caused by comparing variables <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436AA" id="P70004970270000000000000000436AA">i1</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436AB" id="P70004970270000000000000000436AB">i2</code> to n have good prediction performance—the only mispredictions occur when they first become false. The comparison between values <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436AC" id="P70004970270000000000000000436AC">src1[i1]</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436AD" id="P70004970270000000000000000436AD">src2[i2]</code> (line 6), on the other hand, is highly unpredictable for typical data. This comparison controls a conditional branch, yielding a CPE (where the number of elements is 2<var class="pcalibre17 pcalibre2 pcalibre1">n</var>) of around 15.0 when run on random data.</p>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436AE" id="P70004970270000000000000000436AE">Rewrite the code so that the effect of the conditional statement in the first loop (lines 6-9) can be implemented with a conditional move.</p></div></li>
</ol>
</section>
</section>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.12 Understanding Memory Performance</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000004F49"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P70004970270000000000000000436AF" epub:type="title" id="P70004970270000000000000000436AF"><span class="pcalibre1 pcalibre21 pcalibre2">5.12 </span>Understanding Memory Performance</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436B0" id="P70004970270000000000000000436B0">All of the code we have written thus far, and all the tests we have run, access relatively small amounts of memory. For example, the combining routines were measured over vectors of length less than 1,000 elements, requiring no more than 8,000 bytes of data. All modern processors contain one or more <i class="pcalibre17 pcalibre2 pcalibre1">cache</i> memories to provide fast access to such small amounts of memory. In this section, we will further investigate the performance of programs that involve load (reading from memory into registers) and store (writing from registers to memory) operations, considering only the cases where all data are held in cache. In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000005190.xhtml#P7000497027000000000000000005190"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">6</span></a>, we go into much more detail about how caches work, their performance characteristics, and how to write code that makes best use of caches.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436B1" id="P70004970270000000000000000436B1"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004F4D" epub:type="pagebreak" id="P7000497027000000000000000004F4D" title="554"></span>As <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004B76"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.11</span></a> shows, modern processors have dedicated functional units to perform load and store operations, and these units have internal buffers to hold sets of outstanding requests for memory operations. For example, our reference machine has two load units, each of which can holdup to 72 pending read requests. It has a single store unit with a store buffer containing up to 42 write requests. Each of these units can initiate 1 operation every clock cycle.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004F4E" id="P7000497027000000000000000004F4E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436B2" epub:type="title" id="P70004970270000000000000000436B2"><span class="pcalibre1 pcalibre21 pcalibre2">5.12.1 </span>Load Performance</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436B3" id="P70004970270000000000000000436B3">The performance of a program containing load operations depends on both the pipelining capability and the latency of the load unit. In our experiments with combining operations using our reference machine, we saw that the CPE never got below 0.50 for any combination of data type and combining operation, except when using SIMD operations. One factor limiting the CPE for our examples is that they all require reading one value from memory for each element computed. With two load units, each able to initiate at most 1 load operation every clock cycle, the CPE cannot be less than 0.50. For applications where we must load <var class="pcalibre17 pcalibre2 pcalibre1">k</var> values for every element computed, we can never achieve a CPE lower than <var class="pcalibre17 pcalibre2 pcalibre1">k</var>/2 (see, for example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000005090.xhtml#P70004970270000000000000000050AF"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15</span></a>).</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436B4" id="P70004970270000000000000000436B4">In our examples so far, we have not seen any performance effects due to the latency of load operations. The addresses for our load operations depended only on the loop index <var class="pcalibre17 pcalibre2 pcalibre1">i</var>, and so the load operations did not form part of a performance-limiting critical path.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436B5" id="P70004970270000000000000000436B5">To determine the latency of the load operation on a machine, we can set up a computation with a sequence of load operations, where the outcome of one determines the address for the next. As an example, consider the function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436B6" id="P70004970270000000000000000436B6">list_len</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F57"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.31</span></a>, which computes the length of a linked list. In the loop of this function, each successive value of variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436B7" id="P70004970270000000000000000436B7">ls</code> depends on the value read by the pointer reference <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436B8" id="P70004970270000000000000000436B8">ls-&gt;next</code>. Our measurements show that function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436B9" id="P70004970270000000000000000436B9">list_len</code> has</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004F57" id="P7000497027000000000000000004F57">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436BA" id="P70004970270000000000000000436BA"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436BB" id="P70004970270000000000000000436BB">
1	typedef struct ELE {
2		struct ELE *next;
3		long data;
4	} list_ele, *list_ptr; 5
6	long list_len(list_ptr ls) {
7		long len = 0;
8		while (ls) {
9			len++;
10			ls = ls-&gt;next;
11		}
12		return len;
13	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000436BC" id="P70004970270000000000000000436BC"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000436BD" epub:type="title" id="P70004970270000000000000000436BD"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.31 </span>Linked list function.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436BE" id="P70004970270000000000000000436BE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436BF" id="P70004970270000000000000000436BF">Its performance is limited by the latency of the load operation.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436C0" id="P70004970270000000000000000436C0"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004F5F" epub:type="pagebreak" id="P7000497027000000000000000004F5F" title="555"></span>a CPE of 4.00, which we claim is a direct indication of the latency of the load operation. To see this, consider the assembly code for the loop:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436C1" id="P70004970270000000000000000436C1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436C2" id="P70004970270000000000000000436C2">
	<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of list_len</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">ls in %rdi, len in %rax</i>
1	.L3:			<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	 addq $1, %rax		  <i class="pcalibre17 pcalibre2 pcalibre1">Increment len</i>
3	 movq (%rdi), %rdi	  <i class="pcalibre17 pcalibre2 pcalibre1">ls = ls-&gt;next</i>
4	 testq %rdi, %rdi	  <i class="pcalibre17 pcalibre2 pcalibre1">Test ls</i>
5	 jne .L3		  <i class="pcalibre17 pcalibre2 pcalibre1">If nonnull, goto</i> loop
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436C3" id="P70004970270000000000000000436C3">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436C4" id="P70004970270000000000000000436C4">movq</code> instruction on line 3 forms the critical bottleneck in this loop. Each successive value of register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436C5" id="P70004970270000000000000000436C5">%rdi</code> depends on the result of a load operation having the value in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436C6" id="P70004970270000000000000000436C6">%rdi</code> as its address. Thus, the load operation for one iteration cannot begin until the one for the previous iteration has completed. The CPE of 4.00 for this function is determined by the latency of the load operation. Indeed, this measurement matches the documented access time of 4 cycles for the reference machine's L1 cache, as is discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000556F.xhtml#P700049702700000000000000000556F"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">6.4</span></a>.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004F66" id="P7000497027000000000000000004F66"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436C7" epub:type="title" id="P70004970270000000000000000436C7"><span class="pcalibre1 pcalibre21 pcalibre2">5.12.2 </span>Store Performance</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436C8" id="P70004970270000000000000000436C8">In all of our examples thus far, we analyzed only functions that reference memory mostly with load operations, reading from a memory location into a register. Its counterpart, the <i class="pcalibre17 pcalibre2 pcalibre1">store</i> operation, writes a register value to memory. The performance of this operation, particularly in relation to its interactions with load operations, involves several subtle issues.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436C9" id="P70004970270000000000000000436C9">As with the load operation, in most cases, the store operation can operate in a fully pipelined mode, beginning a new store on every cycle. For example, consider the function shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F6E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.32</span></a> that sets the elements of an array <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436CA" id="P70004970270000000000000000436CA">dest</code> of length <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436CB" id="P70004970270000000000000000436CB">n</code> to zero. Our measurements show a CPE of 1.0. This is the best we can achieve on a machine with a single store functional unit.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436CC" id="P70004970270000000000000000436CC">Unlike the other operations we have considered so far, the store operation does not affect any register values. Thus, by their very nature, a series of store operations cannot create a data dependency. Only a load operation is affected by the result of a store operation, since only a load can read back the memory value that has been written by the store. The function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436CD" id="P70004970270000000000000000436CD">write_read</code> shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.33</span></a></p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004F6E" id="P7000497027000000000000000004F6E">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436CE" id="P70004970270000000000000000436CE"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436CF" id="P70004970270000000000000000436CF">
1	/* Set elements of array to 0 */
2	void clear_array(long *dest, long n) {
3		long i;
4		for (i = 0; i &lt; n; i++)
5			dest[i] = 0;
6	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000436D0" id="P70004970270000000000000000436D0"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000436D1" epub:type="title" id="P70004970270000000000000000436D1"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.32 </span>Function to set array elements to 0.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436D2" id="P70004970270000000000000000436D2"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436D3" id="P70004970270000000000000000436D3">This code achieves a CPE of 1.0.</p></div></figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004F75" id="P7000497027000000000000000004F75">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004F76" epub:type="pagebreak" id="P7000497027000000000000000004F76" title="556"></span>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436D4" id="P70004970270000000000000000436D4"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436D5" id="P70004970270000000000000000436D5">
1	/* Write to dest, read from src */
2	void write_read(long *src, long *dst, long n)
3	{
4		long cnt = n;
5		long val = 0; 6
7		while (cnt) {
8			*dst = val;
9			val = (*src)+1;
10			cnt−;
11		}
12	}
</code></pre>
<img alt="A diagram includes a code and illustrations of two executions." class="pcalibre1 pcalibre202 pcalibre2" data-uri="P700049702700000000000000000B722" id="P70004970270000000000000000436D6" src="Images/chapter-05-image-20.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000436D7" id="P70004970270000000000000000436D7"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000436D8" epub:type="title" id="P70004970270000000000000000436D8"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.33 </span>Code to write and read memory locations, along with illustrative executions.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000436D9" id="P70004970270000000000000000436D9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436DA" id="P70004970270000000000000000436DA">This function highlights the interactions between stores and loads when arguments <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436DB" id="P70004970270000000000000000436DB">src</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436DC" id="P70004970270000000000000000436DC">dest</code> are equal.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P70004970270000000000000000239C8" id="P70004970270000000000000000239C8">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436DD" id="P70004970270000000000000000436DD">The lines of the code are reproduced below.</p>
<ol class="pcalibre1 calibre19 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436DE" id="P70004970270000000000000000436DE">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436DF" id="P70004970270000000000000000436DF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436E0" id="P70004970270000000000000000436E0">/* Write to dest, read from src */</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436E1" id="P70004970270000000000000000436E1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436E2" id="P70004970270000000000000000436E2">void write_read(long *src, long *dst, long n)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436E3" id="P70004970270000000000000000436E3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436E4" id="P70004970270000000000000000436E4">{</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436E5" id="P70004970270000000000000000436E5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436E6" id="P70004970270000000000000000436E6">long cnt = n;</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436E7" id="P70004970270000000000000000436E7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436E8" id="P70004970270000000000000000436E8">long val = 0;</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436E9" id="P70004970270000000000000000436E9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436EA" id="P70004970270000000000000000436EA">(blank)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436EB" id="P70004970270000000000000000436EB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436EC" id="P70004970270000000000000000436EC">while (cnt) {</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436ED" id="P70004970270000000000000000436ED"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436EE" id="P70004970270000000000000000436EE"> *dst = val;</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436EF" id="P70004970270000000000000000436EF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436F0" id="P70004970270000000000000000436F0"> val = (*src)+1;</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436F1" id="P70004970270000000000000000436F1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436F2" id="P70004970270000000000000000436F2"> cnt–;</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436F3" id="P70004970270000000000000000436F3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436F4" id="P70004970270000000000000000436F4"> }</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000436F5" id="P70004970270000000000000000436F5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000436F6" id="P70004970270000000000000000436F6">}</p></li>
</ol>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000436F7" id="P70004970270000000000000000436F7">The two execution illustrations are arranged per the following tables.</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P70004970270000000000000000436F8" id="P70004970270000000000000000436F8">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" colspan="5" data-uri="chapter05.xhtml#P70004970270000000000000000436F9" id="P70004970270000000000000000436F9">Example A: write_read(&amp;a[0], &amp;a[1], 3)</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000436FA" id="P70004970270000000000000000436FA"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000436FB" id="P70004970270000000000000000436FB">Initial</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000436FC" id="P70004970270000000000000000436FC">Iter. 1</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000436FD" id="P70004970270000000000000000436FD">Iter. 2</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000436FE" id="P70004970270000000000000000436FE">Iter. 3</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000436FF" id="P70004970270000000000000000436FF">cnt</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043700" id="P7000497027000000000000000043700">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043701" id="P7000497027000000000000000043701">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043702" id="P7000497027000000000000000043702">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043703" id="P7000497027000000000000000043703">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043704" id="P7000497027000000000000000043704">a</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043705" id="P7000497027000000000000000043705">Negative 10 and 17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043706" id="P7000497027000000000000000043706">Negative 10 and 2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043707" id="P7000497027000000000000000043707">Negative 10 and negative 9</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043708" id="P7000497027000000000000000043708">Negative 10 and negative 9</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043709" id="P7000497027000000000000000043709">val</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004370A" id="P700049702700000000000000004370A">0</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004370B" id="P700049702700000000000000004370B">Negative 9</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004370C" id="P700049702700000000000000004370C">Negative 9</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004370D" id="P700049702700000000000000004370D">Negative 9</td>
</tr>
</tbody>
</table>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P700049702700000000000000004370E" id="P700049702700000000000000004370E">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" colspan="5" data-uri="chapter05.xhtml#P700049702700000000000000004370F" id="P700049702700000000000000004370F">Example B: write_read(&amp;a[0], &amp;a[0], 3)</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043710" id="P7000497027000000000000000043710"></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043711" id="P7000497027000000000000000043711">Initial</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043712" id="P7000497027000000000000000043712">Iter. 1</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043713" id="P7000497027000000000000000043713">Iter. 2</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P7000497027000000000000000043714" id="P7000497027000000000000000043714">Iter. 3</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043715" id="P7000497027000000000000000043715">cnt</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043716" id="P7000497027000000000000000043716">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043717" id="P7000497027000000000000000043717">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043718" id="P7000497027000000000000000043718">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043719" id="P7000497027000000000000000043719">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004371A" id="P700049702700000000000000004371A">a</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004371B" id="P700049702700000000000000004371B">Negative 10 and 17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004371C" id="P700049702700000000000000004371C">Negative 0 and 17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004371D" id="P700049702700000000000000004371D">1 and 17</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004371E" id="P700049702700000000000000004371E">2 and 17</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P700049702700000000000000004371F" id="P700049702700000000000000004371F">val</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043720" id="P7000497027000000000000000043720">0</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043721" id="P7000497027000000000000000043721">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043722" id="P7000497027000000000000000043722">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043723" id="P7000497027000000000000000043723">3</td>
</tr>
</tbody>
</table>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043724" id="P7000497027000000000000000043724">illustrates the potential interactions between loads and stores. This figure also shows two example executions of this function, when it is called for a two-element array a, with initial contents −10 and 17, and with argument <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043725" id="P7000497027000000000000000043725">cnt</code> equal to 3. These executions illustrate some subtleties of the load and store operations.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043726" id="P7000497027000000000000000043726">In Example A of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.33</span></a>, argument <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043727" id="P7000497027000000000000000043727">src</code> is a pointer to array element <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043728" id="P7000497027000000000000000043728">a[0]</code>, while <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043729" id="P7000497027000000000000000043729">dest</code> is a pointer to array element <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004372A" id="P700049702700000000000000004372A">a[1]</code>. In this case, each load by the pointer reference <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004372B" id="P700049702700000000000000004372B">*src</code> will yield the value −10. Hence, after two iterations, the array elements will remain fixed at −10 and −9, respectively. The result of the read from <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004372C" id="P700049702700000000000000004372C">src</code> is not affected by the write to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004372D" id="P700049702700000000000000004372D">dest</code>. Measuring this example over a larger number of iterations gives a CPE of 1.3.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004372E" id="P700049702700000000000000004372E">In Example B of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.33</span></a>, both arguments <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004372F" id="P700049702700000000000000004372F">src</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043730" id="P7000497027000000000000000043730">dest</code> are pointers to array element <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043731" id="P7000497027000000000000000043731">a[0]</code>. In this case, each load by the pointer reference <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043732" id="P7000497027000000000000000043732">*src</code> will yield the value stored by the previous execution of the pointer reference <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043733" id="P7000497027000000000000000043733">*dest</code>.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004F90" id="P7000497027000000000000000004F90">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004F91" epub:type="pagebreak" id="P7000497027000000000000000004F91" title="557"></span>
<img alt="A diagram depicts interactions between load unit, store unit, and data cache." class="pcalibre1 pcalibre2 pcalibre203" data-uri="P700049702700000000000000000B723" id="P7000497027000000000000000043734" src="Images/chapter-05-image-21.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043735" id="P7000497027000000000000000043735"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043736" epub:type="title" id="P7000497027000000000000000043736"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.34 </span>Detail of load and store units.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043737" id="P7000497027000000000000000043737"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043738" id="P7000497027000000000000000043738">The store unit maintains a buffer of pending writes. The load unit must check its address with those in the store unit to detect a write/read dependency.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P7000497027000000000000000023A25" id="P7000497027000000000000000023A25">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043739" id="P7000497027000000000000000043739">A diagram shows a load unit sending address to store unit and data cache and receiving data from each. The store unit includes the store buffer, composed of matching addresses within address and data, each of which is sent to data cache.</p>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004373A" id="P700049702700000000000000004373A">As a consequence, a series of ascending values will be stored in this location. In general, if function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004373B" id="P700049702700000000000000004373B">write_read</code> is called with arguments <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004373C" id="P700049702700000000000000004373C">src</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004373D" id="P700049702700000000000000004373D">dest</code> pointing to the same memory location, and with argument <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004373E" id="P700049702700000000000000004373E">cnt</code> having some value <var class="pcalibre17 pcalibre2 pcalibre1">n</var> &gt; 0, the net effect is to set the location to <var class="pcalibre17 pcalibre2 pcalibre1">n</var> − 1. This example illustrates a phenomenon we will call a <i class="pcalibre17 pcalibre2 pcalibre1">write/read dependency</i>—the outcome of a memory read depends on a recent memory write. Our performance measurements show that Example B has a CPE of 7.3. The write/read dependency causes a slowdown in the processing of around 6 clock cycles.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004373F" id="P700049702700000000000000004373F">To see how the processor can distinguish between these two cases and why one runs slower than the other, we must take a more detailed look at the load and store execution units, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F90"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.34</span></a>. The store unit includes a <i class="pcalibre17 pcalibre2 pcalibre1">store buffer</i> containing the addresses and data of the store operations that have been issued to the store unit, but have not yet been completed, where completion involves updating the data cache. This buffer is provided so that a series of store operations can be executed without having to wait for each one to update the cache. When a load operation occurs, it must check the entries in the store buffer for matching addresses. If it finds a match (meaning that any of the bytes being written have the same address as any of the bytes being read), it retrieves the corresponding data entry as the result of the load operation.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043740" id="P7000497027000000000000000043740"><span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the following code for the inner loop of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043741" id="P7000497027000000000000000043741">write_read</code>:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043742" id="P7000497027000000000000000043742"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043743" id="P7000497027000000000000000043743">
<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of write_read</i>
<i class="pcalibre17 pcalibre2 pcalibre1">src in %rdi, dst in %rsi, val in %rax</i>
.L3:			<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
 movq	%rax, (%rsi)	  <i class="pcalibre17 pcalibre2 pcalibre1">Write val to dst</i>
 movq	(%rdi), %rax	  <i class="pcalibre17 pcalibre2 pcalibre1">t = *src</i>
 addq	$1, %rax	  <i class="pcalibre17 pcalibre2 pcalibre1">val = t+1</i>
 subq	$1, %rdx	  <i class="pcalibre17 pcalibre2 pcalibre1">cnt−</i>
 jne	. L3		  <i class="pcalibre17 pcalibre2 pcalibre1">If != 0, goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">loop</b>
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004FA1" id="P7000497027000000000000000004FA1">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004FA2" epub:type="pagebreak" id="P7000497027000000000000000004FA2" title="558"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for write_read." class="pcalibre1 pcalibre2 pcalibre204" data-uri="P700049702700000000000000000B724" id="P7000497027000000000000000043744" src="Images/chapter-05-image-22.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043745" id="P7000497027000000000000000043745"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043746" epub:type="title" id="P7000497027000000000000000043746"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.35 </span>Graphical representation of inner-loop code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043747" id="P7000497027000000000000000043747">write_read</code>.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043748" id="P7000497027000000000000000043748"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043749" id="P7000497027000000000000000043749">The first <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004374A" id="P700049702700000000000000004374A">movl</code> instruction is decoded into separate operations to compute the store address and to store the data to memory.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P7000497027000000000000000023A38" id="P7000497027000000000000000023A38">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004374B" id="P700049702700000000000000004374B">A diagram has two rows of boxes, each with %rax, %rdi, %rsi, and %rdx, with output from top %rdi and %rsi to bottom %rdi and %rsi, respectively. A column of boxes includes the six operations summarized below, from top to bottom:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter05.xhtml#P700049702700000000000000004374C" id="P700049702700000000000000004374C">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004374D" id="P700049702700000000000000004374D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004374E" id="P700049702700000000000000004374E">s_addr: receives input from top %rsi and sends output to s_data and load operations below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004374F" id="P700049702700000000000000004374F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043750" id="P7000497027000000000000000043750">s_data: receives input from s_addr, with the two together representing movq %rax, (%rsi); receives input from top %rax and sends output to load below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043751" id="P7000497027000000000000000043751"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043752" id="P7000497027000000000000000043752">Load (movq (%rdi), %rax): receives input from s_addr, s_data, and top %rdi; sends output to add below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043753" id="P7000497027000000000000000043753"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043754" id="P7000497027000000000000000043754">add (addq $1, %rax): receives input from load and sends output to bottom %rax</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043755" id="P7000497027000000000000000043755"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043756" id="P7000497027000000000000000043756">sub (subq $1, %rdx): receives input from top %rdx and sends output to bottom %rdx and jne below</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043757" id="P7000497027000000000000000043757"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043758" id="P7000497027000000000000000043758">jne (jne loop): receives input from sub and sends output to bottom %rdx</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043759" id="P7000497027000000000000000043759"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FA1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.35</span></a> shows a data-flow representation of this loop code. The instruction <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004375A" id="P700049702700000000000000004375A">movq %rax,(%rsi)</code> is translated into two operations: The s_addr instruction computes the address for the store operation, creates an entry in the store buffer, and sets the address field for that entry. The s_data operation sets the data field for the entry. As we will see, the fact that these two computations are performed independently can be important to program performance. This motivates the separate functional units for these operations in the reference machine.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004375B" id="P700049702700000000000000004375B">In addition to the data dependencies between the operations caused by the writing and reading of registers, the arcs on the right of the operators denote a set of implicit dependencies for these operations. In particular, the address computation of the s_addr operation must clearly precede the s_data operation. In addition, the load operation generated by decoding the instruction <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004375C" id="P700049702700000000000000004375C">movq</code> <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004375D" id="P700049702700000000000000004375D">(%rdi), %rax</code> must check the addresses of any pending store operations, creating a data dependency between it and the s_addr operation. The figure shows a dashed arc between the s_data and load operations. This dependency is conditional: if the two addresses match, the load operation must wait until the s_data has deposited its result into the store buffer, but if the two addresses differ, the two operations can proceed independently.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004375E" id="P700049702700000000000000004375E"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FB3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.36</span></a> illustrates the data dependencies between the operations for the inner loop of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004375F" id="P700049702700000000000000004375F">write_read</code>. In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FB3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.36(a)</span></a>, we have rearranged the operations to allow the dependencies to be seen more clearly. We have labeled the three dependencies involving the load and store operations for special attention. The arc labeled "1" represents the requirement that the store address must be computed before the data can be stored. The arc labeled "2" represents the need for the load operation to compare its address with that for any pending store operations. Finally, the dashed arc labeled "3" represents the conditional data dependency that arises when the load and store addresses match.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043760" id="P7000497027000000000000000043760"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FB3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.36(b)</span></a> illustrates what happens when we take away those operations that do not directly affect the flow of data from one iteration to the next. The data-flow graph shows just two chains of dependencies: the one on the left, with data values being stored, loaded, and incremented (only for the case of matching addresses); and the one on the right, decrementing variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043761" id="P7000497027000000000000000043761">cnt</code>.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004FB3" id="P7000497027000000000000000004FB3">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004FB4" epub:type="pagebreak" id="P7000497027000000000000000004FB4" title="559"></span>
<img alt="A diagram depicts two data-flow graphs for write_read." class="pcalibre1 pcalibre2 pcalibre205" data-uri="P700049702700000000000000000B725" id="P7000497027000000000000000043762" src="Images/chapter-05-image-23.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043763" id="P7000497027000000000000000043763"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P7000497027000000000000000043764" epub:type="title" id="P7000497027000000000000000043764"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.36 </span>Abstracting the operations for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043765" id="P7000497027000000000000000043765">write_read</code>.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043766" id="P7000497027000000000000000043766"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043767" id="P7000497027000000000000000043767">We first rearrange the operators of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FA1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.35(a)</span></a> and then show only those operations that use values from one iteration to produce new values for the next (b).</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P7000497027000000000000000023A56" id="P7000497027000000000000000023A56">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre141" data-uri="chapter05.xhtml#P7000497027000000000000000043768" id="P7000497027000000000000000043768">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043769" id="P7000497027000000000000000043769"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004376A" id="P700049702700000000000000004376A">Data flows from top %rax to s_data to load (numbered 3) to add to bottom %rax; from %rdi to load; from %rsi to s_addr, with 1 to s_data and 2 to load; top %rdx to sub, which moves to jne and bottom %rdx.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004376B" id="P700049702700000000000000004376B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004376C" id="P700049702700000000000000004376C">Data flows from top %rax through s_data, load, and add to bottom %rax; from top %rdx to sub to bottom %rdx.</p></li>
</ol>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004376D" id="P700049702700000000000000004376D">We can now understand the performance characteristics of function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004376E" id="P700049702700000000000000004376E">write_read</code>. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FC7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.37</span></a> illustrates the data dependencies formed by multiple iterations of its inner loop. For the case of Example A in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.33</span></a>, with differing source and destination addresses, the load and store operations can proceed independently, and hence the only critical path is formed by the decrementing of variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004376F" id="P700049702700000000000000004376F">cnt</code>, resulting in a CPE bound of 1.0. For the case of Example B with matching source and destination addresses, the data dependency between the s_data and load instructions causes a critical path to form involving data being stored, loaded, and incremented. We found that these three operations in sequence require a total of around 7 clock cycles.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043770" id="P7000497027000000000000000043770">As these two examples show, the implementation of memory operations involves many subtleties. With operations on registers, the processor can determine which instructions will affect which others as they are being decoded into operations. With memory operations, on the other hand, the processor cannot predict which will affect which others until the load and store addresses have been computed. Efficient handling of memory operations is critical to the performance of many programs. The memory subsystem makes use of many optimizations, such as the potential parallelism when operations can proceed independently.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004FBF" epub:type="practice" id="P7000497027000000000000000004FBF"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043771" epub:type="title" id="P7000497027000000000000000043771"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.10 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005159">577</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P7000497027000000000000000043772" id="P7000497027000000000000000043772">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P7000497027000000000000000043773" id="P7000497027000000000000000043773">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043774" id="P7000497027000000000000000043774"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043775" id="P7000497027000000000000000043775">As another example of code with potential load-store interactions, consider the following function to copy the contents of one array to another:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043776" id="P7000497027000000000000000043776"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043777" id="P7000497027000000000000000043777">
1	void copy_array(long *src, long *dest, long n)
2	{
3		long i;
4		for (i = 0; i &lt; n; i++)
5			dest[i] = src[i];
6	}
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000004FC7" id="P7000497027000000000000000004FC7">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004FC8" epub:type="pagebreak" id="P7000497027000000000000000004FC8" title="560"></span>
<img alt="Example A shows a critical path flowing through sub operations. Example B shows a critical path flowing between groups through s_data, load, and add." class="pcalibre1 pcalibre2 calibre49" data-uri="P700049702700000000000000000B726" id="P7000497027000000000000000043778" src="Images/chapter-05-image-24.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043779" id="P7000497027000000000000000043779"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P700049702700000000000000004377A" epub:type="title" id="P700049702700000000000000004377A"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.37 </span>Data-flow representation of function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004377B" id="P700049702700000000000000004377B">write_read</code>.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004377C" id="P700049702700000000000000004377C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004377D" id="P700049702700000000000000004377D">When the two addresses do not match, the only critical path is formed by the decrementing of <b class="pcalibre1 pcalibre2 pcalibre12">cnt</b> (Example A). When they do match, the chain of data being stored, loaded, and incremented forms the critical path (Example B).</p></div>
</figcaption></figure>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004377E" id="P700049702700000000000000004377E">Suppose <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004377F" id="P700049702700000000000000004377F">a</code> is an array of length 1,000 initialized so that each element <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043780" id="P7000497027000000000000000043780">a[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> equals <i class="pcalibre17 pcalibre2 pcalibre1">i.</i></p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter05.xhtml#P7000497027000000000000000043781" id="P7000497027000000000000000043781">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043782" id="P7000497027000000000000000043782"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043783" id="P7000497027000000000000000043783">What would be the effect of the call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043784" id="P7000497027000000000000000043784">copy_array(a+1,a,999)?</code></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043785" id="P7000497027000000000000000043785"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043786" id="P7000497027000000000000000043786">What would be the effect of the call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043787" id="P7000497027000000000000000043787">copy_array(a,a+1,999)?</code></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043788" id="P7000497027000000000000000043788"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043789" id="P7000497027000000000000000043789">Our performance measurements indicate that the call of part A has a CPE of 1.2 (which drops to 1.0 when the loop is unrolled by a factor of 4), while the call of part B has a CPE of 5.0. To what factor do you attribute this performance difference?</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004378A" id="P700049702700000000000000004378A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004378B" id="P700049702700000000000000004378B">What performance would you expect for the call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004378C" id="P700049702700000000000000004378C">copy_array (a,a, 999)?</code></p></li>
</ol></div></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004FDE" epub:type="practice" id="P7000497027000000000000000004FDE"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004378D" epub:type="title" id="P700049702700000000000000004378D"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000004FE0" epub:type="pagebreak" id="P7000497027000000000000000004FE0" title="561"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.11 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005159">577</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P700049702700000000000000004378E" id="P700049702700000000000000004378E">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P700049702700000000000000004378F" id="P700049702700000000000000004378F">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043790" id="P7000497027000000000000000043790"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043791" id="P7000497027000000000000000043791">We saw that our measurements of the prefix-sum function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043792" id="P7000497027000000000000000043792">psum1</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000493B.xhtml#P7000497027000000000000000004949"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1</span></a>) yield a CPE of 9.00 on a machine where the basic operation to be performed, floating-point addition, has a latency of just 3 clock cycles. Let us try to understand why our function performs so poorly.</p>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043793" id="P7000497027000000000000000043793">The following is the assembly code for the inner loop of the function:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043794" id="P7000497027000000000000000043794"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043795" id="P7000497027000000000000000043795">
<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of psum1</i>
<i class="pcalibre17 pcalibre2 pcalibre1">a in %rdi, i in %rax, cnt in %rdx</i>
1	.L5:					<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	  vmovss −4(%rsi,%rax,4), %xmm0		  <i class="pcalibre17 pcalibre2 pcalibre1">Get p[i-1]</i>
3	  vaddss (%rdi,%rax,4), %xmm0, %xmm0	  <i class="pcalibre17 pcalibre2 pcalibre1">Add a[i]</i>
4	  vmovss %xmm0, (%rsi,%rax,4)		  <i class="pcalibre17 pcalibre2 pcalibre1">Store at p[i]</i>
5	  addq $1, %rax				  <i class="pcalibre17 pcalibre2 pcalibre1">Increment i</i>
6	  cmpq %rdx, %rax			  <i class="pcalibre17 pcalibre2 pcalibre1">Compare i : cnt</i>
7	  jne .L5				  <i class="pcalibre17 pcalibre2 pcalibre1">If ! =, goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">loop</b>
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043796" id="P7000497027000000000000000043796">Perform an analysis similar to those shown for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043797" id="P7000497027000000000000000043797">combine3</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14</span></a>) and for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043798" id="P7000497027000000000000000043798">write_read</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FB3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.36</span></a>) to diagram the data dependencies created by this loop, and hence the critical path that forms as the computation proceeds. Explain why the CPE is so high.</p></div></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000004FEC" epub:type="practice" id="P7000497027000000000000000004FEC"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043799" epub:type="title" id="P7000497027000000000000000043799"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005159">577</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter05.xhtml#P700049702700000000000000004379A" id="P700049702700000000000000004379A">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P700049702700000000000000004379B" id="P700049702700000000000000004379B">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P700049702700000000000000004379C" id="P700049702700000000000000004379C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004379D" id="P700049702700000000000000004379D">Rewrite the code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004379E" id="P700049702700000000000000004379E">psum1</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000493B.xhtml#P7000497027000000000000000004949"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1</span></a>) so that it does not need to repeatedly retrieve the value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004379F" id="P700049702700000000000000004379F">p[i]</code> from memory. You do not need to use loop unrolling. We measured the resulting code to have a CPE of 3.00, limited by the latency of floating-point addition.</p></div></li>
</ol>
</section>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.13 Life in the Real World: Performance Improvement Techniques</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000004FF4"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P70004970270000000000000000437A0" epub:type="title" id="P70004970270000000000000000437A0"><span class="pcalibre1 pcalibre21 pcalibre2">5.13 </span>Life in the Real World: Performance Improvement Techniques</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437A1" id="P70004970270000000000000000437A1">Although we have only considered a limited set of applications, we can draw important lessons on how to write efficient code. We have described a number of basic strategies for optimizing program performance:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437A2" id="P70004970270000000000000000437A2">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437A3" id="P70004970270000000000000000437A3"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000437A4" id="P70004970270000000000000000437A4"><span class="pcalibre1 pcalibre2 pcalibre41">High-level design. </span>Choose appropriate algorithms and data structures for the problem at hand. Be especially vigilant to avoid algorithms or coding techniques that yield asymptotically poor performance.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437A5" id="P70004970270000000000000000437A5"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000437A6" id="P70004970270000000000000000437A6"><span class="pcalibre1 pcalibre2 pcalibre41">Basic coding principles. </span>Avoid optimization blockers so that a compiler can generate efficient code.</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter05.xhtml#P70004970270000000000000000437A7" id="P70004970270000000000000000437A7">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437A8" id="P70004970270000000000000000437A8"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000437A9" id="P70004970270000000000000000437A9">Eliminate excessive function calls. Move computations out of loops when possible. Consider selective compromises of program modularity to gain greater efficiency.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437AA" id="P70004970270000000000000000437AA"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000437AB" id="P70004970270000000000000000437AB"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005001" epub:type="pagebreak" id="P7000497027000000000000000005001" title="562"></span>Eliminate unnecessary memory references. Introduce temporary variables to hold intermediate results. Store a result in an array or global variable only when the final value has been computed.</p></li>
</ul></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437AC" id="P70004970270000000000000000437AC"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000437AD" id="P70004970270000000000000000437AD"><span class="pcalibre1 pcalibre2 pcalibre41">Low-level optimizations. </span>Structure code to take advantage of the hardware capabilities.</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter05.xhtml#P70004970270000000000000000437AE" id="P70004970270000000000000000437AE">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437AF" id="P70004970270000000000000000437AF"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000437B0" id="P70004970270000000000000000437B0">Unroll loops to reduce overhead and to enable further optimizations.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437B1" id="P70004970270000000000000000437B1"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000437B2" id="P70004970270000000000000000437B2">Find ways to increase instruction-level parallelism by techniques such as multiple accumulators and reassociation.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437B3" id="P70004970270000000000000000437B3"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P70004970270000000000000000437B4" id="P70004970270000000000000000437B4">Rewrite conditional operations in a functional style to enable compilation via conditional data transfers.</p></li>
</ul></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437B5" id="P70004970270000000000000000437B5">A final word of advice to the reader is to be vigilant to avoid introducing errors as you rewrite programs in the interest of efficiency. It is very easy to make mistakes when introducing new variables, changing loop bounds, and making the code more complex overall. One useful technique is to use checking code to test each version of a function as it is being optimized, to ensure no bugs are introduced during this process. Checking code applies a series of tests to the new versions of a function and makes sure they yield the same results as the original. The set of test cases must become more extensive with highly optimized code, since there are more cases to consider. For example, checking code that uses loop unrolling requires testing for many different loop bounds to make sure it handles all of the different possible numbers of single-step iterations required at the end.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.14 Identifying and Eliminating Performance Bottlenecks</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000500C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P70004970270000000000000000437B6" epub:type="title" id="P70004970270000000000000000437B6"><span class="pcalibre1 pcalibre21 pcalibre2">5.14 </span>Identifying and Eliminating Performance Bottlenecks</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437B7" id="P70004970270000000000000000437B7">Up to this point, we have only considered optimizing small programs, where there is some clear place in the program that limits its performance and therefore should be the focus of our optimization efforts. When working with large programs, even knowing where to focus our optimization efforts can be difficult. In this section, we describe how to use <i class="pcalibre17 pcalibre2 pcalibre1">code profilers</i>, analysis tools that collect performance data about a program as it executes. We also discuss some general principles of code optimization, including the implications of Amdahl's law, introduced in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000204"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">1.9.1</span></a>.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P700049702700000000000000000500F" id="P700049702700000000000000000500F"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437B8" epub:type="title" id="P70004970270000000000000000437B8"><span class="pcalibre1 pcalibre21 pcalibre2">5.14.1 </span>Program Profiling</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437B9" id="P70004970270000000000000000437B9">Program <i class="pcalibre17 pcalibre2 pcalibre1">profiling</i> involves running a version of a program in which instrumentation code has been incorporated to determine how much time the different parts of the program require. It can be very useful for identifying the parts of a program we should focus on in our optimization efforts. One strength of profiling is that it can be performed while running the actual program on realistic benchmark data.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437BA" id="P70004970270000000000000000437BA">Unix systems provide the profiling program <span class="pcalibre1 pcalibre29 pcalibre2">gprof</span>. This program generates two forms of information. First, it determines how much CPU time was spent for each of the functions in the program. Second, it computes a count of how many times each function gets called, categorized by which function performs the call. Both forms of information can be quite useful. The timings give a sense of <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005013" epub:type="pagebreak" id="P7000497027000000000000000005013" title="563"></span>the relative importance of the different functions in determining the overall run time. The calling information allows us to understand the dynamic behavior of the program.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437BB" id="P70004970270000000000000000437BB">Profiling with <span class="pcalibre1 pcalibre29 pcalibre2">gprof </span>requires three steps, as shown for a C program <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437BC" id="P70004970270000000000000000437BC">prog.c</code>, which runs with command-line argument <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437BD" id="P70004970270000000000000000437BD">file.txt</code>:</p>
<ol class="pcalibre1 calibre19 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437BE" id="P70004970270000000000000000437BE">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437BF" id="P70004970270000000000000000437BF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437C0" id="P70004970270000000000000000437C0">The program must be compiled and linked for profiling. With <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>(and other C compilers), this involves simply including the run-time flag <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437C1" id="P70004970270000000000000000437C1">−pg</code> on the command line. It is important to ensure that the compiler does not attempt to perform any optimizations via inline substitution, or else the calls to functions may not be tabulated accurately. We use optimization flag <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437C2" id="P70004970270000000000000000437C2">−Og</code>, guaranteeing that function calls will be tracked properly.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437C3" id="P70004970270000000000000000437C3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437C4" id="P70004970270000000000000000437C4">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -Og -pg prog.c -o prog</i></code></pre></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437C5" id="P70004970270000000000000000437C5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437C6" id="P70004970270000000000000000437C6">The program is then executed as usual:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437C7" id="P70004970270000000000000000437C7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437C8" id="P70004970270000000000000000437C8">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./prog file.txt</i></code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437C9" id="P70004970270000000000000000437C9">It runs slightly (around a factor of 2) slower than normal, but otherwise the only difference is that it generates a file <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437CA" id="P70004970270000000000000000437CA">gmon.out</code>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437CB" id="P70004970270000000000000000437CB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437CC" id="P70004970270000000000000000437CC"><span class="pcalibre1 pcalibre29 pcalibre2">gprof </span>is invoked to analyze the data in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437CD" id="P70004970270000000000000000437CD">gmon.out</code>:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437CE" id="P70004970270000000000000000437CE"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437CF" id="P70004970270000000000000000437CF">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gprof prog</i></code></pre></li>
</ol>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437D0" id="P70004970270000000000000000437D0">The first part of the profile report lists the times spent executing the different functions, sorted in descending order. As an example, the following listing shows this part of the report for the three most time-consuming functions in a program:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437D1" id="P70004970270000000000000000437D1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437D2" id="P70004970270000000000000000437D2">
%	 cumulative	self		self	total	
time	seconds		seconds	calls	s/call	s/call	name
97.58	 203.66		 203.66     1	203.66	 203.66 sort_words
2.32	 208.50		   4.85 965027	  0.00	   0.00	find_ele_rec
0.14	 208.81		   0.30	12511031  0.00	   0.00	Strien
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437D3" id="P70004970270000000000000000437D3">Each row represents the time spent for all calls to some function. The first column indicates the percentage of the overall time spent on the function. The second shows the cumulative time spent by the functions up to and including the one on this row. The third shows the time spent on this particular function, and the fourth shows how many times it was called (not counting recursive calls). In our example, the function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437D4" id="P70004970270000000000000000437D4">sort_words</code> was called only once, but this single call required 203.66 seconds, while the function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437D5" id="P70004970270000000000000000437D5">find_ele_rec</code> was called 965,027 times (not including recursive calls), requiring a total of 4.85 seconds. Function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437D6" id="P70004970270000000000000000437D6">Strlen</code> computes the length of a string by calling the library function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437D7" id="P70004970270000000000000000437D7">strlen</code>. Library function calls are normally not shown in the results by <span class="pcalibre1 pcalibre29 pcalibre2">gprof</span>. Their times are usually reported as part of the function calling them. By creating the "wrapper function" <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437D8" id="P70004970270000000000000000437D8">Strlen</code>, we can reliably track the calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437D9" id="P70004970270000000000000000437D9">strlen</code>, showing that it was called 12,511,031 times but only requiring a total of 0.30 seconds.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437DA" id="P70004970270000000000000000437DA"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005034" epub:type="pagebreak" id="P7000497027000000000000000005034" title="564"></span>The second part of the profile report shows the calling history of the functions. The following is the history for a recursive function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437DB" id="P70004970270000000000000000437DB">find_ele_rec</code>:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437DC" id="P70004970270000000000000000437DC"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437DD" id="P70004970270000000000000000437DD">
				158655725	find_ele_rec [5]
		4.85	0.10	965027/965027	insert_string [4]
[5]	2.4	4.85	0.10	965027+158655725	find_ele_rec [5]
		0.08	0.01	363039/363039	save_string [8]
		0.00	0.01	363039/363039	new_ele [12]
				158655725	find_ele_rec [5]
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437DE" id="P70004970270000000000000000437DE">This history shows both the functions that called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437DF" id="P70004970270000000000000000437DF">find_ele_rec</code>, as well as the functions that it called. The first two lines show the calls to the function: 158,655,725 calls by itself recursively, and 965,027 calls by function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437E0" id="P70004970270000000000000000437E0">insert_string</code> (which is itself called 965,027 times). Function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437E1" id="P70004970270000000000000000437E1">find_ele_rec</code>, in turn, called two other functions, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437E2" id="P70004970270000000000000000437E2">save_string</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437E3" id="P70004970270000000000000000437E3">new_ele</code>, each a total of 363,039 times.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437E4" id="P70004970270000000000000000437E4">From these call data, we can often infer useful information about the program behavior. For example, the function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437E5" id="P70004970270000000000000000437E5">find_ele_rec</code> is a recursive procedure that scans the linked list for a hash bucket looking for a particular string. For this function, comparing the number of recursive calls with the number of top-level calls provides statistical information about the lengths of the traversals through these lists. Given that their ratio is 164.4:1, we can infer that the program scanned an average of around 164 elements each time.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437E6" id="P70004970270000000000000000437E6">Some properties of <span class="pcalibre1 pcalibre29 pcalibre2">gprof </span>are worth noting:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437E7" id="P70004970270000000000000000437E7">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437E8" id="P70004970270000000000000000437E8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437E9" id="P70004970270000000000000000437E9">The timing is not very precise. It is based on a simple <i class="pcalibre17 pcalibre2 pcalibre1">interval counting</i> scheme in which the compiled program maintains a counter for each function recording the time spent executing that function. The operating system causes the program to be interrupted at some regular time interval <i class="pcalibre17 pcalibre2 pcalibre1">δ</i>. Typical values of <i class="pcalibre17 pcalibre2 pcalibre1">δ</i> range between 1.0 and 10.0 milliseconds. It then determines what function the program was executing when the interrupt occurred and increments the counter for that function by <i class="pcalibre17 pcalibre2 pcalibre1">δ</i>. Of course, it may happen that this function just started executing and will shortly be completed, but it is assigned the full cost of the execution since the previous interrupt. Some other function may run between two interrupts and therefore not be charged any time at all.</p>
<p class="pcalibre1 pcalibre2 pcalibre63" data-uri="chapter05.xhtml#P70004970270000000000000000437EA" id="P70004970270000000000000000437EA">Over a long duration, this scheme works reasonably well. Statistically, every function should be charged according to the relative time spent executing it. For programs that run for less than around 1 second, however, the numbers should be viewed as only rough estimates.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437EB" id="P70004970270000000000000000437EB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437EC" id="P70004970270000000000000000437EC">The calling information is quite reliable, assuming no inline substitutions have been performed. The compiled program maintains a counter for each combination of caller and callee. The appropriate counter is incremented every time a procedure is called.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437ED" id="P70004970270000000000000000437ED"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437EE" id="P70004970270000000000000000437EE">By default, the timings for library functions are not shown. Instead, these times are incorporated into the times for the calling functions.</p></li>
</ul>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000005049" id="P7000497027000000000000000005049"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437EF" epub:type="title" id="P70004970270000000000000000437EF"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P700049702700000000000000000504B" epub:type="pagebreak" id="P700049702700000000000000000504B" title="565"></span><span class="pcalibre1 pcalibre21 pcalibre2">5.14.2 </span>Using a Profiler to Guide Optimization</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437F0" id="P70004970270000000000000000437F0">As an example of using a profiler to guide program optimization, we created an application that involves several different tasks and data structures. This application analyzes the <i class="pcalibre17 pcalibre2 pcalibre1">n-gram</i> statistics of a text document, where an <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-gram is a sequence of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> words occurring in a document. For <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 1, we collect statistics on individual words, for <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 2 on pairs of words, and so on. For a given value of <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, our program reads a text file, creates a table of unique <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams and how many times each one occurs, then sorts the <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams in descending order of occurrence.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437F1" id="P70004970270000000000000000437F1">As a benchmark, we ran it on a file consisting of the complete works of William Shakespeare, totaling 965,028 words, of which 23,706 are unique. We found that for <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 1, even a poorly written analysis program can readily process the entire file in under 1 second, and so we set <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 2 to make things more challenging. For the case of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 2, <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams are referred to as <i class="pcalibre17 pcalibre2 pcalibre1">bigrams</i> (pronounced "bye-grams"). We determined that Shakespeare's works contain 363,039 unique bigrams. The most common is "I am," occurring 1,892 times. Perhaps his most famous bigram, "to be," occurs 1,020 times. Fully 266,018 of the bigrams occur only once.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437F2" id="P70004970270000000000000000437F2">Our program consists of the following parts. We created multiple versions, starting with simple algorithms for the different parts and then replacing them with more sophisticated ones:</p>
<ol class="pcalibre1 calibre19 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437F3" id="P70004970270000000000000000437F3">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437F4" id="P70004970270000000000000000437F4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437F5" id="P70004970270000000000000000437F5">Each word is read from the file and converted to lowercase. Our initial version used the function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437F6" id="P70004970270000000000000000437F6">lower1</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000049CE.xhtml#P7000497027000000000000000004A11"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.7</span></a>), which we know to have quadratic run time due to repeated calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437F7" id="P70004970270000000000000000437F7">strlen</code>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437F8" id="P70004970270000000000000000437F8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437F9" id="P70004970270000000000000000437F9">A hash function is applied to the string to create a number between 0 and <var class="pcalibre17 pcalibre2 pcalibre1">s</var> − 1, for a hash table with <var class="pcalibre17 pcalibre2 pcalibre1">s</var> buckets. Our initial function simply summed the ASCII codes for the characters modulo <i class="pcalibre17 pcalibre2 pcalibre1">s.</i></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437FA" id="P70004970270000000000000000437FA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437FB" id="P70004970270000000000000000437FB">Each hash bucket is organized as a linked list. The program scans down this list looking for a matching entry. If one is found, the frequency for this <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-gram is incremented. Otherwise, a new list element is created. Our initial version performed this operation recursively, inserting new elements at the end of the list.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000437FC" id="P70004970270000000000000000437FC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000437FD" id="P70004970270000000000000000437FD">Once the table has been generated, we sort all of the elements according to the frequencies. Our initial version used insertion sort.</p></li>
</ol>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437FE" id="P70004970270000000000000000437FE"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005064"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.38</span></a> shows the profile results for six different versions of our <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-gram-frequency analysis program. For each version, we divide the time into the following categories:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000437FF" id="P70004970270000000000000000437FF">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043800" id="P7000497027000000000000000043800"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043801" id="P7000497027000000000000000043801"><span class="pcalibre1 pcalibre2 pcalibre41">Sort. </span>Sorting <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams by frequency</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043802" id="P7000497027000000000000000043802"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043803" id="P7000497027000000000000000043803"><span class="pcalibre1 pcalibre2 pcalibre41">List. </span>Scanning the linked list for a matching <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-gram, inserting a new element if necessary</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043804" id="P7000497027000000000000000043804"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043805" id="P7000497027000000000000000043805"><span class="pcalibre1 pcalibre2 pcalibre41">Lower. </span>Converting strings to lowercase</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043806" id="P7000497027000000000000000043806"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043807" id="P7000497027000000000000000043807"><span class="pcalibre1 pcalibre2 pcalibre41">Strlen. </span>Computing string lengths</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000005064" id="P7000497027000000000000000005064">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005065" epub:type="pagebreak" id="P7000497027000000000000000005065" title="566"></span>
<img alt="Two graphs depict profile results." class="pcalibre1 pcalibre2 calibre50" data-uri="P700049702700000000000000000B727" id="P7000497027000000000000000043808" src="Images/chapter-05-image-25.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043809" id="P7000497027000000000000000043809"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P700049702700000000000000004380A" epub:type="title" id="P700049702700000000000000004380A"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.38 </span>Profile results for different versions of bigram-frequency counting program.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P700049702700000000000000004380B" id="P700049702700000000000000004380B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004380C" id="P700049702700000000000000004380C">Time is divided according to the different major operations in the program.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P7000497027000000000000000023AFC" id="P7000497027000000000000000023AFC">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P700049702700000000000000004380D" id="P700049702700000000000000004380D">Two graphs each have bars for Initial, Quicksort, Iter first, Iter last, Big table, Better hash, and Linear lower, rising to various CPU seconds. Each bar is divided into sort, list, lower, strlen, hash, and reset. The data are summarized below.</p>
<ol class="pcalibre1 pcalibre2 pcalibre141" data-uri="chapter05.xhtml#P700049702700000000000000004380E" id="P700049702700000000000000004380E">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004380F" id="P700049702700000000000000004380F"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043810" id="P7000497027000000000000000043810">All versions: a bar for initial rises to about 210 CPU seconds, with about 200 CPU seconds as sort and about 10 as list. The other bars are all less than 20 CPU seconds.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043811" id="P7000497027000000000000000043811"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043812" id="P7000497027000000000000000043812">All but the slowest version: bars are divided approximately as summarized below.</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter05.xhtml#P7000497027000000000000000043813" id="P7000497027000000000000000043813">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043814" id="P7000497027000000000000000043814"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043815" id="P7000497027000000000000000043815">Quicksort: 5.5 seconds, with 5 seconds as list and 0.4 as strlen</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043816" id="P7000497027000000000000000043816"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043817" id="P7000497027000000000000000043817">Iter first: 6 seconds, with 5.5 as list and 0.3 as strlen</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043818" id="P7000497027000000000000000043818"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043819" id="P7000497027000000000000000043819">Iter last: 5.3 seconds, with 5 as list and 0.2 as strlen</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004381A" id="P700049702700000000000000004381A"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P700049702700000000000000004381B" id="P700049702700000000000000004381B">Big table: 5.1 seconds, with 4.5 as list and 0.2 as strlen</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004381C" id="P700049702700000000000000004381C"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P700049702700000000000000004381D" id="P700049702700000000000000004381D">Better hash: 0.7 seconds, with 0.4 as strlen</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004381E" id="P700049702700000000000000004381E"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P700049702700000000000000004381F" id="P700049702700000000000000004381F">Linear lower: 0.2 seconds</p></li>
</ul></li>
</ol>
</details>
</figcaption></figure></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043820" id="P7000497027000000000000000043820"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043821" id="P7000497027000000000000000043821"><span class="pcalibre1 pcalibre2 pcalibre41">Hash. </span>Computing the hash function</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043822" id="P7000497027000000000000000043822"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter05.xhtml#P7000497027000000000000000043823" id="P7000497027000000000000000043823"><span class="pcalibre1 pcalibre2 pcalibre41">Rest. </span>The sum of all other functions</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043824" id="P7000497027000000000000000043824">As part (a) of the figure shows, our initial version required 3.5 minutes, with most of the time spent sorting. This is not surprising, since insertion sort has quadratic run time and the program sorted 363,039 values.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043825" id="P7000497027000000000000000043825">In our next version, we performed sorting using the library function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043826" id="P7000497027000000000000000043826">qsort</code>, which is based on the quicksort algorithm [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B468">98</a>]. It has an expected run time of <var class="pcalibre17 pcalibre2 pcalibre1">O</var>(<var class="pcalibre17 pcalibre2 pcalibre1">n</var> log <var class="pcalibre17 pcalibre2 pcalibre1">n</var>). This version is labeled "Quicksort" in the figure. The more efficient sorting algorithm reduces the time spent sorting to become negligible, and the overall run time to around 5.4 seconds. Part (b) of the figure shows the times for the remaining version on a scale where we can see them more clearly.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043827" id="P7000497027000000000000000043827"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005073" epub:type="pagebreak" id="P7000497027000000000000000005073" title="567"></span>With improved sorting, we now find that list scanning becomes the bottleneck. Thinking that the inefficiency is due to the recursive structure of the function, we replaced it by an iterative one, shown as "Iter first." Surprisingly, the run time increases to around 7.5 seconds. On closer study, we find a subtle difference between the two list functions. The recursive version inserted new elements at the end of the list, while the iterative one inserted them at the front. To maximize performance, we want the most frequent <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams to occur near the beginning of the lists. That way, the function will quickly locate the common cases. Assuming that <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams are spread uniformly throughout the document, we would expect the first occurrence of a frequent one to come before that of a less frequent one. By inserting new <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams at the end, the first function tended to order <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams in descending order of frequency, while the second function tended to do just the opposite. We therefore created a third list-scanning function that uses iteration but inserts new elements at the end of this list. With this version, shown as "Iter last," the time dropped to around 5.3 seconds, slightly better than with the recursive version. These measurements demonstrate the importance of running experiments on a program as part of an optimization effort. We initially assumed that converting recursive code to iterative code would improve its performance and did not consider the distinction between adding to the end or to the beginning of a list.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043828" id="P7000497027000000000000000043828">Next, we consider the hash table structure. The initial version had only 1,021 buckets (typically, the number of buckets is chosen to be a prime number to enhance the ability of the hash function to distribute keys uniformly among the buckets). For a table with 363,039 entries, this would imply an average <i class="pcalibre17 pcalibre2 pcalibre1">load</i> of 363,039/1,021 = 355.6. That explains why so much of the time is spent performing list operations—the searches involve testing a significant number of candidate <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams. It also explains why the performance is so sensitive to the list ordering. We then increased the number of buckets to 199,999, reducing the average load to 1.8. Oddly enough, however, our overall run time only drops to 5.1 seconds, a difference of only 0.2 seconds.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043829" id="P7000497027000000000000000043829">On further inspection, we can see that the minimal performance gain with a larger table was due to a poor choice of hash function. Simply summing the character codes for a string does not produce a very wide range of values. In particular, the maximum code value for a letter is 122, and so a string of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> characters will generate a sum of at most 122<var class="pcalibre17 pcalibre2 pcalibre1">n</var>. The longest bigram in our document, "honorificabilitudinitatibus*** thou" sums to just 3,371, and so most of the buckets in our hash table will go unused. In addition, a commutative hash function, such as addition, does not differentiate among the different possible orderings of characters with a string. For example, the words "rat" and "tar" will generate the same sums.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004382A" id="P700049702700000000000000004382A">We switched to a hash function that uses shift and <span class="pcalibre1 pcalibre29 pcalibre2">exclusive-or </span>operations. With this version, shown as "Better hash," the time drops to 0.6 seconds. A more systematic approach would be to study the distribution of keys among the buckets more carefully, making sure that it comes close to what one would expect if the hash function had a uniform output distribution.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004382B" id="P700049702700000000000000004382B"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005078" epub:type="pagebreak" id="P7000497027000000000000000005078" title="568"></span>Finally, we have reduced the run time to the point where most of the time is spent in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004382C" id="P700049702700000000000000004382C">strlen</code>, and most of the calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004382D" id="P700049702700000000000000004382D">strlen</code> occur as part of the lowercase conversion. We have already seen that function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004382E" id="P700049702700000000000000004382E">lower1</code> has quadratic performance, especially for long strings. The words in this document are short enough to avoid the disastrous consequences of quadratic performance; the longest bigram is just 32 characters. Still, switching to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004382F" id="P700049702700000000000000004382F">lower2</code>, shown as "Linear lower," yields a significant improvement, with the overall time dropping to around 0.2 seconds.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043830" id="P7000497027000000000000000043830">With this exercise, we have shown that code profiling can help drop the time required for a simple application from 3.5 minutes down to 0.2 seconds, yielding a performance gain of around 1,000×. The profiler helps us focus our attention on the most time-consuming parts of the program and also provides useful information about the procedure call structure. Some of the bottlenecks in our code, such as using a quadratic sort routine, are easy to anticipate, while others, such as whether to append to the beginning or end of a list, emerge only through a careful analysis.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043831" id="P7000497027000000000000000043831">We can see that profiling is a useful tool to have in the toolbox, but it should not be the only one. The timing measurements are imperfect, especially for shorter (less than 1 second) run times. More significantly, the results apply only to the particular data tested. For example, if we had run the original function on data consisting of a smaller number of longer strings, we would have found that the lowercase conversion routine was the major performance bottleneck. Even worse, if it only profiled documents with short words, we might never detect hidden bottlenecks such as the quadratic performance of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043832" id="P7000497027000000000000000043832">lower1</code>. In general, profiling can help us optimize for <i class="pcalibre17 pcalibre2 pcalibre1">typical</i> cases, assuming we run the program on representative data, but we should also make sure the program will have respectable performance for all possible cases. This mainly involves avoiding algorithms (such as insertion sort) and bad programming practices (such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043833" id="P7000497027000000000000000043833">lower1</code>) that yield poor asymptotic performance.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043834" id="P7000497027000000000000000043834">Amdahl's law, described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000204"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">1.9.1</span></a>, provides some additional insights into the performance gains that can be obtained by targeted optimizations. For our <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-gram code, we saw the total execution time drop from 209.0 to 5.4 seconds when we replaced insertion sort by quicksort. The initial version spent 203.7 of its 209.0 seconds performing insertion sort, giving <i class="pcalibre17 pcalibre2 pcalibre1">α</i> = 0.974, the fraction of time subject to speedup. With quicksort, the time spent sorting becomes negligible, giving a predicted speedup of 209/<i class="pcalibre17 pcalibre2 pcalibre1">α</i> = 39.0, close to the measured speedup of 38.5. We were able to gain a large speedup because sorting constituted a very large fraction of the overall execution time. However, when one bottleneck is eliminated, a new one arises, and so gaining additional speedup required focusing on other parts of the program.</p>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>5.15 Summary </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000005082"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P7000497027000000000000000043835" epub:type="title" id="P7000497027000000000000000043835"><span class="pcalibre1 pcalibre21 pcalibre2">5.15 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary </span></h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043836" id="P7000497027000000000000000043836">Although most presentations on code optimization describe how compilers can generate efficient code, much can be done by an application programmer to assist the compiler in this task. No compiler can replace an inefficient algorithm or data <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005085" epub:type="pagebreak" id="P7000497027000000000000000005085" title="569"></span>structure by a good one, and so these aspects of program design should remain a primary concern for programmers. We also have seen that optimization blockers, such as memory aliasing and procedure calls, seriously restrict the ability of compilers to perform extensive optimizations. Again, the programmer must take primary responsibility for eliminating these. These should simply be considered parts of good programming practice, since they serve to eliminate unneeded work.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043837" id="P7000497027000000000000000043837">Tuning performance beyond a basic level requires some understanding of the processor's microarchitecture, describing the underlying mechanisms by which the processor implements its instruction set architecture. For the case of out-of-order processors, just knowing something about the operations, capabilities, latencies, and issue times of the functional units establishes a baseline for predicting program performance.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043838" id="P7000497027000000000000000043838">We have studied a series of techniques—including loop unrolling, creating multiple accumulators, and reassociation—that can exploit the instruction-level parallelism provided by modern processors. As we get deeper into the optimization, it becomes important to study the generated assembly code and to try to understand how the computation is being performed by the machine. Much can be gained by identifying the critical paths determined by the data dependencies in the program, especially between the different iterations of a loop. We can also compute a throughput bound for a computation, based on the number of operations that must be computed and the number and issue times of the units that perform those operations.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043839" id="P7000497027000000000000000043839">Programs that involve conditional branches or complex interactions with the memory system are more difficult to analyze and optimize than the simple loop programs we first considered. The basic strategy is to try to make branches more predictable or make them amenable to implementation using conditional data transfers. We must also watch out for the interactions between store and load operations. Keeping values in local variables, allowing them to be stored in registers, can often be helpful.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004383A" id="P700049702700000000000000004383A">When working with large programs, it becomes important to focus our optimization efforts on the parts that consume the most time. Code profilers and related tools can help us systematically evaluate and improve program performance. We described <span class="pcalibre1 pcalibre29 pcalibre2">gprof</span>, a standard Unix profiling tool. More sophisticated profilers are available, such as the <span class="pcalibre1 pcalibre29 pcalibre2">vtune </span>program development system from Intel, and <span class="pcalibre1 pcalibre29 pcalibre2">valgrind</span>, commonly available on Linux systems. These tools can break down the execution time below the procedure level to estimate the performance of each <i class="pcalibre17 pcalibre2 pcalibre1">basic block</i> of the program. (A basic block is a sequence of instructions that has no transfers of control out of its middle, and so the block is always executed in its entirety.)</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Bibliographic Notes </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre83 pcalibre2" epub:type="bibliography" id="P700049702700000000000000000508A"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 title" data-uri="chapter05.xhtml#P700049702700000000000000004383B" epub:type="title" id="P700049702700000000000000004383B"><span class="pcalibre1 pcalibre21 pcalibre2">Bibliographic Notes </span></h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004383C" id="P700049702700000000000000004383C">Our focus has been to describe code optimization from the programmer's perspective, demonstrating how to write code that will make it easier for compilers to generate efficient code. An extended paper by Chellappa, Franchetti, and P$uUschel [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3C7">19</a>] <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P700049702700000000000000000508D" epub:type="pagebreak" id="P700049702700000000000000000508D" title="570"></span>takes a similar approach but goes into more detail with respect to the processor's characteristics.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004383D" id="P700049702700000000000000004383D">Many publications describe code optimization from a compiler's perspective, formulating ways that compilers can generate more efficient code. Muchnick's book is considered the most comprehensive [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B443">80</a>]. Wadleigh and Crawford's book on software optimization [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B48B">115</a>] covers some of the material we have presented, but it also describes the process of getting high performance on parallel machines. An early paper by Mahlke et al. [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B439">75</a>] describes how several techniques developed for compilers that map programs onto parallel machines can be adapted to exploit the instruction-level parallelism of modern processors. This paper covers the code transformations we presented, including loop unrolling, multiple accumulators (which they refer to as <i class="pcalibre17 pcalibre2 pcalibre1">accumulator variable expansion</i>), and reassociation (which they refer to as <i class="pcalibre17 pcalibre2 pcalibre1">tree height reduction</i>).</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004383E" id="P700049702700000000000000004383E">Our presentation of the operation of an out-of-order processor is fairly brief and abstract. More complete descriptions of the general principles can be found in advanced computer architecture textbooks, such as the one by Hennessy and Patterson [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3FE">46</a>, Ch. 2−3]. Shen and Lipasti's book [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B46C">100</a>] provides an in-depth treatment of modern processor design.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Homework Problems </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" epub:type="practice" id="P7000497027000000000000000005090"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P700049702700000000000000004383F" epub:type="title" id="P700049702700000000000000004383F"><span class="pcalibre1 pcalibre21 pcalibre2">Homework Problems </span></h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000005092" id="P7000497027000000000000000005092"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043840" epub:type="title" id="P7000497027000000000000000043840"><span class="pcalibre1 pcalibre21 pcalibre2">5.13 </span>♦♦</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043841" id="P7000497027000000000000000043841"><p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043842" id="P7000497027000000000000000043842">Suppose we wish to write a procedure that computes the inner product of two vectors u and v. An abstract version of the function has a CPE of 14−18 with x86-64 for different types of integer and floating-point data. By doing the same sort of transformations we did to transform the abstract program <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043843" id="P7000497027000000000000000043843">combine1</code> into the more efficient <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043844" id="P7000497027000000000000000043844">combine4</code>, we get the following code:</p></div>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043845" id="P7000497027000000000000000043845"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043846" id="P7000497027000000000000000043846">
1	/* Inner product. Accumulate in temporary */
2	void inner4(vec_ptr u, vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(u);
6		data_t *udata = get_vec_start(u);
7		data_t *vdata = get_vec_start(v);
8		data_t sum = (data_t) 0;
9	
10		for (i = 0; i &lt; length; i++) {
11			sum = sum + udata[i] * vdata[i];
12		}
13		*dest = sum;
14	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043847" id="P7000497027000000000000000043847">Our measurements show that this function has CPEs of 1.50 for integer data and 3.00 for floating-point data. For data type double, the x86-64 assembly code for the inner loop is as follows:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043848" id="P7000497027000000000000000043848"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043849" id="P7000497027000000000000000043849">
	<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P700049702700000000000000000509C" epub:type="pagebreak" id="P700049702700000000000000000509C" title="571"></span><i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of inner4. data_t = double, OP = *</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">udata in %rbp, vdata in %rax, sum in %xmm0</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">i in %rcx, limit in %rbx</i>
1	.L15:					<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	 vmovsd 0(%rbp,%rcx,8), %xmml		  Get <i class="pcalibre17 pcalibre2 pcalibre1">udata[i]</i>
3	 vmulsd (%rax,%rcx,8), %xmml, %xmml	  <i class="pcalibre17 pcalibre2 pcalibre1">Multiply by vdata[i]</i>
4	 vaddsd %xmml, %xmm0, %xmm0		  <i class="pcalibre17 pcalibre2 pcalibre1">Add to sum</i>
5	 addq $1, 7,rcx				  <i class="pcalibre17 pcalibre2 pcalibre1">Increment i</i>
6	 cmpq %rbx, %rcx			  <i class="pcalibre17 pcalibre2 pcalibre1">Compare i:limit</i>
7	 jne .L15				  <i class="pcalibre17 pcalibre2 pcalibre1">If ! =, goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">loop</b>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004384A" id="P700049702700000000000000004384A">Assume that the functional units have the characteristics listed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004BAA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a>.</p>
<ol class="pcalibre1 pcalibre2 pcalibre128" data-uri="chapter05.xhtml#P700049702700000000000000004384B" id="P700049702700000000000000004384B">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P700049702700000000000000004384C" id="P700049702700000000000000004384C">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P700049702700000000000000004384D" id="P700049702700000000000000004384D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004384E" id="P700049702700000000000000004384E">Diagram how this instruction sequence would be decoded into operations and show how the data dependencies between them would create a critical path of operations, in the style of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figures </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> and <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">5.14</span></a>.</p></div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P700049702700000000000000004384F" id="P700049702700000000000000004384F">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043850" id="P7000497027000000000000000043850"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043851" id="P7000497027000000000000000043851">For data type double, what lower bound on the CPE is determined by the critical path?</p></div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P7000497027000000000000000043852" id="P7000497027000000000000000043852">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043853" id="P7000497027000000000000000043853"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043854" id="P7000497027000000000000000043854">Assuming similar instruction sequences for the integer code as well, what lower bound on the CPE is determined by the critical path for integer data?</p></div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter05.xhtml#P7000497027000000000000000043855" id="P7000497027000000000000000043855">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P7000497027000000000000000043856" id="P7000497027000000000000000043856"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043857" id="P7000497027000000000000000043857">Explain how the floating-point versions can have CPEs of 3.00, even though the multiplication operation requires 5 clock cycles.</p></div></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P70004970270000000000000000050A7" id="P70004970270000000000000000050A7"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043858" epub:type="title" id="P7000497027000000000000000043858"><span class="pcalibre1 pcalibre21 pcalibre2">5.14 </span>♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043859" id="P7000497027000000000000000043859">Write a version of the inner product procedure described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005092"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> that uses 6 × 1 loop unrolling. For x86-64, our measurements of the unrolled version give a CPE of 1.07 for integer data but still 3.01 for both floating-point data.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter05.xhtml#P700049702700000000000000004385A" id="P700049702700000000000000004385A">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004385B" id="P700049702700000000000000004385B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004385C" id="P700049702700000000000000004385C">Explain why any (scalar) version of an inner product procedure running on an Intel Core i7 Haswell processor cannot achieve a CPE less than 1.00.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004385D" id="P700049702700000000000000004385D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004385E" id="P700049702700000000000000004385E">Explain why the performance for floating-point data did not improve with loop unrolling.</p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P70004970270000000000000000050AF" id="P70004970270000000000000000050AF"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004385F" epub:type="title" id="P700049702700000000000000004385F"><span class="pcalibre1 pcalibre21 pcalibre2">5.15 </span>♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043860" id="P7000497027000000000000000043860">Write a version of the inner product procedure described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005092"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> that uses 6 × 6 loop unrolling. Our measurements for this function with x86-64 give a CPE of 1.06 for integer data and 1.01 for floating-point data.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043861" id="P7000497027000000000000000043861">What factor limits the performance to a CPE of 1.00?</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P70004970270000000000000000050B3" id="P70004970270000000000000000050B3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043862" epub:type="title" id="P7000497027000000000000000043862"><span class="pcalibre1 pcalibre21 pcalibre2">5.16 </span>♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043863" id="P7000497027000000000000000043863">Write a version of the inner product procedure described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005092"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> that uses 6 × 1<var class="pcalibre17 pcalibre2 pcalibre1">a</var> loop unrolling to enable greater parallelism. Our measurements for this function give a CPE of 1.10 for integer data and 1.05 for floating-point data.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P70004970270000000000000000050B6" id="P70004970270000000000000000050B6"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043864" epub:type="title" id="P7000497027000000000000000043864"><span class="pcalibre1 pcalibre21 pcalibre2">5.17 </span>♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043865" id="P7000497027000000000000000043865">The library function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043866" id="P7000497027000000000000000043866">memset</code> has the following prototype:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043867" id="P7000497027000000000000000043867"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043868" id="P7000497027000000000000000043868">void *memset(void *s, int c, size_t n);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043869" id="P7000497027000000000000000043869"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P70004970270000000000000000050BD" epub:type="pagebreak" id="P70004970270000000000000000050BD" title="572"></span>This function fills <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004386A" id="P700049702700000000000000004386A">n</code> bytes of the memory area starting at <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004386B" id="P700049702700000000000000004386B">s</code> with copies of the low-order byte of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004386C" id="P700049702700000000000000004386C">c</code>. For example, it can be used to zero out a region of memory by giving argument 0 for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004386D" id="P700049702700000000000000004386D">c</code>, but other values are possible.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004386E" id="P700049702700000000000000004386E">The following is a straightforward implementation of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004386F" id="P700049702700000000000000004386F">memset</code>:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043870" id="P7000497027000000000000000043870"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043871" id="P7000497027000000000000000043871">
1	/* Basic implementation of memset */
2	void *basic_memset(void *s, int c, size_t n)
3	{
4		size_t cnt = 0;
5		unsigned char *schar = s;
6		while (cnt &lt; n) {
7			*schar++ = (unsigned char) c;
8			cnt++;
9		}
10		return s;
11	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043872" id="P7000497027000000000000000043872">Implement a more efficient version of the function by using a word of data type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043873" id="P7000497027000000000000000043873">unsigned long</code> to pack eight copies of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043874" id="P7000497027000000000000000043874">c</code>, and then step through the region using word-level writes. You might find it helpful to do additional loop unrolling as well. On our reference machine, we were able to reduce the CPE from 1.00 for the straightforward implementation to 0.127. That is, the program is able to write 8 bytes every clock cycle.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043875" id="P7000497027000000000000000043875">Here are some additional guidelines. To ensure portability, let <var class="pcalibre17 pcalibre2 pcalibre1">K</var> denote the value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043876" id="P7000497027000000000000000043876">sizeof (unsigned long)</code> for the machine on which you run your program.</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043877" id="P7000497027000000000000000043877">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043878" id="P7000497027000000000000000043878"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043879" id="P7000497027000000000000000043879">You may not call any library functions.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004387A" id="P700049702700000000000000004387A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004387B" id="P700049702700000000000000004387B">Your code should work for arbitrary values of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004387C" id="P700049702700000000000000004387C">n</code>, including when it is not a multiple of <i class="pcalibre17 pcalibre2 pcalibre1">K.</i> You can do this in a manner similar to the way we finish the last few iterations with loop unrolling.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004387D" id="P700049702700000000000000004387D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004387E" id="P700049702700000000000000004387E">You should write your code so that it will compile and run correctly on any machine regardless of the value of <i class="pcalibre17 pcalibre2 pcalibre1">K.</i> Make use of the operation <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004387F" id="P700049702700000000000000004387F">sizeof</code> to do this.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043880" id="P7000497027000000000000000043880"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043881" id="P7000497027000000000000000043881">On some machines, unaligned writes can be much slower than aligned ones. (On some non-x86 machines, they can even cause segmentation faults.) Write your code so that it starts with byte-level writes until the destination address is a multiple of <var class="pcalibre17 pcalibre2 pcalibre1">K</var>, then do word-level writes, and then (if necessary) finish with byte-level writes.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043882" id="P7000497027000000000000000043882"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043883" id="P7000497027000000000000000043883">Beware of the case where <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043884" id="P7000497027000000000000000043884">cnt</code> is small enough that the upper bounds on some of the loops become negative. With expressions involving the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043885" id="P7000497027000000000000000043885">sizeof</code> operator, the testing may be performed with unsigned arithmetic. (See <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000077D_split_001.xhtml#P7000497027000000000000000000C88"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">2.2.8</span></a> and <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001498.xhtml#P70004970270000000000000000015A5"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">2.72</span></a>.)</p></li>
</ul>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P70004970270000000000000000050DA" id="P70004970270000000000000000050DA"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043886" epub:type="title" id="P7000497027000000000000000043886"><span class="pcalibre1 pcalibre21 pcalibre2">5.18 </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043887" id="P7000497027000000000000000043887">We considered the task of polynomial evaluation in Practice Problems 5.5 and 5.6, with both a direct evaluation and an evaluation by Horner's method. Try to write <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P70004970270000000000000000050DD" epub:type="pagebreak" id="P70004970270000000000000000050DD" title="573"></span>faster versions of the function using the optimization techniques we have explored, including loop unrolling, parallel accumulation, and reassociation. You will find many different ways of mixing together Horner's scheme and direct evaluation with these optimization techniques.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043888" id="P7000497027000000000000000043888">Ideally, you should be able to reach a CPE close to the throughput limit of your machine. Our best version achieves a CPE of 1.07 on our reference machine.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P70004970270000000000000000050DF" id="P70004970270000000000000000050DF"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043889" epub:type="title" id="P7000497027000000000000000043889"><span class="pcalibre1 pcalibre21 pcalibre2">5.19 </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004388A" id="P700049702700000000000000004388A">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004FEC"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a>, we were able to reduce the CPE for the prefix-sum computation to 3.00, limited by the latency of floating-point addition on this machine. Simple loop unrolling does not improve things.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004388B" id="P700049702700000000000000004388B">Using a combination of loop unrolling and reassociation, write code for a prefix sum that achieves a CPE less than the latency of floating-point addition on your machine. Doing this requires actually increasing the number of additions performed. For example, our version with two-way unrolling requires three additions per iteration, while our version with four-way unrolling requires five. Our best implementation achieves a CPE of 1.67 on our reference machine.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004388C" id="P700049702700000000000000004388C">Determine how the throughput and latency limits of your machine limit the minimum CPE you can achieve for the prefix-sum operation.</p>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Solutions to Practice Problems </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P70004970270000000000000000050E4"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter05.xhtml#P700049702700000000000000004388D" epub:type="title" id="P700049702700000000000000004388D"><span class="pcalibre1 pcalibre21 pcalibre2">Solutions to Practice Problems </span></h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P70004970270000000000000000050E6" id="P70004970270000000000000000050E6"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004388E" epub:type="title" id="P700049702700000000000000004388E"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000048D0.xhtml#P7000497027000000000000000004908"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000048D0.xhtml#P7000497027000000000000000004904">500</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004388F" id="P700049702700000000000000004388F">This problem illustrates some of the subtle effects of memory aliasing.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043890" id="P7000497027000000000000000043890">As the following commented code shows, the effect will be to set the value at <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043891" id="P7000497027000000000000000043891">xp</code> to zero:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043892" id="P7000497027000000000000000043892"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043893" id="P7000497027000000000000000043893">
4	*xp = *xp + *xp; /* 2x */
5	*xp = *xp − *xp; /* 2x-2x = 0 */
6	*xp = *xp − *xp; /* 0−0 = 0 */
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043894" id="P7000497027000000000000000043894">This example illustrates that our intuition about program behavior can often be wrong. We naturally think of the case where <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043895" id="P7000497027000000000000000043895">xp</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043896" id="P7000497027000000000000000043896">yp</code> are distinct but overlook the possibility that they might be equal. Bugs often arise due to conditions the programmer does not anticipate.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P70004970270000000000000000050F0" id="P70004970270000000000000000050F0"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043897" epub:type="title" id="P7000497027000000000000000043897"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000493B.xhtml#P7000497027000000000000000004960"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.2 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000493B.xhtml#P7000497027000000000000000004959">504</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043898" id="P7000497027000000000000000043898">This problem illustrates the relationship between CPE and absolute performance. It can be solved using elementary algebra. We find that for <var class="pcalibre17 pcalibre2 pcalibre1">n</var> ≤ 2, version 1 is the fastest. Version 2 is fastest for 3 ≤ <var class="pcalibre17 pcalibre2 pcalibre1">n</var> ≤ 7, and version 3 is fastest for <var class="pcalibre17 pcalibre2 pcalibre1">n</var> ≥ 8.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P70004970270000000000000000050F3" id="P70004970270000000000000000050F3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043899" epub:type="title" id="P7000497027000000000000000043899"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000049CE.xhtml#P7000497027000000000000000004A51"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.3 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000049CE.xhtml#P7000497027000000000000000004A4F">512</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004389A" id="P700049702700000000000000004389A">This is a simple exercise, but it is important to recognize that the four statements of a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004389B" id="P700049702700000000000000004389B">for</code> loop—initial, test, update, and body—get executed different numbers of times.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004389C" id="P700049702700000000000000004389C"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P70004970270000000000000000050F8" epub:type="pagebreak" id="P70004970270000000000000000050F8" title="574"></span></p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter05.xhtml#P700049702700000000000000004389D" id="P700049702700000000000000004389D">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004389E" id="P700049702700000000000000004389E">Code</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P700049702700000000000000004389F" id="P700049702700000000000000004389F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438A0" id="P70004970270000000000000000438A0">min</code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000438A1" id="P70004970270000000000000000438A1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438A2" id="P70004970270000000000000000438A2">max</code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000438A3" id="P70004970270000000000000000438A3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438A4" id="P70004970270000000000000000438A4">incr</code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter05.xhtml#P70004970270000000000000000438A5" id="P70004970270000000000000000438A5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438A6" id="P70004970270000000000000000438A6">square</code></th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438A7" id="P70004970270000000000000000438A7">A.</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438A8" id="P70004970270000000000000000438A8">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438A9" id="P70004970270000000000000000438A9">91</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438AA" id="P70004970270000000000000000438AA">90</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438AB" id="P70004970270000000000000000438AB">90</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438AC" id="P70004970270000000000000000438AC">B.</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438AD" id="P70004970270000000000000000438AD">91</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438AE" id="P70004970270000000000000000438AE">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438AF" id="P70004970270000000000000000438AF">90</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438B0" id="P70004970270000000000000000438B0">90</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438B1" id="P70004970270000000000000000438B1">C.</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438B2" id="P70004970270000000000000000438B2">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438B3" id="P70004970270000000000000000438B3">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438B4" id="P70004970270000000000000000438B4">90</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438B5" id="P70004970270000000000000000438B5">90</td>
</tr>
</tbody>
</table>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000005112" id="P7000497027000000000000000005112"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438B6" epub:type="title" id="P70004970270000000000000000438B6"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004AB6.xhtml#P7000497027000000000000000004B22"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.4 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000004AB6.xhtml#P7000497027000000000000000004B1A">516</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438B7" id="P70004970270000000000000000438B7">This assembly code demonstrates a clever optimization opportunity detected by <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>. It is worth studying this code carefully to better understand the subtleties of code optimization.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter05.xhtml#P70004970270000000000000000438B8" id="P70004970270000000000000000438B8">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438B9" id="P70004970270000000000000000438B9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438BA" id="P70004970270000000000000000438BA">In the less optimized code, register <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438BB" id="P70004970270000000000000000438BB">%xmm0</code> is simply used as a temporary value, both set and used on each loop iteration. In the more optimized code, it is used more in the manner of variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438BC" id="P70004970270000000000000000438BC">acc</code> in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438BD" id="P70004970270000000000000000438BD">combine4</code>, accumulating the product of the vector elements. The difference with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438BE" id="P70004970270000000000000000438BE">combine4</code>, however, is that location <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438BF" id="P70004970270000000000000000438BF">dest</code> is updated on each iteration by the second <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438C0" id="P70004970270000000000000000438C0">vmovsd</code> instruction.</p>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438C1" id="P70004970270000000000000000438C1">We can see that this optimized version operates much like the following C code:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438C2" id="P70004970270000000000000000438C2"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438C3" id="P70004970270000000000000000438C3">
1	/* Make sure dest updated on each iteration */
2	void combine3w(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		data_t *data = get_vec_start(v);
7		data_t acc = IDENT;
8	
9		/* Initialize in event length &lt;= 0 */
10		*dest = ace;
11	
12		for (i = 0; i &lt; length; i++) {
13			acc = acc OP data[i];
14			*dest = ace;
15		}
16	}
</code></pre>
</li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438C4" id="P70004970270000000000000000438C4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438C5" id="P70004970270000000000000000438C5">The two versions of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438C6" id="P70004970270000000000000000438C6">combine3</code> will have identical functionality, even with memory aliasing.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438C7" id="P70004970270000000000000000438C7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438C8" id="P70004970270000000000000000438C8">This transformation can be made without changing the program behavior, because, with the exception of the first iteration, the value read from <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438C9" id="P70004970270000000000000000438C9">dest</code> at the beginning of each iteration will be the same value written to this register <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005127" epub:type="pagebreak" id="P7000497027000000000000000005127" title="575"></span>at the end of the previous iteration. Therefore, the combining instruction can simply use the value already in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438CA" id="P70004970270000000000000000438CA">%xmm0</code> at the beginning of the loop.</p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000005129" id="P7000497027000000000000000005129"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438CB" epub:type="title" id="P70004970270000000000000000438CB"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C70"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.5 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C72">530</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438CC" id="P70004970270000000000000000438CC">Polynomial evaluation is a core technique for solving many problems. For example, polynomial functions are commonly used to approximate trigonometric functions in math libraries.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter05.xhtml#P70004970270000000000000000438CD" id="P70004970270000000000000000438CD">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438CE" id="P70004970270000000000000000438CE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438CF" id="P70004970270000000000000000438CF">The function performs 2<var class="pcalibre17 pcalibre2 pcalibre1">n</var> multiplications and <var class="pcalibre17 pcalibre2 pcalibre1">n</var> additions.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438D0" id="P70004970270000000000000000438D0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438D1" id="P70004970270000000000000000438D1">We can see that the performance-limiting computation here is the repeated computation of the expression <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438D2" id="P70004970270000000000000000438D2">xpwr = x * xpwr</code>. This requires a floating-point multiplication (5 clock cycles), and the computation for one iteration cannot begin until the one for the previous iteration has completed. The updating of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438D3" id="P70004970270000000000000000438D3">result</code> only requires a floating-point addition (3 clock cycles) between successive iterations.</p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000005133" id="P7000497027000000000000000005133"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438D4" epub:type="title" id="P70004970270000000000000000438D4"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C82"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.6 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C72">530</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438D5" id="P70004970270000000000000000438D5">This problem demonstrates that minimizing the number of operations in a computation may not improve its performance.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter05.xhtml#P70004970270000000000000000438D6" id="P70004970270000000000000000438D6">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438D7" id="P70004970270000000000000000438D7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438D8" id="P70004970270000000000000000438D8">The function performs <var class="pcalibre17 pcalibre2 pcalibre1">n</var> multiplications and <var class="pcalibre17 pcalibre2 pcalibre1">n</var> additions, half the number of multiplications as the original function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438D9" id="P70004970270000000000000000438D9">poly</code>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438DA" id="P70004970270000000000000000438DA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438DB" id="P70004970270000000000000000438DB">We can see that the performance-limiting computation here is the repeated computation of the expression <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438DC" id="P70004970270000000000000000438DC">result = a[i] + x*result.</code> Starting from the value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438DD" id="P70004970270000000000000000438DD">result</code> from the previous iteration, we must first multiply it by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438DE" id="P70004970270000000000000000438DE">x</code> (5 clock cycles) and then add it to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438DF" id="P70004970270000000000000000438DF">a[i]</code> (3 cycles) before we have the value for this iteration. Thus, each iteration imposes a minimum latency of 8 cycles, exactly our measured CPE.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438E0" id="P70004970270000000000000000438E0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438E1" id="P70004970270000000000000000438E1">Although each iteration in function <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438E2" id="P70004970270000000000000000438E2">poly</code> requires two multiplications rather than one, only a single multiplication occurs along the critical path per iteration.</p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000005143" id="P7000497027000000000000000005143"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438E3" epub:type="title" id="P70004970270000000000000000438E3"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004C94.xhtml#P7000497027000000000000000004CA9"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.7 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000004C94.xhtml#P7000497027000000000000000004C9E">532</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438E4" id="P70004970270000000000000000438E4">The following code directly follows the rules we have stated for unrolling a loop by some factor <i class="pcalibre17 pcalibre2 pcalibre1">k:</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438E5" id="P70004970270000000000000000438E5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438E6" id="P70004970270000000000000000438E6">
1	void unroll5(vec_ptr v, data_t *dest)
2	{
3		long i;
4		long length = vec_length(v);
5		long limit = length-4;
6		data_t *data = get_vec_start(v);
7		data_t acc = IDENT;
8	
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005148" epub:type="pagebreak" id="P7000497027000000000000000005148" title="576"></span>9		/* Combine 5 elements at a time */
10		for (i = 0; i &lt; limit; i+=5) {
11			acc = acc OP data[i] OP data[i+1];
12			acc = acc OP data[i+2] OP data[i+3];
13			acc = acc OP data[i+4];
14		}
15	
16		/* Finish any remaining elements */
17		for (;i &lt; length; i++) {
18			acc = acc OP data[i];
19		}
20		*dest = ace;
21	}
</code></pre>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000005149" id="P7000497027000000000000000005149"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438E7" epub:type="title" id="P70004970270000000000000000438E7"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004D16.xhtml#P7000497027000000000000000004E13"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.8 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000004D16.xhtml#P7000497027000000000000000004E0B">545</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438E8" id="P70004970270000000000000000438E8">This problem demonstrates how small changes in a program can yield dramatic performance differences, especially on a machine with out-of-order execution. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005152"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.39</span></a> diagrams the three multiplication operations for a single iteration of the function. In this figure, the operations shown as blue boxes are along the critical path—they need to be computed in sequence to compute a new value for loop variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438E9" id="P70004970270000000000000000438E9">r</code>. The operations shown as light boxes can be computed in parallel with the critical path operations. For a loop with <var class="pcalibre17 pcalibre2 pcalibre1">P</var> operations along the critical path, each iteration will require a minimum of 5<var class="pcalibre17 pcalibre2 pcalibre1">P</var> clock cycles and will compute the product for three elements, giving a lower bound on the CPE of 5<var class="pcalibre17 pcalibre2 pcalibre1">P</var>/3. This implies lower bounds of 5.00 for Al, 3.33 for A2 and A5, and 1.67 for A3 and A4. We ran these functions on an Intel Core i7 Haswell processor and found that it could achieve these CPE values.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P700049702700000000000000000514D" id="P700049702700000000000000000514D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438EA" epub:type="title" id="P70004970270000000000000000438EA"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004E9A.xhtml#P7000497027000000000000000004F3B"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.9 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000004E9A.xhtml#P7000497027000000000000000004F3A">553</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438EB" id="P70004970270000000000000000438EB">This is another demonstration that a slight change in coding style can make it much easier for the compiler to detect opportunities to use conditional moves:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438EC" id="P70004970270000000000000000438EC"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438ED" id="P70004970270000000000000000438ED">
while (i1 &lt; n &amp;&amp; i2 &lt; n) {
	long v1 = srcl [i1];
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter05.xhtml#P7000497027000000000000000005152" id="P7000497027000000000000000005152">
<img alt="Diagrams depict paths for five cases." class="pcalibre1 pcalibre2 pcalibre206" data-uri="P700049702700000000000000000B728" id="P70004970270000000000000000438EE" src="Images/chapter-05-image-26.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter05.xhtml#P70004970270000000000000000438EF" id="P70004970270000000000000000438EF"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter05.xhtml#P70004970270000000000000000438F0" epub:type="title" id="P70004970270000000000000000438F0"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.39 </span>Data dependencies among multiplication operations for cases in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004D16.xhtml#P7000497027000000000000000004E13"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">5.8</span></a>.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter05.xhtml#P70004970270000000000000000438F1" id="P70004970270000000000000000438F1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438F2" id="P70004970270000000000000000438F2">The operations shown as blue boxes form the critical paths for the iterations.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter05.xhtml#P7000497027000000000000000023BDE" id="P7000497027000000000000000023BDE">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter05.xhtml#P70004970270000000000000000438F3" id="P70004970270000000000000000438F3">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438F4" id="P70004970270000000000000000438F4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438F5" id="P70004970270000000000000000438F5">A1: ((r*x)*y)*x: path from r through three blue boxes to r; path from x to first blue box; path from y to second blue box; path from z to third blue box</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438F6" id="P70004970270000000000000000438F6"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438F7" id="P70004970270000000000000000438F7">* A2: (r*(x*y))*z: path from r through two blue boxes to r; paths from x and y to light box, then first blue box; path from z to second blue box</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438F8" id="P70004970270000000000000000438F8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438F9" id="P70004970270000000000000000438F9">* A3: r*((x*y)*z): path from r through one blue box to r; paths from x and y through two light boxes to blue box; path from z to second light box&gt;</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438FA" id="P70004970270000000000000000438FA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438FB" id="P70004970270000000000000000438FB">* A4: r*(x*y*z)): path from r through one blue box to r; path from x to lower light box to blue box; paths from y and z to higher light box to lower light box</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438FC" id="P70004970270000000000000000438FC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P70004970270000000000000000438FD" id="P70004970270000000000000000438FD">* A5: (r*x)*(y*z): path from r through two blue boxes to r; path from x to first blue box; paths from y and z to light box to second blue box.</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P70004970270000000000000000438FE" id="P70004970270000000000000000438FE"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005159" epub:type="pagebreak" id="P7000497027000000000000000005159" title="577"></span></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P70004970270000000000000000438FF" id="P70004970270000000000000000438FF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043900" id="P7000497027000000000000000043900">
	long v2 = src2 [i2];
	long takel = v1 &lt; v2;
	dest[id++] = take1 ? v1 : v2;
	i1 += take1;
	i2 += (1-take1);
}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043901" id="P7000497027000000000000000043901">We measured a CPE of around 12.0 for this version of the code, a modest improvement over the original CPE of 15.0.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P700049702700000000000000000515D" id="P700049702700000000000000000515D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043902" epub:type="title" id="P7000497027000000000000000043902"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004FBF"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.10 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004FB4">559</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043903" id="P7000497027000000000000000043903">This problem requires you to analyze the potential load-store interactions in a program.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter05.xhtml#P7000497027000000000000000043904" id="P7000497027000000000000000043904">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043905" id="P7000497027000000000000000043905"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043906" id="P7000497027000000000000000043906">It will set each element <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043907" id="P7000497027000000000000000043907">a[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> to <var class="pcalibre17 pcalibre2 pcalibre1">i</var> + 1, for 0 ≤ <var class="pcalibre17 pcalibre2 pcalibre1">i</var> ≤ 998.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043908" id="P7000497027000000000000000043908"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P7000497027000000000000000043909" id="P7000497027000000000000000043909">It will set each element <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004390A" id="P700049702700000000000000004390A">a[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> to 0, for 1 ≤ <var class="pcalibre17 pcalibre2 pcalibre1">i</var> ≤ 999.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004390B" id="P700049702700000000000000004390B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004390C" id="P700049702700000000000000004390C">In the second case, the load of one iteration depends on the result of the store from the previous iteration. Thus, there is a write/read dependency between successive iterations.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P700049702700000000000000004390D" id="P700049702700000000000000004390D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter05.xhtml#P700049702700000000000000004390E" id="P700049702700000000000000004390E">It will give a CPE of 1.2, the same as for Example A, since there are no dependencies between stores and subsequent loads.</p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P700049702700000000000000000516B" id="P700049702700000000000000000516B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004390F" epub:type="title" id="P700049702700000000000000004390F"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004FDE"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.11 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004FE0">561</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043910" id="P7000497027000000000000000043910">We can see that this function has a write/read dependency between successive iterations—the destination value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043911" id="P7000497027000000000000000043911">p[i]</code> on one iteration matches the source value <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043912" id="P7000497027000000000000000043912">p[i-1]</code> on the next. A critical path is therefore formed for each iteration consisting of a store (from the previous iteration), a load, and a floating-point addition. The CPE measurement of 9.0 is consistent with our measurement of 7.3 for the CPE of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043913" id="P7000497027000000000000000043913">write_read</code> when there is a data dependency, since <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043914" id="P7000497027000000000000000043914">write_read</code> involves an integer addition (1 clock-cycle latency), while <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043915" id="P7000497027000000000000000043915">psum1</code> involves a floating-point addition (3 clock-cycle latency).</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter05.xhtml#P7000497027000000000000000005173" id="P7000497027000000000000000005173"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043916" epub:type="title" id="P7000497027000000000000000043916"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004FEC"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004FE0">561</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043917" id="P7000497027000000000000000043917">Here is a revised version of the function:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043918" id="P7000497027000000000000000043918"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043919" id="P7000497027000000000000000043919">
1	void psum1a(float a[], float p[], long n)
2	{
3		long i;
4		/* last_val holds p[i-1]; val holds p [i] */
5		float last_val, val;
6		last_val = p[0] = a[0];
7		for (i = 1; i &lt; n; i++) {
8			val = last_val + a[i];
9			p[i] = val;
10			last_val = val;
11		}
12	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004391A" id="P700049702700000000000000004391A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter05.xhtml#P7000497027000000000000000005179" epub:type="pagebreak" id="P7000497027000000000000000005179" title="578"></span>We introduce a local variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004391B" id="P700049702700000000000000004391B">last_val</code>. At the start of iteration <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004391C" id="P700049702700000000000000004391C">i</code>, it holds the value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004391D" id="P700049702700000000000000004391D">p[i-1]</code>. We then compute <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004391E" id="P700049702700000000000000004391E">val</code> to be the value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P700049702700000000000000004391F" id="P700049702700000000000000004391F">p[i]</code> and to be the new value for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043920" id="P7000497027000000000000000043920">last_val</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043921" id="P7000497027000000000000000043921">This version compiles to the following assembly code:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter05.xhtml#P7000497027000000000000000043922" id="P7000497027000000000000000043922"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043923" id="P7000497027000000000000000043923">
	<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of psum1a</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">a in %rdi, i in %rax, cnt in %rdx, last_val in %xmm0</i>
1	.L16:					<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	 vaddss (%rdi,%rax, 4), %xmm0, %xmm0	  <i class="pcalibre17 pcalibre2 pcalibre1">last_val = val = last_val + a[i]</i>
3	 vmovss %xmm0, (%rsi,%rax,4)		  <i class="pcalibre17 pcalibre2 pcalibre1">Store val in p[i]</i>
4	 addq $1, %rax				  <i class="pcalibre17 pcalibre2 pcalibre1">Increment i</i>
5	 cmpq %rdx, 7,rax			  <i class="pcalibre17 pcalibre2 pcalibre1">Compare i : cnt</i>
6	 jne .L16				  <i class="pcalibre17 pcalibre2 pcalibre1">If ! =, goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">loop</b>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043924" id="P7000497027000000000000000043924">This code holds <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043925" id="P7000497027000000000000000043925">last_val</code> in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043926" id="P7000497027000000000000000043926">%xmm0</code>, avoiding the need to read <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043927" id="P7000497027000000000000000043927">p[i-1]</code> from memory and thus eliminating the write/read dependency seen in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter05.xhtml#P7000497027000000000000000043928" id="P7000497027000000000000000043928">psum1</code>.</p>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Chapter 12 Concurrent Programming</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" epub:type="chapter" id="P7000497027000000000000000008060"><header class="pcalibre1 pcalibre2 pcalibre48"><h1 class="pcalibre1 pcalibre2 pcalibre49" data-uri="chapter12.xhtml#P7000497027000000000000000046B6B" epub:type="title" id="P7000497027000000000000000046B6B"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008062" epub:type="pagebreak" id="P7000497027000000000000000008062" title="971"></span><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre50 pcalibre2">12 </span>Concurrent Programming</h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" id="d9e172027">
<nav class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000046B6C" epub:type="toc" id="P7000497027000000000000000046B6C">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046B6D" id="P7000497027000000000000000046B6D">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B6E" id="P7000497027000000000000000046B6E">
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B6F" id="P7000497027000000000000000046B6F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B70" id="P7000497027000000000000000046B70"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008097.xhtml#P7000497027000000000000000008097"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.1 </span>Concurrent Programming with Processes </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">973</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B71" id="P7000497027000000000000000046B71"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B72" id="P7000497027000000000000000046B72"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP70004970270000000000000000080DE.xhtml#P70004970270000000000000000080DE"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.2 </span>Concurrent Programming with I/O Multiplexing </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">977</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B73" id="P7000497027000000000000000046B73"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B74" id="P7000497027000000000000000046B74"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000817D.xhtml#P700049702700000000000000000817D"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3 </span>Concurrent Programming with Threads </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">985</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B75" id="P7000497027000000000000000046B75"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B76" id="P7000497027000000000000000046B76"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000821D.xhtml#P700049702700000000000000000821D"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.4 </span>Shared Variables in Threaded Programs </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">992</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B77" id="P7000497027000000000000000046B77"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B78" id="P7000497027000000000000000046B78"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000827E.xhtml#P700049702700000000000000000827E"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.5 </span>Synchronizing Threads with Semaphores </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">995</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B79" id="P7000497027000000000000000046B79"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B7A" id="P7000497027000000000000000046B7A"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000849B.xhtml#P700049702700000000000000000849B"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.6 </span>Using Threads for Parallelism </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1013</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B7B" id="P7000497027000000000000000046B7B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B7C" id="P7000497027000000000000000046B7C"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008577.xhtml#P7000497027000000000000000008577"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.7 </span>Other Concurrency Issues </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1020</span></a></p></li>
</ol></div>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046B7D" id="P7000497027000000000000000046B7D">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B7E" id="P7000497027000000000000000046B7E">
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B7F" id="P7000497027000000000000000046B7F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B80" id="P7000497027000000000000000046B80"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008670.xhtml#P7000497027000000000000000008670"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.8 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary</span> </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1030</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B81" id="P7000497027000000000000000046B81"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B82" id="P7000497027000000000000000046B82"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008676.xhtml#P7000497027000000000000000008676"><span class="pcalibre1 pcalibre2" epub:type="title">Bibliographic Notes </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1030</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B83" id="P7000497027000000000000000046B83"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B84" id="P7000497027000000000000000046B84"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000867A"><span class="pcalibre1 pcalibre2" epub:type="title">Homework Problems </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1031</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B85" id="P7000497027000000000000000046B85"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B86" id="P7000497027000000000000000046B86"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000875E.xhtml#P700049702700000000000000000875E"><span class="pcalibre1 pcalibre2" epub:type="title">Solutions to Practice Problems </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1036</span></a></p></li>
</ol></div>
</nav>
<section class="pcalibre1 pcalibre2 pcalibre51" data-uri="chapter12.xhtml#P7000497027000000000000000046B87" epub:type="introduction" id="P7000497027000000000000000046B87">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B88" id="P7000497027000000000000000046B88"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008080" epub:type="pagebreak" id="P7000497027000000000000000008080" title="972"></span>As we learned in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">8</span></a>, logical control flows are <i class="pcalibre17 pcalibre2 pcalibre1">concurrent</i> if they overlap in time. This general phenomenon, known as <i class="pcalibre17 pcalibre2 pcalibre1">concurrency</i>, shows up at many different levels of a computer system. Hardware exception handlers, processes, and Linux signal handlers are all familiar examples.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B89" id="P7000497027000000000000000046B89">Thus far, we have treated concurrency mainly as a mechanism that the operating system kernel uses to run multiple application programs. But concurrency is not just limited to the kernel. It can play an important role in application programs as well. For example, we have seen how Linux signal handlers allow applications to respond to asynchronous events such as the user typing Ctrl+C or the program accessing an undefined area of virtual memory. Application-level concurrency is useful in other ways as well:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B8A" id="P7000497027000000000000000046B8A">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B8B" id="P7000497027000000000000000046B8B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B8C" id="P7000497027000000000000000046B8C"><span class="pcalibre1 pcalibre2 pcalibre41">Accessing slow I/O devices. </span>When an application is waiting for data to arrive from a slow I/O device such as a disk, the kernel keeps the CPU busy by running other processes. Individual applications can exploit concurrency in a similar way by overlapping useful work with I/O requests.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B8D" id="P7000497027000000000000000046B8D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B8E" id="P7000497027000000000000000046B8E"><span class="pcalibre1 pcalibre2 pcalibre41">Interacting with humans. </span>People who interact with computers demand the ability to perform multiple tasks at the same time. For example, they might want to resize a window while they are printing a document. Modern windowing systems use concurrency to provide this capability. Each time the user requests some action (say, by clicking the mouse), a separate concurrent logical flow is created to perform the action.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B8F" id="P7000497027000000000000000046B8F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B90" id="P7000497027000000000000000046B90"><span class="pcalibre1 pcalibre2 pcalibre41">Reducing latency by deferring work. </span>Sometimes, applications can use concurrency to reduce the latency of certain operations by deferring other operations and performing them concurrently. For example, a dynamic storage allocator might reduce the latency of individual free operations by deferring coalescing to a concurrent "coalescing" flow that runs at a lower priority, soaking up spare CPU cycles as they become available.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B91" id="P7000497027000000000000000046B91"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B92" id="P7000497027000000000000000046B92"><span class="pcalibre1 pcalibre2 pcalibre41">Servicing multiple network clients. </span>The iterative network servers that we studied in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007B7A.xhtml#P7000497027000000000000000007B7A"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">11</span></a> are unrealistic because they can only service one client at a time. Thus, a single slow client can deny service to every other client. For a real server that might be expected to service hundreds or thousands of clients per second, it is not acceptable to allow one slow client to deny service to the others. A better approach is to build a <i class="pcalibre17 pcalibre2 pcalibre1">concurrent server</i> that creates a separate logical flow for each client. This allows the server to service multiple clients concurrently and precludes slow clients from monopolizing the server.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B93" id="P7000497027000000000000000046B93"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B94" id="P7000497027000000000000000046B94"><span class="pcalibre1 pcalibre2 pcalibre41">Computing in parallel on multi-core machines. </span>Many modern systems are equipped with multi-core processors that contain multiple CPUs. Applications that are partitioned into concurrent flows often run faster on multi-core machines than on uniprocessor machines because the flows execute in parallel rather than being interleaved.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B95" id="P7000497027000000000000000046B95">Applications that use application-level concurrency are known as <i class="pcalibre17 pcalibre2 pcalibre1">concurrent programs</i>. Modern operating systems provide three basic approaches for building concurrent programs:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B96" id="P7000497027000000000000000046B96">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B97" id="P7000497027000000000000000046B97"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B98" id="P7000497027000000000000000046B98"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008091" epub:type="pagebreak" id="P7000497027000000000000000008091" title="973"></span><span class="pcalibre1 pcalibre2 pcalibre41">Processes. </span>With this approach, each logical control flow is a process that is scheduled and maintained by the kernel. Since processes have separate virtual address spaces, flows that want to communicate with each other must use some kind of explicit <i class="pcalibre17 pcalibre2 pcalibre1">interprocess communication (IPC)</i> mechanism.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B99" id="P7000497027000000000000000046B99"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B9A" id="P7000497027000000000000000046B9A"><span class="pcalibre1 pcalibre2 pcalibre41">I/O multiplexing. </span>his is a form of concurrent programming where applications explicitly schedule their own logical flows in the context of a single process. Logical flows are modeled as state machines that the main program explicitly transitions from state to state as a result of data arriving on file descriptors. Since the program is a single process, all flows share the same address space.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B9B" id="P7000497027000000000000000046B9B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B9C" id="P7000497027000000000000000046B9C"><span class="pcalibre1 pcalibre2 pcalibre41">Threads. </span>Threads are logical flows that run in the context of a single process and are scheduled by the kernel. You can think of threads as a hybrid of the other two approaches, scheduled by the kernel like process flows and sharing the same virtual address space like I/O multiplexing flows.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B9D" id="P7000497027000000000000000046B9D">This chapter investigates these three different concurrent programming techniques. To keep our discussion concrete, we will work with the same motivating application throughout—a concurrent version of the iterative echo server from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E4C"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.9</span></a>.</p>
</section>
</section>
<!--EOF:P7000497027000000000000000008097-->
<!--EOF:P70004970270000000000000000080DE-->
<!--EOF:P700049702700000000000000000817D-->
<!--EOF:P700049702700000000000000000821D-->
<!--EOF:P700049702700000000000000000827E-->
<!--EOF:P700049702700000000000000000849B-->
<!--EOF:P7000497027000000000000000008577-->
<!--EOF:P7000497027000000000000000008670-->
<!--EOF:P7000497027000000000000000008676-->
<!--EOF:P700049702700000000000000000867A-->
<!--EOF:P700049702700000000000000000875E-->
</section></body></html>
