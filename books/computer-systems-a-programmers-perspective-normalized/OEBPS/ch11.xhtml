<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Chapter 12 Concurrent Programming</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" epub:type="chapter" id="P7000497027000000000000000008060"><header class="pcalibre1 pcalibre2 pcalibre48"><h1 class="pcalibre1 pcalibre2 pcalibre49" data-uri="chapter12.xhtml#P7000497027000000000000000046B6B" epub:type="title" id="P7000497027000000000000000046B6B"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008062" epub:type="pagebreak" id="P7000497027000000000000000008062" title="971"></span><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre50 pcalibre2">12 </span>Concurrent Programming</h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" id="d9e172027">
<nav class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000046B6C" epub:type="toc" id="P7000497027000000000000000046B6C">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046B6D" id="P7000497027000000000000000046B6D">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B6E" id="P7000497027000000000000000046B6E">
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B6F" id="P7000497027000000000000000046B6F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B70" id="P7000497027000000000000000046B70"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008097.xhtml#P7000497027000000000000000008097"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.1 </span>Concurrent Programming with Processes </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">973</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B71" id="P7000497027000000000000000046B71"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B72" id="P7000497027000000000000000046B72"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP70004970270000000000000000080DE.xhtml#P70004970270000000000000000080DE"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.2 </span>Concurrent Programming with I/O Multiplexing </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">977</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B73" id="P7000497027000000000000000046B73"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B74" id="P7000497027000000000000000046B74"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000817D.xhtml#P700049702700000000000000000817D"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3 </span>Concurrent Programming with Threads </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">985</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B75" id="P7000497027000000000000000046B75"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B76" id="P7000497027000000000000000046B76"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000821D.xhtml#P700049702700000000000000000821D"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.4 </span>Shared Variables in Threaded Programs </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">992</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B77" id="P7000497027000000000000000046B77"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B78" id="P7000497027000000000000000046B78"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000827E.xhtml#P700049702700000000000000000827E"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.5 </span>Synchronizing Threads with Semaphores </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">995</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B79" id="P7000497027000000000000000046B79"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B7A" id="P7000497027000000000000000046B7A"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000849B.xhtml#P700049702700000000000000000849B"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.6 </span>Using Threads for Parallelism </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1013</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter12.xhtml#P7000497027000000000000000046B7B" id="P7000497027000000000000000046B7B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B7C" id="P7000497027000000000000000046B7C"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008577.xhtml#P7000497027000000000000000008577"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.7 </span>Other Concurrency Issues </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1020</span></a></p></li>
</ol></div>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046B7D" id="P7000497027000000000000000046B7D">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B7E" id="P7000497027000000000000000046B7E">
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B7F" id="P7000497027000000000000000046B7F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B80" id="P7000497027000000000000000046B80"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008670.xhtml#P7000497027000000000000000008670"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.8 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary</span> </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1030</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B81" id="P7000497027000000000000000046B81"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B82" id="P7000497027000000000000000046B82"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008676.xhtml#P7000497027000000000000000008676"><span class="pcalibre1 pcalibre2" epub:type="title">Bibliographic Notes </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1030</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B83" id="P7000497027000000000000000046B83"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B84" id="P7000497027000000000000000046B84"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000867A"><span class="pcalibre1 pcalibre2" epub:type="title">Homework Problems </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1031</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter12.xhtml#P7000497027000000000000000046B85" id="P7000497027000000000000000046B85"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B86" id="P7000497027000000000000000046B86"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000875E.xhtml#P700049702700000000000000000875E"><span class="pcalibre1 pcalibre2" epub:type="title">Solutions to Practice Problems </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">1036</span></a></p></li>
</ol></div>
</nav>
<section class="pcalibre1 pcalibre2 pcalibre51" data-uri="chapter12.xhtml#P7000497027000000000000000046B87" epub:type="introduction" id="P7000497027000000000000000046B87">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B88" id="P7000497027000000000000000046B88"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008080" epub:type="pagebreak" id="P7000497027000000000000000008080" title="972"></span>As we learned in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">8</span></a>, logical control flows are <i class="pcalibre17 pcalibre2 pcalibre1">concurrent</i> if they overlap in time. This general phenomenon, known as <i class="pcalibre17 pcalibre2 pcalibre1">concurrency</i>, shows up at many different levels of a computer system. Hardware exception handlers, processes, and Linux signal handlers are all familiar examples.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B89" id="P7000497027000000000000000046B89">Thus far, we have treated concurrency mainly as a mechanism that the operating system kernel uses to run multiple application programs. But concurrency is not just limited to the kernel. It can play an important role in application programs as well. For example, we have seen how Linux signal handlers allow applications to respond to asynchronous events such as the user typing Ctrl+C or the program accessing an undefined area of virtual memory. Application-level concurrency is useful in other ways as well:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B8A" id="P7000497027000000000000000046B8A">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B8B" id="P7000497027000000000000000046B8B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B8C" id="P7000497027000000000000000046B8C"><span class="pcalibre1 pcalibre2 pcalibre41">Accessing slow I/O devices. </span>When an application is waiting for data to arrive from a slow I/O device such as a disk, the kernel keeps the CPU busy by running other processes. Individual applications can exploit concurrency in a similar way by overlapping useful work with I/O requests.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B8D" id="P7000497027000000000000000046B8D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B8E" id="P7000497027000000000000000046B8E"><span class="pcalibre1 pcalibre2 pcalibre41">Interacting with humans. </span>People who interact with computers demand the ability to perform multiple tasks at the same time. For example, they might want to resize a window while they are printing a document. Modern windowing systems use concurrency to provide this capability. Each time the user requests some action (say, by clicking the mouse), a separate concurrent logical flow is created to perform the action.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B8F" id="P7000497027000000000000000046B8F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B90" id="P7000497027000000000000000046B90"><span class="pcalibre1 pcalibre2 pcalibre41">Reducing latency by deferring work. </span>Sometimes, applications can use concurrency to reduce the latency of certain operations by deferring other operations and performing them concurrently. For example, a dynamic storage allocator might reduce the latency of individual free operations by deferring coalescing to a concurrent "coalescing" flow that runs at a lower priority, soaking up spare CPU cycles as they become available.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B91" id="P7000497027000000000000000046B91"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B92" id="P7000497027000000000000000046B92"><span class="pcalibre1 pcalibre2 pcalibre41">Servicing multiple network clients. </span>The iterative network servers that we studied in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007B7A.xhtml#P7000497027000000000000000007B7A"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">11</span></a> are unrealistic because they can only service one client at a time. Thus, a single slow client can deny service to every other client. For a real server that might be expected to service hundreds or thousands of clients per second, it is not acceptable to allow one slow client to deny service to the others. A better approach is to build a <i class="pcalibre17 pcalibre2 pcalibre1">concurrent server</i> that creates a separate logical flow for each client. This allows the server to service multiple clients concurrently and precludes slow clients from monopolizing the server.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B93" id="P7000497027000000000000000046B93"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B94" id="P7000497027000000000000000046B94"><span class="pcalibre1 pcalibre2 pcalibre41">Computing in parallel on multi-core machines. </span>Many modern systems are equipped with multi-core processors that contain multiple CPUs. Applications that are partitioned into concurrent flows often run faster on multi-core machines than on uniprocessor machines because the flows execute in parallel rather than being interleaved.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B95" id="P7000497027000000000000000046B95">Applications that use application-level concurrency are known as <i class="pcalibre17 pcalibre2 pcalibre1">concurrent programs</i>. Modern operating systems provide three basic approaches for building concurrent programs:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B96" id="P7000497027000000000000000046B96">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B97" id="P7000497027000000000000000046B97"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B98" id="P7000497027000000000000000046B98"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008091" epub:type="pagebreak" id="P7000497027000000000000000008091" title="973"></span><span class="pcalibre1 pcalibre2 pcalibre41">Processes. </span>With this approach, each logical control flow is a process that is scheduled and maintained by the kernel. Since processes have separate virtual address spaces, flows that want to communicate with each other must use some kind of explicit <i class="pcalibre17 pcalibre2 pcalibre1">interprocess communication (IPC)</i> mechanism.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B99" id="P7000497027000000000000000046B99"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B9A" id="P7000497027000000000000000046B9A"><span class="pcalibre1 pcalibre2 pcalibre41">I/O multiplexing. </span>his is a form of concurrent programming where applications explicitly schedule their own logical flows in the context of a single process. Logical flows are modeled as state machines that the main program explicitly transitions from state to state as a result of data arriving on file descriptors. Since the program is a single process, all flows share the same address space.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046B9B" id="P7000497027000000000000000046B9B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046B9C" id="P7000497027000000000000000046B9C"><span class="pcalibre1 pcalibre2 pcalibre41">Threads. </span>Threads are logical flows that run in the context of a single process and are scheduled by the kernel. You can think of threads as a hybrid of the other two approaches, scheduled by the kernel like process flows and sharing the same virtual address space like I/O multiplexing flows.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B9D" id="P7000497027000000000000000046B9D">This chapter investigates these three different concurrent programming techniques. To keep our discussion concrete, we will work with the same motivating application throughout—a concurrent version of the iterative echo server from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E4C"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.9</span></a>.</p>
</section>
</section>
<!--EOF:P7000497027000000000000000008097-->
<!--EOF:P70004970270000000000000000080DE-->
<!--EOF:P700049702700000000000000000817D-->
<!--EOF:P700049702700000000000000000821D-->
<!--EOF:P700049702700000000000000000827E-->
<!--EOF:P700049702700000000000000000849B-->
<!--EOF:P7000497027000000000000000008577-->
<!--EOF:P7000497027000000000000000008670-->
<!--EOF:P7000497027000000000000000008676-->
<!--EOF:P700049702700000000000000000867A-->
<!--EOF:P700049702700000000000000000875E-->
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Chapter 8 Exceptional Control Flow</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" epub:type="chapter" id="P700049702700000000000000000666E"><header class="pcalibre1 pcalibre2 pcalibre48"><h1 class="pcalibre1 pcalibre2 pcalibre49" data-uri="chapter08.xhtml#P7000497027000000000000000044E58" epub:type="title" id="P7000497027000000000000000044E58"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P7000497027000000000000000006670" epub:type="pagebreak" id="P7000497027000000000000000006670" title="721"></span><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre50 pcalibre2">8 </span>Exceptional Control Flow</h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" id="d9e141296">
<nav class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter08.xhtml#P7000497027000000000000000044E59" epub:type="toc" id="P7000497027000000000000000044E59">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044E5A" id="P7000497027000000000000000044E5A">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E5B" id="P7000497027000000000000000044E5B">
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E5C" id="P7000497027000000000000000044E5C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E5D" id="P7000497027000000000000000044E5D"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP70004970270000000000000000066A6.xhtml#P70004970270000000000000000066A6"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.1 </span>Exceptions 723</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E5E" id="P7000497027000000000000000044E5E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E5F" id="P7000497027000000000000000044E5F"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP70004970270000000000000000067D4.xhtml#P70004970270000000000000000067D4"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.2 </span>Processes 732</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E60" id="P7000497027000000000000000044E60"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E61" id="P7000497027000000000000000044E61"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000683E.xhtml#P700049702700000000000000000683E"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.3 </span>System Call Error Handling 737</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E62" id="P7000497027000000000000000044E62"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E63" id="P7000497027000000000000000044E63"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP700049702700000000000000000685D.xhtml#P700049702700000000000000000685D"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.4 </span>Process Control 738</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E64" id="P7000497027000000000000000044E64"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E65" id="P7000497027000000000000000044E65"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006A2D.xhtml#P7000497027000000000000000006A2D"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.5 </span>Signals 756</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E66" id="P7000497027000000000000000044E66"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E67" id="P7000497027000000000000000044E67"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006DFA.xhtml#P7000497027000000000000000006DFA"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.6 </span>Nonlocal Jumps 781</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter08.xhtml#P7000497027000000000000000044E68" id="P7000497027000000000000000044E68"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E69" id="P7000497027000000000000000044E69"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006E64.xhtml#P7000497027000000000000000006E64"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.7 </span>Tools for Manipulating Processes 786</span></a></p></li>
</ol>
</div>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter08.xhtml#P7000497027000000000000000044E6A" id="P7000497027000000000000000044E6A">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E6B" id="P7000497027000000000000000044E6B">
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter08.xhtml#P7000497027000000000000000044E6C" id="P7000497027000000000000000044E6C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E6D" id="P7000497027000000000000000044E6D"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006E75.xhtml#P7000497027000000000000000006E75"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.8 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary</span> 787</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter08.xhtml#P7000497027000000000000000044E6E" id="P7000497027000000000000000044E6E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E6F" id="P7000497027000000000000000044E6F"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006E7E.xhtml#P7000497027000000000000000006E7E"><span class="pcalibre1 pcalibre2" epub:type="title">Bibliographic Notes 787</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter08.xhtml#P7000497027000000000000000044E70" id="P7000497027000000000000000044E70"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E71" id="P7000497027000000000000000044E71"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006E81.xhtml#P7000497027000000000000000006E81"><span class="pcalibre1 pcalibre2" epub:type="title">Homework Problems 788</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter08.xhtml#P7000497027000000000000000044E72" id="P7000497027000000000000000044E72"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E73" id="P7000497027000000000000000044E73"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006F9A"><span class="pcalibre1 pcalibre2" epub:type="title">Solutions to Practice Problems 795</span></a></p></li>
</ol>
</div>
</nav>
<section class="pcalibre1 pcalibre2 pcalibre51" data-uri="chapter08.xhtml#P7000497027000000000000000044E74" epub:type="introduction" id="P7000497027000000000000000044E74">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E75" id="P7000497027000000000000000044E75"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000668E" epub:type="pagebreak" id="P700049702700000000000000000668E" title="722"></span>From the time you first apply power to a processor until the time you shut it off, the program counter assumes a sequence of values</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter08.xhtml#P7000497027000000000000000044E76" id="P7000497027000000000000000044E76">
<m:math altimg="../images/ch08-eq1.png" altimg-height="15" altimg-width="140" alttext="" data-uri="" display="block"><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mn>...</m:mn><m:mo>,</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E77" id="P7000497027000000000000000044E77">where each <i class="pcalibre17 pcalibre2 pcalibre1">a<sub class="pcalibre1 pcalibre2 pcalibre241">k</sub></i> is the address of some corresponding instruction <i class="pcalibre17 pcalibre2 pcalibre1">I<sub class="pcalibre1 pcalibre2 pcalibre241">k</sub></i>. Each transition from <i class="pcalibre17 pcalibre2 pcalibre1">a<sub class="pcalibre1 pcalibre2 pcalibre241">k</sub></i> to <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 pcalibre241"><var class="pcalibre17 pcalibre2 pcalibre1">k</var>+1</sub> is called a <i class="pcalibre17 pcalibre2 pcalibre1">control transfer</i>. A sequence of such control transfers is called the <i class="pcalibre17 pcalibre2 pcalibre1">flow of control</i>, or <i class="pcalibre17 pcalibre2 pcalibre1">control flow</i>, of the processor.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E78" id="P7000497027000000000000000044E78">The simplest kind of control flow is a “smooth” sequence where each <var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 pcalibre241"><var class="pcalibre17 pcalibre2 pcalibre1">k</var></sub> and <var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 pcalibre241"><var class="pcalibre17 pcalibre2 pcalibre1">k</var>+1</sub> are adjacent in memory. Typically, abrupt changes to this smooth flow, where <var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 pcalibre241"><var class="pcalibre17 pcalibre2 pcalibre1">k</var>+1</sub> is not adjacent to <i class="pcalibre17 pcalibre2 pcalibre1">I<sub class="pcalibre1 pcalibre2 pcalibre241">k</sub></i>, are caused by familiar program instructions such as jumps, calls, and returns. Such instructions are necessary mechanisms that allow programs to react to changes in internal program state represented by program variables.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E79" id="P7000497027000000000000000044E79">But systems must also be able to react to changes in system state that are not captured by internal program variables and are not necessarily related to the execution of the program. For example, a hardware timer goes off at regular intervals and must be dealt with. Packets arrive at the network adapter and must be stored in memory. Programs request data from a disk and then sleep until they are notified that the data are ready. Parent processes that create child processes must be notified when their children terminate.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E7A" id="P7000497027000000000000000044E7A">Modern systems react to these situations by making abrupt changes in the control flow. In general, we refer to these abrupt changes as <i class="pcalibre17 pcalibre2 pcalibre1">exceptional control flow (ECF</i>). ECF occurs at all levels of a computer system. For example, at the hardware level, events detected by the hardware trigger abrupt control transfers to exception handlers. At the operating systems level, the kernel transfers control from one user process to another via context switches. At the application level, a process can send a <i class="pcalibre17 pcalibre2 pcalibre1">signal</i> to another process that abruptly transfers control to a signal handler in the recipient. An individual program can react to errors by sidestepping the usual stack discipline and making nonlocal jumps to arbitrary locations in other functions.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E7B" id="P7000497027000000000000000044E7B">As programmers, there are a number of reasons why it is important for you to understand ECF:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E7C" id="P7000497027000000000000000044E7C">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E7D" id="P7000497027000000000000000044E7D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E7E" id="P7000497027000000000000000044E7E"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding ECF will help you understand important systems concepts. </span>ECF is the basic mechanism that operating systems use to implement I/O, processes, and virtual memory. Before you can really understand these important ideas, you need to understand ECF.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E7F" id="P7000497027000000000000000044E7F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E80" id="P7000497027000000000000000044E80"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding ECF will help you understand how applications interact with the operating system. </span>Applications request services from the operating system by using a form of ECF known as a <i class="pcalibre17 pcalibre2 pcalibre1">trap</i> or <i class="pcalibre17 pcalibre2 pcalibre1">system call</i>. For example, writing data to a disk, reading data from a network, creating a new process, and terminating the current process are all accomplished by application programs invoking system calls. Understanding the basic system call mechanism will help you understand how these services are provided to applications.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E81" id="P7000497027000000000000000044E81"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E82" id="P7000497027000000000000000044E82"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding ECF will help you write interesting new application programs. </span>The operating system provides application programs with powerful ECF <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter08.xhtml#P700049702700000000000000000669C" epub:type="pagebreak" id="P700049702700000000000000000669C" title="723"></span>mechanisms for creating new processes, waiting for processes to terminate, notifying other processes of exceptional events in the system, and detecting and responding to these events. If you understand these ECF mechanisms, then you can use them to write interesting programs such as Unix shells and Web servers.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E83" id="P7000497027000000000000000044E83"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E84" id="P7000497027000000000000000044E84"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding ECF will help you understand concurrency. </span>ECF is a basic mechanism for implementing concurrency in computer systems. The following are all examples of concurrency in action: an exception handler that interrupts the execution of an application program; processes and threads whose execution overlap in time; and a signal handler that interrupts the execution of an application program. Understanding ECF is a first step to understanding concurrency. We will return to study it in more detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">12</span></a>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter08.xhtml#P7000497027000000000000000044E85" id="P7000497027000000000000000044E85"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter08.xhtml#P7000497027000000000000000044E86" id="P7000497027000000000000000044E86"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding ECF will help you understand how software exceptions work. </span>Languages such as C++ and Java provide software exception mechanisms via <code class="pcalibre52 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E87" id="P7000497027000000000000000044E87">try, catch</code>, and <code class="pcalibre52 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E88" id="P7000497027000000000000000044E88">throw</code> statements. Software exceptions allow the program to make <i class="pcalibre17 pcalibre2 pcalibre1">nonlocal</i> jumps (i.e., jumps that violate the usual call/return stack discipline) in response to error conditions. Nonlocal jumps are a form of application-level ECF and are provided in C via the <code class="pcalibre52 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E89" id="P7000497027000000000000000044E89">setjmp</code> and <code class="pcalibre52 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E8A" id="P7000497027000000000000000044E8A">longjmp</code> functions. Understanding these low-level functions will help you understand how higher-level software exceptions can be implemented.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter08.xhtml#P7000497027000000000000000044E8B" id="P7000497027000000000000000044E8B">Up to this point in your study of systems, you have learned how applications interact with the hardware. This chapter is pivotal in the sense that you will begin to learn how your applications interact with the operating system. Interestingly, these interactions all revolve around ECF. We describe the various forms of ECF that exist at all levels of a computer system. We start with exceptions, which lie at the intersection of the hardware and the operating system. We also discuss system calls, which are exceptions that provide applications with entry points into the operating system. We then move up a level of abstraction and describe processes and signals, which lie at the intersection of applications and the operating system. Finally, we discuss nonlocal jumps, which are an application-level form of ECF.</p>
</section>
</section>
<!--EOF:P70004970270000000000000000066A6-->
<!--EOF:P70004970270000000000000000067D4-->
<!--EOF:P700049702700000000000000000683E-->
<!--EOF:P700049702700000000000000000685D-->
<!--EOF:P7000497027000000000000000006A2D-->
<!--EOF:P7000497027000000000000000006DFA-->
<!--EOF:P7000497027000000000000000006E64-->
<!--EOF:P7000497027000000000000000006E75-->
<!--EOF:P7000497027000000000000000006E7E-->
<!--EOF:P7000497027000000000000000006E81-->
<!--EOF:P7000497027000000000000000006F9A-->
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Chapter 11 Network Programming</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" epub:type="chapter" id="P7000497027000000000000000007B7A"><header class="pcalibre1 pcalibre2 pcalibre48"><h1 class="pcalibre1 pcalibre2 pcalibre49" data-uri="chapter11.xhtml#P7000497027000000000000000046683" epub:type="title" id="P7000497027000000000000000046683"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007B7C" epub:type="pagebreak" id="P7000497027000000000000000007B7C" title="917"></span><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre50 pcalibre2">11 </span>Network Programming</h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" id="d9e166589">
<nav class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000046684" epub:type="toc" id="P7000497027000000000000000046684">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter11.xhtml#P7000497027000000000000000046685" id="P7000497027000000000000000046685">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046686" id="P7000497027000000000000000046686">
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter11.xhtml#P7000497027000000000000000046687" id="P7000497027000000000000000046687"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046688" id="P7000497027000000000000000046688"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000007B9A.xhtml#P7000497027000000000000000007B9A"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.1 </span>The Client-Server Programming Model </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">918</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter11.xhtml#P7000497027000000000000000046689" id="P7000497027000000000000000046689"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004668A" id="P700049702700000000000000004668A"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000007BB0.xhtml#P7000497027000000000000000007BB0"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.2 </span>Networks </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">919</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter11.xhtml#P700049702700000000000000004668B" id="P700049702700000000000000004668B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004668C" id="P700049702700000000000000004668C"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000007BFE.xhtml#P7000497027000000000000000007BFE"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.3 </span>The Global IP Internet </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">924</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter11.xhtml#P700049702700000000000000004668D" id="P700049702700000000000000004668D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004668E" id="P700049702700000000000000004668E"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007CC1"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4 </span>The Sockets Interface </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">932</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter11.xhtml#P700049702700000000000000004668F" id="P700049702700000000000000004668F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046690" id="P7000497027000000000000000046690"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000007E82.xhtml#P7000497027000000000000000007E82"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.5 </span>Web Servers </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">948</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-class="toclevel1" data-uri="chapter11.xhtml#P7000497027000000000000000046691" id="P7000497027000000000000000046691"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046692" id="P7000497027000000000000000046692"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000007F64.xhtml#P7000497027000000000000000007F64"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.6 </span>Putting It Together: The Tiny Web Server </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">956</span></a></p></li>
</ol></div>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter11.xhtml#P7000497027000000000000000046693" id="P7000497027000000000000000046693">
<ol class="pcalibre23 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046694" id="P7000497027000000000000000046694">
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter11.xhtml#P7000497027000000000000000046695" id="P7000497027000000000000000046695"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046696" id="P7000497027000000000000000046696"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000007FE5.xhtml#P7000497027000000000000000007FE5"><span class="pcalibre1 pcalibre2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.7 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary</span> </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">964</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter11.xhtml#P7000497027000000000000000046697" id="P7000497027000000000000000046697"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046698" id="P7000497027000000000000000046698"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000007FEC.xhtml#P7000497027000000000000000007FEC"><span class="pcalibre1 pcalibre2" epub:type="title">Bibliographic Notes </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">965</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter11.xhtml#P7000497027000000000000000046699" id="P7000497027000000000000000046699"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004669A" id="P700049702700000000000000004669A"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000007FF4.xhtml#P7000497027000000000000000007FF4"><span class="pcalibre1 pcalibre2" epub:type="title">Homework Problems </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">965</span></a></p></li>
<li class="pcalibre1 pcalibre2 pcalibre24" data-uri="chapter11.xhtml#P700049702700000000000000004669B" id="P700049702700000000000000004669B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004669C" id="P700049702700000000000000004669C"><a class="pcalibre1 pcalibre2 pcalibre25 pcalibre16 pcalibre14 pcalibre15" href="fileP7000497027000000000000000008021.xhtml#P7000497027000000000000000008021"><span class="pcalibre1 pcalibre2" epub:type="title">Solutions to Practice Problems </span><span class="pcalibre1 pcalibre2" epub:type="pagebreak">966</span></a></p></li>
</ol></div>
</nav>
<section class="pcalibre1 pcalibre2 pcalibre51" data-uri="chapter11.xhtml#P700049702700000000000000004669D" epub:type="introduction" id="P700049702700000000000000004669D">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004669E" id="P700049702700000000000000004669E"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007B98" epub:type="pagebreak" id="P7000497027000000000000000007B98" title="918"></span>Network applications are everywhere. Any time you browse the Web, send an email message, or play an online game, you are using a network application. Interestingly, all network applications are based on the same basic programming model, have similar overall logical structures, and rely on the same programming interface.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004669F" id="P700049702700000000000000004669F">Network applications rely on many of the concepts that you have already learned in our study of systems. For example, processes, signals, byte ordering, memory mapping, and dynamic storage allocation all play important roles. There are new concepts to master as well. You will need to understand the basic client-server programming model and how to write client-server programs that use the services provided by the Internet. At the end, we will tie all of these ideas together by developing a tiny but functional Web server that can serve both static and dynamic content with text and graphics to real Web browsers.</p>
</section>
</section>
<!--EOF:P7000497027000000000000000007B9A-->
<!--EOF:P7000497027000000000000000007BB0-->
<!--EOF:P7000497027000000000000000007BFE-->
<!--EOF:P7000497027000000000000000007CC1-->
<!--EOF:P7000497027000000000000000007E82-->
<!--EOF:P7000497027000000000000000007F64-->
<!--EOF:P7000497027000000000000000007FE5-->
<!--EOF:P7000497027000000000000000007FEC-->
<!--EOF:P7000497027000000000000000007FF4-->
<!--EOF:P7000497027000000000000000008021-->
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>11.4 The Sockets Interface</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000007CC1"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter11.xhtml#P70004970270000000000000000467FF" epub:type="title" id="P70004970270000000000000000467FF"><span class="pcalibre1 pcalibre21 pcalibre2">11.4 </span>The Sockets Interface</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046800" id="P7000497027000000000000000046800">The <i class="pcalibre17 pcalibre2 pcalibre1">sockets interface</i> is a set of functions that are used in conjunction with the Unix I/O functions to build network applications. It has been implemented on most modern systems, including all Unix variants as well as Windows and Macintosh systems. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007CC4"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.12</span></a> gives an overview of the sockets interface in the context of a typical client-server transaction. You should use this picture as a road map when we discuss the individual functions.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007CC4" id="P7000497027000000000000000007CC4">
<img alt="A diagram illustrates network applications based on the sockets interface." class="pcalibre1 pcalibre2 pcalibre306" data-uri="P700049702700000000000000000B7C5" id="P7000497027000000000000000046801" src="Images/chapter-10-image-11.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P7000497027000000000000000046802" id="P7000497027000000000000000046802"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P7000497027000000000000000046803" epub:type="title" id="P7000497027000000000000000046803"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">11.12 </span>Overview of network applications based on the sockets interface.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter11.xhtml#P7000497027000000000000000026B70" id="P7000497027000000000000000026B70">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046804" id="P7000497027000000000000000046804">A diagram shows a flow of connections under client and server, with the components summarized below.</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter11.xhtml#P7000497027000000000000000046805" id="P7000497027000000000000000046805">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046806" id="P7000497027000000000000000046806"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046807" id="P7000497027000000000000000046807">Client</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter11.xhtml#P7000497027000000000000000046808" id="P7000497027000000000000000046808">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046809" id="P7000497027000000000000000046809"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004680A" id="P700049702700000000000000004680A">Open_clientfd, including:</p>
<ul class="pcalibre146 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004680B" id="P700049702700000000000000004680B">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004680C" id="P700049702700000000000000004680C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004680D" id="P700049702700000000000000004680D">Getaddrinfo</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004680E" id="P700049702700000000000000004680E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004680F" id="P700049702700000000000000004680F">Socket</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046810" id="P7000497027000000000000000046810"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046811" id="P7000497027000000000000000046811">Connect (connection request to accept under server)</p></li>
</ul></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046812" id="P7000497027000000000000000046812"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046813" id="P7000497027000000000000000046813">Rio_writen (to rio_readlineb under server)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046814" id="P7000497027000000000000000046814"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046815" id="P7000497027000000000000000046815">Rio_readlineb (from rio_writen under server)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046816" id="P7000497027000000000000000046816"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046817" id="P7000497027000000000000000046817">Close (EOF to rio_readlineb)</p></li>
</ul></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046818" id="P7000497027000000000000000046818"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046819" id="P7000497027000000000000000046819">Server:</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter11.xhtml#P700049702700000000000000004681A" id="P700049702700000000000000004681A">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004681B" id="P700049702700000000000000004681B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004681C" id="P700049702700000000000000004681C">Open_listenfd, including:</p>
<ul class="pcalibre146 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004681D" id="P700049702700000000000000004681D">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004681E" id="P700049702700000000000000004681E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004681F" id="P700049702700000000000000004681F">Getaddrinfo</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046820" id="P7000497027000000000000000046820"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046821" id="P7000497027000000000000000046821">Socket</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046822" id="P7000497027000000000000000046822"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046823" id="P7000497027000000000000000046823">Bind</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046824" id="P7000497027000000000000000046824"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046825" id="P7000497027000000000000000046825">Listen</p></li>
</ul></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046826" id="P7000497027000000000000000046826"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046827" id="P7000497027000000000000000046827">Accept (connection request from connect under Client and await connection request from next client from close below)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046828" id="P7000497027000000000000000046828"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046829" id="P7000497027000000000000000046829">Rio_readlineb (from rio_writen under client)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004682A" id="P700049702700000000000000004682A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004682B" id="P700049702700000000000000004682B">Rio_writen (to rio_readlineb under client)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004682C" id="P700049702700000000000000004682C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004682D" id="P700049702700000000000000004682D">Rio_readlineb (EOF from close under client)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004682E" id="P700049702700000000000000004682E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004682F" id="P700049702700000000000000004682F">Close (await connection request from next client to accept)</p></li>
</ul></li>
</ul>
</details>
</figcaption>
</figure>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000007CC8" id="P7000497027000000000000000007CC8"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter11.xhtml#P7000497027000000000000000046830" epub:type="title" id="P7000497027000000000000000046830"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007CCA" epub:type="pagebreak" id="P7000497027000000000000000007CCA" title="933"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>What does the <code class="pcalibre1 pcalibre2 calibre16" data-uri="chapter11.xhtml#P7000497027000000000000000046831" id="P7000497027000000000000000046831">_in</code> suffix mean?</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046832" id="P7000497027000000000000000046832">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046833" id="P7000497027000000000000000046833">_in</code> suffix is short for <i class="pcalibre17 pcalibre2 pcalibre1">internet</i>, not <i class="pcalibre17 pcalibre2 pcalibre1">input</i>.</p>
</aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007CCE" id="P7000497027000000000000000007CCE">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046834" id="P7000497027000000000000000046834"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046835" id="P7000497027000000000000000046835">
/* IP socket address structure */
struct sockaddr_in {
  uint16_t	sin_family;	/* Protocol family (always AF_INET) */
  uint16_t	sin_port;	/* Port number in network byte order */
  struct in_addr	sin_addr;	/* IP address in network byte order */
  unsigned char	sin_zero[8];	/* Pad to sizeof(struct sockaddr) */
};
/* Generic socket address structure (for connect, bind, and accept) */ struct sockaddr {
  uint16_t	sa_family;	/* Protocol family */
  char		sa_data[14];	/* Address data */
};
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P7000497027000000000000000046836" id="P7000497027000000000000000046836"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P7000497027000000000000000046837" epub:type="title" id="P7000497027000000000000000046837"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">11.13 </span>Socket address structures.</h1></header>
</figcaption>
</figure>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007CD3" id="P7000497027000000000000000007CD3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046838" epub:type="title" id="P7000497027000000000000000046838"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.1 </span>Socket Address Structures</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046839" id="P7000497027000000000000000046839">From the perspective of the Linux kernel, a socket is an end point for communication. From the perspective of a Linux program, a socket is an open file with a corresponding descriptor.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004683A" id="P700049702700000000000000004683A">Internet socket addresses are stored in 16-byte structures having the type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004683B" id="P700049702700000000000000004683B">sockaddr_in</code>, shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007CCE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.13</span></a>. For Internet applications, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004683C" id="P700049702700000000000000004683C">sin_family</code> field is AF_INET, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004683D" id="P700049702700000000000000004683D">sin_port</code> field is a 16-bit port number, and the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004683E" id="P700049702700000000000000004683E">sin_addr</code> field contains a 32-bit IP address. The IP address and port number are always stored in network (big-endian) byte order.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004683F" id="P700049702700000000000000004683F">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046840" id="P7000497027000000000000000046840">connect, bind</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046841" id="P7000497027000000000000000046841">accept</code> functions require a pointer to a protocol-specific socket address structure. The problem faced by the designers of the sockets interface was how to define these functions to accept any kind of socket address structure. Today, we would use the generic <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046842" id="P7000497027000000000000000046842">void</code> * pointer, which did not exist in C at that time. Their solution was to define sockets functions to expect a pointer to a generic <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046843" id="P7000497027000000000000000046843">sockaddr</code> structure (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007CCE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.13</span></a>) and then require applications to cast any pointers to protocol-specific structures to this generic structure. To simplify our code examples, we follow Stevens's lead and define the following type:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046844" id="P7000497027000000000000000046844"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046845" id="P7000497027000000000000000046845">typedef struct sockaddr SA;</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046846" id="P7000497027000000000000000046846"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007CE3" epub:type="pagebreak" id="P7000497027000000000000000007CE3" title="934"></span>We then use this type whenever we need to cast a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046847" id="P7000497027000000000000000046847">sockaddr_in</code> structure to a generic <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046848" id="P7000497027000000000000000046848">sockaddr</code> structure.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007CE6" id="P7000497027000000000000000007CE6"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046849" epub:type="title" id="P7000497027000000000000000046849"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.2 </span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004684A" id="P700049702700000000000000004684A">socket</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004684B" id="P700049702700000000000000004684B">Clients and servers use the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004684C" id="P700049702700000000000000004684C">socket</code> function to create a <i class="pcalibre17 pcalibre2 pcalibre1">socket descriptor</i>.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004684D" id="P700049702700000000000000004684D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004684E" id="P700049702700000000000000004684E">
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);
				Returns: nonnegative descriptor if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004684F" id="P700049702700000000000000004684F">If we wanted the socket to be the end point for a connection, then we could call socket with the following hardcoded arguments:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046850" id="P7000497027000000000000000046850"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046851" id="P7000497027000000000000000046851">clientfd = Socket(AF_INET, SOCK_STREAM, 0);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046852" id="P7000497027000000000000000046852">where AF_INET indicates that we are using 32-bit IP addresses and SOCK_STREAM indicates that the socket will be an end point for a connection. However, the best practice is to use the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046853" id="P7000497027000000000000000046853">getaddrinfo</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007D50"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.7</span></a>) to generate these parameters automatically, so that the code is protocol-independent. We will show you how to use <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046854" id="P7000497027000000000000000046854">getaddrinfo</code> with the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046855" id="P7000497027000000000000000046855">socket</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E0B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.8</span></a>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046856" id="P7000497027000000000000000046856">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046857" id="P7000497027000000000000000046857">clientfd</code> descriptor returned by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046858" id="P7000497027000000000000000046858">socket</code> is only partially opened and cannot yet be used for reading and writing. How we finish opening the socket depends on whether we are a client or a server. The next section describes how we finish opening the socket if we are a client.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007CF7" id="P7000497027000000000000000007CF7"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046859" epub:type="title" id="P7000497027000000000000000046859"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.3 </span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004685A" id="P700049702700000000000000004685A">connect</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004685B" id="P700049702700000000000000004685B">A client establishes a connection with a server by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004685C" id="P700049702700000000000000004685C">connect</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004685D" id="P700049702700000000000000004685D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004685E" id="P700049702700000000000000004685E">
#include &lt;sys/socket.h&gt;
int connect(int clientfd, const struct sockaddr *addr,
			socklen_t addrlen);
							Returns: 0 if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004685F" id="P700049702700000000000000004685F">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046860" id="P7000497027000000000000000046860">connect</code> function attempts to establish an Internet connection with the server at socket address <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046861" id="P7000497027000000000000000046861">addr</code>, where <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046862" id="P7000497027000000000000000046862">addrlen</code> is <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046863" id="P7000497027000000000000000046863">sizeof(sockaddr_in)</code>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046864" id="P7000497027000000000000000046864">connect</code> function blocks until either the connection is successfully established or an error occurs. If successful, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046865" id="P7000497027000000000000000046865">clientfd</code> descriptor is now ready for reading and writing, and the resulting connection is characterized by the socket pair</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046866" id="P7000497027000000000000000046866"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046867" id="P7000497027000000000000000046867">(x:y, addr.sin_addr:addr.sin_port)</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046868" id="P7000497027000000000000000046868"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007D08" epub:type="pagebreak" id="P7000497027000000000000000007D08" title="935"></span>where <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046869" id="P7000497027000000000000000046869">x</code> is the client's IP address and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004686A" id="P700049702700000000000000004686A">y</code> is the ephemeral port that uniquely identifies the client process on the client host. As with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004686B" id="P700049702700000000000000004686B">socket</code>, the best practice is to use <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004686C" id="P700049702700000000000000004686C">getaddrinfo</code> to supply the arguments to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004686D" id="P700049702700000000000000004686D">connect</code> (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E0B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.8</span></a>).</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007D0E" id="P7000497027000000000000000007D0E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004686E" epub:type="title" id="P700049702700000000000000004686E"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.4 </span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004686F" id="P700049702700000000000000004686F">bind</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046870" id="P7000497027000000000000000046870">The remaining sockets functions—<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046871" id="P7000497027000000000000000046871">bind, listen</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046872" id="P7000497027000000000000000046872">accept</code>—are used by servers to establish connections with clients.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046873" id="P7000497027000000000000000046873"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046874" id="P7000497027000000000000000046874">
#include &lt;sys/socket.h&gt;
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
				Returns: 0 if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046875" id="P7000497027000000000000000046875">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046876" id="P7000497027000000000000000046876">bind</code> function asks the kernel to associate the server's socket address in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046877" id="P7000497027000000000000000046877">addr</code> with the socket descriptor <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046878" id="P7000497027000000000000000046878">sockfd</code>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046879" id="P7000497027000000000000000046879">addrlen</code> argument is <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004687A" id="P700049702700000000000000004687A">sizeof(sockaddr_in)</code>. As with <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004687B" id="P700049702700000000000000004687B">socket</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004687C" id="P700049702700000000000000004687C">connect</code>, the best practice is to use <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004687D" id="P700049702700000000000000004687D">getaddrinfo</code> to supply the arguments to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004687E" id="P700049702700000000000000004687E">bind</code> (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E0B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.8</span></a>).</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007D20" id="P7000497027000000000000000007D20"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004687F" epub:type="title" id="P700049702700000000000000004687F"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.5 </span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046880" id="P7000497027000000000000000046880">listen</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046881" id="P7000497027000000000000000046881">Clients are active entities that initiate connection requests. Servers are passive entities that wait for connection requests from clients. By default, the kernel assumes that a descriptor created by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046882" id="P7000497027000000000000000046882">socket</code> function corresponds to an <i class="pcalibre17 pcalibre2 pcalibre1">active socket</i> that will live on the client end of a connection. A server calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046883" id="P7000497027000000000000000046883">listen</code> function to tell the kernel that the descriptor will be used by a server instead of a client.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046884" id="P7000497027000000000000000046884"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046885" id="P7000497027000000000000000046885">
#include &lt;sys/socket.h&gt;
int listen(int sockfd, int backlog);
				Returns: 0 if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046886" id="P7000497027000000000000000046886">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046887" id="P7000497027000000000000000046887">listen</code> function converts <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046888" id="P7000497027000000000000000046888">sockfd</code> from an active socket to a <i class="pcalibre17 pcalibre2 pcalibre1">listening socket</i> that can accept connection requests from clients. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046889" id="P7000497027000000000000000046889">backlog</code> argument is a hint about the number of outstanding connection requests that the kernel should queue up before it starts to refuse requests. The exact meaning of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004688A" id="P700049702700000000000000004688A">backlog</code> argument requires an understanding of TCP/IP that is beyond our scope. We will typically set it to a large value, such as 1,024.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007D2D" id="P7000497027000000000000000007D2D">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007D2E" epub:type="pagebreak" id="P7000497027000000000000000007D2E" title="936"></span>
<img alt="A diagram illustrates three roles of the listening and connected descriptors." class="pcalibre1 pcalibre2 calibre85" data-uri="P700049702700000000000000000B7C6" id="P700049702700000000000000004688B" src="Images/chapter-10-image-12.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P700049702700000000000000004688C" id="P700049702700000000000000004688C"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P700049702700000000000000004688D" epub:type="title" id="P700049702700000000000000004688D"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">11.14 </span>The roles of the listening and connected descriptors.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter11.xhtml#P7000497027000000000000000026BFB" id="P7000497027000000000000000026BFB">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004688E" id="P700049702700000000000000004688E">The three steps are summarized below.</p>
<ol class="pcalibre75 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004688F" id="P700049702700000000000000004688F">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046890" id="P7000497027000000000000000046890"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046891" id="P7000497027000000000000000046891">Server blocks in accept, waiting for connection request on listening descriptor listenfd (Client shown with clientfd and server with listenfd(3))</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046892" id="P7000497027000000000000000046892"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046893" id="P7000497027000000000000000046893">Client makes connection request by calling and blocking in connect. (Connection request from client to listen(3) on server)</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046894" id="P7000497027000000000000000046894"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046895" id="P7000497027000000000000000046895">Server returns connfd from accept. Client returns from connect. Connection is now established between clientfd and connfd. (Connection between clientfd and connfd(4) on server)</p></li>
</ol>
</details>
</figcaption>
</figure>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007D32" id="P7000497027000000000000000007D32"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046896" epub:type="title" id="P7000497027000000000000000046896"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.6 </span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046897" id="P7000497027000000000000000046897">accept</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046898" id="P7000497027000000000000000046898">Servers wait for connection requests from clients by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046899" id="P7000497027000000000000000046899">accept</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004689A" id="P700049702700000000000000004689A"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004689B" id="P700049702700000000000000004689B">
#include &lt;sys/socket.h&gt;
int accept(int listenfd, struct sockaddr *addr, int *addrlen);
				Returns: nonnegative connected descriptor if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004689C" id="P700049702700000000000000004689C">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004689D" id="P700049702700000000000000004689D">accept</code> function waits for a connection request from a client to arrive on the listening descriptor <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004689E" id="P700049702700000000000000004689E">listenfd</code>, then fills in the client's socket address in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004689F" id="P700049702700000000000000004689F">addr</code>, and returns a <i class="pcalibre17 pcalibre2 pcalibre1">connected descriptor</i> that can be used to communicate with the client using Unix I/O functions.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468A0" id="P70004970270000000000000000468A0">The distinction between a listening descriptor and a connected descriptor confuses many students. The listening descriptor serves as an end point for client connection requests. It is typically created once and exists for the lifetime of the server. The connected descriptor is the end point of the connection that is established between the client and the server. It is created each time the server accepts a connection request and exists only as long as it takes the server to service a client.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468A1" id="P70004970270000000000000000468A1"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007D2D"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.14</span></a> outlines the roles of the listening and connected descriptors. In step 1, the server calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468A2" id="P70004970270000000000000000468A2">accept</code>, which waits for a connection request to arrive on the listening descriptor, which for concreteness we will assume is descriptor 3. Recall that descriptors 0−2 are reserved for the standard files.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468A3" id="P70004970270000000000000000468A3">In step 2, the client calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468A4" id="P70004970270000000000000000468A4">connect</code> function, which sends a connection request to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468A5" id="P70004970270000000000000000468A5">listenfd</code>. In step 3, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468A6" id="P70004970270000000000000000468A6">accept</code> function opens a new connected descriptor <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468A7" id="P70004970270000000000000000468A7">connfd</code> (which we will assume is descriptor 4), establishes the connection between <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468A8" id="P70004970270000000000000000468A8">clientfd</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468A9" id="P70004970270000000000000000468A9">connfd</code>, and then returns <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468AA" id="P70004970270000000000000000468AA">connfd</code> to the application. The</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000007D48" id="P7000497027000000000000000007D48"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter11.xhtml#P70004970270000000000000000468AB" epub:type="title" id="P70004970270000000000000000468AB"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007D4A" epub:type="pagebreak" id="P7000497027000000000000000007D4A" title="937"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Why the distinction between listening and connected descriptors?</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468AC" id="P70004970270000000000000000468AC">You might wonder why the sockets interface makes a distinction between listening and connected descriptors. At first glance, it appears to be an unnecessary complication. However, distinguishing between the two turns out to be quite useful, because it allows us to build concurrent servers that can process many client connections simultaneously. For example, each time a connection request arrives on the listening descriptor, we might fork a new process that communicates with the client over its connected descriptor. You'll learn more about concurrent servers in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">12</span></a>.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468AD" id="P70004970270000000000000000468AD">client also returns from the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468AE" id="P70004970270000000000000000468AE">connect</code>, and from this point, the client and server can pass data back and forth by reading and writing <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468AF" id="P70004970270000000000000000468AF">clientfd</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468B0" id="P70004970270000000000000000468B0">connfd</code>, respectively.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007D50" id="P7000497027000000000000000007D50"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468B1" epub:type="title" id="P70004970270000000000000000468B1"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.7 </span>Host and Service Conversion</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468B2" id="P70004970270000000000000000468B2">Linux provides some powerful functions, called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468B3" id="P70004970270000000000000000468B3">getaddrinfo</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468B4" id="P70004970270000000000000000468B4">getnameinfo</code>, for converting back and forth between binary socket address structures and the string representations of hostnames, host addresses, service names, and port numbers. When used in conjunction with the sockets interface, they allow us to write network programs that are independent of any particular version of the IP protocol.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007D55" id="P7000497027000000000000000007D55"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468B5" epub:type="title" id="P70004970270000000000000000468B5">The <code class="pcalibre1 pcalibre2 calibre16" data-uri="chapter11.xhtml#P70004970270000000000000000468B6" id="P70004970270000000000000000468B6">getaddrinfo</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468B7" id="P70004970270000000000000000468B7">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468B8" id="P70004970270000000000000000468B8">getaddrinfo</code> function converts string representations of hostnames, host addresses, service names, and port numbers into socket address structures. It is the modern replacement for the obsolete <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468B9" id="P70004970270000000000000000468B9">gethostbyname</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468BA" id="P70004970270000000000000000468BA">getservbyname</code> functions. Unlike these functions, it is reentrant (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008577.xhtml#P70004970270000000000000000085BA"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7.2</span></a>) and works with any protocol.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468BB" id="P70004970270000000000000000468BB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468BC" id="P70004970270000000000000000468BC">
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
int getaddrinfo(const char *host, const char *service,
			const struct addrinfo *hints,
			struct addrinfo **result);
					Returns: 0 if OK, nonzero error code on error
void freeaddrinfo(struct addrinfo *result);
				Returns: nothing
const char *gai_strerror(int errcode);
				Returns: error message
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007D5E" id="P7000497027000000000000000007D5E">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007D5F" epub:type="pagebreak" id="P7000497027000000000000000007D5F" title="938"></span>
<img alt="A diagram shows lists of data structure returned by getaddrinfo." class="pcalibre1 pcalibre2 calibre86" data-uri="P700049702700000000000000000B7C7" id="P70004970270000000000000000468BD" src="Images/chapter-10-image-13.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P70004970270000000000000000468BE" id="P70004970270000000000000000468BE"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P70004970270000000000000000468BF" epub:type="title" id="P70004970270000000000000000468BF"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.15 </span>Data structure returned by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468C0" id="P70004970270000000000000000468C0">getaddrinfo</code>.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter11.xhtml#P7000497027000000000000000026C2F" id="P7000497027000000000000000026C2F">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468C1" id="P70004970270000000000000000468C1">A diagram shows a result leading to a list of addrinfo structs, leading to others as follows:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter11.xhtml#P70004970270000000000000000468C2" id="P70004970270000000000000000468C2">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468C3" id="P70004970270000000000000000468C3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468C4" id="P70004970270000000000000000468C4">Ai_canonname, to cell under result</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468C5" id="P70004970270000000000000000468C5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468C6" id="P70004970270000000000000000468C6">Ai_addr, to socket address struct</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468C7" id="P70004970270000000000000000468C7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468C8" id="P70004970270000000000000000468C8">Ai_next, to next list:</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter11.xhtml#P70004970270000000000000000468C9" id="P70004970270000000000000000468C9">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468CA" id="P70004970270000000000000000468CA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468CB" id="P70004970270000000000000000468CB">NULL</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468CC" id="P70004970270000000000000000468CC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468CD" id="P70004970270000000000000000468CD">Ai_addr, to socket address struct</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468CE" id="P70004970270000000000000000468CE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468CF" id="P70004970270000000000000000468CF">Ai_next, to next list:</p>
<ul class="pcalibre146 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468D0" id="P70004970270000000000000000468D0">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468D1" id="P70004970270000000000000000468D1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468D2" id="P70004970270000000000000000468D2">NULL</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468D3" id="P70004970270000000000000000468D3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468D4" id="P70004970270000000000000000468D4">Ai_addr, to socket address struct</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468D5" id="P70004970270000000000000000468D5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468D6" id="P70004970270000000000000000468D6">NULL</p></li>
</ul>
</li></ul>
</li></ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468D7" id="P70004970270000000000000000468D7">Given <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468D8" id="P70004970270000000000000000468D8">host</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468D9" id="P70004970270000000000000000468D9">service</code> (the two components of a socket address), <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468DA" id="P70004970270000000000000000468DA">getaddrinfo</code> returns a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468DB" id="P70004970270000000000000000468DB">result</code> that points to a linked list of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468DC" id="P70004970270000000000000000468DC">addrinfo</code> structures, each of which points to a socket address structure that corresponds to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468DD" id="P70004970270000000000000000468DD">host</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468DE" id="P70004970270000000000000000468DE">service</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007D5E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.15</span></a>).</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468DF" id="P70004970270000000000000000468DF">After a client calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468E0" id="P70004970270000000000000000468E0">getaddrinfo</code>, it walks this list, trying each socket address in turn until the calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468E1" id="P70004970270000000000000000468E1">socket</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468E2" id="P70004970270000000000000000468E2">connect</code> succeed and the connection is established. Similarly, a server tries each socket address on the list until the calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468E3" id="P70004970270000000000000000468E3">socket</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468E4" id="P70004970270000000000000000468E4">bind</code> succeed and the descriptor is bound to a valid socket address. To avoid memory leaks, the application must eventually free the list by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468E5" id="P70004970270000000000000000468E5">freeaddrinfo</code>. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468E6" id="P70004970270000000000000000468E6">getaddrinfo</code> returns a nonzero error code, the application can call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468E7" id="P70004970270000000000000000468E7">gai_strerror</code> to convert the code to a message string.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468E8" id="P70004970270000000000000000468E8">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468E9" id="P70004970270000000000000000468E9">host</code> argument to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468EA" id="P70004970270000000000000000468EA">getaddrinfo</code> can be either a domain name or a numeric address (e.g., a dotted-decimal IP address). The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468EB" id="P70004970270000000000000000468EB">service</code> argument can be either a service name <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468EC" id="P70004970270000000000000000468EC">(e.g., http)</code> or a decimal port number. If we are not interested in converting the hostname to an address, we can set <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468ED" id="P70004970270000000000000000468ED">host</code> to NULL. The same holds for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468EE" id="P70004970270000000000000000468EE">service</code>. However, at least one of them must be specified.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468EF" id="P70004970270000000000000000468EF">The optional <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468F0" id="P70004970270000000000000000468F0">hints</code> argument is an <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468F1" id="P70004970270000000000000000468F1">addrinfo</code> structure (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007D88"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.16</span></a>) that provides finer control over the list of socket addresses that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468F2" id="P70004970270000000000000000468F2">getaddrinfo</code> returns. When passed as a hints argument, only the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468F3" id="P70004970270000000000000000468F3">ai_family, ai_socktype, ai_protocol</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468F4" id="P70004970270000000000000000468F4">ai_flags</code> fields can be set. The other fields must be set to zero (or NULL). In practice, we use <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468F5" id="P70004970270000000000000000468F5">memset</code> to zero the entire structure and then set a few selected fields:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468F6" id="P70004970270000000000000000468F6">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468F7" id="P70004970270000000000000000468F7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000468F8" id="P70004970270000000000000000468F8">By default, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468F9" id="P70004970270000000000000000468F9">getaddrinfo</code> can return both IPv4 and IPv6 socket addresses. Setting <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468FA" id="P70004970270000000000000000468FA">ai_family</code> to AF_INET restricts the list to IPv4 addresses. Setting it to AF_INET6 restricts the list to IPv6 addresses.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007D88" id="P7000497027000000000000000007D88">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007D89" epub:type="pagebreak" id="P7000497027000000000000000007D89" title="939"></span>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000468FB" id="P70004970270000000000000000468FB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468FC" id="P70004970270000000000000000468FC">
struct addrinfo {
	int		ai_flags;	/* Hints argument flags */
	int		ai_family;	/* First arg to socket function */
	int		ai_socktype;	/* Second arg to socket function */
	int		ai_protocol;	/* Third arg to socket function */
	char		*ai_canonname;	/* Canonical hostname */
	size_t		ai_addrlen;	/* Size of ai_addr struct */
	struct sockaddr	*ai_addr;	/* Ptr to socket address structure */
struct addrinfo		*ai_next;	/* Ptr to next item in linked list */
};
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P70004970270000000000000000468FD" id="P70004970270000000000000000468FD"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P70004970270000000000000000468FE" epub:type="title" id="P70004970270000000000000000468FE"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.16 </span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000468FF" id="P70004970270000000000000000468FF">addrinfo</code> structure used by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046900" id="P7000497027000000000000000046900">getaddrinfo</code>.</h1></header>
</figcaption>
</figure></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046901" id="P7000497027000000000000000046901"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046902" id="P7000497027000000000000000046902">By default, for each unique address associated with host, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046903" id="P7000497027000000000000000046903">getaddrinfo</code> function can return up to three <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046904" id="P7000497027000000000000000046904">addrinfo</code> structures, each with a different <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046905" id="P7000497027000000000000000046905">ai_socktype</code> field: one for connections, one for datagrams (not covered), and one for raw sockets (not covered). Setting <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046906" id="P7000497027000000000000000046906">ai_socktype</code> to SOCK_STREAM restricts the list to at most one <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046907" id="P7000497027000000000000000046907">addrinfo</code> structure for each unique address, one whose socket address can be used as the end point of a connection. This is the desired behavior for all of our example programs.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046908" id="P7000497027000000000000000046908"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P7000497027000000000000000046909" id="P7000497027000000000000000046909">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004690A" id="P700049702700000000000000004690A">ai_flags</code> field is a bit mask that further modifies the default behavior. You create it by <span class="pcalibre1 pcalibre29 pcalibre2">or</span>ing combinations of various values. Here are some that we find useful:</p>
<ul class="pcalibre1 pcalibre2 pcalibre126" data-uri="chapter11.xhtml#P700049702700000000000000004690B" id="P700049702700000000000000004690B">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004690C" id="P700049702700000000000000004690C"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter11.xhtml#P700049702700000000000000004690D" id="P700049702700000000000000004690D">AI_ADDRCONFIG. This flag is recommended if you are using connections <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3E5">[34]</a>. It asks <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004690E" id="P700049702700000000000000004690E">getaddrinfo</code> to return IPv4 addresses only if the local host is configured for IPv4. Similarly for IPv6.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004690F" id="P700049702700000000000000004690F"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter11.xhtml#P7000497027000000000000000046910" id="P7000497027000000000000000046910">AI_CANONNAME. By default, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046911" id="P7000497027000000000000000046911">ai_canonname</code> field is NULL. If this flag is set, it instructs <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046912" id="P7000497027000000000000000046912">getaddrinfo</code> to point the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046913" id="P7000497027000000000000000046913">ai_canonname</code> field in the first <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046914" id="P7000497027000000000000000046914">addrinfo</code> structure in the list to the canonical (official) name of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046915" id="P7000497027000000000000000046915">host</code> (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007D5E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.15</span></a>).</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046916" id="P7000497027000000000000000046916"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter11.xhtml#P7000497027000000000000000046917" id="P7000497027000000000000000046917">AI_NUMERICSERV. By default, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046918" id="P7000497027000000000000000046918">service</code> argument can be a service name or a port number. This flag forces the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046919" id="P7000497027000000000000000046919">service</code> argument to be a port number.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004691A" id="P700049702700000000000000004691A"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter11.xhtml#P700049702700000000000000004691B" id="P700049702700000000000000004691B">AI_PASSIVE. By default, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004691C" id="P700049702700000000000000004691C">getaddrinfo</code> returns socket addresses that can be used by clients as active sockets in calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004691D" id="P700049702700000000000000004691D">connect</code>. This flag instructs it to return socket addresses that can be used by servers as listening sockets. In this case, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004691E" id="P700049702700000000000000004691E">host</code> argument should be NULL. The address field in the resulting socket address structure(s) will be the <i class="pcalibre17 pcalibre2 pcalibre1">wildcard address</i>, which tells the kernel that this server will accept requests to any of the IP addresses for this host. This is the desired behavior for all of our example servers.</p></li>
</ul></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004691F" id="P700049702700000000000000004691F"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007DAF" epub:type="pagebreak" id="P7000497027000000000000000007DAF" title="940"></span>When <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046920" id="P7000497027000000000000000046920">getaddrinfo</code> creates an <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046921" id="P7000497027000000000000000046921">addrinfo</code> structure in the output list, it fills in each field except for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046922" id="P7000497027000000000000000046922">ai_flags</code>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046923" id="P7000497027000000000000000046923">ai_addr</code> field points to a socket address structure, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046924" id="P7000497027000000000000000046924">ai_addrlen</code> field gives the size of this socket address structure, and the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046925" id="P7000497027000000000000000046925">ai_next</code> field points to the next <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046926" id="P7000497027000000000000000046926">addrinfo</code> structure in the list. The other fields describe various attributes of the socket address.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046927" id="P7000497027000000000000000046927">One of the elegant aspects of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046928" id="P7000497027000000000000000046928">getaddrinfo</code> is that the fields in an <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046929" id="P7000497027000000000000000046929">addrinfo</code> structure are opaque, in the sense that they can be passed directly to the functions in the sockets interface without any further manipulation by the application code. For example, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004692A" id="P700049702700000000000000004692A">ai_family, ai_socktype</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004692B" id="P700049702700000000000000004692B">ai_protocol</code> can be passed directly to socket. Similarly, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004692C" id="P700049702700000000000000004692C">ai_addr</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004692D" id="P700049702700000000000000004692D">ai_addrlen</code> can be passed directly to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004692E" id="P700049702700000000000000004692E">connect</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004692F" id="P700049702700000000000000004692F">bind</code>. This powerful property allows us to write clients and servers that are independent of any particular version of the IP protocol.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007DC0" id="P7000497027000000000000000007DC0"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046930" epub:type="title" id="P7000497027000000000000000046930">The <code class="pcalibre1 pcalibre2 calibre16" data-uri="chapter11.xhtml#P7000497027000000000000000046931" id="P7000497027000000000000000046931">getnameinfo</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046932" id="P7000497027000000000000000046932">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046933" id="P7000497027000000000000000046933">getnameinfo</code> function is the inverse of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046934" id="P7000497027000000000000000046934">getaddrinfo</code>. It converts a socket address structure to the corresponding host and service name strings. It is the modern replacement for the obsolete <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046935" id="P7000497027000000000000000046935">gethostbyaddr</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046936" id="P7000497027000000000000000046936">getservbyport</code> functions, and unlike those functions, it is reentrant and protocol-independent.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046937" id="P7000497027000000000000000046937"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046938" id="P7000497027000000000000000046938">
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
int getnameinfo(const struct sockaddr *sa, socklen_t salen,
				char *host, size_t hostlen,
				char *service, size_t servlen, int flags);
									Returns: 0 if OK, nonzero error code on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046939" id="P7000497027000000000000000046939">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004693A" id="P700049702700000000000000004693A">sa</code> argument points to a socket address structure of size <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004693B" id="P700049702700000000000000004693B">salen</code> bytes, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004693C" id="P700049702700000000000000004693C">host</code> to a buffer of size <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004693D" id="P700049702700000000000000004693D">hostlen</code> bytes, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004693E" id="P700049702700000000000000004693E">service</code> to a buffer of size <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004693F" id="P700049702700000000000000004693F">servlen</code> bytes. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046940" id="P7000497027000000000000000046940">getnameinfo</code> function converts the socket address structure <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046941" id="P7000497027000000000000000046941">sa</code> to the corresponding <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046942" id="P7000497027000000000000000046942">host</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046943" id="P7000497027000000000000000046943">service</code> name strings and copies them to the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046944" id="P7000497027000000000000000046944">host</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046945" id="P7000497027000000000000000046945">service</code> buffers. If <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046946" id="P7000497027000000000000000046946">getnameinfo</code> returns a nonzero error code, the application can convert it to a string by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046947" id="P7000497027000000000000000046947">gai_strerror</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046948" id="P7000497027000000000000000046948">If we don't want the hostname, we can <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046949" id="P7000497027000000000000000046949">set host</code> to NULL and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004694A" id="P700049702700000000000000004694A">hostlen</code> to zero. The same holds for the service fields. However, one or the other must be set.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004694B" id="P700049702700000000000000004694B">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004694C" id="P700049702700000000000000004694C">flags</code> argument is a bit mask that modifies the default behavior. You create it by <span class="pcalibre1 pcalibre29 pcalibre2">or</span>ing combinations of various values. Here are a couple of useful ones:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004694D" id="P700049702700000000000000004694D">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004694E" id="P700049702700000000000000004694E"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter11.xhtml#P700049702700000000000000004694F" id="P700049702700000000000000004694F">NI_NUMERICHOST. By default, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046950" id="P7000497027000000000000000046950">getnameinfo</code> tries to return a domain name in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046951" id="P7000497027000000000000000046951">host</code>. Setting this flag will cause it to return a numeric address string instead.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046952" id="P7000497027000000000000000046952"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter11.xhtml#P7000497027000000000000000046953" id="P7000497027000000000000000046953">NI_NUMERICSERV. By default, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046954" id="P7000497027000000000000000046954">getnameinfo</code> will look in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046955" id="P7000497027000000000000000046955">/etc/services</code> and if possible, return a service name instead of a port number. Setting this flag forces it to skip the lookup and simply return the port number.</p></li>
</ul>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007DE7" id="P7000497027000000000000000007DE7">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007DE8" epub:type="pagebreak" id="P7000497027000000000000000007DE8" title="941"></span>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046956" id="P7000497027000000000000000046956"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046957" id="P7000497027000000000000000046957">
1	#include "csapp.h"
2	
3	int main(int argc, char **argv)
4	{
5		struct addrinfo *p, *listp, hints;
6		char buf[MAXLINE];
7		int rc, flags;
8	
9		if (argc != 2) {
10			fprintf(stderr, "usage: %s &lt;domain name&gt;\n", argv[0]);
11			exit(0);
12		}
13	
14		/* Get a list of addrinfo records */
15		memset(&amp;hints, 0, sizeof(struct addrinfo));
16		hints.ai_family = AF_INET; /* IPv4 only */
17		hints.ai_socktype = SOCK_STREAM; /* Connections only */
18		if ((rc = getaddrinfo(argv[1], NULL, &amp;hints, &amp;listp)) != 0) {
19			fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(rc));
20			exit(1);
21	}
22	
23		/* Walk the list and display each IP address */
24		flags = NI_NUMERICHOST; /* Display address string instead of domain name */
25		for (p = listp; p; p = p-&gt;ai_next) {
26			Getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, NULL, 0, flags);
27			printf("%s\n", buf);
28		}
29	
30		/* Clean up */
31		Freeaddrinfo(listp);
32	
33		exit(0);
34	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P7000497027000000000000000046958" id="P7000497027000000000000000046958"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P7000497027000000000000000046959" epub:type="title" id="P7000497027000000000000000046959"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.17 </span>H<span class="pcalibre1 pcalibre2 pcalibre84">ostinfo</span> displays the mapping of a domain name to its associated IP addresses.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004695A" id="P700049702700000000000000004695A"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007DE7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.17</span></a> shows a simple program, called <span class="pcalibre1 pcalibre29 pcalibre2">hostinfo</span>, that uses <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004695B" id="P700049702700000000000000004695B">getaddrinfo</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004695C" id="P700049702700000000000000004695C">getnameinfo</code> to display the mapping of a domain name to its associated IP addresses. It is similar to the <span class="pcalibre1 pcalibre29 pcalibre2">nslookup </span>program from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007BFE.xhtml#P7000497027000000000000000007C6B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.3.2</span></a>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004695D" id="P700049702700000000000000004695D">First, we initialize the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004695E" id="P700049702700000000000000004695E">hints</code> structure so that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004695F" id="P700049702700000000000000004695F">getaddrinfo</code> returns the addresses we want. In this case, we are looking for 32-bit IP addresses (line 16) <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007DF3" epub:type="pagebreak" id="P7000497027000000000000000007DF3" title="942"></span>that can be used as end points of connections (line 17). Since we are only asking <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046960" id="P7000497027000000000000000046960">getaddrinfo</code> to convert domain names, we call it with a NULL <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046961" id="P7000497027000000000000000046961">service</code> argument.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046962" id="P7000497027000000000000000046962">After the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046963" id="P7000497027000000000000000046963">getaddrinfo</code>, we walk the list of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046964" id="P7000497027000000000000000046964">addrinfo</code> structures, using <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046965" id="P7000497027000000000000000046965">getnameinfo</code> to convert each socket address to a dotted-decimal address string. After walking the list, we are careful to free it by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046966" id="P7000497027000000000000000046966">freeaddrinfo</code> (although for this simple program it is not strictly necessary).</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046967" id="P7000497027000000000000000046967">When we run <span class="pcalibre1 pcalibre29 pcalibre2">hostinfo</span>, we see that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046968" id="P7000497027000000000000000046968"><a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="http://twitter.com">twitter.com</a></code> maps to four IP addresses, which is what we saw using <span class="pcalibre1 pcalibre29 pcalibre2">nslookup </span>in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007BFE.xhtml#P7000497027000000000000000007C6B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.3.2</span></a>.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046969" id="P7000497027000000000000000046969"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004696A" id="P700049702700000000000000004696A">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./hostinfo twitter.com</i>
199.16.156.102
199.16.156.230
199.16.156.6
199.16.156.70
</code></pre>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007DFF" epub:type="practice" id="P7000497027000000000000000007DFF"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004696B" epub:type="title" id="P700049702700000000000000004696B"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000008021.xhtml#P7000497027000000000000000008049">968</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter11.xhtml#P700049702700000000000000004696C" id="P700049702700000000000000004696C">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter11.xhtml#P700049702700000000000000004696D" id="P700049702700000000000000004696D">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter11.xhtml#P700049702700000000000000004696E" id="P700049702700000000000000004696E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004696F" id="P700049702700000000000000004696F">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046970" id="P7000497027000000000000000046970">getaddrinfo</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046971" id="P7000497027000000000000000046971">getnameinfo</code> functions subsume the functionality of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046972" id="P7000497027000000000000000046972">inet_pton</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046973" id="P7000497027000000000000000046973">inet_ntop</code>, respectively, and they provide a higher-level of abstraction that is independent of any particular address format. To convince yourself how handy this is, write a version of <span class="pcalibre1 pcalibre29 pcalibre2">hostinfo </span>(<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007DE7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.17</span></a>) that uses <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046974" id="P7000497027000000000000000046974">inet_ntop</code> instead of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046975" id="P7000497027000000000000000046975">getnameinfo</code> to convert each socket address to a dotted-decimal address string.</p></div></li>
</ol>
</section>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007E0B" id="P7000497027000000000000000007E0B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046976" epub:type="title" id="P7000497027000000000000000046976"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.8 </span>Helper Functions for the Sockets Interface</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046977" id="P7000497027000000000000000046977">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046978" id="P7000497027000000000000000046978">getaddrinfo</code> function and the sockets interface can seem somewhat daunting when you first learn about them. We find it convenient to wrap them with higher-level helper functions, called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046979" id="P7000497027000000000000000046979">open_clientfd</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004697A" id="P700049702700000000000000004697A">open_listenfd</code>, that clients and servers can use when they want to communicate with each other.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007E11" id="P7000497027000000000000000007E11"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004697B" epub:type="title" id="P700049702700000000000000004697B">The <code class="pcalibre1 pcalibre2 calibre16" data-uri="chapter11.xhtml#P700049702700000000000000004697C" id="P700049702700000000000000004697C">open_clientfd</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004697D" id="P700049702700000000000000004697D">A client establishes a connection with a server by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004697E" id="P700049702700000000000000004697E">open_clientfd</code>.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004697F" id="P700049702700000000000000004697F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046980" id="P7000497027000000000000000046980">
#include "csapp.h"
int open_clientfd(char *hostname, char *port);
Returns: descriptor if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046981" id="P7000497027000000000000000046981">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046982" id="P7000497027000000000000000046982">open_clientfd</code> function establishes a connection with a server running on host <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046983" id="P7000497027000000000000000046983">hostname</code> and listening for connection requests on port number port. It returns an open socket descriptor that is ready for input and output using the Unix I/O functions. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E1F"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.18</span></a> shows the code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046984" id="P7000497027000000000000000046984">open_clientfd.</code></p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046985" id="P7000497027000000000000000046985">We call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046986" id="P7000497027000000000000000046986">getaddrinfo</code>, which returns a list of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046987" id="P7000497027000000000000000046987">addrinfo</code> structures, each of which points to a socket address structure that is suitable for establishing a connection</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007E1F" id="P7000497027000000000000000007E1F">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007E20" epub:type="pagebreak" id="P7000497027000000000000000007E20" title="943"></span>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P7000497027000000000000000046988" id="P7000497027000000000000000046988"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046989" id="P7000497027000000000000000046989">
1	int open_clientfd(char *hostname, char *port) {
2		int clientfd;
3		struct addrinfo hints, *listp, *p;
4	
5		/* Get a list of potential server addresses */
6		memset(&amp;hints, 0, sizeof(struct addrinfo));
7		hints.ai_socktype = SOCK_STREAM; /* Open a connection */
8		hints.ai_flags = AI_NUMERICSERV; /* ... using a numeric port arg. */
9		hints.ai_flags |= AI_ADDRCONFIG; /* Recommended for connections */
10		Getaddrinfo(hostname, port, &amp;hints, &amp;listp);
11	
12		/* Walk the list for one that we can successfully connect to */
13		for (p = listp; p; p = p-&gt;ai_next) {
14			/* Create a socket descriptor */
15			if ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0)
16				continue; /* Socket failed, try the next */
17	
18			/* Connect to the server */
19			if (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != −1)
20				break; /* Success */
21			Close(clientfd); /* Connect failed, try another */
22		}
23	
24		/* Clean up */
25		Freeaddrinfo(listp);
26		if (!p) /* All connects failed */
27			return −1;
28		else	/* The last connect succeeded */
29		return clientfd;
30	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P700049702700000000000000004698A" id="P700049702700000000000000004698A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P700049702700000000000000004698B" epub:type="title" id="P700049702700000000000000004698B"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.18 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004698C" id="P700049702700000000000000004698C">open_clientfd</code>: Helper function that establishes a connection with a server.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004698D" id="P700049702700000000000000004698D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P700049702700000000000000004698E" id="P700049702700000000000000004698E">It is reentrant and protocol-independent.</p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004698F" id="P700049702700000000000000004698F">with a server running on <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046990" id="P7000497027000000000000000046990">hostname</code> and listening on <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046991" id="P7000497027000000000000000046991">port</code>. We then walk the list, trying each list entry in turn, until the calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046992" id="P7000497027000000000000000046992">socket</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046993" id="P7000497027000000000000000046993">connect</code> succeed. If the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046994" id="P7000497027000000000000000046994">connect</code> fails, we are careful to close the socket descriptor before trying the next entry. If the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046995" id="P7000497027000000000000000046995">connect</code> succeeds, we free the list memory and return the socket descriptor to the client, which can immediately begin using Unix I/O to communicate with the server.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046996" id="P7000497027000000000000000046996">Notice how there is no dependence on any particular version of IP anywhere in the code. The arguments to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046997" id="P7000497027000000000000000046997">socket</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046998" id="P7000497027000000000000000046998">connect</code> are generated for us automatically by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000046999" id="P7000497027000000000000000046999">getaddrinfo</code>, which allows our code to be clean and portable.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007E33" id="P7000497027000000000000000007E33"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004699A" epub:type="title" id="P700049702700000000000000004699A"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007E35" epub:type="pagebreak" id="P7000497027000000000000000007E35" title="944"></span>The <code class="pcalibre1 pcalibre2 calibre16" data-uri="chapter11.xhtml#P700049702700000000000000004699B" id="P700049702700000000000000004699B">open_listenfd</code> Function</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004699C" id="P700049702700000000000000004699C">A server creates a listening descriptor that is ready to receive connection requests by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004699D" id="P700049702700000000000000004699D">open_listenfd</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P700049702700000000000000004699E" id="P700049702700000000000000004699E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P700049702700000000000000004699F" id="P700049702700000000000000004699F">
#include "csapp.h"
int open_listenfd(char *port);
Returns: descriptor if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469A0" id="P70004970270000000000000000469A0">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469A1" id="P70004970270000000000000000469A1">open_listenfd</code> function returns a listening descriptor that is ready to receive connection requests on port <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469A2" id="P70004970270000000000000000469A2">port</code>. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E55"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.19</span></a> shows the code for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469A3" id="P70004970270000000000000000469A3">open_listenfd</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469A4" id="P70004970270000000000000000469A4">The style is similar to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469A5" id="P70004970270000000000000000469A5">open_clientfd</code>. We call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469A6" id="P70004970270000000000000000469A6">getaddrinfo</code> and then walk the resulting list until the calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469A7" id="P70004970270000000000000000469A7">socket</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469A8" id="P70004970270000000000000000469A8">bind</code> succeed. Note that in line 20 we use the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469A9" id="P70004970270000000000000000469A9">setsockopt</code> function (not described here) to configure the server so that it can be terminated, be restarted, and begin accepting connection requests immediately. By default, a restarted server will deny connection requests from clients for approximately 30 seconds, which seriously hinders debugging.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469AA" id="P70004970270000000000000000469AA">Since we have called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469AB" id="P70004970270000000000000000469AB">getaddrinfo</code> with the AI_PASSIVE flag and a NULL <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469AC" id="P70004970270000000000000000469AC">host</code> argument, the address field in each socket address structure is set to the wildcard address, which tells the kernel that this server will accept requests to any of the IP addresses for this host.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469AD" id="P70004970270000000000000000469AD">Finally, we call the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469AE" id="P70004970270000000000000000469AE">listen</code> function to convert <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469AF" id="P70004970270000000000000000469AF">listenfd</code> to a listening descriptor and return it to the caller. If the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469B0" id="P70004970270000000000000000469B0">listen</code> fails, we are careful to avoid a memory leak by closing the descriptor before returning.</p>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter11.xhtml#P7000497027000000000000000007E4C" id="P7000497027000000000000000007E4C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469B1" epub:type="title" id="P70004970270000000000000000469B1"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.9 </span>Example Echo Client and Server</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469B2" id="P70004970270000000000000000469B2">The best way to learn the sockets interface is to study example code. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E5E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.20</span></a> shows the code for an echo client. After establishing a connection with the server, the client enters a loop that repeatedly reads a text line from standard input, sends the text line to the server, reads the echo line from the server, and prints the result to standard output. The loop terminates when <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469B3" id="P70004970270000000000000000469B3">fgets</code> encounters EOF on standard input, either because the user typed Ctrl+D at the keyboard or because it has exhausted the text lines in a redirected input file.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469B4" id="P70004970270000000000000000469B4">After the loop terminates, the client closes the descriptor. This results in an EOF notification being sent to the server, which it detects when it receives a return code of zero from its <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469B5" id="P70004970270000000000000000469B5">rio_readlineb</code> function. After closing its descriptor, the client terminates. Since the client's kernel automatically closes all open descriptors when a process terminates, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469B6" id="P70004970270000000000000000469B6">close</code> in line 24 is not necessary. However, it is good programming practice to explicitly close any descriptors that you have opened.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469B7" id="P70004970270000000000000000469B7"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E72"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.21</span></a> shows the main routine for the echo server. After opening the listening descriptor, it enters an infinite loop. Each iteration waits for a connection request from a client, prints the domain name and port of the connected client, and then calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469B8" id="P70004970270000000000000000469B8">echo</code> function that services the client. After the echo routine returns,</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007E55" id="P7000497027000000000000000007E55">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007E56" epub:type="pagebreak" id="P7000497027000000000000000007E56" title="945"></span>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000469B9" id="P70004970270000000000000000469B9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469BA" id="P70004970270000000000000000469BA">
1	int open_listenfd(char *port)
2	{
3		struct addrinfo hints, *listp, *p;
4		int listenfd, optval=1;
5	
6		/* Get a list of potential server addresses */
7		memset(&amp;hints, 0, sizeof(struct addrinfo));
8		hints.ai_socktype = SOCK_STREAM;				/* Accept connections */
9		hints.ai_flags = AI_PASSIVE	|		AI_ADDRCONFIG;	/* ... on any IP address */
10		hints.ai_flags |= AI_NUMERICSERV;				/* ... using port number */
11		Getaddrinfo(NULL, port, &amp;hints, &amp;listp);
12	
13		/* Walk the list for one that we can bind to */
14		for (p = listp; p; p = p-&gt;ai_next) {
15			/* Create a socket descriptor */
16			if ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0)
17				continue; /* Socket failed, try the next */
18	
19			/* Eliminates "Address already in use" error from bind */
20			Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,
21					(const void *)&amp;optval , sizeof(int));
22	
23			/* Bind the descriptor to the address */
24			if (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == 0)
25				break; /* Success */
26			Close(listenfd); /* Bind failed, try the next */
27		}
28	
29		/* Clean up */
30		Freeaddrinfo(listp);
31		if (!p) /* No address worked */
32			return -1;
33	
34		/* Make it a listening socket ready to accept connection requests */
35		if (listen(listenfd, LISTENQ) &lt; 0) {
36			Close(listenfd);
37			return −1;
38		}
39		return listenfd;
40	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P70004970270000000000000000469BB" id="P70004970270000000000000000469BB"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P70004970270000000000000000469BC" epub:type="title" id="P70004970270000000000000000469BC"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.19 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469BD" id="P70004970270000000000000000469BD">open_listenfd</code>: Helper function that opens and returns a listening descriptor.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469BE" id="P70004970270000000000000000469BE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000469BF" id="P70004970270000000000000000469BF">It is reentrant and protocol-independent.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007E5E" id="P7000497027000000000000000007E5E">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007E5F" epub:type="pagebreak" id="P7000497027000000000000000007E5F" title="946"></span>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000469C0" id="P70004970270000000000000000469C0"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469C1" id="P70004970270000000000000000469C1">
1	#include "csapp.h"
2	
3	int main(int argc, char **argv)
4	{
5		int clientfd;
6		char *host, *port, buf[MAXLINE];
7		rio_t rio;
8
9		if (argc != 3) {
10			fprintf(stderr, "usage: %s &lt;host&gt; &lt;port&gt;\n", argv[0]);
11			exit(0);
12		}
13		host = argv[1];
14		port = argv[2];
15	
16		clientfd = Open_clientfd(host, port);
17		Rio_readinitb(,&amp;rio, clientfd);
18	
19		while (Fgets(buf, MAXLINE, stdin) != NULL) {
20			Rio_writen(clientfd, buf, strlen(buf));
21			Rio_readlineb(&amp;rio, buf, MAXLINE);
22			Fputs(buf, stdout);
23		}
24		Close(clientfd);
25		exit(0);
26	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P70004970270000000000000000469C2" id="P70004970270000000000000000469C2"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P70004970270000000000000000469C3" epub:type="title" id="P70004970270000000000000000469C3"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">11.20 </span>Echo client main routine.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469C4" id="P70004970270000000000000000469C4">the main routine closes the connected descriptor. Once the client and server have closed their respective descriptors, the connection is terminated.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469C5" id="P70004970270000000000000000469C5">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469C6" id="P70004970270000000000000000469C6">clientaddr</code> variable in line 9 is a socket address structure that is passed to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469C7" id="P70004970270000000000000000469C7">accept</code>. Before <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469C8" id="P70004970270000000000000000469C8">accept</code> returns, it fills in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469C9" id="P70004970270000000000000000469C9">clientaddr</code> with the socket address of the client on the other end of the connection. Notice how we declare <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469CA" id="P70004970270000000000000000469CA">clientaddr</code> as type struct <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469CB" id="P70004970270000000000000000469CB">sockaddr_storage</code> rather than struct <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469CC" id="P70004970270000000000000000469CC">sockaddr_in</code>. By definition, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469CD" id="P70004970270000000000000000469CD">sockaddr_storage</code> structure is large enough to hold any type of socket address, which keeps the code protocol-independent.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469CE" id="P70004970270000000000000000469CE">Notice that our simple echo server can only handle one client at a time. A server of this type that iterates through clients, one at a time, is called an <i class="pcalibre17 pcalibre2 pcalibre1">iterative server</i>. In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">12</span></a>, we will learn how to build more sophisticated <i class="pcalibre17 pcalibre2 pcalibre1">concurrent servers</i> that can handle multiple clients simultaneously.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469CF" id="P70004970270000000000000000469CF">Finally, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E78"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.22</span></a> shows the code for the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469D0" id="P70004970270000000000000000469D0">echo</code> routine, which repeatedly reads and writes lines of text until the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469D1" id="P70004970270000000000000000469D1">rio_readlineb</code> function encounters EOF in line 10.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007E72" id="P7000497027000000000000000007E72">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007E73" epub:type="pagebreak" id="P7000497027000000000000000007E73" title="947"></span>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000469D2" id="P70004970270000000000000000469D2"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469D3" id="P70004970270000000000000000469D3">
1	#include "csapp.h"
2	
3	void echo(int connfd);
4	
5	int main(int argc, char **argv)
6	{
7		int listenfd, connfd;
8		socklen_t clientlen;
9		struct sockaddr_storage clientaddr; /* Enough space for any address */
10		char client_hostname[MAXLINE], client_port[MAXLINE];
11	
12		if (argc != 2) {
13			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
14			exit(0);
15		}
16	
17		listenfd = Open_listenfd(argv[1]);
18		while (1) {
19			clientlen = sizeof(struct sockaddr_storage);
20			connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
21			Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname, MAXLINE,
22				client_port, MAXLINE, 0);
23			printf("Connected to (%s, %s)\n", client_hostname, client_port);
24			echo(connfd);
25			Close(connfd);
26		}
27		exit(0);
28	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P70004970270000000000000000469D4" id="P70004970270000000000000000469D4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P70004970270000000000000000469D5" epub:type="title" id="P70004970270000000000000000469D5"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">11.21 </span>Iterative echo server main routine.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter11.xhtml#P7000497027000000000000000007E78" id="P7000497027000000000000000007E78">
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter11.xhtml#P70004970270000000000000000469D6" id="P70004970270000000000000000469D6"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469D7" id="P70004970270000000000000000469D7">
1	#include "csapp.h"
2	
3	void echo(int connfd)
4	{
5		size_t n;
6		char buf[MAXLINE];
7		rio_t rio; 8
9		Rio_readinitb(&amp;rio, connfd);
10		while((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {
11			printf("server received %d bytes\n", (int)n);
12			Rio_writen(connfd, buf, n);
13		}
14	}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter11.xhtml#P70004970270000000000000000469D8" id="P70004970270000000000000000469D8"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter11.xhtml#P70004970270000000000000000469D9" epub:type="title" id="P70004970270000000000000000469D9"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.22 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter11.xhtml#P70004970270000000000000000469DA" id="P70004970270000000000000000469DA">echo</code> function that reads and echoes text lines.</h1></header>
</figcaption>
</figure>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter11.xhtml#P7000497027000000000000000007E7E" id="P7000497027000000000000000007E7E"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter11.xhtml#P70004970270000000000000000469DB" epub:type="title" id="P70004970270000000000000000469DB"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter11.xhtml#P7000497027000000000000000007E80" epub:type="pagebreak" id="P7000497027000000000000000007E80" title="948"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>What does EOF on a connection mean?</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter11.xhtml#P70004970270000000000000000469DC" id="P70004970270000000000000000469DC">The idea of EOF is often confusing to students, especially in the context of Internet connections. First, we need to understand that there is no such thing as an EOF character. Rather, EOF is a condition that is detected by the kernel. An application finds out about the EOF condition when it receives a zero return code from the read function. For disk files, EOF occurs when the current file position exceeds the file length. For Internet connections, EOF occurs when a process closes its end of the connection. The process at the other end of the connection detects the EOF when it attempts to read past the last byte in the stream.</p>
</aside>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>12.1 Concurrent Programming with Processes</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000008097"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046B9E" epub:type="title" id="P7000497027000000000000000046B9E"><span class="pcalibre1 pcalibre21 pcalibre2">12.1 </span>Concurrent Programming with Processes</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046B9F" id="P7000497027000000000000000046B9F">The simplest way to build a concurrent program is with processes, using familiar functions such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BA0" id="P7000497027000000000000000046BA0">fork, exec</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BA1" id="P7000497027000000000000000046BA1">waitpid</code>. For example, a natural approach for building a concurrent server is to accept client connection requests in the parent and then create a new child process to service each new client.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BA2" id="P7000497027000000000000000046BA2">To see how this might work, suppose we have two clients and a server that is listening for connection requests on a listening descriptor (say, 3). Now suppose that the server accepts a connection request from client 1 and returns a connected descriptor (say, 4), as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000809E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.1</span></a>. After accepting the connection request, the server forks a child, which gets a complete copy of the server's descriptor table. The child closes its copy of listening descriptor 3, and the parent closes its copy of connected descriptor 4, since they are no longer needed. This gives us the situation shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080A2"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.2</span></a>, where the child process is busy servicing the client.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BA3" id="P7000497027000000000000000046BA3">Since the connected descriptors in the parent and child each point to the same file table entry, it is crucial for the parent to close its copy of the connected</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P700049702700000000000000000809E" id="P700049702700000000000000000809E">
<img alt="A diagram shows step 1: a connection request from client 1 (which contains clientfd) to listenfd(3) on server (which also has connfd(4)). Client 2 below also contains clientfd." class="pcalibre309 pcalibre1 pcalibre2" data-uri="P700049702700000000000000000B7C8" id="P7000497027000000000000000046BA4" src="Images/chapter-11-image-04.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046BA5" id="P7000497027000000000000000046BA5"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046BA6" epub:type="title" id="P7000497027000000000000000046BA6"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.1 </span>Step 1: Server accepts connection request from client.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000080A2" id="P70004970270000000000000000080A2">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000080A3" epub:type="pagebreak" id="P70004970270000000000000000080A3" title="974"></span>
<img alt="A diagram shows step 2: data transfers between clientfd on client 1 and connfd(4) on Child 1." class="pcalibre1 pcalibre310 pcalibre2" data-uri="P700049702700000000000000000B7C9" id="P7000497027000000000000000046BA7" src="Images/chapter-11-image-05.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046BA8" id="P7000497027000000000000000046BA8"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046BA9" epub:type="title" id="P7000497027000000000000000046BA9"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.2 </span>Step 2: Server forks a child process to service the client.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000080A7" id="P70004970270000000000000000080A7">
<img alt="A diagram shows step 3: data.transfers between clientfd on client 1 and connfd(4) on child 1, and connection request from clientfd on client 2 to listenfd(3) on server (also has connfd(5))." class="pcalibre1 pcalibre310 pcalibre2" data-uri="P700049702700000000000000000B7CA" id="P7000497027000000000000000046BAA" src="Images/chapter-11-image-06.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046BAB" id="P7000497027000000000000000046BAB"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046BAC" epub:type="title" id="P7000497027000000000000000046BAC"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.3 </span>Step 3: Server accepts another connection request.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BAD" id="P7000497027000000000000000046BAD">descriptor. Otherwise, the file table entry for connected descriptor 4 will never be released, and the resulting memory leak will eventually consume the available memory and crash the system.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BAE" id="P7000497027000000000000000046BAE">Now suppose that after the parent creates the child for client 1, it accepts a new connection request from client 2 and returns a new connected descriptor (say, 5), as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080A7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.3</span></a>. The parent then forks another child, which begins servicing its client using connected descriptor 5, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080B6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.4</span></a>. At this point, the parent is waiting for the next connection request and the two children are servicing their respective clients concurrently.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000080AD" id="P70004970270000000000000000080AD"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BAF" epub:type="title" id="P7000497027000000000000000046BAF"><span class="pcalibre1 pcalibre21 pcalibre2">12.1.1 </span>A Concurrent Server Based on Processes</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BB0" id="P7000497027000000000000000046BB0"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080CF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5</span></a> shows the code for a concurrent echo server based on processes. The echo function called in line 29 comes from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E78"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.22</span></a>. There are several important points to make about this server:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BB1" id="P7000497027000000000000000046BB1">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046BB2" id="P7000497027000000000000000046BB2"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BB3" id="P7000497027000000000000000046BB3">First, servers typically run for long periods of time, so we must include a SIGCHLD handler that reaps zombie children (lines 4−9). Since SIGCHLD signals are blocked while the SIGCHLD handler is executing, and since Linux signals are not queued, the SIGCHLD handler must be prepared to reap multiple zombie children.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046BB4" id="P7000497027000000000000000046BB4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BB5" id="P7000497027000000000000000046BB5">Second, the parent and the child must close their respective copies of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BB6" id="P7000497027000000000000000046BB6">connfd</code> (lines 33 and 30, respectively). As we have mentioned, this is especially important</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000080B6" id="P70004970270000000000000000080B6">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000080B7" epub:type="pagebreak" id="P70004970270000000000000000080B7" title="975"></span>
<img alt="A diagram shows step 4: data.transfers between clientfd on client 1 and connfd(4) on child 1, and between clientfd on client 2 and connfd(5) on child 2." class="pcalibre1 pcalibre2 pcalibre311" data-uri="P700049702700000000000000000B7CB" id="P7000497027000000000000000046BB7" src="Images/chapter-11-image-07.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046BB8" id="P7000497027000000000000000046BB8"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046BB9" epub:type="title" id="P7000497027000000000000000046BB9"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.4 </span>Step 4: Server forks another child to service the new client.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BBA" id="P7000497027000000000000000046BBA">for the parent, which must close its copy of the connected descriptor to avoid a memory leak.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046BBB" id="P7000497027000000000000000046BBB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BBC" id="P7000497027000000000000000046BBC">Finally, because of the reference count in the socket's file table entry, the connection to the client will not be terminated until both the parent's and child's copies of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BBD" id="P7000497027000000000000000046BBD">connfd</code> are closed.</p></li>
</ul>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000080BF" id="P70004970270000000000000000080BF"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BBE" epub:type="title" id="P7000497027000000000000000046BBE"><span class="pcalibre1 pcalibre21 pcalibre2">12.1.2 </span>Pros and Cons of Processes</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BBF" id="P7000497027000000000000000046BBF">Processes have a clean model for sharing state information between parents and children: file tables are shared and user address spaces are not. Having separate address spaces for processes is both an advantage and a disadvantage. It is impossible for one process to accidentally overwrite the virtual memory of another process, which eliminates a lot of confusing failures—an obvious advantage.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BC0" id="P7000497027000000000000000046BC0">On the other hand, separate address spaces make it more difficult for processes to share state information. To share information, they must use explicit IPC (interprocess communications) mechanisms. (See the Aside on <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="#P70004970270000000000000000080DB">page 977</a>.) Another disadvantage of process-based designs is that they tend to be slower because the overhead for process control and IPC is high.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000080C3" epub:type="practice" id="P70004970270000000000000000080C3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BC1" epub:type="title" id="P7000497027000000000000000046BC1"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.1 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P7000497027000000000000000046BC2" id="P7000497027000000000000000046BC2">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000046BC3" id="P7000497027000000000000000046BC3">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046BC4" id="P7000497027000000000000000046BC4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BC5" id="P7000497027000000000000000046BC5">After the parent closes the connected descriptor in line 33 of the concurrent server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080CF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5</span></a>, the child is still able to communicate with the client using its copy of the descriptor. Why?</p></div></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000080C9" epub:type="practice" id="P70004970270000000000000000080C9"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BC6" epub:type="title" id="P7000497027000000000000000046BC6"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.2 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P7000497027000000000000000046BC7" id="P7000497027000000000000000046BC7">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000046BC8" id="P7000497027000000000000000046BC8">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046BC9" id="P7000497027000000000000000046BC9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BCA" id="P7000497027000000000000000046BCA">If we were to delete line 30 of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080CF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5</span></a>, which closes the connected descriptor, the code would still be correct, in the sense that there would be no memory leak. Why?</p></div></li>
</ol>
</section>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000080CF" id="P70004970270000000000000000080CF">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000080D0" epub:type="pagebreak" id="P70004970270000000000000000080D0" title="976"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BCB" id="P7000497027000000000000000046BCB">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoserverp.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046BCC" id="P7000497027000000000000000046BCC"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BCD" id="P7000497027000000000000000046BCD">
1	#include "csapp.h"
2	void echo(int connfd);
3	
4	void sigchld_handler(int sig)
5	{
6		while (waitpid(−1, 0, WNOHANG) &gt; 0)
7			;
8		return;
9	}
10	
11	int main(int argc, char **argv)
12	{
13		int listenfd, connfd;
14		socklen_t clientlen;
15		struct sockaddr_storage clientaddr;
16
17		if (argc != 2) {
18			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
19			exit(0);
20		}
21	
22		Signal(SIGCHLD, sigchld_handler);
23		listenfd = Open_listenfd(argv[1]);
24		while (1) {
25			clientlen = sizeof(struct sockaddr_storage);
26			connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);
27			if (Fork() == 0) {
28				Close(listenfd); /* Child closes its listening socket */
29				echo(connfd);	 /* Child services client */
30				Close(connfd);	 /* Child closes connection with client */
31				exit(0);	 /* Child exits */
32			}
33			Close(connfd); /* Parent closes connected socket (important!) */
34		}
35	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BCE" id="P7000497027000000000000000046BCE">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoserverp.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046BCF" id="P7000497027000000000000000046BCF"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046BD0" epub:type="title" id="P7000497027000000000000000046BD0"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.5 </span>Concurrent echo server based on processes.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BD1" id="P7000497027000000000000000046BD1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BD2" id="P7000497027000000000000000046BD2">The parent forks a child to handle each new connection request.</p></div></figcaption>
</figure>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000080D9" id="P70004970270000000000000000080D9"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter12.xhtml#P7000497027000000000000000046BD3" epub:type="title" id="P7000497027000000000000000046BD3"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000080DB" epub:type="pagebreak" id="P70004970270000000000000000080DB" title="977"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Unix IPC</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BD4" id="P7000497027000000000000000046BD4">You have already encountered several examples of IPC in this text. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BD5" id="P7000497027000000000000000046BD5">waitpid</code> function and signals from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">8</span></a> are primitive IPC mechanisms that allow processes to send tiny messages to process running on the same host. The sockets interface from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007B7A.xhtml#P7000497027000000000000000007B7A"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">11</span></a> is an important form of IPC that allows processes on different hosts to exchange arbitrary byte streams. However, the term <i class="pcalibre17 pcalibre2 pcalibre1">Unix IPC</i> is typically reserved for a hodgepodge of techniques that allow processes to communicate with other processes that are running on the same host. Examples include pipes, FIFOs, System V shared memory, and System V semaphores. These mechanisms are beyond our scope. The book by Kerrisk [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41E">62</a>] is an excellent reference.</p>
</aside>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>12.2 Concurrent Programming with I/O Multiplexing</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P70004970270000000000000000080DE"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046BD6" epub:type="title" id="P7000497027000000000000000046BD6"><span class="pcalibre1 pcalibre21 pcalibre2">12.2 </span>Concurrent Programming with I/O Multiplexing</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BD7" id="P7000497027000000000000000046BD7">Suppose you are asked to write an echo server that can also respond to interactive commands that the user types to standard input. In this case, the server must respond to two independent I/O events: (1) a network client making a connection request, and (2) a user typing a command line at the keyboard. Which event do we wait for first? Neither option is ideal. If we are waiting for a connection request in accept, then we cannot respond to input commands. Similarly, if we are waiting for an input command in read, then we cannot respond to any connection requests.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BD8" id="P7000497027000000000000000046BD8">One solution to this dilemma is a technique called <i class="pcalibre17 pcalibre2 pcalibre1">I/O multiplexing</i>. The basic idea is to use the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BD9" id="P7000497027000000000000000046BD9">select</code> function to ask the kernel to suspend the process, returning control to the application only after one or more I/O events have occurred, as in the following examples:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BDA" id="P7000497027000000000000000046BDA">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046BDB" id="P7000497027000000000000000046BDB"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BDC" id="P7000497027000000000000000046BDC">Return when any descriptor in the set {0, 4} is ready for reading.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046BDD" id="P7000497027000000000000000046BDD"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BDE" id="P7000497027000000000000000046BDE">Return when any descriptor in the set {1, 2, 7} is ready for writing.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046BDF" id="P7000497027000000000000000046BDF"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046BE0" id="P7000497027000000000000000046BE0">Time out if 152.13 seconds have elapsed waiting for an I/O event to occur.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BE1" id="P7000497027000000000000000046BE1"><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BE2" id="P7000497027000000000000000046BE2">Select</code> is a complicated function with many different usage scenarios. We will only discuss the first scenario: waiting for a set of descriptors to be ready for reading. See [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41E">62</a>, <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>] for a complete discussion.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046BE3" id="P7000497027000000000000000046BE3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BE4" id="P7000497027000000000000000046BE4">
#include &lt;sys/select.h&gt;
int select(int n, fd_set *fdset, NULL, NULL, NULL);
			   Returns: nonzero count of ready descriptors, --1 on error
FD_ZERO(fd_set *fdset);			/* Clear all bits in fdset */
FD_CLR(int fd, fd_set *fdset);		/* Clear bit fd in fdset */
FD_SET(int fd, fd_set *fdset);		/* Turn on bit fd in fdset */
FD_ISSET(int fd, fd_set *fdset);	/* Is bit fd in fdset on? */
					   Macros for manipulating descriptor sets
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BE5" id="P7000497027000000000000000046BE5"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000080EF" epub:type="pagebreak" id="P70004970270000000000000000080EF" title="978"></span>The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BE6" id="P7000497027000000000000000046BE6">select</code> function manipulates sets of type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BE7" id="P7000497027000000000000000046BE7">fd_set</code>, which are known as <i class="pcalibre17 pcalibre2 pcalibre1">descriptor sets</i>. Logically, we think of a descriptor set as a bit vector (introduced in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000002AD_split_000.xhtml#P70004970270000000000000000002AD"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">2.1</span></a>) of size <var class="pcalibre17 pcalibre2 pcalibre1">n</var>:</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter12.xhtml#P7000497027000000000000000046BE8" id="P7000497027000000000000000046BE8">
<m:math altimg="../images/ch12-01.png" altimg-height="20" altimg-width="140" alttext="" data-uri="" display="block"><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mi>n</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>b</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>b</m:mi><m:mn>0</m:mn></m:msub></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BE9" id="P7000497027000000000000000046BE9">Each bit <i class="pcalibre17 pcalibre2 pcalibre1">b<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> corresponds to descriptor <var class="pcalibre17 pcalibre2 pcalibre1">k</var>. Descriptor <var class="pcalibre17 pcalibre2 pcalibre1">k</var> is a member of the descriptor set if and only if <i class="pcalibre17 pcalibre2 pcalibre1">b<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> = 1. You are only allowed to do three things with descriptor sets: (1) allocate them, (2) assign one variable of this type to another, and (3) modify and inspect them using the FD_ZERO, FD_SET, FD_CLR, and FD_ISSET macros.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BEA" id="P7000497027000000000000000046BEA">For our purposes, the select function takes two inputs: a descriptor set (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BEB" id="P7000497027000000000000000046BEB">fdset</code>) called the <i class="pcalibre17 pcalibre2 pcalibre1">read set</i>, and the cardinality (n) of the read set (actually the maximum cardinality of any descriptor set). The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BEC" id="P7000497027000000000000000046BEC">select</code> function blocks until at least one descriptor in the read set is ready for reading. A descriptor <var class="pcalibre17 pcalibre2 pcalibre1">k</var> is <i class="pcalibre17 pcalibre2 pcalibre1">ready for reading</i> if and only if a request to read 1 byte from that descriptor would not block. As a side effect, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BED" id="P7000497027000000000000000046BED">select</code> modifies the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BEE" id="P7000497027000000000000000046BEE">fd_set</code> pointed to by argument <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BEF" id="P7000497027000000000000000046BEF">fdset</code> to indicate a subset of the read set called the <i class="pcalibre17 pcalibre2 pcalibre1">ready set</i>, consisting of the descriptors in the read set that are ready for reading. The value returned by the function indicates the cardinality of the ready set. Note that because of the side effect, we must update the read set every time <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BF0" id="P7000497027000000000000000046BF0">select</code> is called.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BF1" id="P7000497027000000000000000046BF1">The best way to understand <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BF2" id="P7000497027000000000000000046BF2">select</code> is to study a concrete example. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008109"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.6</span></a> shows how we might use <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BF3" id="P7000497027000000000000000046BF3">select</code> to implement an iterative echo server that also accepts user commands on the standard input. We begin by using the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BF4" id="P7000497027000000000000000046BF4">open_listenfd</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E55"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.19</span></a> to open a listening descriptor (line 16), and then using FD_ZERO to create an empty read set (line 18):</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000046BF5" id="P7000497027000000000000000046BF5">
<img alt="A diagram of read_set (Ø) has 0 within bits 3 (listenfd) to 0 (stdin)." class="pcalibre312 pcalibre1 pcalibre2" data-uri="P700049702700000000000000000B7CC" id="P7000497027000000000000000046BF6" src="Images/chapter-11-image-08.png"/>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BF7" id="P7000497027000000000000000046BF7">Next, in lines 19 and 20, we define the read set to consist of descriptor 0 (standard input) and descriptor 3 (the listening descriptor), respectively:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000046BF8" id="P7000497027000000000000000046BF8">
<img alt="A diagram of read_set ({0,3}) has 1 within bits 3 (listenfd) to 0 (stdin), and 0 in bits 2 and 1." class="pcalibre313 pcalibre2 pcalibre1" data-uri="P700049702700000000000000000B7CD" id="P7000497027000000000000000046BF9" src="Images/chapter-11-image-09.png"/>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BFA" id="P7000497027000000000000000046BFA">At this point, we begin the typical server loop. But instead of waiting for a connection request by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BFB" id="P7000497027000000000000000046BFB">accept</code> function, we call the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BFC" id="P7000497027000000000000000046BFC">select</code> function, which blocks until either the listening descriptor or standard input is ready for reading (line 24). For example, here is the value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BFD" id="P7000497027000000000000000046BFD">ready_set</code> that <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BFE" id="P7000497027000000000000000046BFE">select</code> would return if the user hit the enter key, thus causing the standard input descriptor to</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008109" id="P7000497027000000000000000008109">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000810A" epub:type="pagebreak" id="P700049702700000000000000000810A" title="979"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046BFF" id="P7000497027000000000000000046BFF">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/select.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046C00" id="P7000497027000000000000000046C00"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C01" id="P7000497027000000000000000046C01">
1	#include "csapp.h"
2	void echo(int connfd);
3	void command(void);
4	
5	int main(int argc, char **argv)
6	{
7		int listenfd, connfd;
8		socklen_t clientlen;
9		struct sockaddr_storage clientaddr;
10		fd_set read_set, ready_set;
11	
12		if (argc != 2) {
13			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
14			exit(0);
15		}
16		listenfd = Open_listenfd(argv[1]);
17	
18		FD_ZERO(&amp;read_set);			/* Clear read set */
19		FD_SET(STDIN_FILENO, &amp;read_set);	/* Add stdin to read set */
20		FD_SET(listenfd, &amp;read_set);		/* Add listenfd to read set */
21	
22		while (1) {
23			ready_set = read_set;
24			Select(listenfd+1, &amp;ready_set, NULL, NULL, NULL);
25			if (FD_ISSET(STDIN_FILENO, &amp;ready_set))
26				command(); /* Read command line from stdin */
27			if (FD_ISSET(listenfd, &amp;ready_set)) {
28				clientlen = sizeof(struct sockaddr_storage);
29				connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
30				echo(connfd); /* Echo client input until EOF */
31				Close(connfd);
32			}
33		}
34	}
35	
36	void command(void) {
37		char buf[MAXLINE];
38		if (!Fgets(buf, MAXLINE, stdin))
39			exit(0); /* EOF */
40		printf("%s", buf); /* Process the input command */
41	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C02" id="P7000497027000000000000000046C02">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/select.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046C03" id="P7000497027000000000000000046C03"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046C04" epub:type="title" id="P7000497027000000000000000046C04"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.6 </span>An iterative echo server that uses I/O multiplexing.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C05" id="P7000497027000000000000000046C05"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046C06" id="P7000497027000000000000000046C06">The server uses <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C07" id="P7000497027000000000000000046C07">select</code> to wait for connection requests on a listening descriptor and commands on standard input.</p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C08" id="P7000497027000000000000000046C08"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008115" epub:type="pagebreak" id="P7000497027000000000000000008115" title="980"></span>become ready for reading:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000046C09" id="P7000497027000000000000000046C09">
<img alt="A diagram of read_set ({0}) shows 1 within bit 0 (stdin) and 0 in bits 3 (listenfd) to 1." class="pcalibre1 pcalibre2 pcalibre314" data-uri="P700049702700000000000000000B7CE" id="P7000497027000000000000000046C0A" src="Images/chapter-11-image-10.png"/>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C0B" id="P7000497027000000000000000046C0B">Once <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C0C" id="P7000497027000000000000000046C0C">select</code> returns, we use the FD_ISSET macro to determine which descriptors are ready for reading. If standard input is ready (line 25), we call the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C0D" id="P7000497027000000000000000046C0D">command</code> function, which reads, parses, and responds to the command before returning to the main routine. If the listening descriptor is ready (line 27), we call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C0E" id="P7000497027000000000000000046C0E">accept</code> to get a connected descriptor and then call the echo function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E78"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.22</span></a>, which echoes each line from the client until the client closes its end of the connection.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C0F" id="P7000497027000000000000000046C0F">While this program is a good example of using <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C10" id="P7000497027000000000000000046C10">select</code>, it still leaves something to be desired. The problem is that once it connects to a client, it continues echoing input lines until the client closes its end of the connection. Thus, if you type a command to standard input, you will not get a response until the server is finished with the client. A better approach would be to multiplex at a finer granularity, echoing (at most) one text line each time through the server loop.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000811E" epub:type="practice" id="P700049702700000000000000000811E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C11" epub:type="title" id="P7000497027000000000000000046C11"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.3 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P7000497027000000000000000046C12" id="P7000497027000000000000000046C12">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000046C13" id="P7000497027000000000000000046C13">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046C14" id="P7000497027000000000000000046C14"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046C15" id="P7000497027000000000000000046C15">In Linux systems, typing Ctrl+D indicates EOF on standard input. What happens if you type Ctrl+D to the program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008109"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.6</span></a> while it is blocked in the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C16" id="P7000497027000000000000000046C16">select</code>?</p></div></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008125" id="P7000497027000000000000000008125"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C17" epub:type="title" id="P7000497027000000000000000046C17"><span class="pcalibre1 pcalibre21 pcalibre2">12.2.1 </span>A Concurrent Event-Driven Server Based on I/O Multiplexing</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C18" id="P7000497027000000000000000046C18">I/O multiplexing can be used as the basis for concurrent <i class="pcalibre17 pcalibre2 pcalibre1">event-driven</i> programs, where flows make progress as a result of certain events. The general idea is to model logical flows as state machines. Informally, a <i class="pcalibre17 pcalibre2 pcalibre1">state machine</i> is a collection of <i class="pcalibre17 pcalibre2 pcalibre1">states</i>, <i class="pcalibre17 pcalibre2 pcalibre1">input events</i>, and <i class="pcalibre17 pcalibre2 pcalibre1">transitions</i> that map states and input events to states. Each transition maps an (input state, input event) pair to an output state. A <i class="pcalibre17 pcalibre2 pcalibre1">self-loop</i> is a transition between the same input and output state. State machines are typically drawn as directed graphs, where nodes represent states, directed arcs represent transitions, and arc labels represent input events. A state machine begins execution in some initial state. Each input event triggers a transition from the current state to the next state.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C19" id="P7000497027000000000000000046C19">For each new client <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, a concurrent server based on I/O multiplexing creates a new state machine <i class="pcalibre17 pcalibre2 pcalibre1">s<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> and associates it with connected descriptor <i class="pcalibre17 pcalibre2 pcalibre1">d<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i>. As shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008129"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7</span></a>, each state machine <i class="pcalibre17 pcalibre2 pcalibre1">s<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> has one state ("waiting for descriptor <i class="pcalibre17 pcalibre2 pcalibre1">d<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> to be ready for reading"), one input event ("descriptor <i class="pcalibre17 pcalibre2 pcalibre1">d<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> is ready for reading"), and one transition ("read a text line from descriptor <i class="pcalibre17 pcalibre2 pcalibre1">d<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i>").</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008129" id="P7000497027000000000000000008129">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000812A" epub:type="pagebreak" id="P700049702700000000000000000812A" title="981"></span>
<img alt="A diagram illustrates a state machine." class="pcalibre1 pcalibre2 calibre87" data-uri="P700049702700000000000000000B7CF" id="P7000497027000000000000000046C1A" src="Images/chapter-11-image-11.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046C1B" id="P7000497027000000000000000046C1B"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046C1C" epub:type="title" id="P7000497027000000000000000046C1C"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.7 </span>State machine for a logical flow in a concurrent event-driven echo server.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter12.xhtml#P7000497027000000000000000026F8C" id="P7000497027000000000000000026F8C">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046C1D" id="P7000497027000000000000000046C1D">A diagram shows a state machine with State: “waiting for descriptor d<sub class="pcalibre1 pcalibre2 calibre14">k</sub> to be ready for reading.” An arrow on the state loops from input event: “descriptor d<sub class="pcalibre1 pcalibre2 calibre14">k</sub> is ready for reading,” back to the state a transition: “read a text line from descriptor d<sub class="pcalibre1 pcalibre2 calibre14">k</sub>.”</p>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C1E" id="P7000497027000000000000000046C1E">The server uses the I/O multiplexing, courtesy of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C1F" id="P7000497027000000000000000046C1F">select</code> function, to detect the occurrence of input events. As each connected descriptor becomes ready for reading, the server executes the transition for the corresponding state machine—in this case, reading and echoing a text line from the descriptor.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C20" id="P7000497027000000000000000046C20"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008144"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.8</span></a> shows the complete example code for a concurrent event-driven server based on I/O multiplexing. The set of active clients is maintained in a pool structure (lines 3−11). After initializing the pool by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C21" id="P7000497027000000000000000046C21">init_pool</code> (line 27), the server enters an infinite loop. During each iteration of this loop, the server calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C22" id="P7000497027000000000000000046C22">select</code> function to detect two different kinds of input events: (1) a connection request arriving from a new client, and (2) a connected descriptor for an existing client being ready for reading. When a connection request arrives (line 35), the server opens the connection (line 37) and calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C23" id="P7000497027000000000000000046C23">add_client</code> function to add the client to the pool (line 38). Finally, the server calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C24" id="P7000497027000000000000000046C24">check_clients</code> function to echo a single text line from each ready connected descriptor (line 42).</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C25" id="P7000497027000000000000000046C25">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C26" id="P7000497027000000000000000046C26">init_pool</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000814E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.9</span></a>) initializes the client pool. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C27" id="P7000497027000000000000000046C27">clientfd</code> array represents a set of connected descriptors, with the integer −1 denoting an available slot. Initially, the set of connected descriptors is empty (lines 5−7), and the listening descriptor is the only descriptor in the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C28" id="P7000497027000000000000000046C28">select</code> read set (lines 10−12).</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C29" id="P7000497027000000000000000046C29">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C2A" id="P7000497027000000000000000046C2A">add_client</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008157"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.10</span></a>) adds a new client to the pool of active clients. After finding an empty slot in the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C2B" id="P7000497027000000000000000046C2B">clientfd</code> array, the server adds the connected descriptor to the array and initializes a corresponding R<span class="pcalibre1 pcalibre29 pcalibre2">io </span>read buffer so that we can call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C2C" id="P7000497027000000000000000046C2C">rio_readlineb</code> on the descriptor (lines 8−9). We then add the connected descriptor to the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C2D" id="P7000497027000000000000000046C2D">select</code> read set (line 12), and we update some global properties of the pool. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C2E" id="P7000497027000000000000000046C2E">maxfd</code> variable (lines 15−16) keeps track of the largest file descriptor for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C2F" id="P7000497027000000000000000046C2F">select</code>. The maxi variable (lines 17−18) keeps track of the largest index into the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C30" id="P7000497027000000000000000046C30">clientfd</code> array so that the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C31" id="P7000497027000000000000000046C31">check_clients</code> function does not have to search the entire array.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C32" id="P7000497027000000000000000046C32">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C33" id="P7000497027000000000000000046C33">check_clients</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000815F"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.11</span></a> echoes a text line from each ready connected descriptor. If we are successful in reading a text line from the descriptor, then we echo that line back to the client (lines 15−18). Notice that in line 15, we are maintaining a cumulative count of total bytes received from all clients. If we detect EOF because the client has closed its end of the connection, then we close our end of the connection (line 23) and remove the descriptor from the pool (lines 24−25).</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008144" id="P7000497027000000000000000008144">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008145" epub:type="pagebreak" id="P7000497027000000000000000008145" title="982"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C34" id="P7000497027000000000000000046C34">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046C35" id="P7000497027000000000000000046C35"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C36" id="P7000497027000000000000000046C36">
1	#include "csapp.h"
2	
3	typedef struct {	/* Represents a pool of connected descriptors */
4	int maxfd;		/* Largest descriptor in read_set */
5	fd_set read_set;	/* Set of all active descriptors */
6	fd_set ready_set;	/* Subset of descriptors ready for reading */
7	int nready;		/* Number of ready descriptors from select */
8	int maxi;		/* High water index into client array */
9	int clientfd[FD_SETSIZE];	/* Set of active descriptors */
10	rio_t clientrio[FD_SETSIZE];	/* Set of active read buffers */
11	} pool;
12	
13	int byte_cnt = 0;	/* Counts total bytes received by server */
14	
15	int main(int argc, char **argv)
16	{
17		int listenfd, connfd;
18		socklen_t clientlen;
19		struct sockaddr_storage clientaddr;
20		static pool pool;
21	
22		if (argc != 2) {
23			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
24			exit(0);
25		}
26		listenfd = Open_listenfd(argv[1]);
27		init_pool(listenfd, &amp;pool); 28
29		while (1) {
30			/* Wait for listening/connected descriptor(s) to become ready */
31			pool.ready_set = pool.read_set;
32			pool.nready = Select(pool.maxfd+1, &amp;pool.ready_set, NULL, NULL, NULL);
33	
34			/* If listening descriptor ready, add new client to pool */
35			if (FD_ISSET(listenfd, &amp;pool.ready_set)) {
36				clientlen = sizeof(struct sockaddr_storage);
37				connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
38				add_client(connfd, &amp;pool);
39			}
40	
41			/* Echo a text line from each ready connected descriptor */
42			check_clients(&amp;pool);
43		}
44	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C37" id="P7000497027000000000000000046C37">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046C38" id="P7000497027000000000000000046C38"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046C39" epub:type="title" id="P7000497027000000000000000046C39"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.8 </span>Concurrent echo server based on I/O multiplexing.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C3A" id="P7000497027000000000000000046C3A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046C3B" id="P7000497027000000000000000046C3B">Each server iteration echoes a text line from each ready descriptor.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P700049702700000000000000000814E" id="P700049702700000000000000000814E">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000814F" epub:type="pagebreak" id="P700049702700000000000000000814F" title="983"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C3C" id="P7000497027000000000000000046C3C">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046C3D" id="P7000497027000000000000000046C3D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C3E" id="P7000497027000000000000000046C3E">
1	void init_pool(int listenfd, pool *p)
2	{
3		/* Initially, there are no connected descriptors */
4		int i;
5		p-&gt;maxi = −1;
6		for (i=0; i&lt; FD_SETSIZE; i++)
7			p-&gt;clientfd[i] = −1;
8	
9		/* Initially, listenfd is only member of select read set */
10		p-&gt;maxfd = listenfd;
11		FD_ZERO(&amp;p-&gt;read_set);
12		FD_SET(listenfd, &amp;p-&gt;read_set);
13	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C3F" id="P7000497027000000000000000046C3F">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046C40" id="P7000497027000000000000000046C40"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046C41" epub:type="title" id="P7000497027000000000000000046C41"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.9 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C42" id="P7000497027000000000000000046C42">init_pool</code> initializes the pool of active clients.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008157" id="P7000497027000000000000000008157">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C43" id="P7000497027000000000000000046C43">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046C44" id="P7000497027000000000000000046C44"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C45" id="P7000497027000000000000000046C45">
1	void add_client(int connfd, pool *p)
2	{
3		int i;
4		p-&gt;nready−;
5		for (i = 0; i &lt; FD_SETSIZE; i++) /* Find an available slot */
6			if (p-&gt;clientfd[i] &lt; 0) {
7				/* Add connected descriptor to the pool */
8				p-&gt;clientfd[i] = connfd;
9				Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);
10	
11				/* Add the descriptor to descriptor set */
12				FD_SET(connfd, &amp;p-&gt;read_set);
13	
14				/* Update max descriptor and pool high water mark */
15				if (connfd &gt; p-&gt;maxfd)
16					p-&gt;maxfd = connfd;
17				if (i &gt; p-&gt;maxi)
18					p-&gt;maxi = i;
19				break;
20			}
21		if (i == FD_SETSIZE) /* Couldn't find an empty slot */
22			app_error("add_client error: Too many clients");
23	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C46" id="P7000497027000000000000000046C46">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046C47" id="P7000497027000000000000000046C47"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046C48" epub:type="title" id="P7000497027000000000000000046C48"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.10 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C49" id="P7000497027000000000000000046C49">add_client</code> adds a new client connection to the pool.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P700049702700000000000000000815F" id="P700049702700000000000000000815F">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008160" epub:type="pagebreak" id="P7000497027000000000000000008160" title="984"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C4A" id="P7000497027000000000000000046C4A">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046C4B" id="P7000497027000000000000000046C4B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C4C" id="P7000497027000000000000000046C4C">
1	void check_clients(pool *p)
2	{
3		int i, connfd, n;
4		char buf[MAXLINE];
5		rio_t rio;
6	
7		for (i = 0; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready &gt; 0); i++) {
8			connfd = p-&gt;clientfd[i];
9			rio = p-&gt;clientrio[i];
10	
11			/* If the descriptor is ready, echo a text line from it */
12			if ((connfd &gt; 0) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) {
13				p-&gt;nready−;
14				if ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {
15					byte_cnt += n;
16					printf("Server received %d (%d total) bytes on fd %d\n",
17						n, byte_cnt, connfd);
18					Rio_writen(connfd, buf, n);
19				}
20	
21				/* EOF detected, remove descriptor from pool */
22				else {
23					Close(connfd);
24					FD_CLR(connfd, &amp;p-&gt;read_set);
25					p-&gt;clientfd[i] = −1;
26				}
27			}
28		}
29	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C4D" id="P7000497027000000000000000046C4D">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046C4E" id="P7000497027000000000000000046C4E"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046C4F" epub:type="title" id="P7000497027000000000000000046C4F"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.11 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C50" id="P7000497027000000000000000046C50">check_clients</code> services ready client connections.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C51" id="P7000497027000000000000000046C51">In terms of the finite state model in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008129"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7</span></a>, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C52" id="P7000497027000000000000000046C52">select</code> function detects input events, and the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C53" id="P7000497027000000000000000046C53">add_client</code> function creates a new logical flow (state machine). The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C54" id="P7000497027000000000000000046C54">check_clients</code> function performs state transitions by echoing input lines, and it also deletes the state machine when the client has finished sending text lines.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000816C" epub:type="practice" id="P700049702700000000000000000816C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C55" epub:type="title" id="P7000497027000000000000000046C55"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.4 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P7000497027000000000000000046C56" id="P7000497027000000000000000046C56">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000046C57" id="P7000497027000000000000000046C57">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046C58" id="P7000497027000000000000000046C58"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046C59" id="P7000497027000000000000000046C59">In the server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008144"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.8</span></a>, we are careful to reinitialize the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C5A" id="P7000497027000000000000000046C5A">pool.ready_set</code> variable immediately before every call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C5B" id="P7000497027000000000000000046C5B">select</code>. Why?</p></div></li>
</ol>
</section>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000008174" id="P7000497027000000000000000008174"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter12.xhtml#P7000497027000000000000000046C5C" epub:type="title" id="P7000497027000000000000000046C5C"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008176" epub:type="pagebreak" id="P7000497027000000000000000008176" title="985"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Event-driven Web servers</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046C5D" id="P7000497027000000000000000046C5D">Despite the disadvantages outlined in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008178"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">12.2.2</span></a>, modern high-performance servers such as Node.js, nginx, and Tornado use event-driven programming based on I/O multiplexing, mainly because of the significant performance advantage compared to processes and threads.</p>
</aside>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008178" id="P7000497027000000000000000008178"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C5E" epub:type="title" id="P7000497027000000000000000046C5E"><span class="pcalibre1 pcalibre21 pcalibre2">12.2.2 </span>Pros and Cons of I/O Multiplexing</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C5F" id="P7000497027000000000000000046C5F">The server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008144"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.8</span></a> provides a nice example of the advantages and disadvantages of event-driven programming based on I/O multiplexing. One advantage is that event-driven designs give programmers more control over the behavior of their programs than process-based designs. For example, we can imagine writing an event-driven concurrent server that gives preferred service to some clients, which would be difficult for a concurrent server based on processes.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C60" id="P7000497027000000000000000046C60">Another advantage is that an event-driven server based on I/O multiplexing runs in the context of a single process, and thus every logical flow has access to the entire address space of the process. This makes it easy to share data between flows. A related advantage of running as a single process is that you can debug your concurrent server as you would any sequential program, using a familiar debugging tool such as <span class="pcalibre1 pcalibre29 pcalibre2">gdb</span>. Finally, event-driven designs are often significantly more efficient than process-based designs because they do not require a process context switch to schedule a new flow.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C61" id="P7000497027000000000000000046C61">A significant disadvantage of event-driven designs is coding complexity. Our event-driven concurrent echo server requires three times more code than the process-based server. Unfortunately, the complexity increases as the granularity of the concurrency decreases. By <i class="pcalibre17 pcalibre2 pcalibre1">granularity</i>, we mean the number of instructions that each logical flow executes per time slice. For instance, in our example concurrent server, the granularity of concurrency is the number of instructions required to read an entire text line. As long as some logical flow is busy reading a text line, no other logical flow can make progress. This is fine for our example, but it makes our event-driven server vulnerable to a malicious client that sends only a partial text line and then halts. Modifying an event-driven server to handle partial text lines is a nontrivial task, but it is handled cleanly and automatically by a process-based design. Another significant disadvantage of event-based designs is that they cannot fully utilize multi-core processors.</p>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>12.3 Concurrent Programming with Threads</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000817D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046C62" epub:type="title" id="P7000497027000000000000000046C62"><span class="pcalibre1 pcalibre21 pcalibre2">12.3 </span>Concurrent Programming with Threads</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C63" id="P7000497027000000000000000046C63">To this point, we have looked at two approaches for creating concurrent logical flows. With the first approach, we use a separate process for each flow. The kernel schedules each process automatically, and each process has its own private address space, which makes it difficult for flows to share data. With the second approach, we create our own logical flows and use I/O multiplexing to explicitly schedule the flows. Because there is only one process, flows share the entire address space. <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008180" epub:type="pagebreak" id="P7000497027000000000000000008180" title="986"></span>This section introduces a third approach—based on threads—that is a hybrid of these two.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C64" id="P7000497027000000000000000046C64">A <i class="pcalibre17 pcalibre2 pcalibre1">thread</i> is a logical flow that runs in the context of a process. Thus far in this book, our programs have consisted of a single thread per process. But modern systems also allow us to write programs that have multiple threads running concurrently in a single process. The threads are scheduled automatically by the kernel. Each thread has its own <i class="pcalibre17 pcalibre2 pcalibre1">thread context</i>, including a unique integer <i class="pcalibre17 pcalibre2 pcalibre1">thread ID (TID)</i>, stack, stack pointer, program counter, general-purpose registers, and condition codes. All threads running in a process share the entire virtual address space of that process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C65" id="P7000497027000000000000000046C65">Logical flows based on threads combine qualities of flows based on processes and I/O multiplexing. Like processes, threads are scheduled automatically by the kernel and are known to the kernel by an integer ID. Like flows based on I/O multiplexing, multiple threads run in the context of a single process, and thus they share the entire contents of the process virtual address space, including its code, data, heap, shared libraries, and open files.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008183" id="P7000497027000000000000000008183"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C66" epub:type="title" id="P7000497027000000000000000046C66"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.1 </span>Thread Execution Model</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C67" id="P7000497027000000000000000046C67">The execution model for multiple threads is similar in some ways to the execution model for multiple processes. Consider the example in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008189"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.12</span></a>. Each process begins life as a single thread called the <i class="pcalibre17 pcalibre2 pcalibre1">main thread</i>. At some point, the main thread creates a <i class="pcalibre17 pcalibre2 pcalibre1">peer thread</i>, and from this point in time the two threads run concurrently. Eventually, control passes to the peer thread via a context switch, either because the main thread executes a slow system call such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C68" id="P7000497027000000000000000046C68">read</code> or <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C69" id="P7000497027000000000000000046C69">sleep</code> or because it is interrupted by the system's interval timer. The peer thread executes for a while before control passes back to the main thread, and so on.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C6A" id="P7000497027000000000000000046C6A">Thread execution differs from processes in some important ways. Because a thread context is much smaller than a process context, a thread context switch is faster than a process context switch. Another difference is that threads, unlike processes, are not organized in a rigid parent-child hierarchy. The threads associated</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008189" id="P7000497027000000000000000008189">
<img alt="A diagram of concurrent thread execution shows a progression over time from thread 1 (main thread) to thread 2 (peer thread) within the thread context switch, and proceeding in this pattern." class="calibre88 pcalibre1 pcalibre2" data-uri="P700049702700000000000000000B7D0" id="P7000497027000000000000000046C6B" src="Images/chapter-11-image-12.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046C6C" id="P7000497027000000000000000046C6C"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046C6D" epub:type="title" id="P7000497027000000000000000046C6D"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.12 </span>Concurrent thread execution.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C6E" id="P7000497027000000000000000046C6E"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000818E" epub:type="pagebreak" id="P700049702700000000000000000818E" title="987"></span>with a process form a <i class="pcalibre17 pcalibre2 pcalibre1">pool</i> of peers, independent of which threads were created by which other threads. The main thread is distinguished from other threads only in the sense that it is always the first thread to run in the process. The main impact of this notion of a pool of peers is that a thread can kill any of its peers or wait for any of its peers to terminate. Further, each peer can read and write the same shared data.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000818F" id="P700049702700000000000000000818F"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C6F" epub:type="title" id="P7000497027000000000000000046C6F"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.2 </span>Posix Threads</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C70" id="P7000497027000000000000000046C70">Posix threads (Pthreads) is a standard interface for manipulating threads from C programs. It was adopted in 1995 and is available on all Linux systems. Pthreads defines about 60 functions that allow programs to create, kill, and reap threads, to share data safely with peer threads, and to notify peers about changes in the system state.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C71" id="P7000497027000000000000000046C71"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008195"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.13</span></a> shows a simple Pthreads program. The main thread creates a peer thread and then waits for it to terminate. The peer thread prints <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C72" id="P7000497027000000000000000046C72">Hello, world!\n</code> and terminates. When the main thread detects that the peer thread has terminated, it terminates the process by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C73" id="P7000497027000000000000000046C73">exit</code>. This is the first threaded program we have seen, so let us dissect it carefully. The code and local data for a thread are encapsulated in a <i class="pcalibre17 pcalibre2 pcalibre1">thread routine</i>. As shown by the prototype in line 2, each thread routine takes as input a single generic pointer and returns a generic pointer. If you want to pass multiple arguments to a thread routine, then you should put the arguments into a structure and pass a pointer to the structure. Similarly, if you</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008195" id="P7000497027000000000000000008195">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C74" id="P7000497027000000000000000046C74">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/hello.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046C75" id="P7000497027000000000000000046C75"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C76" id="P7000497027000000000000000046C76">
1	#include "csapp.h"
2	void *thread(void *vargp);
3	
4	int main()
5	{
6		pthread_t tid;
7		Pthread_create(&amp;tid, NULL, thread, NULL);
8		Pthread_join(tid, NULL);
9		exit(0);
10	}
11	
12	void *thread(void *vargp) /* Thread routine */
13	{
14		printf("Hello, world!\n");
15		return NULL;
16	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C77" id="P7000497027000000000000000046C77">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/hello.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046C78" id="P7000497027000000000000000046C78"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046C79" epub:type="title" id="P7000497027000000000000000046C79"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.13 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C7A" id="P7000497027000000000000000046C7A">hello.c</code>: The Pthreads "Hello, world!" program.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C7B" id="P7000497027000000000000000046C7B"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000819E" epub:type="pagebreak" id="P700049702700000000000000000819E" title="988"></span>want the thread routine to return multiple arguments, you can return a pointer to a structure.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C7C" id="P7000497027000000000000000046C7C">Line 4 marks the beginning of the code for the main thread. The main thread declares a single local variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C7D" id="P7000497027000000000000000046C7D">tid</code>, which will be used to store the thread ID of the peer thread (line 6). The main thread creates a new peer thread by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C7E" id="P7000497027000000000000000046C7E">pthread_create</code> function (line 7). When the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C7F" id="P7000497027000000000000000046C7F">pthread_create</code> returns, the main thread and the newly created peer thread are running concurrently, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C80" id="P7000497027000000000000000046C80">tid</code> contains the ID of the new thread. The main thread waits for the peer thread to terminate with the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C81" id="P7000497027000000000000000046C81">pthread_join</code> in line 8. Finally, the main thread calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C82" id="P7000497027000000000000000046C82">exit</code> (line 9), which terminates all threads (in this case, just the main thread) currently running in the process.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C83" id="P7000497027000000000000000046C83">Lines 12−16 define the thread routine for the peer thread. It simply prints a string and then terminates the peer thread by executing the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C84" id="P7000497027000000000000000046C84">return</code> statement in line 15.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000081A8" id="P70004970270000000000000000081A8"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C85" epub:type="title" id="P7000497027000000000000000046C85"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.3 </span>Creating Threads</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C86" id="P7000497027000000000000000046C86">Threads create other threads by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C87" id="P7000497027000000000000000046C87">pthread_create</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046C88" id="P7000497027000000000000000046C88"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C89" id="P7000497027000000000000000046C89">
#include &lt;pthread.h&gt;
typedef void *(func)(void *);
int pthread_create(pthread_t *tid, pthread_attr_t *attr,
		   func *f, void *arg);
					Returns: 0 if OK, nonzero on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C8A" id="P7000497027000000000000000046C8A">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C8B" id="P7000497027000000000000000046C8B">pthread_create</code> function creates a new thread and runs the <i class="pcalibre17 pcalibre2 pcalibre1">thread routine</i> <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C8C" id="P7000497027000000000000000046C8C">f</code> in the context of the new thread and with an input argument of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C8D" id="P7000497027000000000000000046C8D">arg</code>. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C8E" id="P7000497027000000000000000046C8E">attr</code> argument can be used to change the default attributes of the newly created thread. Changing these attributes is beyond our scope, and in our examples, we will always call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C8F" id="P7000497027000000000000000046C8F">pthread_create</code> with a NULL <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C90" id="P7000497027000000000000000046C90">attr</code> argument.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C91" id="P7000497027000000000000000046C91">When <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C92" id="P7000497027000000000000000046C92">pthread_create</code> returns, argument <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C93" id="P7000497027000000000000000046C93">tid</code> contains the ID of the newly created thread. The new thread can determine its own thread ID by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C94" id="P7000497027000000000000000046C94">pthread_self</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046C95" id="P7000497027000000000000000046C95"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C96" id="P7000497027000000000000000046C96">
#include &lt;pthread.h&gt;
pthread_t pthread_self(void);
						Returns: thread ID of caller
</code></pre>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000081BB" id="P70004970270000000000000000081BB"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C97" epub:type="title" id="P7000497027000000000000000046C97"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.4 </span>Terminating Threads</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C98" id="P7000497027000000000000000046C98">A thread terminates in one of the following ways:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C99" id="P7000497027000000000000000046C99">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046C9A" id="P7000497027000000000000000046C9A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046C9B" id="P7000497027000000000000000046C9B">The thread terminates <i class="pcalibre17 pcalibre2 pcalibre1">implicitly</i> when its top-level thread routine returns.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046C9C" id="P7000497027000000000000000046C9C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046C9D" id="P7000497027000000000000000046C9D"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000081C3" epub:type="pagebreak" id="P70004970270000000000000000081C3" title="989"></span>The thread terminates <i class="pcalibre17 pcalibre2 pcalibre1">explicitly</i> by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C9E" id="P7000497027000000000000000046C9E">pthread_exit</code> function. If the main thread calls <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046C9F" id="P7000497027000000000000000046C9F">pthread_exit</code>, it waits for all other peer threads to terminate and then terminates the main thread and the entire process with a return value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CA0" id="P7000497027000000000000000046CA0">thread_return</code>.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CA1" id="P7000497027000000000000000046CA1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CA2" id="P7000497027000000000000000046CA2">
#include &lt;pthread.h&gt;
void pthread_exit(void *thread_return);
						Never returns
</code></pre></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CA3" id="P7000497027000000000000000046CA3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046CA4" id="P7000497027000000000000000046CA4">Some peer thread calls the Linux <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CA5" id="P7000497027000000000000000046CA5">exit</code> function, which terminates the process and all threads associated with the process.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CA6" id="P7000497027000000000000000046CA6"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046CA7" id="P7000497027000000000000000046CA7">Another peer thread terminates the current thread by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CA8" id="P7000497027000000000000000046CA8">pthread_cancel</code> function with the ID of the current thread.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CA9" id="P7000497027000000000000000046CA9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CAA" id="P7000497027000000000000000046CAA">
#include &lt;pthread.h&gt;
int pthread_cancel(pthread_t tid);
					Returns: 0 if OK, nonzero on error
</code></pre></li>
</ul>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000081D1" id="P70004970270000000000000000081D1"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CAB" epub:type="title" id="P7000497027000000000000000046CAB"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.5 </span>Reaping Terminated Threads</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CAC" id="P7000497027000000000000000046CAC">Threads wait for other threads to terminate by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CAD" id="P7000497027000000000000000046CAD">pthread_join</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CAE" id="P7000497027000000000000000046CAE"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CAF" id="P7000497027000000000000000046CAF">
#include &lt;pthread.h&gt;
int pthread_join(pthread_t tid, void **thread_return);
					Returns: 0 if OK, nonzero on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB0" id="P7000497027000000000000000046CB0">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB1" id="P7000497027000000000000000046CB1">pthread_join</code> function blocks until thread <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB2" id="P7000497027000000000000000046CB2">tid</code> terminates, assigns the generic (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB3" id="P7000497027000000000000000046CB3">void *</code>) pointer returned by the thread routine to the location pointed to by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB4" id="P7000497027000000000000000046CB4">thread_return</code>, and then <i class="pcalibre17 pcalibre2 pcalibre1">reaps</i> any memory resources held by the terminated thread.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB5" id="P7000497027000000000000000046CB5">Notice that, unlike the Linux <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB6" id="P7000497027000000000000000046CB6">wait</code> function, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB7" id="P7000497027000000000000000046CB7">pthread_join</code> function can only wait for a specific thread to terminate. There is no way to instruct <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB8" id="P7000497027000000000000000046CB8">pthread_join</code> to wait for an <i class="pcalibre17 pcalibre2 pcalibre1">arbitrary</i> thread to terminate. This can complicate our code by forcing us to use other, less intuitive mechanisms to detect process termination. Indeed, Stevens argues convincingly that this is a bug in the specification [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>].</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000081E0" id="P70004970270000000000000000081E0"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB9" epub:type="title" id="P7000497027000000000000000046CB9"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.6 </span>Detaching Threads</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CBA" id="P7000497027000000000000000046CBA">At any point in time, a thread is <i class="pcalibre17 pcalibre2 pcalibre1">joinable</i> or <i class="pcalibre17 pcalibre2 pcalibre1">detached</i>. A joinable thread can be reaped and killed by other threads. Its memory resources (such as the stack) are not freed until it is reaped by another thread. In contrast, a detached thread cannot <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000081E3" epub:type="pagebreak" id="P70004970270000000000000000081E3" title="990"></span>be reaped or killed by other threads. Its memory resources are freed automatically by the system when it terminates.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CBB" id="P7000497027000000000000000046CBB">By default, threads are created joinable. In order to avoid memory leaks, each joinable thread should be either explicitly reaped by another thread or detached by a call to the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CBC" id="P7000497027000000000000000046CBC">pthread_detach</code> function.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CBD" id="P7000497027000000000000000046CBD"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CBE" id="P7000497027000000000000000046CBE">
#include &lt;pthread.h&gt;
int pthread_detach(pthread_t tid);
					Returns: 0 if OK, nonzero on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CBF" id="P7000497027000000000000000046CBF">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC0" id="P7000497027000000000000000046CC0">pthread_detach</code> function detaches the joinable thread <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC1" id="P7000497027000000000000000046CC1">tid</code>. Threads can detach themselves by calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC2" id="P7000497027000000000000000046CC2">pthread_detach</code> with an argument of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC3" id="P7000497027000000000000000046CC3">pthread_self()</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC4" id="P7000497027000000000000000046CC4">Although some of our examples will use joinable threads, there are good reasons to use detached threads in real programs. For example, a high-performance Web server might create a new peer thread each time it receives a connection request from a Web browser. Since each connection is handled independently by a separate thread, it is unnecessary—and indeed undesirable—for the server to explicitly wait for each peer thread to terminate. In this case, each peer thread should detach itself before it begins processing the request so that its memory resources can be reclaimed after it terminates.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000081EE" id="P70004970270000000000000000081EE"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC5" epub:type="title" id="P7000497027000000000000000046CC5"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.7 </span>Initializing Threads</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC6" id="P7000497027000000000000000046CC6">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC7" id="P7000497027000000000000000046CC7">pthread_once</code> function allows you to initialize the state associated with a thread routine.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CC8" id="P7000497027000000000000000046CC8"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC9" id="P7000497027000000000000000046CC9">
#include &lt;pthread.h&gt;
pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *once_control,
		void (*init_routine)(void));
						Always returns 0
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CCA" id="P7000497027000000000000000046CCA">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CCB" id="P7000497027000000000000000046CCB">once_control</code> variable is a global or static variable that is always initialized to PTHREAD_ONCE_INIT. The first time you call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CCC" id="P7000497027000000000000000046CCC">pthread_once</code> with an argument of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CCD" id="P7000497027000000000000000046CCD">once_control</code>, it invokes <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CCE" id="P7000497027000000000000000046CCE">init_routine</code>, which is a function with no input arguments that returns nothing. Subsequent calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CCF" id="P7000497027000000000000000046CCF">pthread_once</code> with the same <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CD0" id="P7000497027000000000000000046CD0">once_control</code> variable do nothing. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CD1" id="P7000497027000000000000000046CD1">pthread_once</code> function is useful whenever you need to dynamically initialize global variables that are shared by multiple threads. We will look at an example in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008456"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5.5</span></a>.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000081FC" id="P70004970270000000000000000081FC"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CD2" epub:type="title" id="P7000497027000000000000000046CD2"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000081FE" epub:type="pagebreak" id="P70004970270000000000000000081FE" title="991"></span><span class="pcalibre1 pcalibre21 pcalibre2">12.3.8 </span>A Concurrent Server Based on Threads</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CD3" id="P7000497027000000000000000046CD3"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008200"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.14</span></a> shows the code for a concurrent echo server based on threads. The overall structure is similar to the process-based design. The main thread repeatedly waits for a connection request and then creates a peer thread to handle the request. While the code looks simple, there are a couple of general and somewhat subtle issues we need to look at more closely. The first issue is how to pass</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008200" id="P7000497027000000000000000008200">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CD4" id="P7000497027000000000000000046CD4">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservert.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CD5" id="P7000497027000000000000000046CD5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CD6" id="P7000497027000000000000000046CD6">
1	#include "csapp.h"
2	
3	void echo(int connfd);
4	void *thread(void *vargp);
5	
6	int main(int argc, char **argv)
7	{
8		int listenfd, *connfdp;
9		socklen_t clientlen;
10		struct sockaddr_storage clientaddr;
11		pthread_t tid;
12	
13		if (argc != 2) {
14			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
15			exit(0);
16		}
17		listenfd = Open_listenfd(argv[1]); 18
19		while (1) {
20			clientlen=sizeof(struct sockaddr_storage);
21			connfdp = Malloc(sizeof(int));
22			*connfdp = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);
23			Pthread_create(&amp;tid, NULL, thread, connfdp);
24		}
25	}
26	
27	/* Thread routine */
28	void *thread(void *vargp)
29	{
30		int connfd = *((int *)vargp);
31		Pthread_detach(pthread_self());
32		Free(vargp);
33		echo(connfd);
34		Close(connfd);
35		return NULL;
36	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CD7" id="P7000497027000000000000000046CD7">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservert.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046CD8" id="P7000497027000000000000000046CD8"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046CD9" epub:type="title" id="P7000497027000000000000000046CD9"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.14 </span>Concurrent echo server based on threads.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CDA" id="P7000497027000000000000000046CDA"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008208" epub:type="pagebreak" id="P7000497027000000000000000008208" title="992"></span>the connected descriptor to the peer thread when we call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CDB" id="P7000497027000000000000000046CDB">pthread_create</code>. The obvious approach is to pass a pointer to the descriptor, as in the following:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CDC" id="P7000497027000000000000000046CDC"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CDD" id="P7000497027000000000000000046CDD">
connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);
Pthread_create(&amp;tid, NULL, thread, &amp;connfd);
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CDE" id="P7000497027000000000000000046CDE">Then we have the peer thread dereference the pointer and assign it to a local variable, as follows:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CDF" id="P7000497027000000000000000046CDF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE0" id="P7000497027000000000000000046CE0">
void *thread(void *vargp) {
	int connfd = *((int *)vargp);
	⋮
}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE1" id="P7000497027000000000000000046CE1">This would be wrong, however, because it introduces a <i class="pcalibre17 pcalibre2 pcalibre1">race</i> between the assignment statement in the peer thread and the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE2" id="P7000497027000000000000000046CE2">accept</code> statement in the main thread. If the assignment statement completes before the next <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE3" id="P7000497027000000000000000046CE3">accept</code>, then the local <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE4" id="P7000497027000000000000000046CE4">connfd</code> variable in the peer thread gets the correct descriptor value. However, if the assignment completes <i class="pcalibre17 pcalibre2 pcalibre1">after</i> the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE5" id="P7000497027000000000000000046CE5">accept</code>, then the local <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE6" id="P7000497027000000000000000046CE6">connfd</code> variable in the peer thread gets the descriptor number of the <i class="pcalibre17 pcalibre2 pcalibre1">next</i> connection. The unhappy result is that two threads are now performing input and output on the same descriptor. In order to avoid the potentially deadly race, we must assign each connected descriptor returned by <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE7" id="P7000497027000000000000000046CE7">accept</code> to its own dynamically allocated memory block, as shown in lines 21−22. We will return to the issue of races in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008577.xhtml#P7000497027000000000000000008610"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7.4</span></a>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE8" id="P7000497027000000000000000046CE8">Another issue is avoiding memory leaks in the thread routine. Since we are not explicitly reaping threads, we must detach each thread so that its memory resources will be reclaimed when it terminates (line 31). Further, we must be careful to free the memory block that was allocated by the main thread (line 32).</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008217" epub:type="practice" id="P7000497027000000000000000008217"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE9" epub:type="title" id="P7000497027000000000000000046CE9"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P7000497027000000000000000046CEA" id="P7000497027000000000000000046CEA">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000046CEB" id="P7000497027000000000000000046CEB">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046CEC" id="P7000497027000000000000000046CEC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046CED" id="P7000497027000000000000000046CED">In the process-based server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008097.xhtml#P70004970270000000000000000080CF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5</span></a>, we were careful to close the connected descriptor in two places: the parent process and the child process. However, in the threads-based server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008200"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.14</span></a>, we only closed the connected descriptor in one place: the peer thread. Why?</p></div></li>
</ol>
</section>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>12.4 Shared Variables in Threaded Programs</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000821D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046CEE" epub:type="title" id="P7000497027000000000000000046CEE"><span class="pcalibre1 pcalibre21 pcalibre2">12.4 </span>Shared Variables in Threaded Programs</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CEF" id="P7000497027000000000000000046CEF">From a programmer's perspective, one of the attractive aspects of threads is the ease with which multiple threads can share the same program variables. However, this sharing can be tricky. In order to write correctly threaded programs, we must have a clear understanding of what we mean by sharing and how it works.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CF0" id="P7000497027000000000000000046CF0">There are some basic questions to work through in order to understand whether a variable in a C program is shared or not: (1) What is the underlying memory model for threads? (2) Given this model, how are instances of the variable mapped to memory? (3) Finally, how many threads reference each of these</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008221" id="P7000497027000000000000000008221">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008222" epub:type="pagebreak" id="P7000497027000000000000000008222" title="993"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CF1" id="P7000497027000000000000000046CF1">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/sharing.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046CF2" id="P7000497027000000000000000046CF2"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CF3" id="P7000497027000000000000000046CF3">
1	#include "csapp.h"
2	#define N 2
3	void *thread(void *vargp);
4	
5	char **ptr; /* Global variable */
6	
7	int main()
8	{
9		int i;
10		pthread_t tid;
11		char *msgs[N] = {
12			"Hello from foo",
13			"Hello from bar"
14		};
15	
16		ptr = msgs;
17		for (i = 0; i &lt; N; i++)
18			Pthread_create(&amp;tid, NULL, thread, (void *)i);
19		Pthread_exit(NULL);
20	}
21	
22	void *thread(void *vargp)
23	{
24		int myid = (int)vargp;
25		static int cnt = 0;
26		printf("[%d]: %s (cnt=%d)\n", myid, ptr[myid], ++cnt);
27		return NULL;
28	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CF4" id="P7000497027000000000000000046CF4">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/sharing.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046CF5" id="P7000497027000000000000000046CF5"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046CF6" epub:type="title" id="P7000497027000000000000000046CF6"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.15 </span>Example program that illustrates different aspects of sharing.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CF7" id="P7000497027000000000000000046CF7">instances? The variable is <i class="pcalibre17 pcalibre2 pcalibre1">shared</i> if and only if multiple threads reference some instance of the variable.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CF8" id="P7000497027000000000000000046CF8">To keep our discussion of sharing concrete, we will use the program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008221"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.15</span></a> as a running example. Although somewhat contrived, it is nonetheless useful to study because it illustrates a number of subtle points about sharing. The example program consists of a main thread that creates two peer threads. The main thread passes a unique ID to each peer thread, which uses the ID to print a personalized message along with a count of the total number of times that the thread routine has been invoked.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000822B" id="P700049702700000000000000000822B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CF9" epub:type="title" id="P7000497027000000000000000046CF9"><span class="pcalibre1 pcalibre21 pcalibre2">12.4.1 </span>Threads Memory Model</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CFA" id="P7000497027000000000000000046CFA">A pool of concurrent threads runs in the context of a process. Each thread has its own separate <i class="pcalibre17 pcalibre2 pcalibre1">thread context</i>, which includes a thread ID, stack, stack pointer, <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000822E" epub:type="pagebreak" id="P700049702700000000000000000822E" title="994"></span>program counter, condition codes, and general-purpose register values. Each thread shares the rest of the process context with the other threads. This includes the entire user virtual address space, which consists of read-only text (code), read/write data, the heap, and any shared library code and data areas. The threads also share the same set of open files.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CFB" id="P7000497027000000000000000046CFB">In an operational sense, it is impossible for one thread to read or write the register values of another thread. On the other hand, any thread can access any location in the shared virtual memory. If some thread modifies a memory location, then every other thread will eventually see the change if it reads that location. Thus, registers are never shared, whereas virtual memory is always shared.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CFC" id="P7000497027000000000000000046CFC">The memory model for the separate thread stacks is not as clean. These stacks are contained in the stack area of the virtual address space and are <i class="pcalibre17 pcalibre2 pcalibre1">usually</i> accessed independently by their respective threads. We say <i class="pcalibre17 pcalibre2 pcalibre1">usually</i> rather than <i class="pcalibre17 pcalibre2 pcalibre1">always</i>, because different thread stacks are not protected from other threads. So if a thread somehow manages to acquire a pointer to another thread's stack, then it can read and write any part of that stack. Our example program shows this in line 26, where the peer threads reference the contents of the main thread's stack indirectly through the global <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CFD" id="P7000497027000000000000000046CFD">ptr</code> variable.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008232" id="P7000497027000000000000000008232"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CFE" epub:type="title" id="P7000497027000000000000000046CFE"><span class="pcalibre1 pcalibre21 pcalibre2">12.4.2 </span>Mapping Variables to Memory</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046CFF" id="P7000497027000000000000000046CFF">Variables in threaded C programs are mapped to virtual memory according to their storage classes:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D00" id="P7000497027000000000000000046D00">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D01" id="P7000497027000000000000000046D01"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000046D02" id="P7000497027000000000000000046D02"><span class="pcalibre1 pcalibre2 pcalibre41">Global variables. </span>A <i class="pcalibre17 pcalibre2 pcalibre1">global variable</i> is any variable declared outside of a function. At run time, the read/write area of virtual memory contains exactly one instance of each global variable that can be referenced by any thread. For example, the global <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D03" id="P7000497027000000000000000046D03">ptr</code> variable declared in line 5 has one run-time instance in the read/write area of virtual memory. When there is only one instance of a variable, we will denote the instance by simply using the variable name—in this case, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D04" id="P7000497027000000000000000046D04">ptr</code>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D05" id="P7000497027000000000000000046D05"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000046D06" id="P7000497027000000000000000046D06"><span class="pcalibre1 pcalibre2 pcalibre41">Local automatic variables. </span>A <i class="pcalibre17 pcalibre2 pcalibre1">local automatic variable</i> is one that is declared inside a function without the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D07" id="P7000497027000000000000000046D07">static</code> attribute. At run time, each thread's stack contains its own instances of any local automatic variables. This is true even if multiple threads execute the same thread routine. For example, there is one instance of the local variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D08" id="P7000497027000000000000000046D08">tid</code>, and it resides on the stack of the main thread. We will denote this instance as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D09" id="P7000497027000000000000000046D09">tid.m.</code> As another example, there are two instances of the local variable myid, one instance on the stack of peer thread 0 and the other on the stack of peer thread 1. We will denote these instances as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D0A" id="P7000497027000000000000000046D0A">myid.p0</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D0B" id="P7000497027000000000000000046D0B">myid.p1</code>, respectively.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D0C" id="P7000497027000000000000000046D0C"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000046D0D" id="P7000497027000000000000000046D0D"><span class="pcalibre1 pcalibre2 pcalibre41">Local static variables. </span>A <i class="pcalibre17 pcalibre2 pcalibre1">local <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D0E" id="P7000497027000000000000000046D0E">static</code> variable</i> is one that is declared inside a function with the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D0F" id="P7000497027000000000000000046D0F">static</code> attribute. As with global variables, the read/write area of virtual memory contains exactly one instance of each local static <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008245" epub:type="pagebreak" id="P7000497027000000000000000008245" title="995"></span>variable declared in a program. For example, even though each peer thread in our example program declares <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D10" id="P7000497027000000000000000046D10">cnt</code> in line 25, at run time there is only one instance of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D11" id="P7000497027000000000000000046D11">cnt</code> residing in the read/write area of virtual memory. Each peer thread reads and writes this instance.</p></li>
</ul>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008248" id="P7000497027000000000000000008248"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D12" epub:type="title" id="P7000497027000000000000000046D12"><span class="pcalibre1 pcalibre21 pcalibre2">12.4.3 </span>Shared Variables</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D13" id="P7000497027000000000000000046D13">We say that a variable <var class="pcalibre17 pcalibre2 pcalibre1">v</var> is <i class="pcalibre17 pcalibre2 pcalibre1">shared</i> if and only if one of its instances is referenced by more than one thread. For example, variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D14" id="P7000497027000000000000000046D14">cnt</code> in our example program is shared because it has only one run-time instance and this instance is referenced by both peer threads. On the other hand, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D15" id="P7000497027000000000000000046D15">myid</code> is not shared, because each of its two instances is referenced by exactly one thread. However, it is important to realize that local automatic variables such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D16" id="P7000497027000000000000000046D16">msgs</code> can also be shared.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000824E" epub:type="practice" id="P700049702700000000000000000824E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D17" epub:type="title" id="P7000497027000000000000000046D17"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.6 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P7000497027000000000000000046D18" id="P7000497027000000000000000046D18">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000046D19" id="P7000497027000000000000000046D19">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D1A" id="P7000497027000000000000000046D1A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D1B" id="P7000497027000000000000000046D1B">Using the analysis from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000821D"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">12.4</span></a>, fill each entry in the following table with "Yes" or "No" for the example program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008221"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.15</span></a>. In the first column, the notation <i class="pcalibre17 pcalibre2 pcalibre1">v.t</i> denotes an instance of variable <var class="pcalibre17 pcalibre2 pcalibre1">v</var> residing on the local stack for thread <var class="pcalibre17 pcalibre2 pcalibre1">t</var>, where <var class="pcalibre17 pcalibre2 pcalibre1">t</var> is either <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D1C" id="P7000497027000000000000000046D1C">m</code> (main thread), <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D1D" id="P7000497027000000000000000046D1D">p0</code> (peer thread 0), or <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D1E" id="P7000497027000000000000000046D1E">p1</code> (peer thread 1).</p></div>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000046D1F" id="P7000497027000000000000000046D1F">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046D20" id="P7000497027000000000000000046D20" rowspan="2">Variable instance</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="3" data-uri="chapter12.xhtml#P7000497027000000000000000046D21" id="P7000497027000000000000000046D21">Referenced by</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046D22" id="P7000497027000000000000000046D22">main thread?</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046D23" id="P7000497027000000000000000046D23">peer thread 0?</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046D24" id="P7000497027000000000000000046D24">peer thread 1?</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D25" id="P7000497027000000000000000046D25"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D26" id="P7000497027000000000000000046D26">ptr</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D27" id="P7000497027000000000000000046D27">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D28" id="P7000497027000000000000000046D28">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D29" id="P7000497027000000000000000046D29">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D2A" id="P7000497027000000000000000046D2A"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D2B" id="P7000497027000000000000000046D2B">cnt</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D2C" id="P7000497027000000000000000046D2C">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D2D" id="P7000497027000000000000000046D2D">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D2E" id="P7000497027000000000000000046D2E">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D2F" id="P7000497027000000000000000046D2F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D30" id="P7000497027000000000000000046D30">i.m</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D31" id="P7000497027000000000000000046D31">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D32" id="P7000497027000000000000000046D32">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D33" id="P7000497027000000000000000046D33">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D34" id="P7000497027000000000000000046D34"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D35" id="P7000497027000000000000000046D35">msgs.m</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D36" id="P7000497027000000000000000046D36">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D37" id="P7000497027000000000000000046D37">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D38" id="P7000497027000000000000000046D38">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D39" id="P7000497027000000000000000046D39"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D3A" id="P7000497027000000000000000046D3A">myid.p0</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D3B" id="P7000497027000000000000000046D3B">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D3C" id="P7000497027000000000000000046D3C">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D3D" id="P7000497027000000000000000046D3D">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D3E" id="P7000497027000000000000000046D3E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D3F" id="P7000497027000000000000000046D3F">myid.p1</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D40" id="P7000497027000000000000000046D40">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D41" id="P7000497027000000000000000046D41">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D42" id="P7000497027000000000000000046D42">_____</td>
</tr>
</tbody>
</table></li>
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000046D43" id="P7000497027000000000000000046D43">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D44" id="P7000497027000000000000000046D44"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D45" id="P7000497027000000000000000046D45">Given the analysis in part A, which of the variables <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D46" id="P7000497027000000000000000046D46">ptr, cnt, i, msgs</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D47" id="P7000497027000000000000000046D47">myid</code> are shared?</p></div></li>
</ol>
</section>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>12.5 Synchronizing Threads with Semaphores</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000827E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046D48" epub:type="title" id="P7000497027000000000000000046D48"><span class="pcalibre1 pcalibre21 pcalibre2">12.5 </span>Synchronizing Threads with Semaphores</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D49" id="P7000497027000000000000000046D49">Shared variables can be convenient, but they introduce the possibility of nasty <i class="pcalibre17 pcalibre2 pcalibre1">synchronization errors</i>. Consider the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D4A" id="P7000497027000000000000000046D4A">badcnt.c</code> program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008286"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.16</span></a>, which creates two threads, each of which increments a global shared counter variable called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D4B" id="P7000497027000000000000000046D4B">cnt</code>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D4C" id="P7000497027000000000000000046D4C">Since each thread increments the counter niters times, we expect its final value to be <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D4D" id="P7000497027000000000000000046D4D">2 × niters</code>. This seems quite simple and straightforward. However, when we run <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D4E" id="P7000497027000000000000000046D4E">badcnt.c</code> on our Linux system, we not only get wrong answers, we get different answers each time!</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008286" id="P7000497027000000000000000008286">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008287" epub:type="pagebreak" id="P7000497027000000000000000008287" title="996"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D4F" id="P7000497027000000000000000046D4F">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/badcnt.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D50" id="P7000497027000000000000000046D50"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D51" id="P7000497027000000000000000046D51">
1	/* WARNING: This code is buggy! */
2	#include "csapp.h"
3	
4	void *thread(void *vargp); /* Thread routine prototype */
5	
6	/* Global shared variable */
7	volatile long cnt = 0; /* Counter */ 8
9	int main(int argc, char **argv)
10	{
11		long niters;
12		pthread_t tid1, tid2;
13	
14		/* Check input argument */
15		if (argc != 2) {
16			printf("usage: %s &lt;niters&gt;\n", argv[0]);
17			exit(0);
18		}
19		niters = atoi(argv[1]);
20	
21		/* Create threads and wait for them to finish */
22		Pthread_create(&amp;tid1, NULL, thread, &amp;niters);
23		Pthread_create(&amp;tid2, NULL, thread, &amp;niters);
24		Pthread_join(tid1, NULL);
25		Pthread_join(tid2, NULL);
26	
27		/* Check result */
28		if (cnt != (2 * niters))
29			printf("BOOM! cnt=%ld\n", cnt);
30		else
31			printf("OK cnt=%ld\n", cnt);
32		exit(0);
33	}
34	
35	/* Thread routine */
36	void *thread(void *vargp)
37	{
38		long i, niters = *((long *)vargp);
39	
40		for (i = 0; i &lt; niters; i++)
41			cnt++;
42	
43		return NULL;
44	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D52" id="P7000497027000000000000000046D52">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/badcnt.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046D53" id="P7000497027000000000000000046D53"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046D54" epub:type="title" id="P7000497027000000000000000046D54"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.16 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D55" id="P7000497027000000000000000046D55">badcnt.c</code>: An improperly synchronized counter program.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D56" id="P7000497027000000000000000046D56"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008290" epub:type="pagebreak" id="P7000497027000000000000000008290" title="997"></span></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D57" id="P7000497027000000000000000046D57"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D58" id="P7000497027000000000000000046D58">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./badcnt 1000000</i>
BOOM! cnt=1445085
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./badcnt 1000000</i>
BOOM! cnt=1915220
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./badcnt 1000000</i>
BOOM! cnt=1404746
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D59" id="P7000497027000000000000000046D59">So what went wrong? To understand the problem clearly, we need to study the assembly code for the counter loop (lines 40−41), as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000082A5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.17</span></a>. We will find it helpful to partition the loop code for thread <var class="pcalibre17 pcalibre2 pcalibre1">i</var> into five parts:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D5A" id="P7000497027000000000000000046D5A">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D5B" id="P7000497027000000000000000046D5B"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000046D5C" id="P7000497027000000000000000046D5C"><i class="pcalibre17 pcalibre2 pcalibre1">H<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>: The block of instructions at the head of the loop</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D5D" id="P7000497027000000000000000046D5D"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000046D5E" id="P7000497027000000000000000046D5E"><i class="pcalibre17 pcalibre2 pcalibre1">L<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>: The instruction that loads the shared variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D5F" id="P7000497027000000000000000046D5F">cnt</code> into the accumulator register %rdx<sub class="pcalibre1 pcalibre2 calibre14"><var class="pcalibre17 pcalibre2 pcalibre1">i</var></sub>, where %rdx<sub class="pcalibre1 pcalibre2 calibre14"><var class="pcalibre17 pcalibre2 pcalibre1">i</var></sub> denotes the value of register %rdx in thread <var class="pcalibre17 pcalibre2 pcalibre1">i</var></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D60" id="P7000497027000000000000000046D60"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000046D61" id="P7000497027000000000000000046D61"><i class="pcalibre17 pcalibre2 pcalibre1">U<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>: The instruction that updates (increments) %rdx<sub class="pcalibre1 pcalibre2 calibre14"><var class="pcalibre17 pcalibre2 pcalibre1">i</var></sub></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D62" id="P7000497027000000000000000046D62"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000046D63" id="P7000497027000000000000000046D63"><i class="pcalibre17 pcalibre2 pcalibre1">S<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>: The instruction that stores the updated value of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D64" id="P7000497027000000000000000046D64">%rdx<sub class="pcalibre97 pcalibre2 pcalibre1"><var class="pcalibre17 pcalibre2 pcalibre1">i</var></sub></code> back to the shared variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D65" id="P7000497027000000000000000046D65">cnt</code></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D66" id="P7000497027000000000000000046D66"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000046D67" id="P7000497027000000000000000046D67"><i class="pcalibre17 pcalibre2 pcalibre1">T<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>: The block of instructions at the tail of the loop</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D68" id="P7000497027000000000000000046D68">Notice that the head and tail manipulate only local stack variables, while <i class="pcalibre17 pcalibre2 pcalibre1">L<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>, <i class="pcalibre17 pcalibre2 pcalibre1">U<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>, and <i class="pcalibre17 pcalibre2 pcalibre1">S<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i> manipulate the contents of the shared counter variable.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D69" id="P7000497027000000000000000046D69">When the two peer threads in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D6A" id="P7000497027000000000000000046D6A">badcnt.c</code> run concurrently on a uniprocessor, the machine instructions are completed one after the other in some order. Thus, each concurrent execution defines some total ordering (or interleaving) of the instructions in the two threads. Unfortunately, some of these orderings will produce correct results, but others will not.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000082A5" id="P70004970270000000000000000082A5">
<img alt="A diagram shows asm code for thread i." class="pcalibre1 pcalibre2 pcalibre315" data-uri="P700049702700000000000000000B7D1" id="P7000497027000000000000000046D6B" src="Images/chapter-11-image-13.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046D6C" id="P7000497027000000000000000046D6C"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046D6D" epub:type="title" id="P7000497027000000000000000046D6D"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.17 </span>Assembly code for the counter loop (lines 40−41) in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D6E" id="P7000497027000000000000000046D6E">badcnt.c.</code></h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter12.xhtml#P70004970270000000000000000270DD" id="P70004970270000000000000000270DD">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D6F" id="P7000497027000000000000000046D6F">A diagram shows C code for thread I leading to asm code for thread i. The c code reads: for (i = 0; i &lt; niters; i++) cnt++;. The asm code of thread i is divided into three parts:</p>
<ul class="pcalibre1 pcalibre2 pcalibre62" data-uri="chapter12.xhtml#P7000497027000000000000000046D70" id="P7000497027000000000000000046D70">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D71" id="P7000497027000000000000000046D71"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D72" id="P7000497027000000000000000046D72">H<sub class="pcalibre1 pcalibre2 calibre14">i</sub>: Head:</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter12.xhtml#P7000497027000000000000000046D73" id="P7000497027000000000000000046D73">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D74" id="P7000497027000000000000000046D74"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D75" id="P7000497027000000000000000046D75">movq (%rdi), %rcx</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D76" id="P7000497027000000000000000046D76"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D77" id="P7000497027000000000000000046D77">testq %rcx, %rcx</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D78" id="P7000497027000000000000000046D78"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D79" id="P7000497027000000000000000046D79">jle .L2</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D7A" id="P7000497027000000000000000046D7A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D7B" id="P7000497027000000000000000046D7B">movl $0, %eax</p></li>
</ul></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D7C" id="P7000497027000000000000000046D7C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D7D" id="P7000497027000000000000000046D7D">L<sub class="pcalibre1 pcalibre2 calibre14">i</sub>: Load cnt, U<sub class="pcalibre1 pcalibre2 calibre14">i</sub>: Update cnt, S<sub class="pcalibre1 pcalibre2 calibre14">i</sub>: Store cnt:</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter12.xhtml#P7000497027000000000000000046D7E" id="P7000497027000000000000000046D7E">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D7F" id="P7000497027000000000000000046D7F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D80" id="P7000497027000000000000000046D80">.L3:</p>
<ul class="pcalibre146 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D81" id="P7000497027000000000000000046D81">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D82" id="P7000497027000000000000000046D82"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D83" id="P7000497027000000000000000046D83">movq cnt(%rip), %rdx</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D84" id="P7000497027000000000000000046D84"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D85" id="P7000497027000000000000000046D85">addq %eax</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D86" id="P7000497027000000000000000046D86"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D87" id="P7000497027000000000000000046D87">movq %eax, cnt(%rip)</p></li>
</ul></li>
</ul></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D88" id="P7000497027000000000000000046D88"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D89" id="P7000497027000000000000000046D89">T<sub class="pcalibre1 pcalibre2 calibre14">i</sub>: Tail:</p>
<ul class="pcalibre1 pcalibre2 pcalibre69" data-uri="chapter12.xhtml#P7000497027000000000000000046D8A" id="P7000497027000000000000000046D8A">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D8B" id="P7000497027000000000000000046D8B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D8C" id="P7000497027000000000000000046D8C">Addq $1, %rax</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D8D" id="P7000497027000000000000000046D8D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D8E" id="P7000497027000000000000000046D8E">Cmpq %rcx, %rax</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D8F" id="P7000497027000000000000000046D8F"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D90" id="P7000497027000000000000000046D90">Jne .L3</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046D91" id="P7000497027000000000000000046D91"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046D92" id="P7000497027000000000000000046D92">.L2:</p></li>
</ul></li>
</ul>
</details>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000082AA" id="P70004970270000000000000000082AA">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000082AB" epub:type="pagebreak" id="P70004970270000000000000000082AB" title="998"></span>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000046D93" id="P7000497027000000000000000046D93">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" colspan="6" data-uri="chapter12.xhtml#P7000497027000000000000000046D94" id="P7000497027000000000000000046D94">(a) Correct ordering</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046D95" id="P7000497027000000000000000046D95">Step</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046D96" id="P7000497027000000000000000046D96">Thread</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046D97" id="P7000497027000000000000000046D97">Instr.</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046D98" id="P7000497027000000000000000046D98"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D99" id="P7000497027000000000000000046D99">%rdx<sub class="pcalibre1 pcalibre2 pcalibre122">1</sub></code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046D9A" id="P7000497027000000000000000046D9A"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D9B" id="P7000497027000000000000000046D9B">%rdx<sub class="pcalibre1 pcalibre2 pcalibre122">2</sub></code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046D9C" id="P7000497027000000000000000046D9C"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046D9D" id="P7000497027000000000000000046D9D">cnt</code></th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D9E" id="P7000497027000000000000000046D9E">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046D9F" id="P7000497027000000000000000046D9F">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DA0" id="P7000497027000000000000000046DA0"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DA1" id="P7000497027000000000000000046DA1">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DA2" id="P7000497027000000000000000046DA2">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DA3" id="P7000497027000000000000000046DA3">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DA4" id="P7000497027000000000000000046DA4">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DA5" id="P7000497027000000000000000046DA5">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DA6" id="P7000497027000000000000000046DA6"><var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DA7" id="P7000497027000000000000000046DA7">0</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DA8" id="P7000497027000000000000000046DA8">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DA9" id="P7000497027000000000000000046DA9">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DAA" id="P7000497027000000000000000046DAA">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DAB" id="P7000497027000000000000000046DAB">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DAC" id="P7000497027000000000000000046DAC"><var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DAD" id="P7000497027000000000000000046DAD">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DAE" id="P7000497027000000000000000046DAE">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DAF" id="P7000497027000000000000000046DAF">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DB0" id="P7000497027000000000000000046DB0">4</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DB1" id="P7000497027000000000000000046DB1">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DB2" id="P7000497027000000000000000046DB2"><var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DB3" id="P7000497027000000000000000046DB3">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DB4" id="P7000497027000000000000000046DB4">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DB5" id="P7000497027000000000000000046DB5">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DB6" id="P7000497027000000000000000046DB6">5</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DB7" id="P7000497027000000000000000046DB7">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DB8" id="P7000497027000000000000000046DB8"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DB9" id="P7000497027000000000000000046DB9">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DBA" id="P7000497027000000000000000046DBA">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DBB" id="P7000497027000000000000000046DBB">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DBC" id="P7000497027000000000000000046DBC">6</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DBD" id="P7000497027000000000000000046DBD">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DBE" id="P7000497027000000000000000046DBE"><var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DBF" id="P7000497027000000000000000046DBF">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DC0" id="P7000497027000000000000000046DC0">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DC1" id="P7000497027000000000000000046DC1">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DC2" id="P7000497027000000000000000046DC2">7</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DC3" id="P7000497027000000000000000046DC3">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DC4" id="P7000497027000000000000000046DC4"><var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DC5" id="P7000497027000000000000000046DC5">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DC6" id="P7000497027000000000000000046DC6">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DC7" id="P7000497027000000000000000046DC7">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DC8" id="P7000497027000000000000000046DC8">8</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DC9" id="P7000497027000000000000000046DC9">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DCA" id="P7000497027000000000000000046DCA"><var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DCB" id="P7000497027000000000000000046DCB">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DCC" id="P7000497027000000000000000046DCC">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DCD" id="P7000497027000000000000000046DCD">2</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DCE" id="P7000497027000000000000000046DCE">9</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DCF" id="P7000497027000000000000000046DCF">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DD0" id="P7000497027000000000000000046DD0"><var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DD1" id="P7000497027000000000000000046DD1">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DD2" id="P7000497027000000000000000046DD2">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DD3" id="P7000497027000000000000000046DD3">2</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DD4" id="P7000497027000000000000000046DD4">10</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DD5" id="P7000497027000000000000000046DD5">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DD6" id="P7000497027000000000000000046DD6"><var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DD7" id="P7000497027000000000000000046DD7">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DD8" id="P7000497027000000000000000046DD8">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DD9" id="P7000497027000000000000000046DD9">2</td>
</tr>
</tbody>
</table>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000046DDA" id="P7000497027000000000000000046DDA">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" colspan="6" data-uri="chapter12.xhtml#P7000497027000000000000000046DDB" id="P7000497027000000000000000046DDB">(b) Incorrect ordering</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046DDC" id="P7000497027000000000000000046DDC">Step</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046DDD" id="P7000497027000000000000000046DDD">Thread</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046DDE" id="P7000497027000000000000000046DDE">Instr.</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046DDF" id="P7000497027000000000000000046DDF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046DE0" id="P7000497027000000000000000046DE0">%rdx<sub class="pcalibre1 pcalibre2 pcalibre122">1</sub></code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046DE1" id="P7000497027000000000000000046DE1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046DE2" id="P7000497027000000000000000046DE2">%rdx<sub class="pcalibre1 pcalibre2 pcalibre122">2</sub></code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046DE3" id="P7000497027000000000000000046DE3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046DE4" id="P7000497027000000000000000046DE4">cnt</code></th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DE5" id="P7000497027000000000000000046DE5">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DE6" id="P7000497027000000000000000046DE6">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DE7" id="P7000497027000000000000000046DE7"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DE8" id="P7000497027000000000000000046DE8">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DE9" id="P7000497027000000000000000046DE9">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DEA" id="P7000497027000000000000000046DEA">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DEB" id="P7000497027000000000000000046DEB">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DEC" id="P7000497027000000000000000046DEC">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DED" id="P7000497027000000000000000046DED"><var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DEE" id="P7000497027000000000000000046DEE">0</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DEF" id="P7000497027000000000000000046DEF">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DF0" id="P7000497027000000000000000046DF0">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DF1" id="P7000497027000000000000000046DF1">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DF2" id="P7000497027000000000000000046DF2">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DF3" id="P7000497027000000000000000046DF3"><var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DF4" id="P7000497027000000000000000046DF4">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DF5" id="P7000497027000000000000000046DF5">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DF6" id="P7000497027000000000000000046DF6">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DF7" id="P7000497027000000000000000046DF7">4</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DF8" id="P7000497027000000000000000046DF8">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DF9" id="P7000497027000000000000000046DF9"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DFA" id="P7000497027000000000000000046DFA">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DFB" id="P7000497027000000000000000046DFB">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DFC" id="P7000497027000000000000000046DFC">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DFD" id="P7000497027000000000000000046DFD">5</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DFE" id="P7000497027000000000000000046DFE">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046DFF" id="P7000497027000000000000000046DFF"><var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E00" id="P7000497027000000000000000046E00">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E01" id="P7000497027000000000000000046E01">0</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E02" id="P7000497027000000000000000046E02">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E03" id="P7000497027000000000000000046E03">6</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E04" id="P7000497027000000000000000046E04">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E05" id="P7000497027000000000000000046E05"><var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E06" id="P7000497027000000000000000046E06">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E07" id="P7000497027000000000000000046E07">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E08" id="P7000497027000000000000000046E08">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E09" id="P7000497027000000000000000046E09">7</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E0A" id="P7000497027000000000000000046E0A">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E0B" id="P7000497027000000000000000046E0B"><var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E0C" id="P7000497027000000000000000046E0C">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E0D" id="P7000497027000000000000000046E0D">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E0E" id="P7000497027000000000000000046E0E">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E0F" id="P7000497027000000000000000046E0F">8</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E10" id="P7000497027000000000000000046E10">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E11" id="P7000497027000000000000000046E11"><var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E12" id="P7000497027000000000000000046E12">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E13" id="P7000497027000000000000000046E13">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E14" id="P7000497027000000000000000046E14">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E15" id="P7000497027000000000000000046E15">9</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E16" id="P7000497027000000000000000046E16">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E17" id="P7000497027000000000000000046E17"><var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E18" id="P7000497027000000000000000046E18">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E19" id="P7000497027000000000000000046E19">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E1A" id="P7000497027000000000000000046E1A">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E1B" id="P7000497027000000000000000046E1B">10</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E1C" id="P7000497027000000000000000046E1C">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E1D" id="P7000497027000000000000000046E1D"><var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E1E" id="P7000497027000000000000000046E1E">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E1F" id="P7000497027000000000000000046E1F">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E20" id="P7000497027000000000000000046E20">1</td>
</tr>
</tbody>
</table>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046E21" id="P7000497027000000000000000046E21"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046E22" epub:type="title" id="P7000497027000000000000000046E22"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.18 </span>Instruction orderings for the first loop iteration in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E23" id="P7000497027000000000000000046E23">badcnt.c.</code></h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E24" id="P7000497027000000000000000046E24">Here is the crucial point: <i class="pcalibre17 pcalibre2 pcalibre1">In general, there is no way for you to predict whether the operating system will choose a correct ordering for your threads.</i> For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000082AA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.18(a)</span></a> shows the step-by-step operation of a correct instruction ordering. After each thread has updated the shared variable cnt, its value in memory is 2, which is the expected result.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E25" id="P7000497027000000000000000046E25">Ontheother hand, the ordering in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000082AA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.18(b)</span></a> produces an incorrect value for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E26" id="P7000497027000000000000000046E26">cnt</code>. The problem occurs because thread 2 loads <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E27" id="P7000497027000000000000000046E27">cnt</code> in step 5, after thread 1 loads <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E28" id="P7000497027000000000000000046E28">cnt</code>in step 2 but before thread 1 stores its updated value in step 6. Thus, each thread ends up storing an updated counter value of 1. We can clarify these notions of correct and incorrect instruction orderings with the help of a device known as a <i class="pcalibre17 pcalibre2 pcalibre1">progress graph</i>, which we introduce in the next section.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008342" epub:type="practice" id="P7000497027000000000000000008342"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E29" epub:type="title" id="P7000497027000000000000000046E29"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P700049702700000000000000000877A">1037</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P7000497027000000000000000046E2A" id="P7000497027000000000000000046E2A">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000046E2B" id="P7000497027000000000000000046E2B">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E2C" id="P7000497027000000000000000046E2C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046E2D" id="P7000497027000000000000000046E2D">Complete the table for the following instruction ordering of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E2E" id="P7000497027000000000000000046E2E">badcnt.c</code>:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000046E2F" id="P7000497027000000000000000046E2F">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E30" id="P7000497027000000000000000046E30">Step</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E31" id="P7000497027000000000000000046E31">Thread</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E32" id="P7000497027000000000000000046E32">Instr.</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E33" id="P7000497027000000000000000046E33"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E34" id="P7000497027000000000000000046E34">%rdx<sub class="pcalibre1 pcalibre2 pcalibre122">1</sub></code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E35" id="P7000497027000000000000000046E35"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E36" id="P7000497027000000000000000046E36">%rdx<sub class="pcalibre1 pcalibre2 pcalibre122">2</sub></code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E37" id="P7000497027000000000000000046E37"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E38" id="P7000497027000000000000000046E38">cnt</code></th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E39" id="P7000497027000000000000000046E39">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E3A" id="P7000497027000000000000000046E3A">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E3B" id="P7000497027000000000000000046E3B"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E3C" id="P7000497027000000000000000046E3C">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E3D" id="P7000497027000000000000000046E3D">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E3E" id="P7000497027000000000000000046E3E">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E3F" id="P7000497027000000000000000046E3F">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E40" id="P7000497027000000000000000046E40">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E41" id="P7000497027000000000000000046E41"><var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E42" id="P7000497027000000000000000046E42">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E43" id="P7000497027000000000000000046E43">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E44" id="P7000497027000000000000000046E44">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E45" id="P7000497027000000000000000046E45">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E46" id="P7000497027000000000000000046E46">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E47" id="P7000497027000000000000000046E47"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E48" id="P7000497027000000000000000046E48">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E49" id="P7000497027000000000000000046E49">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E4A" id="P7000497027000000000000000046E4A">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E4B" id="P7000497027000000000000000046E4B">4</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E4C" id="P7000497027000000000000000046E4C">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E4D" id="P7000497027000000000000000046E4D"><var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E4E" id="P7000497027000000000000000046E4E">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E4F" id="P7000497027000000000000000046E4F">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E50" id="P7000497027000000000000000046E50">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E51" id="P7000497027000000000000000046E51">5</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E52" id="P7000497027000000000000000046E52">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E53" id="P7000497027000000000000000046E53"><var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E54" id="P7000497027000000000000000046E54">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E55" id="P7000497027000000000000000046E55">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E56" id="P7000497027000000000000000046E56">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E57" id="P7000497027000000000000000046E57">6</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E58" id="P7000497027000000000000000046E58">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E59" id="P7000497027000000000000000046E59"><var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E5A" id="P7000497027000000000000000046E5A">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E5B" id="P7000497027000000000000000046E5B">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E5C" id="P7000497027000000000000000046E5C">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E5D" id="P7000497027000000000000000046E5D">7</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E5E" id="P7000497027000000000000000046E5E">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E5F" id="P7000497027000000000000000046E5F"><var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E60" id="P7000497027000000000000000046E60">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E61" id="P7000497027000000000000000046E61">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E62" id="P7000497027000000000000000046E62">_____</td>
</tr>
</tbody>
</table>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000046E63" id="P7000497027000000000000000046E63">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E64" id="P7000497027000000000000000046E64">Step</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E65" id="P7000497027000000000000000046E65">Thread</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E66" id="P7000497027000000000000000046E66">Instr.</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E67" id="P7000497027000000000000000046E67"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E68" id="P7000497027000000000000000046E68">%rdx<sub class="pcalibre1 pcalibre2 pcalibre122">1</sub></code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E69" id="P7000497027000000000000000046E69"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E6A" id="P7000497027000000000000000046E6A">%rdx<sub class="pcalibre1 pcalibre2 pcalibre122">2</sub></code></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046E6B" id="P7000497027000000000000000046E6B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E6C" id="P7000497027000000000000000046E6C">cnt</code></th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E6D" id="P7000497027000000000000000046E6D">8</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E6E" id="P7000497027000000000000000046E6E">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E6F" id="P7000497027000000000000000046E6F"><var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E70" id="P7000497027000000000000000046E70">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E71" id="P7000497027000000000000000046E71">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E72" id="P7000497027000000000000000046E72">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E73" id="P7000497027000000000000000046E73">9</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E74" id="P7000497027000000000000000046E74">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E75" id="P7000497027000000000000000046E75"><var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E76" id="P7000497027000000000000000046E76">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E77" id="P7000497027000000000000000046E77">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E78" id="P7000497027000000000000000046E78">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E79" id="P7000497027000000000000000046E79"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008394" epub:type="pagebreak" id="P7000497027000000000000000008394" title="999"></span>10</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E7A" id="P7000497027000000000000000046E7A">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E7B" id="P7000497027000000000000000046E7B"><var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E7C" id="P7000497027000000000000000046E7C">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E7D" id="P7000497027000000000000000046E7D">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E7E" id="P7000497027000000000000000046E7E">_____</td>
</tr>
</tbody>
</table>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046E7F" id="P7000497027000000000000000046E7F">Does this ordering result in a correct value for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E80" id="P7000497027000000000000000046E80">cnt</code>?</p>
</div></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000839C" id="P700049702700000000000000000839C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E81" epub:type="title" id="P7000497027000000000000000046E81"><span class="pcalibre1 pcalibre21 pcalibre2">12.5.1 </span>Progress Graphs</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E82" id="P7000497027000000000000000046E82">A <i class="pcalibre17 pcalibre2 pcalibre1">progress graph</i> models the execution of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> concurrent threads as a trajectory through an <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-dimensional Cartesian space. Each axis <var class="pcalibre17 pcalibre2 pcalibre1">k</var> corresponds to the progress of thread <var class="pcalibre17 pcalibre2 pcalibre1">k</var>. Each point (<var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">I</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, . . . , <i class="pcalibre17 pcalibre2 pcalibre1">I<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i>) represents the state where thread <var class="pcalibre17 pcalibre2 pcalibre1">k</var> (<var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 1, . . . , <var class="pcalibre17 pcalibre2 pcalibre1">n</var>) has completed instruction <i class="pcalibre17 pcalibre2 pcalibre1">I<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i>. The origin of the graph corresponds to the <i class="pcalibre17 pcalibre2 pcalibre1">initial state</i> where none of the threads has yet completed an instruction.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E83" id="P7000497027000000000000000046E83"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000083A2"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.19</span></a> shows the two-dimensional progress graph for the first loop iteration of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E84" id="P7000497027000000000000000046E84">badcnt.c</code> program. The horizontal axis corresponds to thread 1, the vertical axis to thread 2. Point (<var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>) corresponds to the state where thread 1 has completed <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub> and thread 2 has completed <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E85" id="P7000497027000000000000000046E85">A progress graph models instruction execution as a <i class="pcalibre17 pcalibre2 pcalibre1">transition</i> from one state to another. A transition is represented as a directed edge from one point to an adjacent point. Legal transitions move to the right (an instruction in thread 1 completes) or up (an instruction in thread 2 completes). Two instructions cannot complete at the same time—diagonal transitions are not allowed. Programs never run backward so transitions that move down or to the left are not legal either.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000083A2" id="P70004970270000000000000000083A2">
<img alt="A graph plots thread 2 versus thread 1." class="pcalibre1 pcalibre2 pcalibre316" data-uri="P700049702700000000000000000B7D2" id="P7000497027000000000000000046E86" src="Images/chapter-11-image-14.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046E87" id="P7000497027000000000000000046E87"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046E88" epub:type="title" id="P7000497027000000000000000046E88"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.19 </span>Progress graph for the first loop iteration of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E89" id="P7000497027000000000000000046E89">badcnt.c</code>.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter12.xhtml#P70004970270000000000000000271F8" id="P70004970270000000000000000271F8">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046E8A" id="P7000497027000000000000000046E8A">A graph has Thread 1 on the horizontal axis and Thread 2 on the vertical axis, each with values for H, L, U, S, and T. Point (L<sub class="pcalibre1 pcalibre2 calibre14">1</sub>, S<sub class="pcalibre1 pcalibre2 calibre14">2</sub>) is aligned with thread 1 L and thread 2 S.</p>
</details>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000083A7" id="P70004970270000000000000000083A7">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000083A8" epub:type="pagebreak" id="P70004970270000000000000000083A8" title="1000"></span>
<img alt="A graph of a trajectory flows through thread 1 H and L and U, up to thread 2 L, right to thread 1 T, then up to thread 2 T." class="pcalibre1 pcalibre2 pcalibre317" data-uri="P700049702700000000000000000B694" id="P7000497027000000000000000046E8B" src="Images/chapter-11-image-15.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046E8C" id="P7000497027000000000000000046E8C"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046E8D" epub:type="title" id="P7000497027000000000000000046E8D"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.20 </span>An example trajectory.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E8E" id="P7000497027000000000000000046E8E">The execution history of a program is modeled as a <i class="pcalibre17 pcalibre2 pcalibre1">trajectory</i> through the state space. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000083A7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.20</span></a> shows the trajectory that corresponds to the following instruction ordering:</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter12.xhtml#P7000497027000000000000000046E8F" id="P7000497027000000000000000046E8F">
<m:math altimg="../images/ch12-02.png" altimg-height="19" altimg-width="317" alttext="" data-uri="" display="block"><m:mrow><m:msub><m:mi>H</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>L</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>U</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>H</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>L</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>S</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>T</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>U</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>S</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>T</m:mi><m:mn>2</m:mn></m:msub></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E90" id="P7000497027000000000000000046E90">For thread <var class="pcalibre17 pcalibre2 pcalibre1">i</var>, the instructions (<i class="pcalibre17 pcalibre2 pcalibre1">L<sub class="pcalibre1 pcalibre2 calibre14">i</sub>, U<sub class="pcalibre1 pcalibre2 calibre14">i</sub>, S<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>) that manipulate the contents of the shared variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E91" id="P7000497027000000000000000046E91">cnt</code>constitute a <i class="pcalibre17 pcalibre2 pcalibre1">critical section</i> (with respect to shared variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E92" id="P7000497027000000000000000046E92">cnt</code>) that should not be interleaved with the critical section of the other thread. In other words, we want to ensure that each thread has <i class="pcalibre17 pcalibre2 pcalibre1">mutually exclusive access</i> to the shared variable while it is executing the instructions in its critical section. The phenomenon in general is known as <i class="pcalibre17 pcalibre2 pcalibre1">mutual exclusion</i>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E93" id="P7000497027000000000000000046E93">On the progress graph, the intersection of the two critical sections defines a region of the state space known as an <i class="pcalibre17 pcalibre2 pcalibre1">unsafe region</i>. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000083B5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.21</span></a> shows the unsafe region for the variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E94" id="P7000497027000000000000000046E94">cnt</code>. Notice that the unsafe region abuts, but does not include, the states along its perimeter. For example, states (<var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub><i class="pcalibre17 pcalibre2 pcalibre1">, H</i><sub class="pcalibre1 pcalibre2 calibre14">2</sub>) and (<var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub><i class="pcalibre17 pcalibre2 pcalibre1">, U</i><sub class="pcalibre1 pcalibre2 calibre14">2</sub>) abut the unsafe region, but they are not part of it. A trajectory that skirts the unsafe region is known as a <i class="pcalibre17 pcalibre2 pcalibre1">safe trajectory</i>. Conversely, a trajectory that touches any part of the unsafe region is an <i class="pcalibre17 pcalibre2 pcalibre1">unsafe trajectory</i>. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000083B5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.21</span></a> shows examples of safe and unsafe trajectories through the state space of our example <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E95" id="P7000497027000000000000000046E95">badcnt.c</code> program. The upper trajectory skirts the unsafe region along its left and top sides, and thus is safe. The lower trajectory crosses the unsafe region, and thus is unsafe.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E96" id="P7000497027000000000000000046E96">Any safe trajectory will correctly update the shared counter. In order to guarantee correct execution of our example threaded program—and indeed any concurrent program that shares global data structures—we must somehow <i class="pcalibre17 pcalibre2 pcalibre1">synchronize</i> the threads so that they always have a safe trajectory. A classic approach is based on the idea of a semaphore, which we introduce next.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000083B5" id="P70004970270000000000000000083B5">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000083B6" epub:type="pagebreak" id="P70004970270000000000000000083B6" title="1001"></span>
<img alt="A graph depicts safe and unsafe trajectories." class="pcalibre1 pcalibre318 pcalibre2" data-uri="P700049702700000000000000000B695" id="P7000497027000000000000000046E97" src="Images/chapter-11-image-16.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046E98" id="P7000497027000000000000000046E98"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046E99" epub:type="title" id="P7000497027000000000000000046E99"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.21 </span>Safe and unsafe trajectories.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046E9A" id="P7000497027000000000000000046E9A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046E9B" id="P7000497027000000000000000046E9B">The intersection of the critical regions forms an unsafe region. Trajectories that skirt the unsafe region correctly update the counter variable.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter12.xhtml#P700049702700000000000000002720B" id="P700049702700000000000000002720B">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046E9C" id="P7000497027000000000000000046E9C">A graph of thread 2 versus thread 1 shows an unsafe region between H<sub class="pcalibre1 pcalibre2 calibre14">1</sub> and S<sub class="pcalibre1 pcalibre2 calibre14">1</sub> (critical section wrt cnt) and H<sub class="pcalibre1 pcalibre2 calibre14">2</sub> and S<sub class="pcalibre1 pcalibre2 calibre14">2</sub> (critical section wrt cnt). The unsafe trajectory travels horizontal to U<sub class="pcalibre1 pcalibre2 calibre14">1</sub>, up into the unsafe region to L<sub class="pcalibre1 pcalibre2 calibre14">2</sub>, right to T<sub class="pcalibre1 pcalibre2 calibre14">1</sub>, and up to T<sub class="pcalibre1 pcalibre2 calibre14">2</sub>. A safe trajectory travels vertical to U<sub class="pcalibre1 pcalibre2 calibre14">2</sub>, right to H<sub class="pcalibre1 pcalibre2 calibre14">1</sub>, up to S<sub class="pcalibre1 pcalibre2 calibre14">2</sub>, right to U<sub class="pcalibre1 pcalibre2 calibre14">1</sub>, up to T<sub class="pcalibre1 pcalibre2 calibre14">2</sub>, and right to T<sub class="pcalibre1 pcalibre2 calibre14">1</sub>.</p>
</details>
</figcaption>
</figure>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000083BC" epub:type="practice" id="P70004970270000000000000000083BC"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046E9D" epub:type="title" id="P7000497027000000000000000046E9D"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.8 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008803">1038</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P7000497027000000000000000046E9E" id="P7000497027000000000000000046E9E">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000046E9F" id="P7000497027000000000000000046E9F">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046EA0" id="P7000497027000000000000000046EA0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046EA1" id="P7000497027000000000000000046EA1">Using the progress graph in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000083B5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.21</span></a>, classify the following trajectories as either <i class="pcalibre17 pcalibre2 pcalibre1">safe</i> or <i class="pcalibre17 pcalibre2 pcalibre1">unsafe</i>.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P7000497027000000000000000046EA2" id="P7000497027000000000000000046EA2">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046EA3" id="P7000497027000000000000000046EA3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046EA4" id="P7000497027000000000000000046EA4"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046EA5" id="P7000497027000000000000000046EA5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046EA6" id="P7000497027000000000000000046EA6"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046EA7" id="P7000497027000000000000000046EA7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046EA8" id="P7000497027000000000000000046EA8"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub></p></li>
</ol></div></li>
</ol>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000083C9" id="P70004970270000000000000000083C9"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EA9" epub:type="title" id="P7000497027000000000000000046EA9"><span class="pcalibre1 pcalibre21 pcalibre2">12.5.2 </span>Semaphores</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EAA" id="P7000497027000000000000000046EAA">Edsger Dijkstra, a pioneer of concurrent programming, proposed a classic solution to the problem of synchronizing different execution threads based on a special type of variable called a <i class="pcalibre17 pcalibre2 pcalibre1">semaphore</i>. A semaphore, <var class="pcalibre17 pcalibre2 pcalibre1">s</var>, is a global variable with a nonnegative integer value that can only be manipulated by two special operations, called <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var>:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EAB" id="P7000497027000000000000000046EAB">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046EAC" id="P7000497027000000000000000046EAC"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000046EAD" id="P7000497027000000000000000046EAD"><span class="pcalibre1 pcalibre2 pcalibre41">P (s:</span> If <var class="pcalibre17 pcalibre2 pcalibre1">s</var> is nonzero, then <var class="pcalibre17 pcalibre2 pcalibre1">P</var> decrements <var class="pcalibre17 pcalibre2 pcalibre1">s</var> and returns immediately. If <var class="pcalibre17 pcalibre2 pcalibre1">s</var> is zero, then suspend the thread until <var class="pcalibre17 pcalibre2 pcalibre1">s</var> becomes nonzero and the thread is restarted by a <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operation. After restarting, the <var class="pcalibre17 pcalibre2 pcalibre1">P</var> operation decrements <var class="pcalibre17 pcalibre2 pcalibre1">s</var> and returns control to the caller.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046EAE" id="P7000497027000000000000000046EAE"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000046EAF" id="P7000497027000000000000000046EAF"><span class="pcalibre1 pcalibre2 pcalibre41">V (s):</span> The <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operation increments <var class="pcalibre17 pcalibre2 pcalibre1">s</var> by 1. If there are any threads blocked at a <var class="pcalibre17 pcalibre2 pcalibre1">P</var> operation waiting for <var class="pcalibre17 pcalibre2 pcalibre1">s</var> to become nonzero, then the <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operation restarts exactly one of these threads, which then completes its <var class="pcalibre17 pcalibre2 pcalibre1">P</var> operation by decrementing <var class="pcalibre17 pcalibre2 pcalibre1">s</var>.</p></li>
</ul>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000083D1" id="P70004970270000000000000000083D1"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter12.xhtml#P7000497027000000000000000046EB0" epub:type="title" id="P7000497027000000000000000046EB0"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000083D3" epub:type="pagebreak" id="P70004970270000000000000000083D3" title="1002"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Origin of the names <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var></h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046EB1" id="P7000497027000000000000000046EB1">Edsger Dijkstra (1930−2002) was originally from the Netherlands. The names <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> come from the Dutch words <i class="pcalibre17 pcalibre2 pcalibre1">proberen</i> (to test) and <i class="pcalibre17 pcalibre2 pcalibre1">verhogen</i> (to increment).</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EB2" id="P7000497027000000000000000046EB2">The test and decrement operations in <var class="pcalibre17 pcalibre2 pcalibre1">P</var> occur indivisibly, in the sense that once the semaphore <var class="pcalibre17 pcalibre2 pcalibre1">s</var> becomes nonzero, the decrement of <var class="pcalibre17 pcalibre2 pcalibre1">s</var> occurs without interruption. The increment operation in <var class="pcalibre17 pcalibre2 pcalibre1">V</var> also occurs indivisibly, in that it loads, increments, and stores the semaphore without interruption. Notice that the definition of <var class="pcalibre17 pcalibre2 pcalibre1">V</var> does <i class="pcalibre17 pcalibre2 pcalibre1">not</i> define the order in which waiting threads are restarted. The only requirement is that the <var class="pcalibre17 pcalibre2 pcalibre1">V</var> must restart exactly one waiting thread. <i class="pcalibre17 pcalibre2 pcalibre1">Thus, when several threads are waiting at a semaphore, you cannot predict which one will be restarted as a result of the V.</i></p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EB3" id="P7000497027000000000000000046EB3">The definitions of <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> ensure that a running program can never enter a state where a properly initialized semaphore has a negative value. This property, known as the <i class="pcalibre17 pcalibre2 pcalibre1">semaphore invariant</i>, provides a powerful tool for controlling the trajectories of concurrent programs, as we shall see in the next section.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EB4" id="P7000497027000000000000000046EB4">The Posix standard defines a variety of functions for manipulating semaphores.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046EB5" id="P7000497027000000000000000046EB5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EB6" id="P7000497027000000000000000046EB6">
#include &lt;semaphore.h&gt;
int sem_init(sem_t *sem, 0, unsigned int value);
int sem_wait(sem_t *s); /* P(s) */
int sem_post(sem_t *s); /* V(s) */
						Returns: 0 if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EB7" id="P7000497027000000000000000046EB7">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EB8" id="P7000497027000000000000000046EB8">sem_init</code> function initializes semaphore <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EB9" id="P7000497027000000000000000046EB9">sem</code> to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EBA" id="P7000497027000000000000000046EBA">value</code>. Each semaphore must be initialized before it can be used. For our purposes, the middle argument is always 0. Programs perform <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operations by calling the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EBB" id="P7000497027000000000000000046EBB">sem_wait</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EBC" id="P7000497027000000000000000046EBC">sem_post</code> functions, respectively. For conciseness, we prefer to use the following equivalent <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> wrapper functions instead:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046EBD" id="P7000497027000000000000000046EBD"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EBE" id="P7000497027000000000000000046EBE">
#include "csapp.h"
void P(sem_t *s);	/* Wrapper function for sem_wait */
void V(sem_t *s);	/* Wrapper function for sem_post */
						Returns: nothing
</code></pre>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000083E2" id="P70004970270000000000000000083E2"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EBF" epub:type="title" id="P7000497027000000000000000046EBF"><span class="pcalibre1 pcalibre21 pcalibre2">12.5.3 </span>Using Semaphores for Mutual Exclusion</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EC0" id="P7000497027000000000000000046EC0">Semaphores provide a convenient way to ensure mutually exclusive access to shared variables. The basic idea is to associate a semaphore <var class="pcalibre17 pcalibre2 pcalibre1">s</var>, initially 1, with</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000083E5" id="P70004970270000000000000000083E5">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000083E6" epub:type="pagebreak" id="P70004970270000000000000000083E6" title="1003"></span>
<img alt="A graph plots thread 2 versus thread 1, suing semaphores for mutual exclusion." class="pcalibre1 pcalibre2 pcalibre319" data-uri="P700049702700000000000000000B696" id="P7000497027000000000000000046EC1" src="Images/chapter-11-image-17.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046EC2" id="P7000497027000000000000000046EC2"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046EC3" epub:type="title" id="P7000497027000000000000000046EC3"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.22 </span>Using semaphores for mutual exclusion.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046EC4" id="P7000497027000000000000000046EC4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046EC5" id="P7000497027000000000000000046EC5">The infeasible states where <var class="pcalibre17 pcalibre2 pcalibre1">s</var> &lt; 0 define a <i class="pcalibre17 pcalibre2 pcalibre1">forbidden region</i> that surrounds the unsafe region and prevents any feasible trajectory from touching the unsafe region.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter12.xhtml#P7000497027000000000000000027236" id="P7000497027000000000000000027236">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046EC6" id="P7000497027000000000000000046EC6">A graph of thread 2 versus thread 1 has H, P(s), L, U, S, V(s), and T on each axis. The unsafe region is marked just within the forbidden region, with all values of negative 1 from P(s) to S<sub class="pcalibre1 pcalibre2 calibre14">1</sub> and P(s) to S<sub class="pcalibre1 pcalibre2 calibre14">2</sub>. All values aligned within the region are 0, and all other values are 1.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EC7" id="P7000497027000000000000000046EC7">each shared variable (or related set of shared variables) and then surround the corresponding critical section with <i class="pcalibre17 pcalibre2 pcalibre1">P (s)</i> and <i class="pcalibre17 pcalibre2 pcalibre1">V (s)</i> operations.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EC8" id="P7000497027000000000000000046EC8">A semaphore that is used in this way to protect shared variables is called a <i class="pcalibre17 pcalibre2 pcalibre1">binary semaphore</i> because its value is always 0 or 1. Binary semaphores whose purpose is to provide mutual exclusion are often called <i class="pcalibre17 pcalibre2 pcalibre1">mutexes</i>. Performing a <var class="pcalibre17 pcalibre2 pcalibre1">P</var> operation on a mutex is called <i class="pcalibre17 pcalibre2 pcalibre1">locking</i> the mutex. Similarly, performing the <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operation is called <i class="pcalibre17 pcalibre2 pcalibre1">unlocking</i> the mutex. A thread that has locked but not yet unlocked a mutex is said to be <i class="pcalibre17 pcalibre2 pcalibre1">holding</i> the mutex. A semaphore that is used as a counter for a set of available resources is called a <i class="pcalibre17 pcalibre2 pcalibre1">counting semaphore</i>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EC9" id="P7000497027000000000000000046EC9">The progress graph in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000083E5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.22</span></a> shows how we would use binary semaphores to properly synchronize our example counter program.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046ECA" id="P7000497027000000000000000046ECA">Each state is labeled with the value of semaphore <var class="pcalibre17 pcalibre2 pcalibre1">s</var> in that state. The crucial idea is that this combination of <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operations creates a collection of states, called a <i class="pcalibre17 pcalibre2 pcalibre1">forbidden region</i>, where <var class="pcalibre17 pcalibre2 pcalibre1">s</var> &lt; 0. Because of the semaphore invariant, no feasible trajectory can include one of the states in the forbidden region. And since the forbidden region completely encloses the unsafe region, no feasible trajectory can touch any part of the unsafe region. Thus, every feasible trajectory is safe, and regardless of the ordering of the instructions at run time, the program correctly increments the counter.</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000083F0" id="P70004970270000000000000000083F0"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter12.xhtml#P7000497027000000000000000046ECB" epub:type="title" id="P7000497027000000000000000046ECB"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000083F2" epub:type="pagebreak" id="P70004970270000000000000000083F2" title="1004"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Limitations of progress graphs</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046ECC" id="P7000497027000000000000000046ECC">Progress graphs give us a nice way to visualize concurrent program execution on uniprocessors and to understand why we need synchronization. However, they do have limitations, particularly with respect to concurrent execution on multiprocessors, where a set of CPU/cache pairs share the same main memory. Multiprocessors behave in ways that cannot be explained by progress graphs. In particular, a multiprocessor memory system can be in a state that does not correspond to any trajectory in a progress graph. Regardless, the message remains the same: always synchronize accesses to your shared variables, regardless if you're running on a uniprocessor or a multiprocessor.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046ECD" id="P7000497027000000000000000046ECD">In an operational sense, the forbidden region created by the <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operations makes it impossible for multiple threads to be executing instructions in the enclosed critical region at any point in time. In other words, the semaphore operations ensure mutually exclusive access to the critical region.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046ECE" id="P7000497027000000000000000046ECE">Putting it all together, to properly synchronize the example counter program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008286"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.16</span></a> using semaphores, we first declare a semaphore called mutex:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046ECF" id="P7000497027000000000000000046ECF"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046ED0" id="P7000497027000000000000000046ED0">
volatile long cnt= 0;	/* Counter */
sem_t mutex;		/* Semaphore that protects counter */
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046ED1" id="P7000497027000000000000000046ED1">and then we initialize it to unity in the main routine:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046ED2" id="P7000497027000000000000000046ED2"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046ED3" id="P7000497027000000000000000046ED3">Sem_init(&amp;mutex, 0, 1); /* mutex = 1 */</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046ED4" id="P7000497027000000000000000046ED4">Finally, we protect the update of the shared <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046ED5" id="P7000497027000000000000000046ED5">cnt</code>variable in the thread routine by surrounding it with	<b class="pcalibre1 pcalibre2 pcalibre12"><var class="pcalibre17 pcalibre2 pcalibre1">P</var></b> and	<b class="pcalibre1 pcalibre2 pcalibre12"><var class="pcalibre17 pcalibre2 pcalibre1">V</var></b> operations:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046ED6" id="P7000497027000000000000000046ED6"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046ED7" id="P7000497027000000000000000046ED7">
for (i = 0; i &lt; niters; i++) {
	P(&amp;mutex);
	cnt++;
	V(&amp;mutex);
}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046ED8" id="P7000497027000000000000000046ED8">When we run the properly synchronized program, it now produces the correct answer each time.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046ED9" id="P7000497027000000000000000046ED9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EDA" id="P7000497027000000000000000046EDA">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./goodcnt 1000000</i>
OK cnt=2000000
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./goodcnt 1000000</i>
OK cnt=2000000
</code></pre>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008402" id="P7000497027000000000000000008402"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EDB" epub:type="title" id="P7000497027000000000000000046EDB"><span class="pcalibre1 pcalibre21 pcalibre2">12.5.4 </span>Using Semaphores to Schedule Shared Resources</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EDC" id="P7000497027000000000000000046EDC">Another important use of semaphores, besides providing mutual exclusion, is to schedule accesses to shared resources. In this scenario, a thread uses a semaphore</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008405" id="P7000497027000000000000000008405">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008406" epub:type="pagebreak" id="P7000497027000000000000000008406" title="1005"></span>
<img alt="A diagram shows a producer thread leading to a bounded buffer leading to a consumer thread." class="pcalibre1 pcalibre2 pcalibre320" data-uri="P700049702700000000000000000B697" id="P7000497027000000000000000046EDD" src="Images/chapter-11-image-18.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046EDE" id="P7000497027000000000000000046EDE"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046EDF" epub:type="title" id="P7000497027000000000000000046EDF"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.23 </span>Producer-consumer problem.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EE0" id="P7000497027000000000000000046EE0"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046EE1" id="P7000497027000000000000000046EE1">The producer generates items and inserts them into a bounded buffer. The consumer removes items from the buffer and then consumes them.</p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EE2" id="P7000497027000000000000000046EE2">operation to notify another thread that some condition in the program state has become true. Two classical and useful examples are the <i class="pcalibre17 pcalibre2 pcalibre1">producer-consumer</i> and <i class="pcalibre17 pcalibre2 pcalibre1">readers-writers</i> problems.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000840D" id="P700049702700000000000000000840D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EE3" epub:type="title" id="P7000497027000000000000000046EE3">Producer-Consumer Problem</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EE4" id="P7000497027000000000000000046EE4">The <i class="pcalibre17 pcalibre2 pcalibre1">producer-consumer</i> problem is shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008405"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.23</span></a>. A producer and consumer thread share a <i class="pcalibre17 pcalibre2 pcalibre1">bounded buffer</i> with <i class="pcalibre17 pcalibre2 pcalibre1">n slots</i>. The producer thread repeatedly produces new <i class="pcalibre17 pcalibre2 pcalibre1">items</i> and inserts them in the buffer. The consumer thread repeatedly removes items from the buffer and then consumes (uses) them. Variants with multiple producers and consumers are also possible.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EE5" id="P7000497027000000000000000046EE5">Since inserting and removing items involves updating shared variables, we must guarantee mutually exclusive access to the buffer. But guaranteeing mutual exclusion is not sufficient. We also need to schedule accesses to the buffer. If the buffer is full (there are no empty slots), then the producer must wait until a slot becomes available. Similarly, if the buffer is empty (there are no available items), then the consumer must wait until an item becomes available.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EE6" id="P7000497027000000000000000046EE6">Producer-consumer interactions occur frequently in real systems. For example, in a multimedia system, the producer might encode video frames while the consumer decodes and renders them on the screen. The purpose of the buffer is to reduce jitter in the video stream caused by data-dependent differences in the encoding and decoding times for individual frames. The buffer provides a reservoir of slots to the producer and a reservoir of encoded frames to the consumer. Another common example is the design of graphical user interfaces. The producer detects mouse and keyboard events and inserts them in the buffer. The consumer removes the events from the buffer in some priority-based manner and paints the screen.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EE7" id="P7000497027000000000000000046EE7">In this section, we will develop a simple package, called S<span class="pcalibre1 pcalibre29 pcalibre2">buf</span>, for building producer-consumer programs. In the next section, we look at how to use it to build an interesting concurrent server based on prethreading. S<span class="pcalibre1 pcalibre29 pcalibre2">buf </span>manipulates bounded buffers of type <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EE8" id="P7000497027000000000000000046EE8">sbuf_t</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000841A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.24</span></a>). Items are stored in a dynamically allocated integer array (<code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EE9" id="P7000497027000000000000000046EE9">buf</code>) with n items. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EEA" id="P7000497027000000000000000046EEA">front</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EEB" id="P7000497027000000000000000046EEB">rear</code> indices keep track of the first and last items in the array. Three semaphores synchronize access to the buffer. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EEC" id="P7000497027000000000000000046EEC">mutex</code> semaphore provides mutually exclusive buffer access. Semaphores <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EED" id="P7000497027000000000000000046EED">slots</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EEE" id="P7000497027000000000000000046EEE">items</code> are counting semaphores that count the number of empty slots and available items, respectively.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P700049702700000000000000000841A" id="P700049702700000000000000000841A">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000841B" epub:type="pagebreak" id="P700049702700000000000000000841B" title="1006"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EEF" id="P7000497027000000000000000046EEF">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/sbuf.h</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046EF0" id="P7000497027000000000000000046EF0"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EF1" id="P7000497027000000000000000046EF1">
1	typedef struct {	
2		int *buf;		/* Buffer array */
3		int n;			/* Maximum number of slots */
4		int front;		/* buf[(front+1)%n] is first item */
5		int rear;		/* buf[rear%n] is last item */
6		sem_t mutex;		/* Protects accesses to buf */
7		sem_t slots;		/* Counts available slots */
8		sem_t items;		/* Counts available items */
9	} sbuf_t;	
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EF2" id="P7000497027000000000000000046EF2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/sbuf.h</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046EF3" id="P7000497027000000000000000046EF3"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046EF4" epub:type="title" id="P7000497027000000000000000046EF4"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.24 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EF5" id="P7000497027000000000000000046EF5">sbuf_t</code>: Bounded buffer used by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EF6" id="P7000497027000000000000000046EF6">S<span class="pcalibre1 pcalibre2 pcalibre84">buf</span></code> package.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EF7" id="P7000497027000000000000000046EF7"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000843D"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.25</span></a> shows the implementation of the S<span class="pcalibre1 pcalibre29 pcalibre2">buf </span>package. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EF8" id="P7000497027000000000000000046EF8">sbuf_init</code> function allocates heap memory for the buffer, sets <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EF9" id="P7000497027000000000000000046EF9">front</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EFA" id="P7000497027000000000000000046EFA">rear</code> to indicate an empty buffer, and assigns initial values to the three semaphores. This function is called once, before calls to any of the other three functions. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EFB" id="P7000497027000000000000000046EFB">sbuf_deinit</code> function frees the buffer storage when the application is through using it. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EFC" id="P7000497027000000000000000046EFC">sbuf_insert</code> function waits for an available slot, locks the mutex, adds the item, unlocks the mutex, and then announces the availability of a new item. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EFD" id="P7000497027000000000000000046EFD">sbuf_remove</code> function is symmetric. After waiting for an available buffer item, it locks the mutex, removes the item from the front of the buffer, unlocks the mutex, and then signals the availability of a new slot.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000842B" epub:type="practice" id="P700049702700000000000000000842B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046EFE" epub:type="title" id="P7000497027000000000000000046EFE"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.9 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008803">1038</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P7000497027000000000000000046EFF" id="P7000497027000000000000000046EFF">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P700049702700000000000000000842E" id="P700049702700000000000000000842E">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046F00" id="P7000497027000000000000000046F00"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F01" id="P7000497027000000000000000046F01">Let <var class="pcalibre17 pcalibre2 pcalibre1">p</var> denote the number of producers, <var class="pcalibre17 pcalibre2 pcalibre1">c</var> the number of consumers, and <var class="pcalibre17 pcalibre2 pcalibre1">n</var> the buffer size in units of items. For each of the following scenarios, indicate whether the mutex semaphore in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F02" id="P7000497027000000000000000046F02">sbuf_insert</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F03" id="P7000497027000000000000000046F03">sbuf_remove</code> is necessary or not.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P7000497027000000000000000046F04" id="P7000497027000000000000000046F04">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046F05" id="P7000497027000000000000000046F05"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F06" id="P7000497027000000000000000046F06"><var class="pcalibre17 pcalibre2 pcalibre1">p</var> = 1, <var class="pcalibre17 pcalibre2 pcalibre1">c</var> = 1, <var class="pcalibre17 pcalibre2 pcalibre1">n</var> &gt; 1</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046F07" id="P7000497027000000000000000046F07"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F08" id="P7000497027000000000000000046F08"><var class="pcalibre17 pcalibre2 pcalibre1">p</var> = 1, <var class="pcalibre17 pcalibre2 pcalibre1">c</var> = 1, <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 1</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046F09" id="P7000497027000000000000000046F09"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F0A" id="P7000497027000000000000000046F0A"><var class="pcalibre17 pcalibre2 pcalibre1">p</var> &gt; 1, <var class="pcalibre17 pcalibre2 pcalibre1">c</var> &gt; 1, <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 1</p></li>
</ol></div></li>
</ol>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000843A" id="P700049702700000000000000000843A"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F0B" epub:type="title" id="P7000497027000000000000000046F0B">Readers-Writers Problem</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F0C" id="P7000497027000000000000000046F0C">The <i class="pcalibre17 pcalibre2 pcalibre1">readers-writers problem</i> is a generalization of the mutual exclusion problem. A collection of concurrent threads is accessing a shared object such as a data structure in main memory or a database on disk. Some threads only read the object, while others modify it. Threads that modify the object are called <i class="pcalibre17 pcalibre2 pcalibre1">writers</i>. Threads that only read it are called <i class="pcalibre17 pcalibre2 pcalibre1">readers</i>. Writers must have exclusive access to the object, but readers may share the object with an unlimited number of other readers. In general, there are an unbounded number of concurrent readers and writers.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P700049702700000000000000000843D" id="P700049702700000000000000000843D">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000843E" epub:type="pagebreak" id="P700049702700000000000000000843E" title="1007"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F0D" id="P7000497027000000000000000046F0D">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/sbuf.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046F0E" id="P7000497027000000000000000046F0E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F0F" id="P7000497027000000000000000046F0F">
1	#include "csapp.h"
2	#include "sbuf.h"
3	
4	/* Create an empty, bounded, shared FIFO buffer with n slots */
5	void sbuf_init(sbuf_t *sp, int n)
6	{
7		sp-&gt;buf = Calloc(n, sizeof(int));
8		sp-&gt;n =n;			/*Buffer holds maxofnitems */
9		sp-&gt;front = sp-&gt;rear = 0;	/* Empty buffer iff front == rear */
10		Sem_init(&amp;sp-&gt;mutex, 0, 1);	/* Binary semaphore for locking */
11		Sem_init(&amp;sp-&gt;slots, 0, n);	/* Initially, buf has n empty slots */
12		Sem_init(&amp;sp-&gt;items, 0, 0);	/* Initially, buf has zero data items */
13	}
14	
15	/* Clean up buffer sp */
16	void sbuf_deinit(sbuf_t *sp)
17	{
18		Free(sp-&gt;buf);
19	}
20	
21	/* Insert item onto the rear of shared buffer sp */
22	void sbuf_insert(sbuf_t *sp, int item)
23	{
24		P(&amp;sp-&gt;slots);				/* Wait for available slot */
25		P(&amp;sp-&gt;mutex);				/*Lock the buffer */
26		sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item;	/* Insert the item */
27		V(&amp;sp-&gt;mutex);				/* Unlock the buffer */
28		V(&amp;sp-&gt;items);				/* Announce available item */
29	}
30	
31	/* Remove and return the first item from buffer sp */
32	int sbuf_remove(sbuf_t *sp)
33	{
34		int item;
35		P(&amp;sp-&gt;items);				/* Wait for available item */
36		P(&amp;sp-&gt;mutex);				/*Lock the buffer */
37		item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];	/* Remove the item */
38		V(&amp;sp-&gt;mutex);				/* Unlock the buffer */
39		V(&amp;sp-&gt;slots);				/* Announce available slot */
40		return item;
41	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F10" id="P7000497027000000000000000046F10">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/sbuf.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046F11" id="P7000497027000000000000000046F11"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046F12" epub:type="title" id="P7000497027000000000000000046F12"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.25 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F13" id="P7000497027000000000000000046F13">S<span class="pcalibre1 pcalibre2 pcalibre84">buf</span></code>: A package for synchronizing concurrent access to bounded buffers.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F14" id="P7000497027000000000000000046F14"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008447" epub:type="pagebreak" id="P7000497027000000000000000008447" title="1008"></span>Readers-writers interactions occur frequently in real systems. For example, in an online airline reservation system, an unlimited number of customers are al-lowed to concurrently inspect the seat assignments, but a customer who is booking a seat must have exclusive access to the database. As another example, in a multithreaded caching Web proxy, an unlimited number of threads can fetch existing pages from the shared page cache, but any thread that writes a new page to the cache must have exclusive access.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F15" id="P7000497027000000000000000046F15">The readers-writers problem has several variations, each based on the priorities of readers and writers. The <i class="pcalibre17 pcalibre2 pcalibre1">first readers-writers problem</i>, which favors readers, requires that no reader be kept waiting unless a writer has already been granted permission to use the object. In other words, no reader should wait simply because a writer is waiting. The <i class="pcalibre17 pcalibre2 pcalibre1">second readers-writers problem</i>, which favors writers, requires that once a writer is ready to write, it performs its write as soon as possible. Unlike the first problem, a reader that arrives after a writer must wait, even if the writer is also waiting.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F16" id="P7000497027000000000000000046F16"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008459"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.26</span></a> shows a solution to the first readers-writers problem. Like the solutions to many synchronization problems, it is subtle and deceptively simple. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F17" id="P7000497027000000000000000046F17">w</code> semaphore controls access to the critical sections that access the shared object. The mutex semaphore protects access to the shared <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F18" id="P7000497027000000000000000046F18">readcnt</code> variable, which counts the number of readers currently in the critical section. A writer locks thew mutex each time it enters the critical section and unlocks it each time it leaves. This guarantees that there is at most one writer in the critical section at any point in time. On the other hand, only the first reader to enter the critical section locks <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F19" id="P7000497027000000000000000046F19">w</code>, and only the last reader to leave the critical section unlocks it. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F1A" id="P7000497027000000000000000046F1A">w</code> mutex is ignored by readers who enter and leave while other readers are present. This means that as long as a single reader holds the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F1B" id="P7000497027000000000000000046F1B">w</code> mutex, an unbounded number of readers can enter the critical section unimpeded.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F1C" id="P7000497027000000000000000046F1C">A correct solution to either of the readers-writers problems can result in <i class="pcalibre17 pcalibre2 pcalibre1">starvation</i>, where a thread blocks indefinitely and fails to make progress. For example, in the solution in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008459"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.26</span></a>, a writer could wait indefinitely while a stream of readers arrived.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008450" epub:type="practice" id="P7000497027000000000000000008450"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F1D" epub:type="title" id="P7000497027000000000000000046F1D"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.10 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008803">1038</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P7000497027000000000000000046F1E" id="P7000497027000000000000000046F1E">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000046F1F" id="P7000497027000000000000000046F1F">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046F20" id="P7000497027000000000000000046F20"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F21" id="P7000497027000000000000000046F21">The solution to the first readers-writers problem in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008459"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.26</span></a> gives priority to readers, but this priority is weak in the sense that a writer leaving its critical section might restart a waiting writer instead of a waiting reader. Describe a scenario where this weak priority would allow a collection of writers to starve a reader.</p></div></li>
</ol>
</section>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008456" id="P7000497027000000000000000008456"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F22" epub:type="title" id="P7000497027000000000000000046F22"><span class="pcalibre1 pcalibre21 pcalibre2">12.5.5 </span>Putting It Together: A Concurrent Server Based on Prethreading</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F23" id="P7000497027000000000000000046F23">We have seen how semaphores can be used to access shared variables and to schedule accesses to shared resources. To help you understand these ideas more clearly, let us apply them to a concurrent server based on a technique called <i class="pcalibre17 pcalibre2 pcalibre1">prethreading</i>.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008459" id="P7000497027000000000000000008459">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000845A" epub:type="pagebreak" id="P700049702700000000000000000845A" title="1009"></span>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046F24" id="P7000497027000000000000000046F24"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F25" id="P7000497027000000000000000046F25">
/* Global variables */
int readcnt; /* Initially = 0 */
sem_t mutex, w; /* Both initially = 1 */
void reader(void)
{
	while (1) {
		P(&amp;mutex);
		readcnt++;
		if (readcnt == 1) /* First in */
			P(&amp;w);
		V(&amp;mutex);
		/* Critical section */
		/* Reading happens */
		P(&amp;mutex);
		readcnt−;
		if (readcnt == 0) /* Last out */
			V(&amp;w);
		V(&amp;mutex);
	}
}
void writer(void)
{
	while (1) {
		P(&amp;w);
		/* Critical section */
		/* Writing happens */
		V(&amp;w);
	}
}
</code></pre>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046F26" id="P7000497027000000000000000046F26"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046F27" epub:type="title" id="P7000497027000000000000000046F27"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.26 </span>Solution to the first readers-writers problem.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F28" id="P7000497027000000000000000046F28"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F29" id="P7000497027000000000000000046F29">Favors readers over writers.</p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F2A" id="P7000497027000000000000000046F2A">In the concurrent server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000817D.xhtml#P7000497027000000000000000008200"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.14</span></a>, we created a new thread for each new client. A disadvantage of this approach is that we incur the nontrivial cost of creating a new thread for each new client. A server based on prethreading tries to reduce this overhead by using the producer-consumer model shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008466"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.27</span></a>. The server consists of a main thread and a set of worker threads. The main thread repeatedly accepts connection requests from clients and places</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000008462" id="P7000497027000000000000000008462"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter12.xhtml#P7000497027000000000000000046F2B" epub:type="title" id="P7000497027000000000000000046F2B"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008464" epub:type="pagebreak" id="P7000497027000000000000000008464" title="1010"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Other synchronization mechanisms</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F2C" id="P7000497027000000000000000046F2C">We have shown you how to synchronize threads using semaphores, mainly because they are simple, classical, and have a clean semantic model. But you should know that other synchronization techniques exist as well. For example, Java threads are synchronized with a mechanism called a <i class="pcalibre17 pcalibre2 pcalibre1">Java monitor</i> [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B402">48</a>], which provides a higher-level abstraction of the mutual exclusion and scheduling capabilities of semaphores; in fact, monitors can be implemented with semaphores. As another example, the Pthreads interface defines a set of synchronization operations on <i class="pcalibre17 pcalibre2 pcalibre1">mutex</i> and <i class="pcalibre17 pcalibre2 pcalibre1">condition</i> variables. Pthreads mutexes are used for mutual exclusion. Condition variables are used for scheduling accesses to shared resources, such as the bounded buffer in a producer-consumer program.</p>
</aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008466" id="P7000497027000000000000000008466">
<img alt="A diagram illustrates the organization of a prethreaded concurrent server." class="pcalibre1 pcalibre2 pcalibre321" data-uri="P700049702700000000000000000B698" id="P7000497027000000000000000046F2D" src="Images/chapter-11-image-19.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046F2E" id="P7000497027000000000000000046F2E"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046F2F" epub:type="title" id="P7000497027000000000000000046F2F"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.27 </span>Organization of a prethreaded concurrent server.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046F30" id="P7000497027000000000000000046F30"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F31" id="P7000497027000000000000000046F31">A set of existing threads repeatedly remove and process connected descriptors from a bounded buffer.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter12.xhtml#P70004970270000000000000000272A3" id="P70004970270000000000000000272A3">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F32" id="P7000497027000000000000000046F32">A diagram shows accepted connections from clients to a master thread; insert descriptors from master thread to buffer; remove descriptors from buffer to worker threads (within a pool of worker threads); and service client from the worker threads back to separate clients.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F33" id="P7000497027000000000000000046F33">the resulting connected descriptors in a bounded buffer. Each worker thread repeatedly removes a descriptor from the buffer, services the client, and then waits for the next descriptor.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F34" id="P7000497027000000000000000046F34"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008478"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.28</span></a> shows how we would use the S<span class="pcalibre1 pcalibre29 pcalibre2">buf </span>package to implement a prethreaded concurrent echo server. After initializing buffer <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F35" id="P7000497027000000000000000046F35">sbuf</code> (line 24), the main thread creates the set of worker threads (lines 25−26). Then it enters the infinite server loop, accepting connection requests and inserting the resulting connected descriptors in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F36" id="P7000497027000000000000000046F36">sbuf</code>. Each worker thread has a very simple behavior. It waits until it is able to remove a connected descriptor from the buffer (line 39) and then calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F37" id="P7000497027000000000000000046F37">echo_cnt</code> function to echo client input.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F38" id="P7000497027000000000000000046F38">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F39" id="P7000497027000000000000000046F39">echo_cnt</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008482"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.29</span></a> is a version of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F3A" id="P7000497027000000000000000046F3A">echo</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E78"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.22</span></a> that records the cumulative number of bytes received from all clients in a global variable called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F3B" id="P7000497027000000000000000046F3B">byte_cnt</code>. This is interesting code to study because it shows you a general technique for initializing packages that are called from thread routines. In our case, we need to initialize the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F3C" id="P7000497027000000000000000046F3C">byte_cnt</code> counter and the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F3D" id="P7000497027000000000000000046F3D">mutex</code> semaphore. One approach, which we used for the S<span class="pcalibre1 pcalibre29 pcalibre2">buf </span>and R<span class="pcalibre1 pcalibre29 pcalibre2">io </span>packages, is to require the main thread to explicitly call an initialization function. Another approach, shown here, uses the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F3E" id="P7000497027000000000000000046F3E">pthread_once</code> function (line 19) to call</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008478" id="P7000497027000000000000000008478">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008479" epub:type="pagebreak" id="P7000497027000000000000000008479" title="1011"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F3F" id="P7000497027000000000000000046F3F">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservert-pre.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046F40" id="P7000497027000000000000000046F40"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F41" id="P7000497027000000000000000046F41">
1	#include "csapp.h"
2	#include "sbuf.h"
3	#define NTHREADS 4
4	#define SBUFSIZE 16
5	
6	void echo_cnt(int connfd);
7	void *thread(void *vargp);
8	
9	sbuf_t sbuf; /* Shared buffer of connected descriptors */
10	
11	int main(int argc, char **argv)
12	{
13		int i, listenfd, connfd;
14		socklen_t clientlen;
15		struct sockaddr_storage clientaddr;
16		pthread_t tid;
17	
18		if (argc != 2) {
19			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
20			exit(0);
21		}
22		listenfd = Open_listenfd(argv[1]);
23	
24		sbuf_init(&amp;sbuf, SBUFSIZE);
25		for (i = 0; i &lt; NTHREADS; i++)	/* Create worker threads */
26			Pthread_create(&amp;tid, NULL, thread, NULL);
27	
28		while (1) {
29			clientlen = sizeof(struct sockaddr_storage);
30			connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);
31			sbuf_insert(&amp;sbuf, connfd); /* Insert connfd in buffer */
32		}
33	}
34	
35	void *thread(void *vargp)
36	{
37		Pthread_detach(pthread_self());
38		while (1) {
39			int connfd = sbuf_remove(&amp;sbuf);	/* Remove connfd from buffer */
40			echo_cnt(connfd);			/* Service client */
41			Close(connfd);
42		}
43	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F42" id="P7000497027000000000000000046F42">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservert-pre.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046F43" id="P7000497027000000000000000046F43"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046F44" epub:type="title" id="P7000497027000000000000000046F44"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.28 </span>A prethreaded concurrent echo server.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F45" id="P7000497027000000000000000046F45"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F46" id="P7000497027000000000000000046F46">The server uses a producer-consumer model with one producer and multiple consumers.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008482" id="P7000497027000000000000000008482">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008483" epub:type="pagebreak" id="P7000497027000000000000000008483" title="1012"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F47" id="P7000497027000000000000000046F47">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echo-cnt.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046F48" id="P7000497027000000000000000046F48"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F49" id="P7000497027000000000000000046F49">
1	#include "csapp.h"
2	
3	static int byte_cnt;	/* Byte counter */
4	static sem_t mutex;	/* and the mutex that protects it */
5	
6	static void init_echo_cnt(void)
7	{
8		Sem_init(&amp;mutex, 0, 1);
9		byte_cnt = 0;
10	}
11	
12	void echo_cnt(int connfd)
13	{
14		int n;
15		char buf[MAXLINE];
16		rio_t rio;
17		static pthread_once_t once = PTHREAD_ONCE_INIT;
18	
19		Pthread_once(&amp;once, init_echo_cnt);
20		Rio_readinitb(&amp;rio, connfd);
21		while((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {
22			P(&amp;mutex);
23			byte_cnt += n;
24			printf("server received %d (%d total) bytes on fd %d\n",
25				n, byte_cnt, connfd);
26			V(&amp;mutex);
27			Rio_writen(connfd, buf, n);
28		}
29	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F4A" id="P7000497027000000000000000046F4A">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echo-cnt.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046F4B" id="P7000497027000000000000000046F4B"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046F4C" epub:type="title" id="P7000497027000000000000000046F4C"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.29 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F4D" id="P7000497027000000000000000046F4D">echo_cnt</code>: A version of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F4E" id="P7000497027000000000000000046F4E">echo</code> that counts all bytes received from clients.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F4F" id="P7000497027000000000000000046F4F">the initialization function the first time some thread calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F50" id="P7000497027000000000000000046F50">echo_cnt</code> function. The advantage of this approach is that it makes the package easier to use. The disadvantage is that every call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F51" id="P7000497027000000000000000046F51">echo_cnt</code> makes a call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F52" id="P7000497027000000000000000046F52">pthread_once</code>, which most times does nothing useful.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F53" id="P7000497027000000000000000046F53">Once the package is initialized, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F54" id="P7000497027000000000000000046F54">echo_cnt</code> function initializes the R<span class="pcalibre1 pcalibre29 pcalibre2">io </span>buffered I/O package (line 20) and then echoes each text line that is received from the client. Notice that the accesses to the shared <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F55" id="P7000497027000000000000000046F55">byte_cnt</code> variable in lines 23−25 are protected by <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operations.</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000008493" id="P7000497027000000000000000008493"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" data-uri="chapter12.xhtml#P7000497027000000000000000046F56" epub:type="title" id="P7000497027000000000000000046F56"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008495" epub:type="pagebreak" id="P7000497027000000000000000008495" title="1013"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Event-driven programs based on threads</h1></header>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F57" id="P7000497027000000000000000046F57">I/O multiplexing is not the only way to write an event-driven program. For example, you might have noticed that the concurrent prethreaded server that we just developed is really an event-driven server with simple state machines for the main and worker threads. The main thread has two states ("waiting for connection request" and "waiting for available buffer slot"), two I/O events ("connection request arrives" and "buffer slot becomes available"), and two transitions ("accept connection request" and "insert buffer item"). Similarly, each worker thread has one state ("waiting for available buffer item"), one I/O event ("buffer item becomes available"), and one transition ("remove buffer item").</p>
</aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008497" id="P7000497027000000000000000008497">
<img alt="A diagram shows all programs divided among concurrent programs and sequential programs. Parallel programs are within concurrent programs." class="pcalibre1 pcalibre2 pcalibre322" data-uri="P700049702700000000000000000B699" id="P7000497027000000000000000046F58" src="Images/chapter-11-image-20.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046F59" id="P7000497027000000000000000046F59"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046F5A" epub:type="title" id="P7000497027000000000000000046F5A"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.30 </span>Relationships between the sets of sequential, concurrent, and parallel programs.</h1></header>
</figcaption>
</figure>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>12.6 Using Threads for Parallelism</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000849B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046F5B" epub:type="title" id="P7000497027000000000000000046F5B"><span class="pcalibre1 pcalibre21 pcalibre2">12.6 </span>Using Threads for Parallelism</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F5C" id="P7000497027000000000000000046F5C">Thus far in our study of concurrency, we have assumed concurrent threads exe-cuting on uniprocessor systems. However, most modern machines have multi-core processors. Concurrent programs often run faster on such machines because the operating system kernel schedules the concurrent threads in parallel on multiple cores, rather than sequentially on a single core. Exploiting such parallelism is critically important in applications such as busy Web servers, database servers, and large scientific codes, and it is becoming increasingly useful in mainstream applications such as Web browsers, spreadsheets, and document processors.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F5D" id="P7000497027000000000000000046F5D"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008497"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.30</span></a> shows the set relationships between sequential, concurrent, and parallel programs. The set of all programs can be partitioned into the disjoint sets of sequential and concurrent programs. A sequential program is written as a single logical flow. A concurrent program is written as multiple concurrent flows. A parallel program is a concurrent program running on multiple processors. Thus, the set of parallel programs is a proper subset of the set of concurrent programs.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F5E" id="P7000497027000000000000000046F5E">A detailed treatment of parallel programs is beyond our scope, but studying a few simple example programs will help you understand some important aspects of parallel programming. For example, consider how we might sum the sequence of integers 0, . . . , <var class="pcalibre17 pcalibre2 pcalibre1">n</var> − 1 in parallel. Of course, there is a closed-form solution for this particular problem, but nonetheless it is a concise and easy-to-understand exemplar that will allow us to make some interesting points about parallel programs.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F5F" id="P7000497027000000000000000046F5F">The most straightforward approach for assigning work to different threads is to partition the sequence into <var class="pcalibre17 pcalibre2 pcalibre1">t</var> disjoint regions and then assign each of <var class="pcalibre17 pcalibre2 pcalibre1">t</var> different <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000084A1" epub:type="pagebreak" id="P70004970270000000000000000084A1" title="1014"></span>threads to work on its own region. For simplicity, assume that <var class="pcalibre17 pcalibre2 pcalibre1">n</var> is a multiple of <var class="pcalibre17 pcalibre2 pcalibre1">t</var>, such that each region has <i class="pcalibre17 pcalibre2 pcalibre1">n/t</i> elements. Let's look at some of the different ways that multiple threads might work on their assigned regions in parallel.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F60" id="P7000497027000000000000000046F60">The simplest and most straightforward option is to have the threads sum into a shared global variable that is protected by a mutex. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000084BD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.31</span></a> shows how we might implement this. In lines 28−33, the main thread creates the peer threads and then waits for them to terminate. Notice that the main thread passes a small integer to each peer thread that serves as a unique thread ID. Each peer thread will use its thread ID to determine which portion of the sequence it should work on. This idea of passing a small unique thread ID to the peer threads is a general technique that is used in many parallel applications. After the peer threads have terminated, the global variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F61" id="P7000497027000000000000000046F61">gsum</code> contains the final sum. The main thread then uses the closed-form solution to verify the result (lines 36−37).</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F62" id="P7000497027000000000000000046F62"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000084C8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.32</span></a> shows the function that each peer thread executes. In line 4, the thread extracts the thread ID from the thread argument and then uses this ID to determine the region of the sequence it should work on (lines 5−6). In lines 9−13, the thread iterates over its portion of the sequence, updating the shared global variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F63" id="P7000497027000000000000000046F63">gsum</code> on each iteration. Notice that we are careful to protect each update with <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> mutex operations.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F64" id="P7000497027000000000000000046F64">When we run <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F65" id="P7000497027000000000000000046F65">psum-mutex</code> on a system with four cores on a sequence of size <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 2<sup class="pcalibre1 pcalibre2 pcalibre85">31</sup> and measure its running time (in seconds) as a function of the number of threads, we get a nasty surprise:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000046F66" id="P7000497027000000000000000046F66">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F67" id="P7000497027000000000000000046F67"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="5" data-uri="chapter12.xhtml#P7000497027000000000000000046F68" id="P7000497027000000000000000046F68">Number of threads</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F69" id="P7000497027000000000000000046F69">Version</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F6A" id="P7000497027000000000000000046F6A">1</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F6B" id="P7000497027000000000000000046F6B">2</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F6C" id="P7000497027000000000000000046F6C">4</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F6D" id="P7000497027000000000000000046F6D">8</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F6E" id="P7000497027000000000000000046F6E">16</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046F6F" id="P7000497027000000000000000046F6F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F70" id="P7000497027000000000000000046F70">psum-mutex</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046F71" id="P7000497027000000000000000046F71">68</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046F72" id="P7000497027000000000000000046F72">432</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046F73" id="P7000497027000000000000000046F73">719</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046F74" id="P7000497027000000000000000046F74">552</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046F75" id="P7000497027000000000000000046F75">599</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F76" id="P7000497027000000000000000046F76">Not only is the program extremely slow when it runs sequentially as a single thread, it is nearly an order of magnitude slower when it runs in parallel as multiple threads. And the performance gets worse as we add more cores. The reason for this poor performance is that the synchronization operations (<var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var>) are very expensive relative to the cost of a single memory update. This highlights an important lesson about parallel programming: <i class="pcalibre17 pcalibre2 pcalibre1">Synchronization overhead is expensive and should be avoided if possible. If it cannot be avoided, the overhead should be amortized by as much useful computation as possible.</i></p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F77" id="P7000497027000000000000000046F77">One way to avoid synchronization in our example program is to have each peer thread compute its partial sum in a private variable that is not shared with any other thread, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000084D3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.33</span></a>. The main thread (not shown) defines a global array called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F78" id="P7000497027000000000000000046F78">psum</code>, and each peer thread <var class="pcalibre17 pcalibre2 pcalibre1">i</var> accumulates its partial sum in <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F79" id="P7000497027000000000000000046F79">psum[i]</code>. Since we are careful to give each peer thread a unique memory location to update, it is not necessary to protect these updates with mutexes. The only necessary synchronization is that the main thread must wait for all of the children to finish. After the peer threads have terminated, the main thread sums up the elements of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F7A" id="P7000497027000000000000000046F7A">psum</code> vector to arrive at the final result.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000084BD" id="P70004970270000000000000000084BD">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000084BE" epub:type="pagebreak" id="P70004970270000000000000000084BE" title="1015"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F7B" id="P7000497027000000000000000046F7B">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/psum-mutex.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046F7C" id="P7000497027000000000000000046F7C"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F7D" id="P7000497027000000000000000046F7D">
1	#include "csapp.h"
2	#define MAXTHREADS 32
3	
4	void *sum_mutex(void *vargp); /* Thread routine */
5	
6	/* Global shared variables */
7	long gsum = 0;		/* Global sum */
8	long nelems_per_thread;	/* Number of elements to sum */
9	sem_t mutex;		/* Mutex to protect global sum */
10	
11	int main(int argc, char **argv)
12	{
13		long i, nelems, log_nelems, nthreads, myid[MAXTHREADS];
14		pthread_t tid[MAXTHREADS]; 15
16		/* Get input arguments */
17		if (argc != 3) {
18			printf("Usage: %s &lt;nthreads&gt; &lt;log_nelems&gt;\n", argv[0]);
19			exit(0);
20		}
21		nthreads = atoi(argv[1]);
22		log_nelems = atoi(argv[2]);
23		nelems = (1L &lt;&lt; log_nelems);
24		nelems_per_thread = nelems / nthreads;
25		sem_init(&amp;mutex, 0, 1);
26	
27		/* Create peer threads and wait for them to finish */
28		for (i = 0; i &lt; nthreads; i++) {
29			myid[i] = i;
30			Pthread_create(&amp;tid[i], NULL, sum_mutex, &amp;myid[i]);
31		}
32		for (i = 0; i &lt; nthreads; i++)
33			Pthread_join(tid[i], NULL);
34	
35		/* Check final answer */
36		if (gsum != (nelems * (nelems-1))/2)
37			printf("Error: result=%ld\n", gsum); 38
39		exit(0);
40	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F7E" id="P7000497027000000000000000046F7E">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/psum-mutex.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046F7F" id="P7000497027000000000000000046F7F"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046F80" epub:type="title" id="P7000497027000000000000000046F80"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.31 </span>Main routine for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F81" id="P7000497027000000000000000046F81">psum-mutex</code>.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F82" id="P7000497027000000000000000046F82"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F83" id="P7000497027000000000000000046F83">Uses multiple threads to sum the elements of a sequence into a shared global variable protected by a mutex.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000084C8" id="P70004970270000000000000000084C8">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000084C9" epub:type="pagebreak" id="P70004970270000000000000000084C9" title="1016"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F84" id="P7000497027000000000000000046F84">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/psum-mutex.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046F85" id="P7000497027000000000000000046F85"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F86" id="P7000497027000000000000000046F86">
1	/* Thread routine for psum-mutex.c */
2	void *sum_mutex(void *vargp)
3	{
4		long myid = *((long *)vargp);		/* Extract the thread ID */
5		long start = myid * nelems_per_thread;	/* Start element index */
6		long end = start + nelems_per_thread;	/* End element index */
7		long i;
8	
9		for (i = start; i &lt; end; i++) {
10			P(&amp;mutex);
11			gsum += i;
12			V(&amp;mutex);
13		}
14		return NULL;
15	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F87" id="P7000497027000000000000000046F87">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/psum-mutex.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046F88" id="P7000497027000000000000000046F88"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046F89" epub:type="title" id="P7000497027000000000000000046F89"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.32 </span>Thread routine for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F8A" id="P7000497027000000000000000046F8A">psum-mutex</code>.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F8B" id="P7000497027000000000000000046F8B"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F8C" id="P7000497027000000000000000046F8C">Each peer thread sums into a shared global variable protected by a mutex.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000084D3" id="P70004970270000000000000000084D3">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F8D" id="P7000497027000000000000000046F8D">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/psum-array.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046F8E" id="P7000497027000000000000000046F8E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F8F" id="P7000497027000000000000000046F8F">
1	/* Thread routine for psum-array.c */
2	void *sum_array(void *vargp)
3	{
4		long myid = *((long *)vargp);		/* Extract the thread ID */
5		long start = myid * nelems_per_thread;	/* Start element index */
6		long end = start + nelems_per_thread;	/* End element index */
7		long i;
8	
9		for (i = start; i &lt; end; i++) {
10			psum[myid] += i;
11		}
12		return NULL;
13	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F90" id="P7000497027000000000000000046F90">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/psum-array.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046F91" id="P7000497027000000000000000046F91"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046F92" epub:type="title" id="P7000497027000000000000000046F92"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.33 </span>Thread routine for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F93" id="P7000497027000000000000000046F93">psum-array</code>.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F94" id="P7000497027000000000000000046F94"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046F95" id="P7000497027000000000000000046F95">Each peer thread accumulates its partial sum in a private array element that is not shared with any other peer thread.</p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F96" id="P7000497027000000000000000046F96"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000084DE" epub:type="pagebreak" id="P70004970270000000000000000084DE" title="1017"></span>When we run <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F97" id="P7000497027000000000000000046F97">psum-array</code> on our four-core system, we see that it runs orders of magnitude faster than <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046F98" id="P7000497027000000000000000046F98">psum-mutex</code>:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000046F99" id="P7000497027000000000000000046F99">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F9A" id="P7000497027000000000000000046F9A"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="5" data-uri="chapter12.xhtml#P7000497027000000000000000046F9B" id="P7000497027000000000000000046F9B">Number of threads</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F9C" id="P7000497027000000000000000046F9C">Version</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F9D" id="P7000497027000000000000000046F9D">1</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F9E" id="P7000497027000000000000000046F9E">2</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046F9F" id="P7000497027000000000000000046F9F">4</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046FA0" id="P7000497027000000000000000046FA0">8</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046FA1" id="P7000497027000000000000000046FA1">16</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FA2" id="P7000497027000000000000000046FA2"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FA3" id="P7000497027000000000000000046FA3">psum-mutex</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FA4" id="P7000497027000000000000000046FA4">68.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FA5" id="P7000497027000000000000000046FA5">432.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FA6" id="P7000497027000000000000000046FA6">719.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FA7" id="P7000497027000000000000000046FA7">552.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FA8" id="P7000497027000000000000000046FA8">599.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FA9" id="P7000497027000000000000000046FA9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FAA" id="P7000497027000000000000000046FAA">psum-array</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FAB" id="P7000497027000000000000000046FAB">7.26</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FAC" id="P7000497027000000000000000046FAC">3.64</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FAD" id="P7000497027000000000000000046FAD">1.91</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FAE" id="P7000497027000000000000000046FAE">1.85</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FAF" id="P7000497027000000000000000046FAF">1.84</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FB0" id="P7000497027000000000000000046FB0">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004893.xhtml#P7000497027000000000000000004893"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">5</span></a>, we learned how to use local variables to eliminate unnecessary memory references. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008518"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.34</span></a> shows how we can apply this principle by having each peer thread accumulate its partial sum into a local variable rather than a global variable. When we run <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FB1" id="P7000497027000000000000000046FB1">psum-local</code> on our four-core machine, we get another order-of-magnitude decrease in running time:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000046FB2" id="P7000497027000000000000000046FB2">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046FB3" id="P7000497027000000000000000046FB3"></th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="5" data-uri="chapter12.xhtml#P7000497027000000000000000046FB4" id="P7000497027000000000000000046FB4">Number of threads</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046FB5" id="P7000497027000000000000000046FB5">Version</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046FB6" id="P7000497027000000000000000046FB6">1</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046FB7" id="P7000497027000000000000000046FB7">2</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046FB8" id="P7000497027000000000000000046FB8">4</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046FB9" id="P7000497027000000000000000046FB9">8</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000046FBA" id="P7000497027000000000000000046FBA">16</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FBB" id="P7000497027000000000000000046FBB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FBC" id="P7000497027000000000000000046FBC">psum-mutex</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FBD" id="P7000497027000000000000000046FBD">68.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FBE" id="P7000497027000000000000000046FBE">432.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FBF" id="P7000497027000000000000000046FBF">719.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FC0" id="P7000497027000000000000000046FC0">552.00</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FC1" id="P7000497027000000000000000046FC1">599.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FC2" id="P7000497027000000000000000046FC2"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FC3" id="P7000497027000000000000000046FC3">psum-array</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FC4" id="P7000497027000000000000000046FC4">7.26</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FC5" id="P7000497027000000000000000046FC5">3.64</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FC6" id="P7000497027000000000000000046FC6">1.91</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FC7" id="P7000497027000000000000000046FC7">1.85</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FC8" id="P7000497027000000000000000046FC8">1.84</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FC9" id="P7000497027000000000000000046FC9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FCA" id="P7000497027000000000000000046FCA">psum-local</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FCB" id="P7000497027000000000000000046FCB">1.06</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FCC" id="P7000497027000000000000000046FCC">0.54</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FCD" id="P7000497027000000000000000046FCD">0.28</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FCE" id="P7000497027000000000000000046FCE">0.29</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FCF" id="P7000497027000000000000000046FCF">0.30</td>
</tr>
</tbody>
</table>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008518" id="P7000497027000000000000000008518">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FD0" id="P7000497027000000000000000046FD0">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/psum-local.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000046FD1" id="P7000497027000000000000000046FD1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FD2" id="P7000497027000000000000000046FD2">
1	/* Thread routine for psum-local.c */
2	void *sum_local(void *vargp)
3	{
4		long myid = *((long *)vargp);		/* Extract the thread ID */
5		long start = myid * nelems_per_thread;	/* Start element index */
6		long end = start + nelems_per_thread;	/* End element index */
7		long i, sum = 0;
8	
9		for (i = start; i &lt; end; i++) {
10			sum += i;
11		}
12		psum[myid] = sum;
13		return NULL;
14	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FD3" id="P7000497027000000000000000046FD3">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/psum-local.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046FD4" id="P7000497027000000000000000046FD4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046FD5" epub:type="title" id="P7000497027000000000000000046FD5"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.34 </span>Thread routine for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FD6" id="P7000497027000000000000000046FD6">psum-local</code>.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FD7" id="P7000497027000000000000000046FD7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046FD8" id="P7000497027000000000000000046FD8">Each peer thread accumulates its partial sum in a local variable.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008522" id="P7000497027000000000000000008522">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008523" epub:type="pagebreak" id="P7000497027000000000000000008523" title="1018"></span>
<img alt="A graph of elapsed time versus thread shows 1.06 seconds at thread 1, 0.54 seconds at thread 2, 0.28 seconds at thread 4, 0.29 seconds at thread 8, and 0.3 seconds at thread 16." class="calibre89 pcalibre2 pcalibre1" data-uri="P700049702700000000000000000B69A" id="P7000497027000000000000000046FD9" src="Images/chapter-11-image-21.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000046FDA" id="P7000497027000000000000000046FDA"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000046FDB" epub:type="title" id="P7000497027000000000000000046FDB"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.35 </span>Performance of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FDC" id="P7000497027000000000000000046FDC">psum-local</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008518"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.34</span></a>).</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FDD" id="P7000497027000000000000000046FDD"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000046FDE" id="P7000497027000000000000000046FDE">Summing a sequence of 2<sup class="pcalibre1 pcalibre2 pcalibre85">31</sup> elements using four processor cores.</p></div>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FDF" id="P7000497027000000000000000046FDF">An important lesson to take away from this exercise is that writing parallel programs is tricky. Seemingly small changes to the code have a significant impact on performance.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000852B" id="P700049702700000000000000000852B">
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000852C" id="P700049702700000000000000000852C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FE0" epub:type="title" id="P7000497027000000000000000046FE0">Characterizing the Performance of Parallel Programs</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FE1" id="P7000497027000000000000000046FE1"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008522"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.35</span></a> plots the total elapsed running time of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FE2" id="P7000497027000000000000000046FE2">psum-local</code> program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008518"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.34</span></a> as a function of the number of threads. In each case, the program runs on a system with four processor cores and sums a sequence of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 2<sup class="pcalibre1 pcalibre2 pcalibre85">31</sup> elements. We see that running time decreases as we increase the number of threads, up to four threads, at which point it levels off and even starts to increase a little.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FE3" id="P7000497027000000000000000046FE3">In the ideal case, we would expect the running time to decrease linearly with the number of cores. That is, we would expect running time to drop by half each time we double the number of threads. This is indeed the case until we reach the point (<var class="pcalibre17 pcalibre2 pcalibre1">t</var> &gt; 4) where each of the four cores is busy running at least one thread. Running time actually increases a bit as we increase the number of threads because of the overhead of context switching multiple threads on the same core. For this reason, parallel programs are often written so that each core runs exactly one thread.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FE4" id="P7000497027000000000000000046FE4">Although absolute running time is the ultimate measure of any program's performance, there are some useful relative measures that can provide insight into how well a parallel program is exploiting potential parallelism. The <i class="pcalibre17 pcalibre2 pcalibre1">speedup</i> of a parallel program is typically defined as</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter12.xhtml#P7000497027000000000000000046FE5" id="P7000497027000000000000000046FE5">
<m:math altimg="../images/ch12-03.png" altimg-height="52" altimg-width="71" alttext="" data-uri="" display="block"><m:mrow><m:msub><m:mi>S</m:mi><m:mi>p</m:mi></m:msub><m:mo>=</m:mo><m:mfrac><m:mrow><m:msub><m:mi>T</m:mi><m:mn>1</m:mn></m:msub></m:mrow><m:mrow><m:msub><m:mi>T</m:mi><m:mi>p</m:mi></m:msub></m:mrow></m:mfrac></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000046FE6" id="P7000497027000000000000000046FE6">where <var class="pcalibre17 pcalibre2 pcalibre1">p</var> is the number of processor cores and <i class="pcalibre17 pcalibre2 pcalibre1">T<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> is the running time on <var class="pcalibre17 pcalibre2 pcalibre1">k</var> cores. This formulation is sometimes referred to as <i class="pcalibre17 pcalibre2 pcalibre1">strong scaling.</i> When <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub> is the execution</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008534" id="P7000497027000000000000000008534">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008535" epub:type="pagebreak" id="P7000497027000000000000000008535" title="1019"></span>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000046FE7" id="P7000497027000000000000000046FE7">
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FE8" id="P7000497027000000000000000046FE8">Threads (<var class="pcalibre17 pcalibre2 pcalibre1">t</var>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FE9" id="P7000497027000000000000000046FE9">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FEA" id="P7000497027000000000000000046FEA">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FEB" id="P7000497027000000000000000046FEB">4</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FEC" id="P7000497027000000000000000046FEC">8</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FED" id="P7000497027000000000000000046FED">16</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FEE" id="P7000497027000000000000000046FEE">Cores (<var class="pcalibre17 pcalibre2 pcalibre1">p</var>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FEF" id="P7000497027000000000000000046FEF">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FF0" id="P7000497027000000000000000046FF0">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FF1" id="P7000497027000000000000000046FF1">4</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FF2" id="P7000497027000000000000000046FF2">4</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FF3" id="P7000497027000000000000000046FF3">4</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FF4" id="P7000497027000000000000000046FF4">Running time (<i class="pcalibre17 pcalibre2 pcalibre1">T<sub class="pcalibre97 pcalibre2 pcalibre1">p</sub></i>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FF5" id="P7000497027000000000000000046FF5">1.06</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FF6" id="P7000497027000000000000000046FF6">0.54</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FF7" id="P7000497027000000000000000046FF7">0.28</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FF8" id="P7000497027000000000000000046FF8">0.29</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FF9" id="P7000497027000000000000000046FF9">0.30</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FFA" id="P7000497027000000000000000046FFA">Speedup (<var class="pcalibre17 pcalibre2 pcalibre1">S</var>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FFB" id="P7000497027000000000000000046FFB">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FFC" id="P7000497027000000000000000046FFC">1.9</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FFD" id="P7000497027000000000000000046FFD">3.8</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FFE" id="P7000497027000000000000000046FFE">3.7</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000046FFF" id="P7000497027000000000000000046FFF">3.5</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047000" id="P7000497027000000000000000047000">Efficiency (<i class="pcalibre17 pcalibre2 pcalibre1">E<sub class="pcalibre97 pcalibre2 pcalibre1">p</sub></i>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047001" id="P7000497027000000000000000047001">100%</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047002" id="P7000497027000000000000000047002">98%</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047003" id="P7000497027000000000000000047003">95%</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047004" id="P7000497027000000000000000047004">91%</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047005" id="P7000497027000000000000000047005">88%</td>
</tr>
</tbody>
</table>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000047006" id="P7000497027000000000000000047006"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000047007" epub:type="title" id="P7000497027000000000000000047007"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.36 </span>Speedup and parallel efficiency for the execution times in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008522"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.35</span></a>.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047008" id="P7000497027000000000000000047008">time of a sequential version of the program, then <i class="pcalibre17 pcalibre2 pcalibre1">S<sub class="pcalibre1 pcalibre2 calibre14">p</sub></i> is called the <i class="pcalibre17 pcalibre2 pcalibre1">absolute speedup</i>. When <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub> is the execution time of the parallel version of the program running on one core, then <i class="pcalibre17 pcalibre2 pcalibre1">S<sub class="pcalibre1 pcalibre2 calibre14">p</sub></i> is called the <i class="pcalibre17 pcalibre2 pcalibre1">relative speedup</i>. Absolute speedup is a truer measure of the benefits of parallelism than relative speedup. Parallel programs often suffer from synchronization overheads, even when they run on one processor, and these overheads can artificially inflate the relative speedup numbers because they increase the size of the numerator. On the other hand, absolute speedup is more difficult to measure than relative speedup because measuring absolute speedup requires two different versions of the program. For complex parallel codes, creating a separate sequential version might not be feasible, either because the code is too complex or because the source code is not available.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047009" id="P7000497027000000000000000047009">A related measure, known as <i class="pcalibre17 pcalibre2 pcalibre1">efficiency</i>, is defined as</p>
<div class="pcalibre1 pcalibre2 informalequation" data-uri="chapter12.xhtml#P700049702700000000000000004700A" id="P700049702700000000000000004700A">
<m:math altimg="../images/ch12-04.png" altimg-height="55" altimg-width="140" alttext="" data-uri="" display="block"><m:mrow><m:msub><m:mi>E</m:mi><m:mi>p</m:mi></m:msub><m:mo>=</m:mo><m:mfrac><m:mrow><m:msub><m:mi>S</m:mi><m:mi>p</m:mi></m:msub></m:mrow><m:mi>p</m:mi></m:mfrac><m:mo>=</m:mo><m:mfrac><m:mrow><m:msub><m:mi>T</m:mi><m:mn>1</m:mn></m:msub></m:mrow><m:mrow><m:mi>p</m:mi><m:msub><m:mi>T</m:mi><m:mi>p</m:mi></m:msub></m:mrow></m:mfrac></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004700B" id="P700049702700000000000000004700B">and is typically reported as a percentage in the range (0, 100]. Efficiency is a measure of the overhead due to parallelization. Programs with high efficiency are spending more time doing useful work and less time synchronizing and communicating than programs with low efficiency.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004700C" id="P700049702700000000000000004700C"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008534"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.36</span></a> shows the different speedup and efficiency measures for our example parallel sum program. Efficiencies over 90 percent such as these are very good, but do not be fooled. We were able to achieve high efficiency because our problem was trivially easy to parallelize. In practice, this is not usually the case. Parallel programming has been an active area of research for decades. With the advent of commodity multi-core machines whose core count is doubling every few years, parallel programming continues to be a deep, difficult, and active area of research.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004700D" id="P700049702700000000000000004700D">There is another view of speedup, known as <i class="pcalibre17 pcalibre2 pcalibre1">weak scaling</i>, which increases the problem size along with the number of processors, such that the amount of work performed on each processor is held constant as the number of processors increases. With this formulation, speedup and efficiency are expressed in terms of the total amount of work accomplished per unit time. For example, if we can double the number of processors and do twice the amount of work per hour, then we are enjoying linear speedup and 100 percent efficiency.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004700E" id="P700049702700000000000000004700E"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000855E" epub:type="pagebreak" id="P700049702700000000000000000855E" title="1020"></span>Weak scaling is often a truer measure than strong scaling because it more accurately reflects our desire to use bigger machines to do more work. This is particularly true for scientific codes, where the problem size can be easily increased and where bigger problem sizes translate directly to better predictions of nature. However, there exist applications whose sizes are not so easily increased, and for these applications strong scaling is more appropriate. For example, the amount of work performed by real-time signal-processing applications is often determined by the properties of the physical sensors that are generating the signals. Changing the total amount of work requires using different physical sensors, which might not be feasible or necessary. For these applications, we typically want to use parallelism to accomplish a fixed amount of work as quickly as possible.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000855F" id="P700049702700000000000000000855F"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004700F" epub:type="title" id="P700049702700000000000000004700F"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.11 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008803">1038</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047010" id="P7000497027000000000000000047010">Fill in the blanks for the parallel program in the following table. Assume strong scaling.</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000047011" id="P7000497027000000000000000047011">
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047012" id="P7000497027000000000000000047012">Threads (<var class="pcalibre17 pcalibre2 pcalibre1">t</var>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047013" id="P7000497027000000000000000047013">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047014" id="P7000497027000000000000000047014">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047015" id="P7000497027000000000000000047015">4</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047016" id="P7000497027000000000000000047016">Cores (<var class="pcalibre17 pcalibre2 pcalibre1">p</var>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047017" id="P7000497027000000000000000047017">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047018" id="P7000497027000000000000000047018">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047019" id="P7000497027000000000000000047019">4</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004701A" id="P700049702700000000000000004701A">Running time (<i class="pcalibre17 pcalibre2 pcalibre1">T<sub class="pcalibre97 pcalibre2 pcalibre1">p</sub></i>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004701B" id="P700049702700000000000000004701B">12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004701C" id="P700049702700000000000000004701C">8</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004701D" id="P700049702700000000000000004701D">6</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004701E" id="P700049702700000000000000004701E">Speedup (<var class="pcalibre17 pcalibre2 pcalibre1">S</var><var class="pcalibre17 pcalibre2 pcalibre1">p</var>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004701F" id="P700049702700000000000000004701F">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047020" id="P7000497027000000000000000047020">1.5</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047021" id="P7000497027000000000000000047021">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047022" id="P7000497027000000000000000047022">Efficiency (<i class="pcalibre17 pcalibre2 pcalibre1">E<sub class="pcalibre97 pcalibre2 pcalibre1">p</sub></i>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047023" id="P7000497027000000000000000047023">100%</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047024" id="P7000497027000000000000000047024">_____</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047025" id="P7000497027000000000000000047025">50%</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>12.7 Other Concurrency Issues</title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000008577"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter12.xhtml#P7000497027000000000000000047026" epub:type="title" id="P7000497027000000000000000047026"><span class="pcalibre1 pcalibre21 pcalibre2">12.7 </span>Other Concurrency Issues</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047027" id="P7000497027000000000000000047027">You probably noticed that life got much more complicated once we were asked to synchronize accesses to shared data. So far, we have looked at techniques for mutual exclusion and producer-consumer synchronization, but this is only the tip of the iceberg. Synchronization is a fundamentally difficult problem that raises issues that simply do not arise in ordinary sequential programs. This section is a survey (by no means complete) of some of the issues you need to be aware of when you write concurrent programs. To keep things concrete, we will couch our discussion in terms of threads. Keep in mind, however, that these are typical of the issues that arise when concurrent flows of any kind manipulate shared resources.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000857A" id="P700049702700000000000000000857A"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047028" epub:type="title" id="P7000497027000000000000000047028"><span class="pcalibre1 pcalibre21 pcalibre2">12.7.1 </span>Thread Safety</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047029" id="P7000497027000000000000000047029">When we program with threads, we must be careful to write functions that have a property called thread safety. A function is said to be <i class="pcalibre17 pcalibre2 pcalibre1">thread-safe</i> if and only if it will always produce correct results when called repeatedly from multiple concurrent threads. If a function is not thread-safe, then we say it is <i class="pcalibre17 pcalibre2 pcalibre1">thread-unsafe</i>.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004702A" id="P700049702700000000000000004702A">We can identify four (nondisjoint) classes of thread-unsafe functions:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004702B" id="P700049702700000000000000004702B">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P700049702700000000000000004702C" id="P700049702700000000000000004702C"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P700049702700000000000000004702D" id="P700049702700000000000000004702D"><span class="pcalibre1 pcalibre2 pcalibre41">Class 1: </span><i class="pcalibre17 pcalibre2 pcalibre1">Functions that do not protect shared variables.</i> We have already encountered this problem with the thread function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008286"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.16</span></a>, which</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008581" id="P7000497027000000000000000008581">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008582" epub:type="pagebreak" id="P7000497027000000000000000008582" title="1021"></span>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P700049702700000000000000004702E" id="P700049702700000000000000004702E">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/rand.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P700049702700000000000000004702F" id="P700049702700000000000000004702F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047030" id="P7000497027000000000000000047030">
1	unsigned next_seed = 1;
2
3	/* rand - return pseudorandom integer in the range 0..32767 */
4	unsigned rand(void)
5	{
6		next_seed = next_seed*1103515245 + 12543;
7		return (unsigned)(next_seed&gt;&gt;16) % 32768;
8	}
9
10	/* srand - set the initial seed for rand() */
11	void srand(unsigned new_seed)
12	{
13		next_seed = new_seed;
14	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000047031" id="P7000497027000000000000000047031">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/rand.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000047032" id="P7000497027000000000000000047032"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000047033" epub:type="title" id="P7000497027000000000000000047033"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.37 </span>A thread-unsafe pseudorandom number generator.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047034" id="P7000497027000000000000000047034"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047035" id="P7000497027000000000000000047035">(Based on [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41C">61</a>])</p></div></figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000047036" id="P7000497027000000000000000047036">increments an unprotected global counter variable. This class of thread-unsafe functions is relatively easy to make thread-safe: protect the shared variables with synchronization operations such as <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var>. An advantage is that it does not require any changes in the calling program. A disadvantage is that the synchronization operations slow down the function.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047037" id="P7000497027000000000000000047037"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000047038" id="P7000497027000000000000000047038"><span class="pcalibre1 pcalibre2 pcalibre41">Class 2: </span><i class="pcalibre17 pcalibre2 pcalibre1">Functions that keep state across multiple invocations.</i> A pseudorandom number generator is a simple example of this class of thread-unsafe functions. Consider the pseudorandom number generator package in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008581"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.37</span></a>.</p>
<p class="pcalibre1 pcalibre2 pcalibre42" data-uri="chapter12.xhtml#P7000497027000000000000000047039" id="P7000497027000000000000000047039">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004703A" id="P700049702700000000000000004703A">rand</code> function is thread-unsafe because the result of the current invocation depends on an intermediate result from the previous iteration. When we call <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004703B" id="P700049702700000000000000004703B">rand</code> repeatedly from a single thread after seeding it with a call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004703C" id="P700049702700000000000000004703C">srand</code>, we can expect a repeatable sequence of numbers. However, this assumption no longer holds if multiple threads are calling <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004703D" id="P700049702700000000000000004703D">rand</code>.</p>
<p class="pcalibre1 pcalibre2 pcalibre42" data-uri="chapter12.xhtml#P700049702700000000000000004703E" id="P700049702700000000000000004703E">The only way to make a function such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004703F" id="P700049702700000000000000004703F">rand</code> thread-safe is to rewrite it so that it does not use any <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047040" id="P7000497027000000000000000047040">static</code> data, relying instead on the caller to pass the state information in arguments. The disadvantage is that the programmer is now forced to change the code in the calling routine as well. In a large program where there are potentially hundreds of different call sites, making such modifications could be nontrivial and prone to error.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047041" id="P7000497027000000000000000047041"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000047042" id="P7000497027000000000000000047042"><span class="pcalibre1 pcalibre2 pcalibre41">Class 3: </span><i class="pcalibre17 pcalibre2 pcalibre1">Functions that return a pointer to a static variable.</i> Some functions, such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047043" id="P7000497027000000000000000047043">ctime</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047044" id="P7000497027000000000000000047044">gethostbyname</code>, compute a result in a <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047045" id="P7000497027000000000000000047045">static</code> variable and then return a pointer to that variable. If we call such functions from</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P700049702700000000000000000859B" id="P700049702700000000000000000859B">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000859C" epub:type="pagebreak" id="P700049702700000000000000000859C" title="1022"></span>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000047046" id="P7000497027000000000000000047046">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/ctime-ts.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047047" id="P7000497027000000000000000047047"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047048" id="P7000497027000000000000000047048">
1	char *ctime_ts(const time_t *timep, char *privatep)
2	{
3		char *sharedp;
4
5		P(&amp;mutex);
6		sharedp = ctime(timep);
7		strcpy(privatep, sharedp); /* Copy string from shared to private */
8		V(&amp;mutex);
9		return privatep;
10	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000047049" id="P7000497027000000000000000047049">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/ctime-ts.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P700049702700000000000000004704A" id="P700049702700000000000000004704A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P700049702700000000000000004704B" epub:type="title" id="P700049702700000000000000004704B"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.38 </span>Thread-safe wrapper function for the C standard library <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004704C" id="P700049702700000000000000004704C">ctime</code> function.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004704D" id="P700049702700000000000000004704D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P700049702700000000000000004704E" id="P700049702700000000000000004704E">This example uses the lock-and-copy technique to call a class 3 thread-unsafe function.</p></div></figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P700049702700000000000000004704F" id="P700049702700000000000000004704F">concurrent threads, then disaster is likely, as results being used by one thread are silently overwritten by another thread.</p>
<p class="pcalibre1 pcalibre2 pcalibre42" data-uri="chapter12.xhtml#P7000497027000000000000000047050" id="P7000497027000000000000000047050">There are two ways to deal with this class of thread-unsafe functions. One option is to rewrite the function so that the caller passes the address of the variable in which to store the results. This eliminates all shared data, but it requires the programmer to have access to the function source code.</p>
<p class="pcalibre1 pcalibre2 pcalibre42" data-uri="chapter12.xhtml#P7000497027000000000000000047051" id="P7000497027000000000000000047051">If the thread-unsafe function is difficult or impossible to modify (e.g., the code is very complex or there is no source code available), then another option is to use the <i class="pcalibre17 pcalibre2 pcalibre1">lock-and-copy</i> technique. The basic idea is to associate a mutex with the thread-unsafe function. At each call site, lock the mutex, call the thread-unsafe function, copy the result returned by the function to a private memory location, and then unlock the mutex. To minimize changes to the caller, you should define a thread-safe wrapper function that performs the lock-and-copy and then replace all calls to the thread-unsafe function with calls to the wrapper. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000859B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.38</span></a> shows a thread-safe wrapper for <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047052" id="P7000497027000000000000000047052">ctime</code> that uses the lock-and-copy technique.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047053" id="P7000497027000000000000000047053"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000047054" id="P7000497027000000000000000047054"><span class="pcalibre1 pcalibre2 pcalibre41">Class 4: </span><i class="pcalibre17 pcalibre2 pcalibre1">Functions that call thread-unsafe functions.</i> If a function <var class="pcalibre17 pcalibre2 pcalibre1">f</var> calls a thread-unsafe function <var class="pcalibre17 pcalibre2 pcalibre1">g</var>, is <var class="pcalibre17 pcalibre2 pcalibre1">f</var> thread-unsafe? It depends. If <var class="pcalibre17 pcalibre2 pcalibre1">g</var> is a class 2 function that relies on state across multiple invocations, then <var class="pcalibre17 pcalibre2 pcalibre1">f</var> is also thread-unsafe and there is no recourse short of rewriting <var class="pcalibre17 pcalibre2 pcalibre1">g</var>. However, if <var class="pcalibre17 pcalibre2 pcalibre1">g</var> is a class 1 or class 3 function, then <var class="pcalibre17 pcalibre2 pcalibre1">f</var> can still be thread-safe if you protect the call site and any resulting shared data with a mutex. We see a good example of this in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000859B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.38</span></a>, where we use lock-and-copy to write a thread-safe function that calls a thread-unsafe function.</p></li>
</ul>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000085AC" id="P70004970270000000000000000085AC">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000085AD" epub:type="pagebreak" id="P70004970270000000000000000085AD" title="1023"></span>
<img alt="A diagram shows all functions divided among thread-safe functions and thread-unsafe functions. Reentrant functions are within thread-safe functions." class="pcalibre1 pcalibre2 calibre90" data-uri="P700049702700000000000000000B69B" id="P7000497027000000000000000047055" src="Images/chapter-11-image-22.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P7000497027000000000000000047056" id="P7000497027000000000000000047056"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P7000497027000000000000000047057" epub:type="title" id="P7000497027000000000000000047057"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.39 </span>Relationships between the sets of reentrant, thread-safe, and thread-unsafe functions.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000085B1" id="P70004970270000000000000000085B1">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047058" id="P7000497027000000000000000047058">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/rand-r.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047059" id="P7000497027000000000000000047059"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004705A" id="P700049702700000000000000004705A">
1	/* rand_r - return a pseudorandom integer on 0..32767 */
2	int rand_r(unsigned int *nextp)
3	{
4		*nextp = *nextp * 1103515245 + 12345;
5		return (unsigned int)(*nextp / 65536) % 32768;
6	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004705B" id="P700049702700000000000000004705B">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/rand-r.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P700049702700000000000000004705C" id="P700049702700000000000000004705C"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P700049702700000000000000004705D" epub:type="title" id="P700049702700000000000000004705D"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.40 </span><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004705E" id="P700049702700000000000000004705E">rand_r</code>: A reentrant version of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004705F" id="P700049702700000000000000004705F">rand</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008581"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.37</span></a>.</h1></header>
</figcaption>
</figure>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000085BA" id="P70004970270000000000000000085BA"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047060" epub:type="title" id="P7000497027000000000000000047060"><span class="pcalibre1 pcalibre21 pcalibre2">12.7.2 </span>Reentrancy</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047061" id="P7000497027000000000000000047061">There is an important class of thread-safe functions, known as <i class="pcalibre17 pcalibre2 pcalibre1">reentrant functions</i>, that are characterized by the property that they do not reference <i class="pcalibre17 pcalibre2 pcalibre1">any</i> shared data when they are called by multiple threads. Although the terms <i class="pcalibre17 pcalibre2 pcalibre1">thread-safe</i> and <i class="pcalibre17 pcalibre2 pcalibre1">reentrant</i> are sometimes used (incorrectly) as synonyms, there is a clear technical distinction that is worth preserving. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000085AC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.39</span></a> shows the set relationships between reentrant, thread-safe, and thread-unsafe functions. The set of all functions is partitioned into the disjoint sets of thread-safe and thread-unsafe functions. The set of reentrant functions is a proper subset of the thread-safe functions.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047062" id="P7000497027000000000000000047062">Reentrant functions are typically more efficient than non-reentrant thread-safe functions because they require no synchronization operations. Furthermore, the only way to convert a class 2 thread-unsafe function into a thread-safe one is to rewrite it so that it is reentrant. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000085B1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.40</span></a> shows a reentrant version of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047063" id="P7000497027000000000000000047063">rand</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008581"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.37</span></a>. The key idea is that we have replaced the static <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047064" id="P7000497027000000000000000047064">next</code> variable with a pointer that is passed in by the caller.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047065" id="P7000497027000000000000000047065">Is it possible to inspect the code of some function and declare a priori that it is reentrant? Unfortunately, it depends. If all function arguments are passed by value (i.e., no pointers) and all data references are to local automatic stack variables (i.e., no references to static or global variables), then the function is <i class="pcalibre17 pcalibre2 pcalibre1">explicitly reentrant</i>, in the sense that we can assert its reentrancy regardless of how it is called.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047066" id="P7000497027000000000000000047066">However, if we loosen our assumptions a bit and allow some parameters in our otherwise explicitly reentrant function to be passed by reference (i.e., we allow them to pass pointers), then we have an <i class="pcalibre17 pcalibre2 pcalibre1">implicitly reentrant</i> function, in the sense that it is only reentrant if the calling threads are careful to pass pointers <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000085C2" epub:type="pagebreak" id="P70004970270000000000000000085C2" title="1024"></span>to nonshared data. For example, the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047067" id="P7000497027000000000000000047067">rand_r</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000085B1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.40</span></a> is implicitly reentrant.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047068" id="P7000497027000000000000000047068">We always use the term <i class="pcalibre17 pcalibre2 pcalibre1">reentrant</i> to include both explicit and implicit reentrant functions. However, it is important to realize that reentrancy is sometimes a property of both the caller and the callee, and not just the callee alone.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000085C5" epub:type="practice" id="P70004970270000000000000000085C5"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047069" epub:type="title" id="P7000497027000000000000000047069"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.12 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008803">1038</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P700049702700000000000000004706A" id="P700049702700000000000000004706A">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P700049702700000000000000004706B" id="P700049702700000000000000004706B">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P700049702700000000000000004706C" id="P700049702700000000000000004706C"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P700049702700000000000000004706D" id="P700049702700000000000000004706D">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004706E" id="P700049702700000000000000004706E">ctime_ts</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000859B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.38</span></a> is thread-safe but not reentrant. Explain.</p></div></li>
</ol>
</section>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000085CC" id="P70004970270000000000000000085CC"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004706F" epub:type="title" id="P700049702700000000000000004706F"><span class="pcalibre1 pcalibre21 pcalibre2">12.7.3 </span>Using Existing Library Functions in Threaded Programs</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047070" id="P7000497027000000000000000047070">Most Linux functions, including the functions defined in the standard C library (such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047071" id="P7000497027000000000000000047071">malloc, free, realloc, printf</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047072" id="P7000497027000000000000000047072">scanf</code>), are thread-safe, with only a few exceptions. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000085DB"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.41</span></a> lists some common exceptions. (See [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>] for a complete list.) The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047073" id="P7000497027000000000000000047073">strtok</code> function is a deprecated function (one whose use is discouraged) for parsing strings. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047074" id="P7000497027000000000000000047074">asctime, ctime</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047075" id="P7000497027000000000000000047075">localtime</code> functions are popular functions for converting back and forth between different time and date formats. The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047076" id="P7000497027000000000000000047076">gethostbyaddr, gethostbyname</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047077" id="P7000497027000000000000000047077">inet_ntoa</code> functions are obsolete network programming functions that have been replaced by the reentrant getaddrinfo, <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047078" id="P7000497027000000000000000047078">getnameinfo</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047079" id="P7000497027000000000000000047079">inet_ntop</code> functions, respectively (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007B7A.xhtml#P7000497027000000000000000007B7A"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">11</span></a>). With the exceptions of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004707A" id="P700049702700000000000000004707A">rand</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004707B" id="P700049702700000000000000004707B">strtok</code>, they are of the class 3 variety that return a pointer to a static variable. If we need to call one of these functions in a threaded program, the least disruptive approach to the caller is to lock and copy. However, the lock-and-copy approach has a number of disadvantages. First, the additional synchronization slows down the program. Second, functions that return pointers to complex structures of structures require a <i class="pcalibre17 pcalibre2 pcalibre1">deep copy</i> of the structures in order to copy the entire structure hierarchy. Third, the lock-and-copy approach will not work for a class 2 thread-unsafe function such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004707C" id="P700049702700000000000000004707C">rand</code> that relies on static state across calls.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P70004970270000000000000000085DB" id="P70004970270000000000000000085DB">
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P700049702700000000000000004707D" id="P700049702700000000000000004707D">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P700049702700000000000000004707E" id="P700049702700000000000000004707E">Thread-unsafe function</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P700049702700000000000000004707F" id="P700049702700000000000000004707F">Thread-unsafe class</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047080" id="P7000497027000000000000000047080">Linux thread-safe version</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047081" id="P7000497027000000000000000047081"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047082" id="P7000497027000000000000000047082">rand</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047083" id="P7000497027000000000000000047083">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047084" id="P7000497027000000000000000047084"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047085" id="P7000497027000000000000000047085">rand_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047086" id="P7000497027000000000000000047086"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047087" id="P7000497027000000000000000047087">strtok</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047088" id="P7000497027000000000000000047088">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047089" id="P7000497027000000000000000047089"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004708A" id="P700049702700000000000000004708A">strtok_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004708B" id="P700049702700000000000000004708B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004708C" id="P700049702700000000000000004708C">asctime</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004708D" id="P700049702700000000000000004708D">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004708E" id="P700049702700000000000000004708E"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004708F" id="P700049702700000000000000004708F">asctime_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047090" id="P7000497027000000000000000047090"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047091" id="P7000497027000000000000000047091">ctime</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047092" id="P7000497027000000000000000047092">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047093" id="P7000497027000000000000000047093"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047094" id="P7000497027000000000000000047094">ctime_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047095" id="P7000497027000000000000000047095"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047096" id="P7000497027000000000000000047096">gethostbyaddr</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047097" id="P7000497027000000000000000047097">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047098" id="P7000497027000000000000000047098"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047099" id="P7000497027000000000000000047099">gethostbyaddr_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004709A" id="P700049702700000000000000004709A"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004709B" id="P700049702700000000000000004709B">gethostbyname</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004709C" id="P700049702700000000000000004709C">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004709D" id="P700049702700000000000000004709D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004709E" id="P700049702700000000000000004709E">gethostbyname_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004709F" id="P700049702700000000000000004709F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470A0" id="P70004970270000000000000000470A0">inet_ntoa</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000470A1" id="P70004970270000000000000000470A1">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000470A2" id="P70004970270000000000000000470A2">(none)</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000470A3" id="P70004970270000000000000000470A3"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470A4" id="P70004970270000000000000000470A4">localtime</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000470A5" id="P70004970270000000000000000470A5">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000470A6" id="P70004970270000000000000000470A6"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470A7" id="P70004970270000000000000000470A7">localtime_r</code></td>
</tr>
</tbody>
</table>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P70004970270000000000000000470A8" id="P70004970270000000000000000470A8"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P70004970270000000000000000470A9" epub:type="title" id="P70004970270000000000000000470A9"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.41 </span>Common thread-unsafe library functions.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470AA" id="P70004970270000000000000000470AA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470AB" id="P70004970270000000000000000470AB"></p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470AC" id="P70004970270000000000000000470AC"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000860C" epub:type="pagebreak" id="P700049702700000000000000000860C" title="1025"></span>Therefore, Linux systems provide reentrant versions of most thread-unsafe functions. The names of the reentrant versions always end with the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470AD" id="P70004970270000000000000000470AD">_r</code> suffix. For example, the reentrant version of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470AE" id="P70004970270000000000000000470AE">asctime</code> is called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470AF" id="P70004970270000000000000000470AF">asctime_r</code>. We recommend using these functions whenever possible.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008610" id="P7000497027000000000000000008610"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470B0" epub:type="title" id="P70004970270000000000000000470B0"><span class="pcalibre1 pcalibre21 pcalibre2">12.7.4 </span>Races</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470B1" id="P70004970270000000000000000470B1">A <i class="pcalibre17 pcalibre2 pcalibre1">race</i> occurs when the correctness of a program depends on one thread reaching point <var class="pcalibre17 pcalibre2 pcalibre1">x</var> in its control flow before another thread reaches point <var class="pcalibre17 pcalibre2 pcalibre1">y</var>. Races usually occur because programmers assume that threads will take some particular trajectory through the execution state space, forgetting the golden rule that threaded programs must work correctly for any feasible trajectory.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470B2" id="P70004970270000000000000000470B2">An example is the easiest way to understand the nature of races. Consider the simple program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008614"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.42</span></a>. The main thread creates four peer threads and passes a pointer to a unique integer ID to each one. Each peer thread copies the</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008614" id="P7000497027000000000000000008614">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470B3" id="P70004970270000000000000000470B3">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/race.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470B4" id="P70004970270000000000000000470B4"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470B5" id="P70004970270000000000000000470B5">
1	/* WARNING: This code is buggy! */
2	#include "csapp.h"
3	#define N 4
4
5	void *thread(void *vargp);
6
7	int main()
8	{
9		pthread_t tid[N];
10		int i;
11
12		for (i = 0; i &lt; N; i++)
13			Pthread_create(&amp;tid[i], NULL, thread, &amp;i);
14		for (i = 0; i &lt; N; i++)
15			Pthread_join(tid[i], NULL);
16		exit(0);
17	}
18
19	/* Thread routine */
20	void *thread(void *vargp)
21	{
22		int myid = *((int *)vargp);
23		printf("Hello from thread %d\n", myid);
24		return NULL;
25	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470B6" id="P70004970270000000000000000470B6">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/race.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P70004970270000000000000000470B7" id="P70004970270000000000000000470B7"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P70004970270000000000000000470B8" epub:type="title" id="P70004970270000000000000000470B8"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.42 </span>program with a race.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470B9" id="P70004970270000000000000000470B9"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000861C" epub:type="pagebreak" id="P700049702700000000000000000861C" title="1026"></span>ID passed in its argument to a local variable (line 22) and then prints a message containing the ID. It looks simple enough, but when we run this program on our system, we get the following incorrect result:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470BA" id="P70004970270000000000000000470BA"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470BB" id="P70004970270000000000000000470BB">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./race</i>
Hello from thread 1
Hello from thread 3
Hello from thread 2
Hello from thread 3</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470BC" id="P70004970270000000000000000470BC">The problem is caused by a race between each peer thread and the main thread. Can you spot the race? Here is what happens. When the main thread creates a peer thread in line 13, it passes a pointer to the local stack variable <var class="pcalibre17 pcalibre2 pcalibre1">i</var>. At this point, the race is on between the next increment of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470BD" id="P70004970270000000000000000470BD">i</code> in line 12 and the dereferencing and assignment of the argument in line 22. If the peer thread executes line 22 before the main thread increments <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470BE" id="P70004970270000000000000000470BE">i</code> in line 12, then the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470BF" id="P70004970270000000000000000470BF">myid</code> variable gets the correct ID. Otherwise, it will contain the ID of some other thread. The scary thing is that whether we get the correct answer depends on how the kernel schedules the execution of the threads. On our system it fails, but on other systems it might work correctly, leaving the programmer blissfully unaware of a serious bug.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470C0" id="P70004970270000000000000000470C0">To eliminate the race, we can dynamically allocate a separate block for each integer ID and pass the thread routine a pointer to this block, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008638"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.43</span></a> (lines 12−14). Notice that the thread routine must free the block in order to avoid a memory leak.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470C1" id="P70004970270000000000000000470C1">When we run this program on our system, we now get the correct result:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470C2" id="P70004970270000000000000000470C2"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470C3" id="P70004970270000000000000000470C3">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./norace</i>
Hello from thread 0
Hello from thread 1
Hello from thread 2
Hello from thread 3</code></pre>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008627" epub:type="practice" id="P7000497027000000000000000008627"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470C4" epub:type="title" id="P70004970270000000000000000470C4"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.13 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008837">1039</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P70004970270000000000000000470C5" id="P70004970270000000000000000470C5">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P70004970270000000000000000470C6" id="P70004970270000000000000000470C6">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P70004970270000000000000000470C7" id="P70004970270000000000000000470C7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470C8" id="P70004970270000000000000000470C8">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008638"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.43</span></a>, we might be tempted to free the allocated memory block immediately after line 14 in the main thread, instead of freeing it in the peer thread. But this would be a bad idea. Why?</p></div></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000862D" epub:type="practice" id="P700049702700000000000000000862D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470C9" epub:type="title" id="P70004970270000000000000000470C9"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.14 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008837">1039</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre323" data-uri="chapter12.xhtml#P70004970270000000000000000470CA" id="P70004970270000000000000000470CA">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P70004970270000000000000000470CB" id="P70004970270000000000000000470CB">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P70004970270000000000000000470CC" id="P70004970270000000000000000470CC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470CD" id="P70004970270000000000000000470CD">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008638"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.43</span></a>, we eliminated the race by allocating a separate block for each integer ID. Outline a different approach that does not call the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470CE" id="P70004970270000000000000000470CE">malloc</code> or <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470CF" id="P70004970270000000000000000470CF">free</code> functions.</p></div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P70004970270000000000000000470D0" id="P70004970270000000000000000470D0">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P70004970270000000000000000470D1" id="P70004970270000000000000000470D1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470D2" id="P70004970270000000000000000470D2">What are the advantages and disadvantages of this approach?</p></div></li>
</ol>
</section>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008638" id="P7000497027000000000000000008638">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008639" epub:type="pagebreak" id="P7000497027000000000000000008639" title="1027"></span>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470D3" id="P70004970270000000000000000470D3">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/norace.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470D4" id="P70004970270000000000000000470D4"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470D5" id="P70004970270000000000000000470D5">
1	#include "csapp.h"
2	#define N 4
3
4	void *thread(void *vargp);
5
6	int main()
7	{
8		pthread_t tid[N];
9		int i, *ptr;
10
11		for (i = 0; i &lt; N; i++) {
12			ptr = Malloc(sizeof(int));
13			*ptr = i;
14			Pthread_create(&amp;tid[i], NULL, thread, ptr);
15		}
16		for (i = 0; i &lt; N; i++)
17			Pthread_join(tid[i], NULL);
18		exit(0);
19	}
20
21	/* Thread routine */
22	void *thread(void *vargp)
23	{
24		int myid = *((int *)vargp);
25		Free(vargp);
26		printf("Hello from thread %d\n", myid);
27		return NULL;
28	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470D6" id="P70004970270000000000000000470D6">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/norace.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P70004970270000000000000000470D7" id="P70004970270000000000000000470D7"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P70004970270000000000000000470D8" epub:type="title" id="P70004970270000000000000000470D8"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.43 </span></h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470D9" id="P70004970270000000000000000470D9"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470DA" id="P70004970270000000000000000470DA">A correct version of the program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008614"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.42</span></a> without a race.</p></div></figcaption>
</figure>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008642" id="P7000497027000000000000000008642"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470DB" epub:type="title" id="P70004970270000000000000000470DB"><span class="pcalibre1 pcalibre21 pcalibre2">12.7.5 </span>Deadlocks</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470DC" id="P70004970270000000000000000470DC">Semaphores introduce the potential for a nasty kind of run-time error, called <i class="pcalibre17 pcalibre2 pcalibre1">deadlock</i>, where a collection of threads is blocked, waiting for a condition that will never be true. The progress graph is an invaluable tool for understanding deadlock. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008648"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.44</span></a> shows the progress graph for a pair of threads that use two semaphores for mutual exclusion. From this graph, we can glean some important insights about deadlock:</p>
<ul class="pcalibre1 calibre9 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470DD" id="P70004970270000000000000000470DD">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470DE" id="P70004970270000000000000000470DE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470DF" id="P70004970270000000000000000470DF">The programmer has incorrectly ordered the <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operations such that the forbidden regions for the two semaphores overlap. If some execution trajectory happens to reach the <i class="pcalibre17 pcalibre2 pcalibre1">deadlock state d</i>, then no further progress is</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008648" id="P7000497027000000000000000008648">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008649" epub:type="pagebreak" id="P7000497027000000000000000008649" title="1028"></span>
<img alt="A graph shows trajectories and regions for a program that can deadlock." class="pcalibre1 pcalibre2 pcalibre324" data-uri="P700049702700000000000000000B69C" id="P70004970270000000000000000470E0" src="Images/chapter-11-image-23.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P70004970270000000000000000470E1" id="P70004970270000000000000000470E1"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P70004970270000000000000000470E2" epub:type="title" id="P70004970270000000000000000470E2"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.44 </span>Progress graph for a program that can deadlock.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter12.xhtml#P7000497027000000000000000027455" id="P7000497027000000000000000027455">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470E3" id="P70004970270000000000000000470E3">A graph of thread 2 versus thread 1 shows P(s), P(t), V(s), and V(t) on the thread 1 axis and P(t), P(s), V(t), and V(s) on the thread 2 axis (initially s = 1 and t = 1). Regions include a forbidden region for s (from P(s) to V(s) on each axis) and a forbidden region for t (from P(t) to V(t) on each axis). The deadlock state d extends from P(s) to P(t). A trajectory that does not deadlock extends vertical to P(s), right to P(s), up to V(s) and then right, outside the regions. A trajectory that deadlocks extends right to P(s), up to P(t), right to the end of P(s), up to the end of P(t), right to P(t), and up into the deadlock state.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470E4" id="P70004970270000000000000000470E4">possible because the overlapping forbidden regions block progress in every legal direction. In other words, the program is deadlocked because each thread is waiting for the other to do a <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operation that will never occur.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470E5" id="P70004970270000000000000000470E5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470E6" id="P70004970270000000000000000470E6">The overlapping forbidden regions induce a set of states called the <i class="pcalibre17 pcalibre2 pcalibre1">deadlock region</i>. If a trajectory happens to touch a state in the deadlock region, then deadlock is inevitable. Trajectories can enter deadlock regions, but they can never leave.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470E7" id="P70004970270000000000000000470E7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470E8" id="P70004970270000000000000000470E8">Deadlock is an especially difficult issue because it is not always predictable. Some lucky execution trajectories will skirt the deadlock region, while others will be trapped by it. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008648"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.44</span></a> shows an example of each. The implications for a programmer are scary. You might run the same program a thousand times without any problem, but then the next time it deadlocks. Or the program might work fine on one machine but deadlock on another. Worst of all, the error is often not repeatable because different executions have different trajectories.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470E9" id="P70004970270000000000000000470E9">Programs deadlock for many reasons, and preventing them is a difficult problem in general. However, when binary semaphores are used for mutual exclusion, as in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008648"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.44</span></a>, then you can apply the following simple and effective rule to prevent deadlocks:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008653" id="P7000497027000000000000000008653">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008654" epub:type="pagebreak" id="P7000497027000000000000000008654" title="1029"></span>
<img alt="A graph shows regions for a dead-lock free program." class="pcalibre1 pcalibre325 pcalibre2" data-uri="P700049702700000000000000000B69D" id="P70004970270000000000000000470EA" src="Images/chapter-11-image-24.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P70004970270000000000000000470EB" id="P70004970270000000000000000470EB"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P70004970270000000000000000470EC" epub:type="title" id="P70004970270000000000000000470EC"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.45 </span>Progress graph for a deadlock-free program.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter12.xhtml#P7000497027000000000000000027460" id="P7000497027000000000000000027460">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470ED" id="P70004970270000000000000000470ED">A graph of thread 2 versus thread 1 shows P(s), P(t), V(s), and V(t) on the thread 1 axis and P(s), P(t), V(t), and V(s) on the thread 2 axis (initially s = 1 and t = 1). Regions include a forbidden region for s from P(s) to V(s) on each axis and a forbidden region for t from P(t) to V(t) on each axis.</p>
</details>
</figcaption>
</figure>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470EE" id="P70004970270000000000000000470EE">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470EF" id="P70004970270000000000000000470EF"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P70004970270000000000000000470F0" id="P70004970270000000000000000470F0"><span class="pcalibre1 pcalibre2 pcalibre41">Mutex lock ordering rule: </span>Given a total ordering of all mutexes, a program is deadlock-free if each thread acquires its mutexes in order and releases them in reverse order.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470F1" id="P70004970270000000000000000470F1">For example, we can fix the deadlock in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008648"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.44</span></a> by locking <var class="pcalibre17 pcalibre2 pcalibre1">s</var> first, then <var class="pcalibre17 pcalibre2 pcalibre1">t</var>, in each thread. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008653"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.45</span></a> shows the resulting progress graph.</p>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000865C" epub:type="practice" id="P700049702700000000000000000865C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470F2" epub:type="title" id="P70004970270000000000000000470F2"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.15 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008837">1039</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" data-uri="chapter12.xhtml#P70004970270000000000000000470F3" id="P70004970270000000000000000470F3">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P70004970270000000000000000470F4" id="P70004970270000000000000000470F4">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P70004970270000000000000000470F5" id="P70004970270000000000000000470F5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470F6" id="P70004970270000000000000000470F6">Consider the following program, which attempts to use a pair of semaphores for mutual exclusion.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470F7" id="P70004970270000000000000000470F7"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470F8" id="P70004970270000000000000000470F8">Initially: s = 1, t = 0.</code></pre>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470F9" id="P70004970270000000000000000470F9"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000470FA" id="P70004970270000000000000000470FA">
      Thread 1:	      Thread 2:
	P(s);		P(s);
	V(s);		V(s);
	P(t);		P(t);
	V(t);		V(t);
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P70004970270000000000000000470FB" id="P70004970270000000000000000470FB">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470FC" id="P70004970270000000000000000470FC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470FD" id="P70004970270000000000000000470FD">Draw the progress graph for this program.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000470FE" id="P70004970270000000000000000470FE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000470FF" id="P70004970270000000000000000470FF">Does it always deadlock?</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047100" id="P7000497027000000000000000047100"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047101" id="P7000497027000000000000000047101"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000866D" epub:type="pagebreak" id="P700049702700000000000000000866D" title="1030"></span>If so, what simple change to the initial semaphore values will eliminate the potential for deadlock?</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047102" id="P7000497027000000000000000047102"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047103" id="P7000497027000000000000000047103">Draw the progress graph for the resulting deadlock-free program.</p></li>
</ol></div></li>
</ol>
</section>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>12.8 Summary </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P7000497027000000000000000008670"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter12.xhtml#P7000497027000000000000000047104" epub:type="title" id="P7000497027000000000000000047104"><span class="pcalibre1 pcalibre21 pcalibre2">12.8 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary </span></h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047105" id="P7000497027000000000000000047105">A concurrent program consists of a collection of logical flows that overlap in time. In this chapter, we have studied three different mechanisms for building concurrent programs: processes, I/O multiplexing, and threads. We used a concurrent network server as the motivating application throughout.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047106" id="P7000497027000000000000000047106">Processes are scheduled automatically by the kernel, and because of their separate virtual address spaces, they require explicit IPC mechanisms in order to share data. Event-driven programs create their own concurrent logical flows, which are modeled as state machines, and use I/O multiplexing to explicitly schedule the flows. Because the program runs in a single process, sharing data between flows is fast and easy. Threads are a hybrid of these approaches. Like flows based on processes, threads are scheduled automatically by the kernel. Like flows based on I/O multiplexing, threads run in the context of a single process, and thus can share data quickly and easily.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047107" id="P7000497027000000000000000047107">Regardless of the concurrency mechanism, synchronizing concurrent accesses to shared data is a difficult problem. The <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operations on semaphores have been developed to help deal with this problem. Semaphore operations can be used to provide mutually exclusive access to shared data, as well as to schedule access to resources such as the bounded buffers in producer-consumer systems and shared objects in readers-writers systems. A concurrent prethreaded echo server provides a compelling example of these usage scenarios for semaphores.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047108" id="P7000497027000000000000000047108">Concurrency introduces other difficult issues as well. Functions that are called by threads must have a property known as thread safety. We have identified four classes of thread-unsafe functions, along with suggestions for making them thread-safe. Reentrant functions are the proper subset of thread-safe functions that do not access any shared data. Reentrant functions are often more efficient than non-reentrant functions because they do not require any synchronization primitives. Some other difficult issues that arise in concurrent programs are races and dead locks. Races occur when programmers make incorrect assumptions about how logical flows are scheduled. Deadlocks occur when a flow is waiting for an event that will never happen.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Bibliographic Notes </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre83 pcalibre2" epub:type="bibliography" id="P7000497027000000000000000008676"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 title" data-uri="chapter12.xhtml#P7000497027000000000000000047109" epub:type="title" id="P7000497027000000000000000047109"><span class="pcalibre1 pcalibre21 pcalibre2">Bibliographic Notes </span></h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004710A" id="P700049702700000000000000004710A">Semaphore operations were introduced by Dijkstra [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3DF">31</a>]. The progress graph concept was introduced by Coffman [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3CF">23</a>] and later formalized by Carson and Reynolds [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3C0">16</a>]. The readers-writers problem was introduced by Courtois et al [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3D3">25</a>]. Operating systems texts describe classical synchronization problems such as the dining philosophers, sleeping barber, and cigarette smokers problems in more detail <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008679" epub:type="pagebreak" id="P7000497027000000000000000008679" title="1031"></span>[<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B470">102</a>, <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B478">106</a>, <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B486">113</a>]. The book by Butenhof [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3BE">15</a>] is a comprehensive description of the Posix threads interface. The paper by Birrell [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3AE">7</a>] is an excellent introduction to threads programming and its pitfalls. The book by Reinders [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B458">90</a>] describes a C/C++ library that simplifies the design and implementation of threaded programs. Several texts cover the fundamentals of parallel programming on multi-core systems [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B400">47</a>, <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B431">71</a>]. Pugh identifies weaknesses with the way that Java threads interact through memory and proposes replacement memory models [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B454">88</a>]. Gustafson proposed the weak-scaling speedup model [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3F8">43</a>] as an alternative to strong scaling.</p>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Homework Problems </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000867A"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter12.xhtml#P700049702700000000000000004710B" epub:type="title" id="P700049702700000000000000004710B"><span class="pcalibre1 pcalibre21 pcalibre2">Homework Problems </span></h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000867C" id="P700049702700000000000000000867C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004710C" epub:type="title" id="P700049702700000000000000004710C"><span class="pcalibre1 pcalibre21 pcalibre2">12.16 </span>♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004710D" id="P700049702700000000000000004710D">Write a version of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004710E" id="P700049702700000000000000004710E">hello.c</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000817D.xhtml#P7000497027000000000000000008195"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.13</span></a>) that creates and reaps <var class="pcalibre17 pcalibre2 pcalibre1">n</var> joinable peer threads, where <var class="pcalibre17 pcalibre2 pcalibre1">n</var> is a command-line argument.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008680" epub:type="practice" id="P7000497027000000000000000008680"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004710F" epub:type="title" id="P700049702700000000000000004710F"><span class="pcalibre1 pcalibre21 pcalibre2">12.17 </span>♦</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre128" data-uri="chapter12.xhtml#P7000497027000000000000000047110" id="P7000497027000000000000000047110">
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000047111" id="P7000497027000000000000000047111">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047112" id="P7000497027000000000000000047112"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047113" id="P7000497027000000000000000047113">The program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008687"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.46</span></a> has a bug. The thread is supposed to sleep for 1 second and then print a string. However, when we run it on our system, nothing prints. Why?</p></div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" data-uri="chapter12.xhtml#P7000497027000000000000000047114" id="P7000497027000000000000000047114">
<div class="pcalibre1 pcalibre2 pcalibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047115" id="P7000497027000000000000000047115"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047116" id="P7000497027000000000000000047116">You can fix this bug by replacing the exit function in line 10 with one of two different Pthreads function calls. Which ones?</p></div></li>
</ol>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008687" id="P7000497027000000000000000008687">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047117" id="P7000497027000000000000000047117">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/hellobug.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047118" id="P7000497027000000000000000047118"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047119" id="P7000497027000000000000000047119">
1	/* WARNING: This code is buggy! */
2	#include "csapp.h"
3	void *thread(void *vargp);
4
5	int main()
6	{
7		pthread_t tid;
8
9		Pthread_create(&amp;tid, NULL, thread, NULL);
10		exit(0);
11	}
12
13	/* Thread routine */
14	void *thread(void *vargp)
15	{
16		Sleep(1);
17		printf("Hello, world!\n");
18		return NULL;
19	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004711A" id="P700049702700000000000000004711A">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/hellobug.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P700049702700000000000000004711B" id="P700049702700000000000000004711B"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P700049702700000000000000004711C" epub:type="title" id="P700049702700000000000000004711C"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.46 </span>Buggy program for <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008680"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">12.17</span></a>.</h1></header>
<div class="pcalibre1 caption pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004711D" id="P700049702700000000000000004711D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P700049702700000000000000004711E" id="P700049702700000000000000004711E"></p></div></figcaption>
</figure>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008690" id="P7000497027000000000000000008690"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004711F" epub:type="title" id="P700049702700000000000000004711F"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008692" epub:type="pagebreak" id="P7000497027000000000000000008692" title="1032"></span><span class="pcalibre1 pcalibre21 pcalibre2">12.18 </span></h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047120" id="P7000497027000000000000000047120">Using the progress graph in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P70004970270000000000000000083B5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.21</span></a>, classify the following trajectories as either safe or unsafe.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P7000497027000000000000000047121" id="P7000497027000000000000000047121">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047122" id="P7000497027000000000000000047122"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047123" id="P7000497027000000000000000047123"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047124" id="P7000497027000000000000000047124"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047125" id="P7000497027000000000000000047125"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub></p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047126" id="P7000497027000000000000000047126"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047127" id="P7000497027000000000000000047127"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub></p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000869B" id="P700049702700000000000000000869B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047128" epub:type="title" id="P7000497027000000000000000047128"><span class="pcalibre1 pcalibre21 pcalibre2">12.19 </span>♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047129" id="P7000497027000000000000000047129">The solution to the first readers-writers problem in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008459"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.26</span></a> gives a somewhat weak priority to readers because a writer leaving its critical section might restart a waiting writer instead of a waiting reader. Derive a solution that gives stronger priority to readers, where a writer leaving its critical section will always restart a waiting reader if one exists.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000869E" id="P700049702700000000000000000869E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004712A" epub:type="title" id="P700049702700000000000000004712A"><span class="pcalibre1 pcalibre21 pcalibre2">12.20  </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004712B" id="P700049702700000000000000004712B">Consider a simpler variant of the readers-writers problem where there are at most <var class="pcalibre17 pcalibre2 pcalibre1">N</var> readers. Derive a solution that gives equal priority to readers and writers, in the sense that pending readers and writers have an equal chance of being granted access to the resource. <i class="pcalibre17 pcalibre2 pcalibre1">Hint:</i> You can solve this problem using a single counting semaphore and a single mutex.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000086A1" id="P70004970270000000000000000086A1"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004712C" epub:type="title" id="P700049702700000000000000004712C"><span class="pcalibre1 pcalibre21 pcalibre2">12.21  </span>♦♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004712D" id="P700049702700000000000000004712D">Derive a solution to the second readers-writers problem, which favors writers instead of readers.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000086A4" id="P70004970270000000000000000086A4"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004712E" epub:type="title" id="P700049702700000000000000004712E"><span class="pcalibre1 pcalibre21 pcalibre2">12.22 </span>♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004712F" id="P700049702700000000000000004712F">Test your understanding of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047130" id="P7000497027000000000000000047130">select</code> function by modifying the server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000080DE.xhtml#P7000497027000000000000000008109"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.6</span></a> so that it echoes at most one text line per iteration of the main server loop.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000086A8" id="P70004970270000000000000000086A8"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047131" epub:type="title" id="P7000497027000000000000000047131"><span class="pcalibre1 pcalibre21 pcalibre2">12.23 </span>♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047132" id="P7000497027000000000000000047132">The event-driven concurrent echo server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000080DE.xhtml#P7000497027000000000000000008144"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.8</span></a> is flawed because a malicious client can deny service to other clients by sending a partial text line. Write an improved version of the server that can handle these partial text lines without blocking.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000086AB" id="P70004970270000000000000000086AB"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047133" epub:type="title" id="P7000497027000000000000000047133"><span class="pcalibre1 pcalibre21 pcalibre2">12.24 </span>♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047134" id="P7000497027000000000000000047134">The functions in the R<span class="pcalibre1 pcalibre29 pcalibre2">io </span>I/O package (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007975.xhtml#P7000497027000000000000000007975"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">10.5</span></a>) are thread-safe. Are they reentrant as well?</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000086AE" id="P70004970270000000000000000086AE"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047135" epub:type="title" id="P7000497027000000000000000047135"><span class="pcalibre1 pcalibre21 pcalibre2">12.25 </span>♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047136" id="P7000497027000000000000000047136">In the prethreaded concurrent echo server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008478"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.28</span></a>, each thread calls the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047137" id="P7000497027000000000000000047137">echo_cnt</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008482"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.29</span></a>). Is <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047138" id="P7000497027000000000000000047138">echo_cnt</code> thread-safe? Is it reentrant? Why or why not?</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000086B3" id="P70004970270000000000000000086B3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047139" epub:type="title" id="P7000497027000000000000000047139"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P70004970270000000000000000086B5" epub:type="pagebreak" id="P70004970270000000000000000086B5" title="1033"></span><span class="pcalibre1 pcalibre21 pcalibre2">12.26  </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004713A" id="P700049702700000000000000004713A">Use the lock-and-copy technique to implement a thread-safe non-reentrant version of <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004713B" id="P700049702700000000000000004713B">gethostbyname</code> called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004713C" id="P700049702700000000000000004713C">gethostbyname_ts</code>. A correct solution will use a deep copy of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004713D" id="P700049702700000000000000004713D">hostent</code> structure protected by a mutex.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000086BA" id="P70004970270000000000000000086BA"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004713E" epub:type="title" id="P700049702700000000000000004713E"><span class="pcalibre1 pcalibre21 pcalibre2">12.27 </span>♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004713F" id="P700049702700000000000000004713F">Some network programming texts suggest the following approach for reading and writing sockets: Before interacting with the client, open two standard I/O streams on the same open connected socket descriptor, one for reading and one for writing:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047140" id="P7000497027000000000000000047140"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047141" id="P7000497027000000000000000047141">FILE *fpin, *fpout;</code></pre>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047142" id="P7000497027000000000000000047142"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047143" id="P7000497027000000000000000047143">
fpin = fdopen(sockfd, "r");
fpout = fdopen(sockfd, "w");</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047144" id="P7000497027000000000000000047144">When the server finishes interacting with the client, close both streams as follows:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047145" id="P7000497027000000000000000047145"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047146" id="P7000497027000000000000000047146">fclose(fpin);
fclose(fpout);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047147" id="P7000497027000000000000000047147">However, if you try this approach in a concurrent server based on threads, you will create a deadly race condition. Explain.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000086C5" id="P70004970270000000000000000086C5"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047148" epub:type="title" id="P7000497027000000000000000047148"><span class="pcalibre1 pcalibre21 pcalibre2">12.28 </span>♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047149" id="P7000497027000000000000000047149">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008577.xhtml#P7000497027000000000000000008653"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.45</span></a>, does swapping the order of the two <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operations have any effect on whether or not the program deadlocks? Justify your answer by drawing the progress graphs for the four possible cases:</p>
<table class="pcalibre1 informaltable pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004714A" id="P700049702700000000000000004714A">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter12.xhtml#P700049702700000000000000004714B" id="P700049702700000000000000004714B">Case1</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter12.xhtml#P700049702700000000000000004714C" id="P700049702700000000000000004714C">Case2</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter12.xhtml#P700049702700000000000000004714D" id="P700049702700000000000000004714D">Case3</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="2" data-uri="chapter12.xhtml#P700049702700000000000000004714E" id="P700049702700000000000000004714E">Case 4</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P700049702700000000000000004714F" id="P700049702700000000000000004714F">Thread 1</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047150" id="P7000497027000000000000000047150">Thread 2</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047151" id="P7000497027000000000000000047151">Thread 1</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047152" id="P7000497027000000000000000047152">Thread 2</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047153" id="P7000497027000000000000000047153">Thread 1</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047154" id="P7000497027000000000000000047154">Thread 2</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047155" id="P7000497027000000000000000047155">Thread 1</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047156" id="P7000497027000000000000000047156">Thread 2</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047157" id="P7000497027000000000000000047157"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047158" id="P7000497027000000000000000047158">P(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047159" id="P7000497027000000000000000047159"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004715A" id="P700049702700000000000000004715A">P(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004715B" id="P700049702700000000000000004715B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004715C" id="P700049702700000000000000004715C">P(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004715D" id="P700049702700000000000000004715D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004715E" id="P700049702700000000000000004715E">P(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004715F" id="P700049702700000000000000004715F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047160" id="P7000497027000000000000000047160">P(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047161" id="P7000497027000000000000000047161"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047162" id="P7000497027000000000000000047162">P(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047163" id="P7000497027000000000000000047163"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047164" id="P7000497027000000000000000047164">P(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047165" id="P7000497027000000000000000047165"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047166" id="P7000497027000000000000000047166">P(s)</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047167" id="P7000497027000000000000000047167"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047168" id="P7000497027000000000000000047168">P(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047169" id="P7000497027000000000000000047169"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004716A" id="P700049702700000000000000004716A">P(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004716B" id="P700049702700000000000000004716B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004716C" id="P700049702700000000000000004716C">P(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004716D" id="P700049702700000000000000004716D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004716E" id="P700049702700000000000000004716E">P(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004716F" id="P700049702700000000000000004716F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047170" id="P7000497027000000000000000047170">P(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047171" id="P7000497027000000000000000047171"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047172" id="P7000497027000000000000000047172">P(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047173" id="P7000497027000000000000000047173"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047174" id="P7000497027000000000000000047174">P(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047175" id="P7000497027000000000000000047175"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047176" id="P7000497027000000000000000047176">P(t)</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047177" id="P7000497027000000000000000047177"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047178" id="P7000497027000000000000000047178">V(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047179" id="P7000497027000000000000000047179"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004717A" id="P700049702700000000000000004717A">V(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004717B" id="P700049702700000000000000004717B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004717C" id="P700049702700000000000000004717C">V(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004717D" id="P700049702700000000000000004717D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004717E" id="P700049702700000000000000004717E">V(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004717F" id="P700049702700000000000000004717F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047180" id="P7000497027000000000000000047180">V(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047181" id="P7000497027000000000000000047181"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047182" id="P7000497027000000000000000047182">V(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047183" id="P7000497027000000000000000047183"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047184" id="P7000497027000000000000000047184">V(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047185" id="P7000497027000000000000000047185"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047186" id="P7000497027000000000000000047186">V(t)</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047187" id="P7000497027000000000000000047187"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047188" id="P7000497027000000000000000047188">V(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047189" id="P7000497027000000000000000047189"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004718A" id="P700049702700000000000000004718A">V(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004718B" id="P700049702700000000000000004718B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004718C" id="P700049702700000000000000004718C">V(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004718D" id="P700049702700000000000000004718D"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004718E" id="P700049702700000000000000004718E">V(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004718F" id="P700049702700000000000000004718F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047190" id="P7000497027000000000000000047190">V(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047191" id="P7000497027000000000000000047191"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047192" id="P7000497027000000000000000047192">V(t)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047193" id="P7000497027000000000000000047193"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047194" id="P7000497027000000000000000047194">V(s)</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047195" id="P7000497027000000000000000047195"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047196" id="P7000497027000000000000000047196">V(s)</code></td>
</tr>
</tbody>
</table>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008715" id="P7000497027000000000000000008715"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047197" epub:type="title" id="P7000497027000000000000000047197"><span class="pcalibre1 pcalibre21 pcalibre2">12.29 </span>♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047198" id="P7000497027000000000000000047198">Can the following program deadlock? Why or why not?</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047199" id="P7000497027000000000000000047199"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004719A" id="P700049702700000000000000004719A">Initially: a = 1, b = 1, c = 1.</code></pre>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P700049702700000000000000004719B" id="P700049702700000000000000004719B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004719C" id="P700049702700000000000000004719C">
     Thread 1:	     Thread 2:
	P(a);		P(c);
	P(b);		P(b);
	V(b);		V(b);
	P(c);		V(c);
	V(c);		
	V(a);		</code></pre>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000871C" id="P700049702700000000000000000871C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004719D" epub:type="title" id="P700049702700000000000000004719D"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000871E" epub:type="pagebreak" id="P700049702700000000000000000871E" title="1034"></span><span class="pcalibre1 pcalibre21 pcalibre2">12.30 </span>♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004719E" id="P700049702700000000000000004719E">Consider the following program that deadlocks.</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P700049702700000000000000004719F" id="P700049702700000000000000004719F"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471A0" id="P70004970270000000000000000471A0">Initially: a = 1, b = 1, c = 1.</code></pre>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000471A1" id="P70004970270000000000000000471A1">
<code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471A2" id="P70004970270000000000000000471A2">     Thread 1:	     Thread 2:	     Thread 3:
	P(a);		P(c);		P(c);
	P(b);		P(b);		V(c);
	V(b);		V(b);		P(b);
	P(c);		V(c);		P(a);
	V(c);		P(a);		V(a);
	V(a);		V(a);		V(b);</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P70004970270000000000000000471A3" id="P70004970270000000000000000471A3">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000471A4" id="P70004970270000000000000000471A4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000471A5" id="P70004970270000000000000000471A5">For each thread, list the pairs of mutexes that it holds simultaneously.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000471A6" id="P70004970270000000000000000471A6"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000471A7" id="P70004970270000000000000000471A7">If <i class="pcalibre17 pcalibre2 pcalibre1">a &lt; b &lt; c</i>, which threads violate the mutex lock ordering rule?</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000471A8" id="P70004970270000000000000000471A8"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000471A9" id="P70004970270000000000000000471A9">For these threads, show a new lock ordering that guarantees freedom from deadlock.</p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000872B" id="P700049702700000000000000000872B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471AA" epub:type="title" id="P70004970270000000000000000471AA"><span class="pcalibre1 pcalibre21 pcalibre2">12.31  </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471AB" id="P70004970270000000000000000471AB">Implement a version of the standard I/O <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471AC" id="P70004970270000000000000000471AC">fgets</code> function, called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471AD" id="P70004970270000000000000000471AD">tfgets</code>, that times out and returns <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471AE" id="P70004970270000000000000000471AE">NULL</code> if it does not receive an input line on standard input within 5 seconds. Your function should be implemented in a package called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471AF" id="P70004970270000000000000000471AF">tfgets-proc.c</code> using processes, signals, and nonlocal jumps. It should not use the Linux alarm function. Test your solution using the driver program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008732"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.47</span></a>.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008732" id="P7000497027000000000000000008732">
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471B0" id="P70004970270000000000000000471B0">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/tfgets-main.c</i></p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000471B1" id="P70004970270000000000000000471B1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471B2" id="P70004970270000000000000000471B2">
1	#include "csapp.h"
2
3	char *tfgets(char *s, int size, FILE *stream);
4
5	int main()
6	{
7		char buf[MAXLINE];
8
9		if (tfgets(buf, MAXLINE, stdin) == NULL)
10			printf("BOOM!\n");
11		else
12			printf("%s", buf);
13
14		exit(0);
15	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471B3" id="P70004970270000000000000000471B3">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/tfgets-main.c</i></p>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P70004970270000000000000000471B4" id="P70004970270000000000000000471B4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P70004970270000000000000000471B5" epub:type="title" id="P70004970270000000000000000471B5"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.47 </span>Driver program for Problems 12.31−12.33.</h1></header>
</figcaption>
</figure>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008739" id="P7000497027000000000000000008739"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471B6" epub:type="title" id="P70004970270000000000000000471B6"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000873B" epub:type="pagebreak" id="P700049702700000000000000000873B" title="1035"></span><span class="pcalibre1 pcalibre21 pcalibre2">12.32  </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471B7" id="P70004970270000000000000000471B7">Implement a version of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471B8" id="P70004970270000000000000000471B8">tfgets</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000872B"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.31</span></a> that uses the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471B9" id="P70004970270000000000000000471B9">select</code> function. Your function should be implemented in a package called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471BA" id="P70004970270000000000000000471BA">tfgets-select.c.</code> Test your solution using the driver program from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000872B"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.31</span></a>. You may assume that standard input is assigned to descriptor 0.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008740" id="P7000497027000000000000000008740"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471BB" epub:type="title" id="P70004970270000000000000000471BB"><span class="pcalibre1 pcalibre21 pcalibre2">12.33  </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471BC" id="P70004970270000000000000000471BC">Implement a threaded version of the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471BD" id="P70004970270000000000000000471BD">tfgets</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000872B"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.31</span></a>. Your function should be implemented in a package called <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471BE" id="P70004970270000000000000000471BE">tfgets-thread.c.</code> Test your solution using the driver program from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000872B"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.31</span></a>.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008745" id="P7000497027000000000000000008745"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471BF" epub:type="title" id="P70004970270000000000000000471BF"><span class="pcalibre1 pcalibre21 pcalibre2">12.34  </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471C0" id="P70004970270000000000000000471C0">Write a parallel threaded version of an <var class="pcalibre17 pcalibre2 pcalibre1">N</var> × <var class="pcalibre17 pcalibre2 pcalibre1">M</var> matrix multiplication kernel. Compare the performance to the sequential case.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008748" id="P7000497027000000000000000008748"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471C1" epub:type="title" id="P70004970270000000000000000471C1"><span class="pcalibre1 pcalibre21 pcalibre2">12.35  </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471C2" id="P70004970270000000000000000471C2">Implement a concurrent version of the T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>Web server based on processes. Your solution should create a new child process for each new connection request. Test your solution using a real Web browser.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000874B" id="P700049702700000000000000000874B"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471C3" epub:type="title" id="P70004970270000000000000000471C3"><span class="pcalibre1 pcalibre21 pcalibre2">12.36  </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471C4" id="P70004970270000000000000000471C4">Implement a concurrent version of the T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>Web server based on I/O multiplexing. Test your solution using a real Web browser.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000874E" id="P700049702700000000000000000874E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471C5" epub:type="title" id="P70004970270000000000000000471C5"><span class="pcalibre1 pcalibre21 pcalibre2">12.37  </span>♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471C6" id="P70004970270000000000000000471C6">Implement a concurrent version of the T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>Web server based on threads. Your solution should create a new thread for each new connection request. Test your solution using a real Web browser.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008751" id="P7000497027000000000000000008751"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471C7" epub:type="title" id="P70004970270000000000000000471C7"><span class="pcalibre1 pcalibre21 pcalibre2">12.38  </span>♦♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471C8" id="P70004970270000000000000000471C8">Implement a concurrent prethreaded version of the T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>Web server. Your solution should dynamically increase or decrease the number of threads in response to the current load. One strategy is to double the number of threads when the buffer becomes full, and halve the number of threads when the buffer becomes empty. Test your solution using a real Web browser.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008754" id="P7000497027000000000000000008754"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471C9" epub:type="title" id="P70004970270000000000000000471C9"><span class="pcalibre1 pcalibre21 pcalibre2">12.39  </span>♦♦♦♦</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471CA" id="P70004970270000000000000000471CA">A Web proxy is a program that acts as a middleman between a Web server and browser. Instead of contacting the server directly to get a Web page, the browser contacts the proxy, which forwards the request to the server. When the server replies to the proxy, the proxy sends the reply to the browser. For this lab, you will write a simple Web proxy that filters and logs requests:</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P70004970270000000000000000471CB" id="P70004970270000000000000000471CB">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000471CC" id="P70004970270000000000000000471CC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000471CD" id="P70004970270000000000000000471CD">In the first part of the lab, you will set up the proxy to accept requests, parse the HTTP, forward the requests to the server, and return the results to the browser. Your proxy should log the URLs of all requests in a log file on disk, and it should also block requests to any URL contained in a filter file on disk.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000471CE" id="P70004970270000000000000000471CE"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000471CF" id="P70004970270000000000000000471CF"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000875C" epub:type="pagebreak" id="P700049702700000000000000000875C" title="1036"></span>In the second part of the lab, you will upgrade your proxy to deal with multiple open connections at once by spawning a separate thread to handle each request. While your proxy is waiting for a remote server to respond to a request so that it can serve one browser, it should be working on a pending request from another browser.</p></li>
</ol>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471D0" id="P70004970270000000000000000471D0">Check your proxy solution using a real Web browser.</p>
</section>
</section></body></html>
<?xml version='1.0' encoding='utf-8'?>
<html epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta content="PXE Basic 1.0" name="dcterms.conformsTo"/>
<meta content="PXE Tools version 1.39.52" name="generator"/>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
<title>Solutions to Practice Problems </title>
<link href="../css/theme/night.css" rel="alternate stylesheet" title="night" type="text/css"/>
<link href="../css/theme/sepia.css" rel="alternate stylesheet" title="sepia" type="text/css"/>
<script src="js/format_lg_obj.js"></script>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body class="pcalibre1 pcalibre2 pcalibre" epub:type="bodymatter">
<section class="pcalibre1 pcalibre2 pcalibre3" id="P700049702700000000000000000875E"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" data-uri="chapter12.xhtml#P70004970270000000000000000471D1" epub:type="title" id="P70004970270000000000000000471D1"><span class="pcalibre1 pcalibre21 pcalibre2">Solutions to Practice Problems </span></h1></header>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008760" id="P7000497027000000000000000008760"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471D2" epub:type="title" id="P70004970270000000000000000471D2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008097.xhtml#P70004970270000000000000000080C3"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.1 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000008097.xhtml#P70004970270000000000000000080B7">975</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471D3" id="P70004970270000000000000000471D3">When the parent forks the child, it gets a copy of the connected descriptor, and the reference count for the associated file table is incremented from 1 to 2. When the parent closes its copy of the descriptor, the reference count is decremented from 2 to 1. Since the kernel will not close a file until the reference counter in its file table goes to 0, the child's end of the connection stays open.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008763" id="P7000497027000000000000000008763"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471D4" epub:type="title" id="P70004970270000000000000000471D4"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008097.xhtml#P70004970270000000000000000080C9"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.2 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000008097.xhtml#P70004970270000000000000000080B7">975</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471D5" id="P70004970270000000000000000471D5">When a process terminates for any reason, the kernel closes all open descriptors. Thus, the child's copy of the connected file descriptor will be closed automatically when the child exits.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008766" id="P7000497027000000000000000008766"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471D6" epub:type="title" id="P70004970270000000000000000471D6"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000080DE.xhtml#P700049702700000000000000000811E"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.3 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000080DE.xhtml#P7000497027000000000000000008115">980</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471D7" id="P70004970270000000000000000471D7">Recall that a descriptor is ready for reading if a request to read 1 byte from that descriptor would not block. If EOF becomes true on a descriptor, then the descriptor is ready for reading because the read operation will return immediately with a zero return code indicating EOF. Thus, typing Ctrl+D causes the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471D8" id="P70004970270000000000000000471D8">select</code> function to return with descriptor 0 in the ready set.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000876A" id="P700049702700000000000000000876A"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471D9" epub:type="title" id="P70004970270000000000000000471D9"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000080DE.xhtml#P700049702700000000000000000816C"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.4 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000080DE.xhtml#P7000497027000000000000000008160">984</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471DA" id="P70004970270000000000000000471DA">We reinitialize the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471DB" id="P70004970270000000000000000471DB">pool.ready_set</code> variable before every call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471DC" id="P70004970270000000000000000471DC">select</code> because it serves as both an input and output argument. On input, it contains the read set. On output, it contains the ready set.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000876F" id="P700049702700000000000000000876F"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471DD" epub:type="title" id="P70004970270000000000000000471DD"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000817D.xhtml#P7000497027000000000000000008217"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000817D.xhtml#P7000497027000000000000000008208">992</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471DE" id="P70004970270000000000000000471DE">Since threads run in the same process, they all share the same descriptor table. No matter how many threads use the connected descriptor, the reference count for the connected descriptor's file table is equal to 1. Thus, a single <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471DF" id="P70004970270000000000000000471DF">close</code> operation is sufficient to free the memory resources associated with the connected descriptor when we are through with it.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008773" id="P7000497027000000000000000008773"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471E0" epub:type="title" id="P70004970270000000000000000471E0"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000821D.xhtml#P700049702700000000000000000824E"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.6 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000821D.xhtml#P7000497027000000000000000008245">995</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471E1" id="P70004970270000000000000000471E1">The main idea here is that stack variables are private, whereas global and static variables are shared. Static variables such as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471E2" id="P70004970270000000000000000471E2">cnt</code> are a little tricky because the sharing is limited to the functions within their scope—in this case, the thread routine.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P70004970270000000000000000471E3" id="P70004970270000000000000000471E3">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000471E4" id="P70004970270000000000000000471E4"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000471E5" id="P70004970270000000000000000471E5"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000877A" epub:type="pagebreak" id="P700049702700000000000000000877A" title="1037"></span>Here is the table:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P70004970270000000000000000471E6" id="P70004970270000000000000000471E6">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P70004970270000000000000000471E7" id="P70004970270000000000000000471E7" rowspan="2">Variable instance</th>
<th class="pcalibre1 pcalibre2 calibre5" colspan="3" data-uri="chapter12.xhtml#P70004970270000000000000000471E8" id="P70004970270000000000000000471E8">Referenced by</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P70004970270000000000000000471E9" id="P70004970270000000000000000471E9">main thread?</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P70004970270000000000000000471EA" id="P70004970270000000000000000471EA">peer thread 0?</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P70004970270000000000000000471EB" id="P70004970270000000000000000471EB">peer thread 1?</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471EC" id="P70004970270000000000000000471EC"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471ED" id="P70004970270000000000000000471ED">ptr</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471EE" id="P70004970270000000000000000471EE">yes</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471EF" id="P70004970270000000000000000471EF">yes</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471F0" id="P70004970270000000000000000471F0">yes</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471F1" id="P70004970270000000000000000471F1"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471F2" id="P70004970270000000000000000471F2">cnt</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471F3" id="P70004970270000000000000000471F3">no</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471F4" id="P70004970270000000000000000471F4">yes</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471F5" id="P70004970270000000000000000471F5">yes</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471F6" id="P70004970270000000000000000471F6"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471F7" id="P70004970270000000000000000471F7">i.m</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471F8" id="P70004970270000000000000000471F8">yes</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471F9" id="P70004970270000000000000000471F9">no</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471FA" id="P70004970270000000000000000471FA">no</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471FB" id="P70004970270000000000000000471FB"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000471FC" id="P70004970270000000000000000471FC">msgs.m</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471FD" id="P70004970270000000000000000471FD">yes</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471FE" id="P70004970270000000000000000471FE">yes</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P70004970270000000000000000471FF" id="P70004970270000000000000000471FF">yes</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047200" id="P7000497027000000000000000047200"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047201" id="P7000497027000000000000000047201">myid.p0</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047202" id="P7000497027000000000000000047202">no</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047203" id="P7000497027000000000000000047203">yes</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047204" id="P7000497027000000000000000047204">no</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047205" id="P7000497027000000000000000047205"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047206" id="P7000497027000000000000000047206">myid.p1</code></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047207" id="P7000497027000000000000000047207">no</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047208" id="P7000497027000000000000000047208">no</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047209" id="P7000497027000000000000000047209">yes</td>
</tr>
</tbody>
</table>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P700049702700000000000000004720A" id="P700049702700000000000000004720A">Notes:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004720B" id="P700049702700000000000000004720B">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P700049702700000000000000004720C" id="P700049702700000000000000004720C"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P700049702700000000000000004720D" id="P700049702700000000000000004720D"><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004720E" id="P700049702700000000000000004720E">ptr</code> A global variable that is written by the main thread and read by the peer threads.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P700049702700000000000000004720F" id="P700049702700000000000000004720F"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000047210" id="P7000497027000000000000000047210"><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047211" id="P7000497027000000000000000047211">cnt</code> A static variable with only one instance in memory that is read and written by the two peer threads.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047212" id="P7000497027000000000000000047212"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000047213" id="P7000497027000000000000000047213"><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047214" id="P7000497027000000000000000047214">i.m</code> A local automatic variable stored on the stack of the main thread. Even though its value is passed to the peer threads, the peer threads never reference it on the stack, and thus it is not shared.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047215" id="P7000497027000000000000000047215"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P7000497027000000000000000047216" id="P7000497027000000000000000047216"><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047217" id="P7000497027000000000000000047217">msgs.m</code> A local automatic variable stored on the main thread's stack and referenced indirectly through <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047218" id="P7000497027000000000000000047218">ptr</code> by both peer threads.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047219" id="P7000497027000000000000000047219"><p class="pcalibre1 pcalibre2 pcalibre40" data-uri="chapter12.xhtml#P700049702700000000000000004721A" id="P700049702700000000000000004721A"><code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004721B" id="P700049702700000000000000004721B">myid.p0</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004721C" id="P700049702700000000000000004721C">myid.p1</code> Instances of a local automatic variable residing on the stacks of peer threads 0 and 1, respectively.</p></li>
</ul></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P700049702700000000000000004721D" id="P700049702700000000000000004721D"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P700049702700000000000000004721E" id="P700049702700000000000000004721E">Variables <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004721F" id="P700049702700000000000000004721F">ptr, cnt</code>, and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047220" id="P7000497027000000000000000047220">msgs</code> are referenced by more than one thread and thus are shared.</p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P70004970270000000000000000087B6" id="P70004970270000000000000000087B6"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047221" epub:type="title" id="P7000497027000000000000000047221"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008342"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000827E.xhtml#P70004970270000000000000000082AB">998</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047222" id="P7000497027000000000000000047222">The important idea here is that you cannot make any assumptions about the ordering that the kernel chooses when it schedules your threads.</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000047223" id="P7000497027000000000000000047223">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047224" id="P7000497027000000000000000047224">Step</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047225" id="P7000497027000000000000000047225">Thread</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047226" id="P7000497027000000000000000047226">Instr.</th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047227" id="P7000497027000000000000000047227"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047228" id="P7000497027000000000000000047228">%rdx</code><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P7000497027000000000000000047229" id="P7000497027000000000000000047229"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004722A" id="P700049702700000000000000004722A">%rdx</code><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></th>
<th class="pcalibre1 pcalibre2 calibre5" data-uri="chapter12.xhtml#P700049702700000000000000004722B" id="P700049702700000000000000004722B"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004722C" id="P700049702700000000000000004722C">cnt</code></th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004722D" id="P700049702700000000000000004722D">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004722E" id="P700049702700000000000000004722E">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004722F" id="P700049702700000000000000004722F"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047230" id="P7000497027000000000000000047230">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047231" id="P7000497027000000000000000047231">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047232" id="P7000497027000000000000000047232">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047233" id="P7000497027000000000000000047233">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047234" id="P7000497027000000000000000047234">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047235" id="P7000497027000000000000000047235"><var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047236" id="P7000497027000000000000000047236">0</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047237" id="P7000497027000000000000000047237">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047238" id="P7000497027000000000000000047238">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047239" id="P7000497027000000000000000047239">3</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004723A" id="P700049702700000000000000004723A">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004723B" id="P700049702700000000000000004723B"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004723C" id="P700049702700000000000000004723C">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004723D" id="P700049702700000000000000004723D">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004723E" id="P700049702700000000000000004723E">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004723F" id="P700049702700000000000000004723F">4</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047240" id="P7000497027000000000000000047240">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047241" id="P7000497027000000000000000047241"><var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047242" id="P7000497027000000000000000047242">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047243" id="P7000497027000000000000000047243">0</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047244" id="P7000497027000000000000000047244">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047245" id="P7000497027000000000000000047245">5</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047246" id="P7000497027000000000000000047246">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047247" id="P7000497027000000000000000047247"><var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047248" id="P7000497027000000000000000047248">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047249" id="P7000497027000000000000000047249">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004724A" id="P700049702700000000000000004724A">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004724B" id="P700049702700000000000000004724B">6</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004724C" id="P700049702700000000000000004724C">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004724D" id="P700049702700000000000000004724D"><var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004724E" id="P700049702700000000000000004724E">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004724F" id="P700049702700000000000000004724F">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047250" id="P7000497027000000000000000047250">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047251" id="P7000497027000000000000000047251">7</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047252" id="P7000497027000000000000000047252">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047253" id="P7000497027000000000000000047253"><var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047254" id="P7000497027000000000000000047254">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047255" id="P7000497027000000000000000047255">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047256" id="P7000497027000000000000000047256">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047257" id="P7000497027000000000000000047257">8</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047258" id="P7000497027000000000000000047258">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047259" id="P7000497027000000000000000047259"><var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004725A" id="P700049702700000000000000004725A">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004725B" id="P700049702700000000000000004725B">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004725C" id="P700049702700000000000000004725C">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004725D" id="P700049702700000000000000004725D">9</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004725E" id="P700049702700000000000000004725E">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004725F" id="P700049702700000000000000004725F"><var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047260" id="P7000497027000000000000000047260">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047261" id="P7000497027000000000000000047261">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047262" id="P7000497027000000000000000047262">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047263" id="P7000497027000000000000000047263">10</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047264" id="P7000497027000000000000000047264">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047265" id="P7000497027000000000000000047265"><var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047266" id="P7000497027000000000000000047266">—</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047267" id="P7000497027000000000000000047267">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047268" id="P7000497027000000000000000047268">1</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047269" id="P7000497027000000000000000047269">Variable <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004726A" id="P700049702700000000000000004726A">cnt</code> has a final incorrect value of 1.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008801" id="P7000497027000000000000000008801"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004726B" epub:type="title" id="P700049702700000000000000004726B"><span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008803" epub:type="pagebreak" id="P7000497027000000000000000008803" title="1038"></span><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P70004970270000000000000000083BC"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.8 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000827E.xhtml#P70004970270000000000000000083B6">1001</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004726C" id="P700049702700000000000000004726C">This problem is a simple test of your understanding of safe and unsafe trajectories in progress graphs. Trajectories such as A and C that skirt the critical region are safe and will produce correct results.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P700049702700000000000000004726D" id="P700049702700000000000000004726D">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P700049702700000000000000004726E" id="P700049702700000000000000004726E"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P700049702700000000000000004726F" id="P700049702700000000000000004726F"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>: safe</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047270" id="P7000497027000000000000000047270"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047271" id="P7000497027000000000000000047271"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>: unsafe</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047272" id="P7000497027000000000000000047272"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047273" id="P7000497027000000000000000047273"><var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">H</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">L</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">T</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>: safe</p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000880C" id="P700049702700000000000000000880C"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047274" epub:type="title" id="P7000497027000000000000000047274"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P700049702700000000000000000842B"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.9 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000827E.xhtml#P700049702700000000000000000841B">1006</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P7000497027000000000000000047275" id="P7000497027000000000000000047275">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047276" id="P7000497027000000000000000047276"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047277" id="P7000497027000000000000000047277"><var class="pcalibre17 pcalibre2 pcalibre1">p</var> = 1, <var class="pcalibre17 pcalibre2 pcalibre1">c</var> = 1, <var class="pcalibre17 pcalibre2 pcalibre1">n</var> &gt; 1: Yes, the mutex semaphore is necessary because the producer and consumer can concurrently access the buffer.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P7000497027000000000000000047278" id="P7000497027000000000000000047278"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P7000497027000000000000000047279" id="P7000497027000000000000000047279"><var class="pcalibre17 pcalibre2 pcalibre1">p</var> = 1, <var class="pcalibre17 pcalibre2 pcalibre1">c</var> = 1, <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 1: No, the mutex semaphore is not necessary in this case, because a nonempty buffer is equivalent to a full buffer. When the buffer contains an item, the producer is blocked. When the buffer is empty, the consumer is blocked. So at any point in time, only a single thread can access the buffer, and thus mutual exclusion is guaranteed without using the mutex.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P700049702700000000000000004727A" id="P700049702700000000000000004727A"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P700049702700000000000000004727B" id="P700049702700000000000000004727B"><var class="pcalibre17 pcalibre2 pcalibre1">p</var> &gt; 1, <var class="pcalibre17 pcalibre2 pcalibre1">c</var> &gt; 1, <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 1: No, the mutex semaphore is not necessary in this case either, by the same argument as the previous case.</p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008815" id="P7000497027000000000000000008815"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004727C" epub:type="title" id="P700049702700000000000000004727C"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008450"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.10 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008447">1008</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004727D" id="P700049702700000000000000004727D">Suppose that a particular semaphore implementation uses a LIFO stack of threads for each semaphore. When a thread blocks on a semaphore in a <var class="pcalibre17 pcalibre2 pcalibre1">P</var> operation, its ID is pushed onto the stack. Similarly, the <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operation pops the top thread ID from the stack and restarts that thread. Given this stack implementation, an adversarial writer in its critical section could simply wait until another writer blocks on the semaphore before releasing the semaphore. In this scenario, a waiting reader might wait forever as two writers passed control back and forth.</p>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004727E" id="P700049702700000000000000004727E">Notice that although it might seem more intuitive to use a FIFO queue rather than a LIFO stack, using such a stack is not incorrect and does not violate the semantics of the <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operations.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008819" id="P7000497027000000000000000008819"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004727F" epub:type="title" id="P700049702700000000000000004727F"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000849B.xhtml#P700049702700000000000000000855F"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.11 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000849B.xhtml#P700049702700000000000000000855E">1020</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047280" id="P7000497027000000000000000047280">This problem is a simple sanity check of your understanding of speedup and parallel efficiency:</p>
<table class="pcalibre1 pcalibre2 pcalibre43" data-uri="chapter12.xhtml#P7000497027000000000000000047281" id="P7000497027000000000000000047281">
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047282" id="P7000497027000000000000000047282">Threads (<var class="pcalibre17 pcalibre2 pcalibre1">t</var>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047283" id="P7000497027000000000000000047283">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047284" id="P7000497027000000000000000047284">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047285" id="P7000497027000000000000000047285">4</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047286" id="P7000497027000000000000000047286">Cores (<var class="pcalibre17 pcalibre2 pcalibre1">p</var>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047287" id="P7000497027000000000000000047287">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047288" id="P7000497027000000000000000047288">2</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047289" id="P7000497027000000000000000047289">4</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004728A" id="P700049702700000000000000004728A">Running time (<i class="pcalibre17 pcalibre2 pcalibre1">T<sub class="pcalibre97 pcalibre2 pcalibre1">p</sub></i>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004728B" id="P700049702700000000000000004728B">12</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004728C" id="P700049702700000000000000004728C">8</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004728D" id="P700049702700000000000000004728D">6</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004728E" id="P700049702700000000000000004728E">Speedup (<i class="pcalibre17 pcalibre2 pcalibre1">S<sub class="pcalibre97 pcalibre2 pcalibre1">p</sub></i>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P700049702700000000000000004728F" id="P700049702700000000000000004728F">1</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047290" id="P7000497027000000000000000047290">1.5</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047291" id="P7000497027000000000000000047291">2</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047292" id="P7000497027000000000000000047292">Efficiency (<i class="pcalibre17 pcalibre2 pcalibre1">E<sub class="pcalibre97 pcalibre2 pcalibre1">p</sub></i>)</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047293" id="P7000497027000000000000000047293">100%</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047294" id="P7000497027000000000000000047294">75%</td>
<td class="pcalibre1 pcalibre2 calibre7" data-uri="chapter12.xhtml#P7000497027000000000000000047295" id="P7000497027000000000000000047295">50%</td>
</tr>
</tbody>
</table>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008831" id="P7000497027000000000000000008831"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047296" epub:type="title" id="P7000497027000000000000000047296"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008577.xhtml#P70004970270000000000000000085C5"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.12 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000008577.xhtml#P70004970270000000000000000085C2">1024</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047297" id="P7000497027000000000000000047297">The <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047298" id="P7000497027000000000000000047298">ctime_ts</code> function is not reentrant, because each invocation shares the same <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P7000497027000000000000000047299" id="P7000497027000000000000000047299">static</code> variable returned by the <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004729A" id="P700049702700000000000000004729A">ctime</code> function. However, it is thread-safe because <span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P7000497027000000000000000008837" epub:type="pagebreak" id="P7000497027000000000000000008837" title="1039"></span>the accesses to the shared variable are protected by <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operations, and thus are mutually exclusive.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008838" id="P7000497027000000000000000008838"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004729B" epub:type="title" id="P700049702700000000000000004729B"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008577.xhtml#P7000497027000000000000000008627"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.13 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000008577.xhtml#P700049702700000000000000000861C">1026</a>)</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004729C" id="P700049702700000000000000004729C">If we free the block immediately after the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004729D" id="P700049702700000000000000004729D">pthread_create</code> in line 14, then we will introduce a new race, this time between the call to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004729E" id="P700049702700000000000000004729E">free</code> in the main thread and the assignment statement in line 24 of the thread routine.</p>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P700049702700000000000000000883D" id="P700049702700000000000000000883D"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P700049702700000000000000004729F" epub:type="title" id="P700049702700000000000000004729F"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008577.xhtml#P700049702700000000000000000862D"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.14 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000008577.xhtml#P700049702700000000000000000861C">1026</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P70004970270000000000000000472A0" id="P70004970270000000000000000472A0">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000472A1" id="P70004970270000000000000000472A1"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000472A2" id="P70004970270000000000000000472A2">Another approach is to pass the integer <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472A3" id="P70004970270000000000000000472A3">i</code> directly, rather than passing a pointer to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472A4" id="P70004970270000000000000000472A4">i</code>:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000472A5" id="P70004970270000000000000000472A5"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472A6" id="P70004970270000000000000000472A6">for (i = 0; i &lt; N; i++)
	Pthread_create(&amp;tid[i], NULL, thread, (void *)i);</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000472A7" id="P70004970270000000000000000472A7">In the thread routine, we cast the argument back to an <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472A8" id="P70004970270000000000000000472A8">int</code> and assign it to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472A9" id="P70004970270000000000000000472A9">myid</code>:</p>
<pre class="calibre2 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000472AA" id="P70004970270000000000000000472AA"><code class="calibre3 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472AB" id="P70004970270000000000000000472AB">int myid = (int) vargp;</code></pre></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000472AC" id="P70004970270000000000000000472AC"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000472AD" id="P70004970270000000000000000472AD">The advantage is that it reduces overhead by eliminating the calls to <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472AE" id="P70004970270000000000000000472AE">malloc</code> and <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472AF" id="P70004970270000000000000000472AF">free</code>. A significant disadvantage is that it assumes that pointers are at least as large as <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472B0" id="P70004970270000000000000000472B0">ints</code>. While this assumption is true for all modern systems, it might not be true for legacy or future systems.</p></li>
</ol>
</section>
<section class="pcalibre1 pcalibre2 pcalibre3" data-uri="chapter12.xhtml#P7000497027000000000000000008850" id="P7000497027000000000000000008850"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472B1" epub:type="title" id="P70004970270000000000000000472B1"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008577.xhtml#P700049702700000000000000000865C"><span class="pcalibre1 pcalibre21 pcalibre2">Solution to Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.15 </span></a>(page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000008577.xhtml#P7000497027000000000000000008654">1029</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre79" data-uri="chapter12.xhtml#P70004970270000000000000000472B2" id="P70004970270000000000000000472B2">
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000472B3" id="P70004970270000000000000000472B3"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000472B4" id="P70004970270000000000000000472B4">The progress graph for the original program is shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000885C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.48</span></a> on the next page.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000472B5" id="P70004970270000000000000000472B5"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000472B6" id="P70004970270000000000000000472B6">The program always deadlocks, since any feasible trajectory is eventually trapped in a deadlock state.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000472B7" id="P70004970270000000000000000472B7"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000472B8" id="P70004970270000000000000000472B8">To eliminate the deadlock potential, initialize the binary semaphore <code class="pcalibre1 calibre1 pcalibre2" data-uri="chapter12.xhtml#P70004970270000000000000000472B9" id="P70004970270000000000000000472B9">t</code> to 1 instead of 0.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" data-uri="chapter12.xhtml#P70004970270000000000000000472BA" id="P70004970270000000000000000472BA"><p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000472BB" id="P70004970270000000000000000472BB">The progress graph for the corrected program is shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008861"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.49</span></a>.</p></li>
</ol>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P700049702700000000000000000885C" id="P700049702700000000000000000885C">
<span class="pcalibre1 pcalibre2 pcalibre5" data-uri="chapter12.xhtml#P700049702700000000000000000885D" epub:type="pagebreak" id="P700049702700000000000000000885D" title="1040"></span>
<img alt="A graph shows regions for a program that deadlocks." class="pcalibre326 pcalibre2 pcalibre1" data-uri="P700049702700000000000000000B69E" id="P70004970270000000000000000472BC" src="Images/chapter-11-image-25.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P70004970270000000000000000472BD" id="P70004970270000000000000000472BD"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P70004970270000000000000000472BE" epub:type="title" id="P70004970270000000000000000472BE"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.48 </span>Progress graph for a program that deadlocks.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter12.xhtml#P7000497027000000000000000027631" id="P7000497027000000000000000027631">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000472BF" id="P70004970270000000000000000472BF">A graph of thread 2 versus thread 1 shows P(s), V(s), P(t), and V(t) on each axis (initially s = 1 and t = 0). Regions include a forbidden region for s from P(s) to V(s) on each axis and forbidden regions for t from P(t) spanning from between P(t) and V(t) on each axis.</p>
</details>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter12.xhtml#P7000497027000000000000000008861" id="P7000497027000000000000000008861">
<img alt="A graph shows regions for a corrected deadlock-free program." class="pcalibre326 pcalibre2 pcalibre1" data-uri="P700049702700000000000000000B69F" id="P70004970270000000000000000472C0" src="Images/chapter-11-image-26.png"/>
<figcaption class="pcalibre1 pcalibre2 calibre4" data-uri="chapter12.xhtml#P70004970270000000000000000472C1" id="P70004970270000000000000000472C1"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" data-uri="chapter12.xhtml#P70004970270000000000000000472C2" epub:type="title" id="P70004970270000000000000000472C2"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.49 </span>Progress graph for the corrected deadlock-free program.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" data-uri="chapter12.xhtml#P7000497027000000000000000027636" id="P7000497027000000000000000027636">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p class="pcalibre1 pcalibre2 pcalibre10" data-uri="chapter12.xhtml#P70004970270000000000000000472C3" id="P70004970270000000000000000472C3">A graph of thread 2 versus thread 1 shows P(s), V(s), P(t), and V(t) on each axis (initially s = 1 and t = 1). Regions include a forbidden region for s from P(s) to V(s) on each axis and a forbidden region for t from P(t) to V(t) on each axis.</p>
</details>
</figcaption>
</figure>
</section>
</section></body></html>
