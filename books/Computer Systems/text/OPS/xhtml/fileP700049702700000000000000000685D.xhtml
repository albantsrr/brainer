<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>8.4 Process Control</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P700049702700000000000000000685D" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000045056" data-uri="chapter08.xhtml#P7000497027000000000000000045056" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.4 </span>Process Control</h1></header>
<p id="P7000497027000000000000000045057" data-uri="chapter08.xhtml#P7000497027000000000000000045057" class="pcalibre8 pcalibre1 pcalibre2">Unix provides a number of system calls for manipulating processes from C programs. This section describes the important functions and gives examples of how they are used.</p>

<section id="P7000497027000000000000000006860" data-uri="chapter08.xhtml#P7000497027000000000000000006860" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045058" data-uri="chapter08.xhtml#P7000497027000000000000000045058" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006862" title="739" data-uri="chapter08.xhtml#P7000497027000000000000000006862" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">8.4.1  </span>Obtaining Process IDs</h1></header>
<p id="P7000497027000000000000000045059" data-uri="chapter08.xhtml#P7000497027000000000000000045059" class="pcalibre8 pcalibre1 pcalibre2">Each process has a unique positive (nonzero) <i class="pcalibre17 pcalibre2 pcalibre1">process ID (PID)</i>. The <code id="P700049702700000000000000004505A" data-uri="chapter08.xhtml#P700049702700000000000000004505A" class="pcalibre1 calibre1 pcalibre2">getpid</code> function returns the PID of the calling process. The <code id="P700049702700000000000000004505B" data-uri="chapter08.xhtml#P700049702700000000000000004505B" class="pcalibre1 calibre1 pcalibre2">getppid</code> function returns the PID of its <i class="pcalibre17 pcalibre2 pcalibre1">parent</i> (i.e., the process that created the calling process).</p>
<pre id="P700049702700000000000000004505C" data-uri="chapter08.xhtml#P700049702700000000000000004505C" class="calibre2 pcalibre2 pcalibre1">
<code id="P700049702700000000000000004505D" data-uri="chapter08.xhtml#P700049702700000000000000004505D" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t getpid(void);
pid_t getppid(void);
				Returns: PID of either the caller or the parent
</code>
</pre>
<p id="P700049702700000000000000004505E" data-uri="chapter08.xhtml#P700049702700000000000000004505E" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P700049702700000000000000004505F" data-uri="chapter08.xhtml#P700049702700000000000000004505F" class="pcalibre1 calibre1 pcalibre2">getpid</code> and <code id="P7000497027000000000000000045060" data-uri="chapter08.xhtml#P7000497027000000000000000045060" class="pcalibre1 calibre1 pcalibre2">getppid</code> routines return an integer value of type <code id="P7000497027000000000000000045061" data-uri="chapter08.xhtml#P7000497027000000000000000045061" class="pcalibre1 calibre1 pcalibre2">pid_t</code>, which on Linux systems is defined in <code id="P7000497027000000000000000045062" data-uri="chapter08.xhtml#P7000497027000000000000000045062" class="pcalibre1 calibre1 pcalibre2">types.h</code> as an int.</p>
</section>

<section id="P700049702700000000000000000686D" data-uri="chapter08.xhtml#P700049702700000000000000000686D" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045063" data-uri="chapter08.xhtml#P7000497027000000000000000045063" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.4.2  </span>Creating and Terminating Processes</h1></header>
<p id="P7000497027000000000000000045064" data-uri="chapter08.xhtml#P7000497027000000000000000045064" class="pcalibre8 pcalibre1 pcalibre2">From a programmer's perspective, we can think of a process as being in one of three states:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P7000497027000000000000000045065" data-uri="chapter08.xhtml#P7000497027000000000000000045065">
<li id="P7000497027000000000000000045066" data-uri="chapter08.xhtml#P7000497027000000000000000045066" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045067" data-uri="chapter08.xhtml#P7000497027000000000000000045067" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Running. </span>The process is either executing on the CPU or waiting to be executed and will eventually be scheduled by the kernel.</p></li>
<li id="P7000497027000000000000000045068" data-uri="chapter08.xhtml#P7000497027000000000000000045068" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045069" data-uri="chapter08.xhtml#P7000497027000000000000000045069" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Stopped. </span>The execution of the process is <i class="pcalibre17 pcalibre2 pcalibre1">suspended</i> and will not be scheduled. A process stops as a result of receiving a SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU signal, and it remains stopped until it receives a SIGCONT signal, at which point it becomes running again. (A <i class="pcalibre17 pcalibre2 pcalibre1">signal</i> is a form of software interrupt that we will describe in detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006993"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5</span></a>.)</p></li>
<li id="P700049702700000000000000004506A" data-uri="chapter08.xhtml#P700049702700000000000000004506A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004506B" data-uri="chapter08.xhtml#P700049702700000000000000004506B" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Terminated. </span>The process is stopped permanently. A process becomes terminated for one of three reasons: (1) receiving a signal whose default action is to terminate the process, (2) returning from the main routine, or (3) calling the <code id="P700049702700000000000000004506C" data-uri="chapter08.xhtml#P700049702700000000000000004506C" class="pcalibre1 calibre1 pcalibre2">exit</code> function.</p></li>
</ul>
<pre id="P700049702700000000000000004506D" data-uri="chapter08.xhtml#P700049702700000000000000004506D" class="calibre2 pcalibre2 pcalibre1">
<code id="P700049702700000000000000004506E" data-uri="chapter08.xhtml#P700049702700000000000000004506E" class="calibre3 pcalibre1 pcalibre2">
#include &lt;stdlib.h&gt;
void exit(int status);
				This function does not return
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004506F" data-uri="chapter08.xhtml#P700049702700000000000000004506F">The <code id="P7000497027000000000000000045070" data-uri="chapter08.xhtml#P7000497027000000000000000045070" class="pcalibre1 calibre1 pcalibre2">exit</code> function terminates the process with an <i class="pcalibre17 pcalibre2 pcalibre1">exit status</i> of <code id="P7000497027000000000000000045071" data-uri="chapter08.xhtml#P7000497027000000000000000045071" class="pcalibre1 calibre1 pcalibre2">status</code>. (The other way to set the exit status is to return an integer value from the main routine.)</p>

<p id="P7000497027000000000000000045072" data-uri="chapter08.xhtml#P7000497027000000000000000045072" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000687E" title="740" data-uri="chapter08.xhtml#P700049702700000000000000000687E" epub:type="pagebreak"></span>A <i class="pcalibre17 pcalibre2 pcalibre1">parent process</i> creates a new running <i class="pcalibre17 pcalibre2 pcalibre1">child process</i> by calling the <code id="P7000497027000000000000000045073" data-uri="chapter08.xhtml#P7000497027000000000000000045073" class="pcalibre1 calibre1 pcalibre2">fork</code> function.</p>
<pre id="P7000497027000000000000000045074" data-uri="chapter08.xhtml#P7000497027000000000000000045074" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045075" data-uri="chapter08.xhtml#P7000497027000000000000000045075" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t fork(void);
			Returns: 0 to child, PID of child to parent, -1 on error
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045076" data-uri="chapter08.xhtml#P7000497027000000000000000045076">The newly created child process is almost, but not quite, identical to the parent. The child gets an identical (but separate) copy of the parent's user-level virtual address space, including the code and data segments, heap, shared libraries, and user stack. The child also gets identical copies of any of the parent's open file descriptors, which means the child can read and write any files that were open in the parent when it called <code id="P7000497027000000000000000045077" data-uri="chapter08.xhtml#P7000497027000000000000000045077" class="pcalibre1 calibre1 pcalibre2">fork</code>. The most significant difference between the parent and the newly created child is that they have different PIDs.</p>
<p id="P7000497027000000000000000045078" data-uri="chapter08.xhtml#P7000497027000000000000000045078" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000045079" data-uri="chapter08.xhtml#P7000497027000000000000000045079" class="pcalibre1 calibre1 pcalibre2">fork</code> function is interesting (and often confusing) because it is called <i class="pcalibre17 pcalibre2 pcalibre1">once</i> but it returns <i class="pcalibre17 pcalibre2 pcalibre1">twice:</i> once in the calling process (the parent), and once in the newly created child process. In the parent, <code id="P700049702700000000000000004507A" data-uri="chapter08.xhtml#P700049702700000000000000004507A" class="pcalibre1 calibre1 pcalibre2">fork</code> returns the PID of the child. In the child, <code id="P700049702700000000000000004507B" data-uri="chapter08.xhtml#P700049702700000000000000004507B" class="pcalibre1 calibre1 pcalibre2">fork</code> returns a value of 0. Since the PID of the child is always nonzero, the return value provides an unambiguous way to tell whether the program is executing in the parent or the child.</p>
<p id="P700049702700000000000000004507C" data-uri="chapter08.xhtml#P700049702700000000000000004507C" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000689A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.15 </span></a>shows a simple example of a parent process that uses <code id="P700049702700000000000000004507D" data-uri="chapter08.xhtml#P700049702700000000000000004507D" class="pcalibre1 calibre1 pcalibre2">fork</code> to create a child process. When the <code id="P700049702700000000000000004507E" data-uri="chapter08.xhtml#P700049702700000000000000004507E" class="pcalibre1 calibre1 pcalibre2">fork</code> call returns in line 6, <code id="P700049702700000000000000004507F" data-uri="chapter08.xhtml#P700049702700000000000000004507F" class="pcalibre1 calibre1 pcalibre2">x</code> has a value of 1 in both the parent and child. The child increments and prints its copy of <code id="P7000497027000000000000000045080" data-uri="chapter08.xhtml#P7000497027000000000000000045080" class="pcalibre1 calibre1 pcalibre2">x</code> in line 8. Similarly, the parent decrements and prints its copy of <code id="P7000497027000000000000000045081" data-uri="chapter08.xhtml#P7000497027000000000000000045081" class="pcalibre1 calibre1 pcalibre2">x</code> in line 13.</p>
<p id="P7000497027000000000000000045082" data-uri="chapter08.xhtml#P7000497027000000000000000045082" class="pcalibre8 pcalibre1 pcalibre2">When we run the program on our Unix system, we get the following result:</p>
<pre id="P7000497027000000000000000045083" data-uri="chapter08.xhtml#P7000497027000000000000000045083" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045084" data-uri="chapter08.xhtml#P7000497027000000000000000045084" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./fork</i>
parent: x=0
child : x=2
</code>
</pre>
<p id="P7000497027000000000000000045085" data-uri="chapter08.xhtml#P7000497027000000000000000045085" class="pcalibre8 pcalibre1 pcalibre2">There are some subtle aspects to this simple example.</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P7000497027000000000000000045086" data-uri="chapter08.xhtml#P7000497027000000000000000045086">
<li id="P7000497027000000000000000045087" data-uri="chapter08.xhtml#P7000497027000000000000000045087" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045088" data-uri="chapter08.xhtml#P7000497027000000000000000045088" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Call once, return twice. </span>The <code id="P7000497027000000000000000045089" data-uri="chapter08.xhtml#P7000497027000000000000000045089" class="pcalibre1 calibre1 pcalibre2">fork</code> function is called once by the parent, but it returns twice: once to the parent and once to the newly created child. This is fairly straightforward for programs that create a single child. But programs with multiple instances of <code id="P700049702700000000000000004508A" data-uri="chapter08.xhtml#P700049702700000000000000004508A" class="pcalibre1 calibre1 pcalibre2">fork</code> can be confusing and need to be reasoned about carefully.</p></li>
<li id="P700049702700000000000000004508B" data-uri="chapter08.xhtml#P700049702700000000000000004508B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004508C" data-uri="chapter08.xhtml#P700049702700000000000000004508C" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Concurrent execution. </span>The parent and the child are separate processes that run concurrently. The instructions in their logical control flows can be interleaved by the kernel in an arbitrary way. When we run the program on our system, the parent process completes its <code id="P700049702700000000000000004508D" data-uri="chapter08.xhtml#P700049702700000000000000004508D" class="pcalibre1 calibre1 pcalibre2">printf</code> statement first, followed by the child. However, on another system the reverse might be true. In general, as programmers we can never make assumptions about the interleaving of the instructions in different processes.</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000689A" data-uri="chapter08.xhtml#P700049702700000000000000000689A">
<p id="P700049702700000000000000004508E" data-uri="chapter08.xhtml#P700049702700000000000000004508E" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000689C" title="741" data-uri="chapter08.xhtml#P700049702700000000000000000689C" epub:type="pagebreak"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/fork.c</i></p>
<pre id="P700049702700000000000000004508F" data-uri="chapter08.xhtml#P700049702700000000000000004508F" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045090" data-uri="chapter08.xhtml#P7000497027000000000000000045090" class="calibre3 pcalibre1 pcalibre2">
1	int main()
2	{
3		pid_t pid;
4		int x = 1;
5	
6		pid = Fork();
7		if (pid == 0) { /* Child */
8			printf("child : x=%d\n", ++x);
9			exit(0);
10		}
11	
12		/* Parent */
13			printf("parent: x=%d\n", --x);
14			exit(0);
15	}
</code>
</pre>
<p id="P7000497027000000000000000045091" data-uri="chapter08.xhtml#P7000497027000000000000000045091" class="pcalibre1 pcalibre2 pcalibre40">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/fork.c</i></p>

<figcaption id="P7000497027000000000000000045092" data-uri="chapter08.xhtml#P7000497027000000000000000045092" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045093" data-uri="chapter08.xhtml#P7000497027000000000000000045093" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.15 </span>Using <code id="P7000497027000000000000000045094" data-uri="chapter08.xhtml#P7000497027000000000000000045094" class="pcalibre1 calibre1 pcalibre2">fork</code> to create a new process.</h1></header>
</figcaption>
</figure>
</li>
<li id="P7000497027000000000000000045095" data-uri="chapter08.xhtml#P7000497027000000000000000045095" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045096" data-uri="chapter08.xhtml#P7000497027000000000000000045096" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Duplicate but separate address spaces. </span>If we could halt both the parent and the child immediately after the <code id="P7000497027000000000000000045097" data-uri="chapter08.xhtml#P7000497027000000000000000045097" class="pcalibre1 calibre1 pcalibre2">fork</code> function returned in each process, we would see that the address space of each process is identical. Each process has the same user stack, the same local variable values, the same heap, the same global variable values, and the same code. Thus, in our example program, local variable <code id="P7000497027000000000000000045098" data-uri="chapter08.xhtml#P7000497027000000000000000045098" class="pcalibre1 calibre1 pcalibre2">x</code> has a value of 1 in both the parent and the child when the <code id="P7000497027000000000000000045099" data-uri="chapter08.xhtml#P7000497027000000000000000045099" class="pcalibre1 calibre1 pcalibre2">fork</code> function returns in line 6. However, since the parent and the child are separate processes, they each have their own private address spaces. Any subsequent changes that a parent or child makes to <code id="P700049702700000000000000004509A" data-uri="chapter08.xhtml#P700049702700000000000000004509A" class="pcalibre1 calibre1 pcalibre2">x</code> are private and are not reflected in the memory of the other process. This is why the variable <code id="P700049702700000000000000004509B" data-uri="chapter08.xhtml#P700049702700000000000000004509B" class="pcalibre1 calibre1 pcalibre2">x</code> has different values in the parent and child when they call their respective <code id="P700049702700000000000000004509C" data-uri="chapter08.xhtml#P700049702700000000000000004509C" class="pcalibre1 calibre1 pcalibre2">printf</code> statements.</p></li>
<li id="P700049702700000000000000004509D" data-uri="chapter08.xhtml#P700049702700000000000000004509D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004509E" data-uri="chapter08.xhtml#P700049702700000000000000004509E" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Shared files. </span>When we run the example program, we notice that both parent and child print their output on the screen. The reason is that the child inherits all of the parent's open files. When the parent calls <code id="P700049702700000000000000004509F" data-uri="chapter08.xhtml#P700049702700000000000000004509F" class="pcalibre1 calibre1 pcalibre2">fork</code>, the <code id="P70004970270000000000000000450A0" data-uri="chapter08.xhtml#P70004970270000000000000000450A0" class="pcalibre1 calibre1 pcalibre2">stdout</code> file is open and directed to the screen. The child inherits this file, and thus its output is also directed to the screen.</p></li>
</ul>

<p id="P70004970270000000000000000450A1" data-uri="chapter08.xhtml#P70004970270000000000000000450A1" class="pcalibre8 pcalibre1 pcalibre2">When you are first learning about the <code id="P70004970270000000000000000450A2" data-uri="chapter08.xhtml#P70004970270000000000000000450A2" class="pcalibre1 calibre1 pcalibre2">fork</code> function, it is often helpful to sketch the <i class="pcalibre17 pcalibre2 pcalibre1">process graph</i>, which is a simple kind of precedence graph that captures the partial ordering of program statements. Each vertex <var class="pcalibre17 pcalibre2 pcalibre1">a</var> corresponds to the execution of a program statement. A directed edge <var class="pcalibre17 pcalibre2 pcalibre1">a</var> → <var class="pcalibre17 pcalibre2 pcalibre1">b</var> denotes that statement <var class="pcalibre17 pcalibre2 pcalibre1">a</var> “happens before” statement <var class="pcalibre17 pcalibre2 pcalibre1">b</var>. Edges can be labeled with information such as the current value of a variable. Vertices corresponding to <code id="P70004970270000000000000000450A3" data-uri="chapter08.xhtml#P70004970270000000000000000450A3" class="pcalibre1 calibre1 pcalibre2">printf</code> statements can be labeled with the output of the <code id="P70004970270000000000000000450A4" data-uri="chapter08.xhtml#P70004970270000000000000000450A4" class="pcalibre1 calibre1 pcalibre2">printf</code>. Each graph begins with a vertex that</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000068B3" data-uri="chapter08.xhtml#P70004970270000000000000000068B3">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000068B4" title="742" data-uri="chapter08.xhtml#P70004970270000000000000000068B4" epub:type="pagebreak"></span><img alt="A diagram shows a process graph." id="P70004970270000000000000000450A5" data-uri="P700049702700000000000000000B76C" src="../images/p742-1.png" class="pcalibre1 pcalibre2 pcalibre250"/>
<figcaption id="P70004970270000000000000000450A6" data-uri="chapter08.xhtml#P70004970270000000000000000450A6" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000450A7" data-uri="chapter08.xhtml#P70004970270000000000000000450A7" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.16 </span>Process graph for the example program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000689A"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.15</span></a>.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000253CB" data-uri="chapter08.xhtml#P70004970270000000000000000253CB">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000450A8" data-uri="chapter08.xhtml#P70004970270000000000000000450A8" class="pcalibre8 pcalibre1 pcalibre2">A diagram shows a process graph flowing as summarized below.</p>
<ul id="P70004970270000000000000000450A9" data-uri="chapter08.xhtml#P70004970270000000000000000450A9" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000450AA" data-uri="chapter08.xhtml#P70004970270000000000000000450AA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450AB" data-uri="chapter08.xhtml#P70004970270000000000000000450AB" class="pcalibre1 pcalibre2 pcalibre10">X==1 from main to fork, splitting toward Child and Parent:</p>
<ul id="P70004970270000000000000000450AC" data-uri="chapter08.xhtml#P70004970270000000000000000450AC" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P70004970270000000000000000450AD" data-uri="chapter08.xhtml#P70004970270000000000000000450AD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450AE" data-uri="chapter08.xhtml#P70004970270000000000000000450AE" class="pcalibre1 pcalibre2 pcalibre10">To printf at child: x=2, and then exit at Child</p></li>
<li id="P70004970270000000000000000450AF" data-uri="chapter08.xhtml#P70004970270000000000000000450AF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450B0" data-uri="chapter08.xhtml#P70004970270000000000000000450B0" class="pcalibre1 pcalibre2 pcalibre10">To printf at parent: x=0, and then exit at Parent</p></li>
</ul></li>
</ul>
</details>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000068B8" data-uri="chapter08.xhtml#P70004970270000000000000000068B8">
<img alt="A diagram shows a code and associated process graph." id="P70004970270000000000000000450B1" data-uri="P700049702700000000000000000B76D" src="../images/p742-2.png" class="pcalibre1 pcalibre251 pcalibre2"/>
<figcaption id="P70004970270000000000000000450B2" data-uri="chapter08.xhtml#P70004970270000000000000000450B2" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000450B3" data-uri="chapter08.xhtml#P70004970270000000000000000450B3" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.17 </span>Process graph for a nested <code id="P70004970270000000000000000450B4" data-uri="chapter08.xhtml#P70004970270000000000000000450B4" class="pcalibre1 calibre1 pcalibre2">fork</code>.</h1></header>

<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000253D9" data-uri="chapter08.xhtml#P70004970270000000000000000253D9">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000450B5" data-uri="chapter08.xhtml#P70004970270000000000000000450B5" class="pcalibre8 pcalibre1 pcalibre2">The lines of the code are listed below.</p>
<ul id="P70004970270000000000000000450B6" data-uri="chapter08.xhtml#P70004970270000000000000000450B6" class="pcalibre1 calibre9 pcalibre2">
<li id="P70004970270000000000000000450B7" data-uri="chapter08.xhtml#P70004970270000000000000000450B7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450B8" data-uri="chapter08.xhtml#P70004970270000000000000000450B8" class="pcalibre1 pcalibre2 pcalibre10">Int main()</p></li>
<li id="P70004970270000000000000000450B9" data-uri="chapter08.xhtml#P70004970270000000000000000450B9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450BA" data-uri="chapter08.xhtml#P70004970270000000000000000450BA" class="pcalibre1 pcalibre2 pcalibre10">{</p></li>
<li id="P70004970270000000000000000450BB" data-uri="chapter08.xhtml#P70004970270000000000000000450BB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450BC" data-uri="chapter08.xhtml#P70004970270000000000000000450BC" class="pcalibre1 pcalibre2 pcalibre10">Fork();</p></li>
<li id="P70004970270000000000000000450BD" data-uri="chapter08.xhtml#P70004970270000000000000000450BD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450BE" data-uri="chapter08.xhtml#P70004970270000000000000000450BE" class="pcalibre1 pcalibre2 pcalibre10">Fork();</p></li>
<li id="P70004970270000000000000000450BF" data-uri="chapter08.xhtml#P70004970270000000000000000450BF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450C0" data-uri="chapter08.xhtml#P70004970270000000000000000450C0" class="pcalibre1 pcalibre2 pcalibre10">printf(“hello\n”);</p></li>
<li id="P70004970270000000000000000450C1" data-uri="chapter08.xhtml#P70004970270000000000000000450C1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450C2" data-uri="chapter08.xhtml#P70004970270000000000000000450C2" class="pcalibre1 pcalibre2 pcalibre10">exit(0);</p></li>
<li id="P70004970270000000000000000450C3" data-uri="chapter08.xhtml#P70004970270000000000000000450C3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450C4" data-uri="chapter08.xhtml#P70004970270000000000000000450C4" class="pcalibre1 pcalibre2 pcalibre10">}</p></li>
</ul>
<p id="P70004970270000000000000000450C5" data-uri="chapter08.xhtml#P70004970270000000000000000450C5" class="pcalibre1 pcalibre2 pcalibre10">The graph has an arrow from main leading to a fork, which splits into two other forks. Each of the forks splits to two printf at hello and then exit.</p>
</details>
</figcaption>
</figure>

<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000450C6" data-uri="chapter08.xhtml#P70004970270000000000000000450C6">corresponds to the parent process calling main. This vertex has no inedges and exactly one outedge. The sequence of vertices for each process ends with a vertex corresponding to a call to <code id="P70004970270000000000000000450C7" data-uri="chapter08.xhtml#P70004970270000000000000000450C7" class="pcalibre1 calibre1 pcalibre2">exit</code>. This vertex has one inedge and no outedges.</p>
<p id="P70004970270000000000000000450C8" data-uri="chapter08.xhtml#P70004970270000000000000000450C8" class="pcalibre8 pcalibre1 pcalibre2">For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000068B3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.16 </span></a>shows the process graph for the example program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000689A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.15</span></a>. Initially, the parent sets variable <code id="P70004970270000000000000000450C9" data-uri="chapter08.xhtml#P70004970270000000000000000450C9" class="pcalibre1 calibre1 pcalibre2">x</code> to 1. The parent calls <code id="P70004970270000000000000000450CA" data-uri="chapter08.xhtml#P70004970270000000000000000450CA" class="pcalibre1 calibre1 pcalibre2">fork</code>, which creates a child process that runs concurrently with the parent in its own private address space.</p>

<p id="P70004970270000000000000000450CB" data-uri="chapter08.xhtml#P70004970270000000000000000450CB" class="pcalibre8 pcalibre1 pcalibre2">For a program running on a single processor, any <i class="pcalibre17 pcalibre2 pcalibre1">topological sort</i> of the vertices in the corresponding process graph represents a feasible total ordering of the statements in the program. Here's a simple way to understand the idea of a topological sort: Given some permutation of the vertices in the process graph, draw the sequence of vertices in a line from left to right, and then draw each of the directed edges. The permutation is a topological sort if and only if each edge in the drawing goes from left to right. Thus, in our example program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000689A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.15</span></a>, the <code id="P70004970270000000000000000450CC" data-uri="chapter08.xhtml#P70004970270000000000000000450CC" class="pcalibre1 calibre1 pcalibre2">printf</code> statements in the parent and child can occur in either order because each of the orderings corresponds to some topological sort of the graph vertices.</p>
<p id="P70004970270000000000000000450CD" data-uri="chapter08.xhtml#P70004970270000000000000000450CD" class="pcalibre8 pcalibre1 pcalibre2">The process graph can be especially helpful in understanding programs with nested <code id="P70004970270000000000000000450CE" data-uri="chapter08.xhtml#P70004970270000000000000000450CE" class="pcalibre1 calibre1 pcalibre2">fork</code> calls. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000068B8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.17</span></a> shows a program with two calls to <code id="P70004970270000000000000000450CF" data-uri="chapter08.xhtml#P70004970270000000000000000450CF" class="pcalibre1 calibre1 pcalibre2">fork</code> in the source code. The corresponding process graph helps us see that this program runs four processes, each of which makes a call to <code id="P70004970270000000000000000450D0" data-uri="chapter08.xhtml#P70004970270000000000000000450D0" class="pcalibre1 calibre1 pcalibre2">printf</code> and which can execute in any order.</p>


<section id="P70004970270000000000000000068C8" data-uri="chapter08.xhtml#P70004970270000000000000000068C8" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000450D1" data-uri="chapter08.xhtml#P70004970270000000000000000450D1" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000068CA" title="743" data-uri="chapter08.xhtml#P70004970270000000000000000068CA" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.2 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006E81.xhtml#P7000497027000000000000000006F86">795</a>)</h1></header>
<p id="P70004970270000000000000000450D2" data-uri="chapter08.xhtml#P70004970270000000000000000450D2" class="pcalibre8 pcalibre1 pcalibre2">Consider the following program:</p>
<p id="P70004970270000000000000000450D3" data-uri="chapter08.xhtml#P70004970270000000000000000450D3" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob0.c</i></p>

<pre id="P70004970270000000000000000450D4" data-uri="chapter08.xhtml#P70004970270000000000000000450D4" class="calibre2 pcalibre2 pcalibre1">
<code id="P70004970270000000000000000450D5" data-uri="chapter08.xhtml#P70004970270000000000000000450D5" class="calibre3 pcalibre1 pcalibre2">
1	int main()
2	{
3		int x = 1;
4	
5		if (Fork() == 0)
6			printf("p1: x=%d\n", ++x);
7		printf("p2: x=%d\n", --x);
8		exit(0);
9	}
</code>
</pre>
<p id="P70004970270000000000000000450D6" data-uri="chapter08.xhtml#P70004970270000000000000000450D6" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/forkprob0.c</i></p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000450D7" data-uri="chapter08.xhtml#P70004970270000000000000000450D7">
<li id="P70004970270000000000000000450D8" data-uri="chapter08.xhtml#P70004970270000000000000000450D8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450D9" data-uri="chapter08.xhtml#P70004970270000000000000000450D9" class="pcalibre1 pcalibre2 pcalibre10">What is the output of the child process?</p></li>
<li id="P70004970270000000000000000450DA" data-uri="chapter08.xhtml#P70004970270000000000000000450DA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450DB" data-uri="chapter08.xhtml#P70004970270000000000000000450DB" class="pcalibre1 pcalibre2 pcalibre10">What is the output of the parent process?</p></li>
</ol>
</section>
</section>

<section id="P70004970270000000000000000068D5" data-uri="chapter08.xhtml#P70004970270000000000000000068D5" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000450DC" data-uri="chapter08.xhtml#P70004970270000000000000000450DC" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.4.3  </span>Reaping Child Processes</h1></header>
<p id="P70004970270000000000000000450DD" data-uri="chapter08.xhtml#P70004970270000000000000000450DD" class="pcalibre8 pcalibre1 pcalibre2">When a process terminates for any reason, the kernel does not remove it from the system immediately. Instead, the process is kept around in a terminated state until it is <i class="pcalibre17 pcalibre2 pcalibre1">reaped</i> by its parent. When the parent reaps the terminated child, the kernel passes the child's exit status to the parent and then discards the terminated process, at which point it ceases to exist. A terminated process that has not yet been reaped is called a <i class="pcalibre17 pcalibre2 pcalibre1">zombie</i>.</p>
<p id="P70004970270000000000000000450DE" data-uri="chapter08.xhtml#P70004970270000000000000000450DE" class="pcalibre8 pcalibre1 pcalibre2">When a parent process terminates, the kernel arranges for the <code id="P70004970270000000000000000450DF" data-uri="chapter08.xhtml#P70004970270000000000000000450DF" class="pcalibre1 calibre1 pcalibre2">init</code> process to become the adopted parent of any orphaned children. The <code id="P70004970270000000000000000450E0" data-uri="chapter08.xhtml#P70004970270000000000000000450E0" class="pcalibre1 calibre1 pcalibre2">init</code> process, which has a PID of 1, is created by the kernel during system start-up, never terminates, and is the ancestor of every process. If a parent process terminates without reaping its zombie children, then the kernel arranges for the <code id="P70004970270000000000000000450E1" data-uri="chapter08.xhtml#P70004970270000000000000000450E1" class="pcalibre1 calibre1 pcalibre2">init</code> process to reap them. However, long-running programs such as shells or servers should always reap their zombie children. Even though zombies are not running, they still consume system memory resources.</p>
<p id="P70004970270000000000000000450E2" data-uri="chapter08.xhtml#P70004970270000000000000000450E2" class="pcalibre8 pcalibre1 pcalibre2">A process waits for its children to terminate or stop by calling the <code id="P70004970270000000000000000450E3" data-uri="chapter08.xhtml#P70004970270000000000000000450E3" class="pcalibre1 calibre1 pcalibre2">waitpid</code> function.</p>
<pre id="P70004970270000000000000000450E4" data-uri="chapter08.xhtml#P70004970270000000000000000450E4" class="calibre2 pcalibre2 pcalibre1">
<code id="P70004970270000000000000000450E5" data-uri="chapter08.xhtml#P70004970270000000000000000450E5" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
pid_t waitpid(pid_t pid, int *statusp, int options);
			Returns: PID of child if OK, 0 (if WNOHANG), or -1 on error
</code>
</pre>

<aside class="pcalibre31 pcalibre32 pcalibre2" id="P70004970270000000000000000450E6" data-uri="chapter08.xhtml#P70004970270000000000000000450E6"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P70004970270000000000000000450E7" data-uri="chapter08.xhtml#P70004970270000000000000000450E7" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000068E2" title="744" data-uri="chapter08.xhtml#P70004970270000000000000000068E2" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Why are terminated children called zombies?</h1></header>
<p id="P70004970270000000000000000450E8" data-uri="chapter08.xhtml#P70004970270000000000000000450E8" class="pcalibre1 pcalibre2 pcalibre10">In folklore, a zombie is a living corpse, an entity that is half alive and half dead. A zombie process is similar in the sense that although it has already terminated, the kernel maintains some of its state until it can be reaped by the parent.</p>
</aside>
<p id="P70004970270000000000000000450E9" data-uri="chapter08.xhtml#P70004970270000000000000000450E9" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P70004970270000000000000000450EA" data-uri="chapter08.xhtml#P70004970270000000000000000450EA" class="pcalibre1 calibre1 pcalibre2">waitpid</code> function is complicated. By default (when <code id="P70004970270000000000000000450EB" data-uri="chapter08.xhtml#P70004970270000000000000000450EB" class="pcalibre1 calibre1 pcalibre2">options = 0</code>), <code id="P70004970270000000000000000450EC" data-uri="chapter08.xhtml#P70004970270000000000000000450EC" class="pcalibre1 calibre1 pcalibre2">waitpid</code> suspends execution of the calling process until a child process in its <i class="pcalibre17 pcalibre2 pcalibre1">wait set</i> terminates. If a process in the wait set has already terminated at the time of the call, then <code id="P70004970270000000000000000450ED" data-uri="chapter08.xhtml#P70004970270000000000000000450ED" class="pcalibre1 calibre1 pcalibre2">waitpid</code> returns immediately. In either case, <code id="P70004970270000000000000000450EE" data-uri="chapter08.xhtml#P70004970270000000000000000450EE" class="pcalibre1 calibre1 pcalibre2">waitpid</code> returns the PID of the terminated child that caused <code id="P70004970270000000000000000450EF" data-uri="chapter08.xhtml#P70004970270000000000000000450EF" class="pcalibre1 calibre1 pcalibre2">waitpid</code> to return. At this point, the terminated child has been reaped and the kernel removes all traces of it from the system.</p>
<section id="P70004970270000000000000000068EB" data-uri="chapter08.xhtml#P70004970270000000000000000068EB" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000450F0" data-uri="chapter08.xhtml#P70004970270000000000000000450F0" epub:type="title">Determining the Members of the Wait Set</h1></header>
<p id="P70004970270000000000000000450F1" data-uri="chapter08.xhtml#P70004970270000000000000000450F1" class="pcalibre8 pcalibre1 pcalibre2">The members of the wait set are determined by the <code id="P70004970270000000000000000450F2" data-uri="chapter08.xhtml#P70004970270000000000000000450F2" class="pcalibre1 calibre1 pcalibre2">pid</code> argument:</p>
<ul id="P70004970270000000000000000450F3" data-uri="chapter08.xhtml#P70004970270000000000000000450F3" class="pcalibre1 calibre9 pcalibre2">
<li id="P70004970270000000000000000450F4" data-uri="chapter08.xhtml#P70004970270000000000000000450F4" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450F5" data-uri="chapter08.xhtml#P70004970270000000000000000450F5" class="pcalibre1 pcalibre2 pcalibre10">If <code id="P70004970270000000000000000450F6" data-uri="chapter08.xhtml#P70004970270000000000000000450F6" class="pcalibre1 calibre1 pcalibre2">pid &gt; 0</code>, then the wait set is the singleton child process whose process ID is equal to <code id="P70004970270000000000000000450F7" data-uri="chapter08.xhtml#P70004970270000000000000000450F7" class="pcalibre1 calibre1 pcalibre2">pid</code>.</p></li>
<li id="P70004970270000000000000000450F8" data-uri="chapter08.xhtml#P70004970270000000000000000450F8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000450F9" data-uri="chapter08.xhtml#P70004970270000000000000000450F9" class="pcalibre1 pcalibre2 pcalibre10">If <code id="P70004970270000000000000000450FA" data-uri="chapter08.xhtml#P70004970270000000000000000450FA" class="pcalibre1 calibre1 pcalibre2">pid = -1</code>, then the wait set consists of all of the parent's child processes.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000450FB" data-uri="chapter08.xhtml#P70004970270000000000000000450FB">The <code id="P70004970270000000000000000450FC" data-uri="chapter08.xhtml#P70004970270000000000000000450FC" class="pcalibre1 calibre1 pcalibre2">waitpid</code> function also supports other kinds of wait sets, involving Unix process groups, which we will not discuss.</p>
</section>
<section id="P70004970270000000000000000068F9" data-uri="chapter08.xhtml#P70004970270000000000000000068F9" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000450FD" data-uri="chapter08.xhtml#P70004970270000000000000000450FD" epub:type="title">Modifying the Default Behavior</h1></header>
<p id="P70004970270000000000000000450FE" data-uri="chapter08.xhtml#P70004970270000000000000000450FE" class="pcalibre8 pcalibre1 pcalibre2">The default behavior can be modified by setting <code id="P70004970270000000000000000450FF" data-uri="chapter08.xhtml#P70004970270000000000000000450FF" class="pcalibre1 calibre1 pcalibre2">options</code> to various combinations of the WNOHANG, WUNTRACED, and WCONTINUED constants:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P7000497027000000000000000045100" data-uri="chapter08.xhtml#P7000497027000000000000000045100">
<li id="P7000497027000000000000000045101" data-uri="chapter08.xhtml#P7000497027000000000000000045101" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045102" data-uri="chapter08.xhtml#P7000497027000000000000000045102" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">WNOHANG. </span>Return immediately (with a return value of 0) if none of the child processes in the wait set has terminated yet. The default behavior suspends the calling process until a child terminates; this option is useful in those cases where you want to continue doing useful work while waiting for a child to terminate.</p></li>
<li id="P7000497027000000000000000045103" data-uri="chapter08.xhtml#P7000497027000000000000000045103" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045104" data-uri="chapter08.xhtml#P7000497027000000000000000045104" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">WUNTRACED. </span>Suspend execution of the calling process until a process in the wait set becomes either terminated or stopped. Return the PID of the terminated or stopped child that caused the return. The default behavior returns only for terminated children; this option is useful when you want to check for both terminated <i class="pcalibre17 pcalibre2 pcalibre1">and</i> stopped children.</p></li>
<li id="P7000497027000000000000000045105" data-uri="chapter08.xhtml#P7000497027000000000000000045105" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045106" data-uri="chapter08.xhtml#P7000497027000000000000000045106" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">WCONTINUED. </span>Suspend execution of the calling process until a running process in the wait set is terminated or until a stopped process in the wait set has been resumed by the receipt of a SIGCONT signal. (Signals are explained in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006993"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5</span></a>.)</p></li>
</ul>
<p id="P7000497027000000000000000045107" data-uri="chapter08.xhtml#P7000497027000000000000000045107" class="pcalibre8 pcalibre1 pcalibre2">You can combine options by <span class="pcalibre1 pcalibre29 pcalibre2">or</span>ing them together. For example:</p>

<ul id="P7000497027000000000000000045108" data-uri="chapter08.xhtml#P7000497027000000000000000045108" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000045109" data-uri="chapter08.xhtml#P7000497027000000000000000045109" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004510A" data-uri="chapter08.xhtml#P700049702700000000000000004510A" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006908" title="745" data-uri="chapter08.xhtml#P7000497027000000000000000006908" epub:type="pagebreak"></span>WNOHANG	|	WUNTRACED: Return immediately, with a return value of 0, if none of the children in the wait set has stopped or terminated, or with a return value equal to the PID of one of the stopped or terminated children.</p></li>
</ul>
</section>
<section id="P7000497027000000000000000006909" data-uri="chapter08.xhtml#P7000497027000000000000000006909" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004510B" data-uri="chapter08.xhtml#P700049702700000000000000004510B" epub:type="title">Checking the Exit Status of a Reaped Child</h1></header>
<p id="P700049702700000000000000004510C" data-uri="chapter08.xhtml#P700049702700000000000000004510C" class="pcalibre8 pcalibre1 pcalibre2">If the <code id="P700049702700000000000000004510D" data-uri="chapter08.xhtml#P700049702700000000000000004510D" class="pcalibre1 calibre1 pcalibre2">statusp</code> argument is non-NULL, then <code id="P700049702700000000000000004510E" data-uri="chapter08.xhtml#P700049702700000000000000004510E" class="pcalibre1 calibre1 pcalibre2">waitpid</code> encodes status information about the child that caused the return in status, which is the value pointed to by <code id="P700049702700000000000000004510F" data-uri="chapter08.xhtml#P700049702700000000000000004510F" class="pcalibre1 calibre1 pcalibre2">statusp</code>. The <code id="P7000497027000000000000000045110" data-uri="chapter08.xhtml#P7000497027000000000000000045110" class="pcalibre1 calibre1 pcalibre2">wait.h</code> include file defines several macros for interpreting the <code id="P7000497027000000000000000045111" data-uri="chapter08.xhtml#P7000497027000000000000000045111" class="pcalibre1 calibre1 pcalibre2">status</code> argument:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P7000497027000000000000000045112" data-uri="chapter08.xhtml#P7000497027000000000000000045112">
<li id="P7000497027000000000000000045113" data-uri="chapter08.xhtml#P7000497027000000000000000045113" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045114" data-uri="chapter08.xhtml#P7000497027000000000000000045114" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">WIFEXITED(<code id="P7000497027000000000000000045115" data-uri="chapter08.xhtml#P7000497027000000000000000045115" class="pcalibre1 calibre1 pcalibre2">status</code>). </span>Returns true if the child terminated normally, via a call to <code id="P7000497027000000000000000045116" data-uri="chapter08.xhtml#P7000497027000000000000000045116" class="pcalibre1 calibre1 pcalibre2">exit</code> or a return.</p></li>
<li id="P7000497027000000000000000045117" data-uri="chapter08.xhtml#P7000497027000000000000000045117" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045118" data-uri="chapter08.xhtml#P7000497027000000000000000045118" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">WEXITSTATUS(<code id="P7000497027000000000000000045119" data-uri="chapter08.xhtml#P7000497027000000000000000045119" class="pcalibre1 calibre1 pcalibre2">status</code>). </span>Returns the exit status of a normally terminated child. This status is only defined if WIFEXITED() returned true.</p></li>
<li id="P700049702700000000000000004511A" data-uri="chapter08.xhtml#P700049702700000000000000004511A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004511B" data-uri="chapter08.xhtml#P700049702700000000000000004511B" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">WIFSIGNALED(<code id="P700049702700000000000000004511C" data-uri="chapter08.xhtml#P700049702700000000000000004511C" class="pcalibre1 calibre1 pcalibre2">status</code>). </span>Returns true if the child process terminated because of a signal that was not caught.</p></li>
<li id="P700049702700000000000000004511D" data-uri="chapter08.xhtml#P700049702700000000000000004511D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004511E" data-uri="chapter08.xhtml#P700049702700000000000000004511E" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">WTERMSIG(<code id="P700049702700000000000000004511F" data-uri="chapter08.xhtml#P700049702700000000000000004511F" class="pcalibre1 calibre1 pcalibre2">status</code>). </span>Returns the number of the signal that caused the child process to terminate. This status is only defined if WIFSIGNALED() returned true.</p></li>
<li id="P7000497027000000000000000045120" data-uri="chapter08.xhtml#P7000497027000000000000000045120" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045121" data-uri="chapter08.xhtml#P7000497027000000000000000045121" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">WIFSTOPPED(<code id="P7000497027000000000000000045122" data-uri="chapter08.xhtml#P7000497027000000000000000045122" class="pcalibre1 calibre1 pcalibre2">status</code>). </span>Returns true if the child that caused the return is currently stopped.</p></li>
<li id="P7000497027000000000000000045123" data-uri="chapter08.xhtml#P7000497027000000000000000045123" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045124" data-uri="chapter08.xhtml#P7000497027000000000000000045124" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">WSTOPSIG(<code id="P7000497027000000000000000045125" data-uri="chapter08.xhtml#P7000497027000000000000000045125" class="pcalibre1 calibre1 pcalibre2">status</code>). </span>Returns the number of the signal that caused the child to stop. This status is only defined if WIFSTOPPED() returned true.</p></li>
<li id="P7000497027000000000000000045126" data-uri="chapter08.xhtml#P7000497027000000000000000045126" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045127" data-uri="chapter08.xhtml#P7000497027000000000000000045127" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">WIFCONTINUED(<code id="P7000497027000000000000000045128" data-uri="chapter08.xhtml#P7000497027000000000000000045128" class="pcalibre1 calibre1 pcalibre2">status</code>). </span>Returns true if the child process was restarted by receipt of a SIGCONT signal.</p></li></ul>
</section>
<section id="P7000497027000000000000000006928" data-uri="chapter08.xhtml#P7000497027000000000000000006928" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000045129" data-uri="chapter08.xhtml#P7000497027000000000000000045129" epub:type="title">Error Conditions</h1></header>
<p id="P700049702700000000000000004512A" data-uri="chapter08.xhtml#P700049702700000000000000004512A" class="pcalibre8 pcalibre1 pcalibre2">If the calling process has no children, then <code id="P700049702700000000000000004512B" data-uri="chapter08.xhtml#P700049702700000000000000004512B" class="pcalibre1 calibre1 pcalibre2">waitpid</code> returns -1 and sets <code id="P700049702700000000000000004512C" data-uri="chapter08.xhtml#P700049702700000000000000004512C" class="pcalibre1 calibre1 pcalibre2">errno</code> to ECHILD. If the <code id="P700049702700000000000000004512D" data-uri="chapter08.xhtml#P700049702700000000000000004512D" class="pcalibre1 calibre1 pcalibre2">waitpid</code> function was interrupted by a signal, then it returns -1 and sets <code id="P700049702700000000000000004512E" data-uri="chapter08.xhtml#P700049702700000000000000004512E" class="pcalibre1 calibre1 pcalibre2">errno</code> to EINTR.</p>
<section id="P700049702700000000000000000692F" data-uri="chapter08.xhtml#P700049702700000000000000000692F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P700049702700000000000000004512F" data-uri="chapter08.xhtml#P700049702700000000000000004512F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.3 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>

<p id="P7000497027000000000000000045130" data-uri="chapter08.xhtml#P7000497027000000000000000045130" class="pcalibre8 pcalibre1 pcalibre2">List all of the possible output sequences for the following program:</p>
<p id="P7000497027000000000000000045131" data-uri="chapter08.xhtml#P7000497027000000000000000045131" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitprob0.c</i></p>
<pre id="P7000497027000000000000000045132" data-uri="chapter08.xhtml#P7000497027000000000000000045132" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045133" data-uri="chapter08.xhtml#P7000497027000000000000000045133" class="calibre3 pcalibre1 pcalibre2">
1	int main()
2	{
3		if (Fork() == 0) {
4			printf("a"); fflush(stdout);
5		}
6		else {
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006935" title="746" data-uri="chapter08.xhtml#P7000497027000000000000000006935" epub:type="pagebreak"></span>7			printf("b"); fflush(stdout);
8			waitpid(-1, NULL, 0);
9		}
10		printf("c"); fflush(stdout);
11		exit(0);
12	}
</code>
</pre>
<p id="P7000497027000000000000000045134" data-uri="chapter08.xhtml#P7000497027000000000000000045134" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitprob0.c</i></p>
</section>
</section>

<section id="P7000497027000000000000000006937" data-uri="chapter08.xhtml#P7000497027000000000000000006937" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000045135" data-uri="chapter08.xhtml#P7000497027000000000000000045135" epub:type="title">The <code id="P7000497027000000000000000045136" data-uri="chapter08.xhtml#P7000497027000000000000000045136" class="pcalibre1 pcalibre2 calibre16">wait</code> Function</h1></header>
<p id="P7000497027000000000000000045137" data-uri="chapter08.xhtml#P7000497027000000000000000045137" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000045138" data-uri="chapter08.xhtml#P7000497027000000000000000045138" class="pcalibre1 calibre1 pcalibre2">wait</code> function is a simpler version of <code id="P7000497027000000000000000045139" data-uri="chapter08.xhtml#P7000497027000000000000000045139" class="pcalibre1 calibre1 pcalibre2">waitpid</code>.</p>
<pre id="P700049702700000000000000004513A" data-uri="chapter08.xhtml#P700049702700000000000000004513A" class="calibre2 pcalibre2 pcalibre1">
<code id="P700049702700000000000000004513B" data-uri="chapter08.xhtml#P700049702700000000000000004513B" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
pid_t wait(int *statusp);
				Returns: PID of child if OK or -1 on error
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004513C" data-uri="chapter08.xhtml#P700049702700000000000000004513C">Calling <code id="P700049702700000000000000004513D" data-uri="chapter08.xhtml#P700049702700000000000000004513D" class="pcalibre1 calibre1 pcalibre2">wait(&amp;status)</code> is equivalent to calling <code id="P700049702700000000000000004513E" data-uri="chapter08.xhtml#P700049702700000000000000004513E" class="pcalibre1 calibre1 pcalibre2">waitpid(-1, &amp;status, 0).</code></p>
</section>
<section id="P7000497027000000000000000006942" data-uri="chapter08.xhtml#P7000497027000000000000000006942" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004513F" data-uri="chapter08.xhtml#P700049702700000000000000004513F" epub:type="title">Examples of Using <code id="P7000497027000000000000000045140" data-uri="chapter08.xhtml#P7000497027000000000000000045140" class="pcalibre1 pcalibre2 calibre16">waitpid</code></h1></header>
<p id="P7000497027000000000000000045141" data-uri="chapter08.xhtml#P7000497027000000000000000045141" class="pcalibre8 pcalibre1 pcalibre2">Because the <code id="P7000497027000000000000000045142" data-uri="chapter08.xhtml#P7000497027000000000000000045142" class="pcalibre1 calibre1 pcalibre2">waitpid</code> function is somewhat complicated, it is helpful to look at a few examples. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006957"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.18 </span></a>shows a program that uses <code id="P7000497027000000000000000045143" data-uri="chapter08.xhtml#P7000497027000000000000000045143" class="pcalibre1 calibre1 pcalibre2">waitpid</code> to wait, in no particular order, for all of its <var class="pcalibre17 pcalibre2 pcalibre1">N</var> children to terminate. In line 11, the parent creates each of the <var class="pcalibre17 pcalibre2 pcalibre1">N</var> children, and in line 12, each child exits with a unique exit status.</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000045144" data-uri="chapter08.xhtml#P7000497027000000000000000045144"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000045145" data-uri="chapter08.xhtml#P7000497027000000000000000045145" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Constants associated with Unix functions</h1></header>
<p id="P7000497027000000000000000045146" data-uri="chapter08.xhtml#P7000497027000000000000000045146" class="pcalibre1 pcalibre2 pcalibre40">Constants such as WNOHANG and WUNTRACED are defined by system header files. For example, WNOHANG and WUNTRACED are defined (indirectly) by the <code id="P7000497027000000000000000045147" data-uri="chapter08.xhtml#P7000497027000000000000000045147" class="pcalibre1 calibre1 pcalibre2">wait.h</code> header file:</p>
<pre id="P7000497027000000000000000045148" data-uri="chapter08.xhtml#P7000497027000000000000000045148" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045149" data-uri="chapter08.xhtml#P7000497027000000000000000045149" class="calibre3 pcalibre1 pcalibre2">
/* Bits in the third argument to ‘waitpid’. */
#define WNOHANG 1 /* Don't block waiting. */
#define WUNTRACED 2 /* Report status of stopped children. */
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P700049702700000000000000004514A" data-uri="chapter08.xhtml#P700049702700000000000000004514A">In order to use these constants, you must include the <code id="P700049702700000000000000004514B" data-uri="chapter08.xhtml#P700049702700000000000000004514B" class="pcalibre1 calibre1 pcalibre2">wait.h</code> header file in your code:</p>
<pre id="P700049702700000000000000004514C" data-uri="chapter08.xhtml#P700049702700000000000000004514C" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004514D" data-uri="chapter08.xhtml#P700049702700000000000000004514D" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/wait.h&gt;
</code>
</pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P700049702700000000000000004514E" data-uri="chapter08.xhtml#P700049702700000000000000004514E">The <code id="P700049702700000000000000004514F" data-uri="chapter08.xhtml#P700049702700000000000000004514F" class="pcalibre1 calibre1 pcalibre2">man</code> page for each Unix function lists the header files to include whenever you use that function in your code. Also, in order to check return codes such as ECHILD and EINTR, you must include <code id="P7000497027000000000000000045150" data-uri="chapter08.xhtml#P7000497027000000000000000045150" class="pcalibre1 calibre1 pcalibre2">errno.h.</code> To simplify our code examples, we include a single header file called <code id="P7000497027000000000000000045151" data-uri="chapter08.xhtml#P7000497027000000000000000045151" class="pcalibre1 calibre1 pcalibre2">csapp.h</code> that includes the header files for all of the functions used in the book. The <code id="P7000497027000000000000000045152" data-uri="chapter08.xhtml#P7000497027000000000000000045152" class="pcalibre1 calibre1 pcalibre2">csapp.h</code> header file is available online from the CS:APP Web site.</p>
</aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000006957" data-uri="chapter08.xhtml#P7000497027000000000000000006957">
<p id="P7000497027000000000000000045153" data-uri="chapter08.xhtml#P7000497027000000000000000045153" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006959" title="747" data-uri="chapter08.xhtml#P7000497027000000000000000006959" epub:type="pagebreak"></span><i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitpid1.c</i></p>
<pre id="P7000497027000000000000000045154" data-uri="chapter08.xhtml#P7000497027000000000000000045154" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045155" data-uri="chapter08.xhtml#P7000497027000000000000000045155" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	#define N 2
3	
4	int main()
5	{
6		int status, i;
7		pid_t pid;
8	
9		/* Parent creates N children */
10		for (i = 0; i &lt; N; i++)
11			if ((pid = Fork()) == 0) /* Child */
12				exit(100+i);
13	
14		/* Parent reaps N children in no particular order */
15		while ((pid = waitpid(-1, &amp;status, 0)) &gt; 0) {
16			if (WIFEXITED(status))
17				printf("child %d terminated normally with exit status=%d\n",
18					pid, WEXITSTATUS(status));
19		else
20			printf("child %d terminated abnormally\n", pid);
21		}
22	
23		/* The only normal termination is if there are no more children */
24		if (errno != ECHILD)
25			unix_error("waitpid error");
26	
27		exit(0);
28	}
</code>
</pre>
<p id="P7000497027000000000000000045156" data-uri="chapter08.xhtml#P7000497027000000000000000045156" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitpid1.c</i></p>
<figcaption id="P7000497027000000000000000045157" data-uri="chapter08.xhtml#P7000497027000000000000000045157" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045158" data-uri="chapter08.xhtml#P7000497027000000000000000045158" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.18 </span>Using the <code id="P7000497027000000000000000045159" data-uri="chapter08.xhtml#P7000497027000000000000000045159" class="pcalibre1 calibre1 pcalibre2">waitpid</code> function to reap zombie children in no particular order.</h1></header>
</figcaption>
</figure>
<p id="P700049702700000000000000004515A" data-uri="chapter08.xhtml#P700049702700000000000000004515A" class="pcalibre8 pcalibre1 pcalibre2">---------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitpid1.c</i></p>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004515B" data-uri="chapter08.xhtml#P700049702700000000000000004515B">Before moving on, make sure you understand why line 12 is executed by each of the children, but not the parent.</p>
<p id="P700049702700000000000000004515C" data-uri="chapter08.xhtml#P700049702700000000000000004515C" class="pcalibre8 pcalibre1 pcalibre2">In line 15, the parent waits for all of its children to terminate by using <code id="P700049702700000000000000004515D" data-uri="chapter08.xhtml#P700049702700000000000000004515D" class="pcalibre1 calibre1 pcalibre2">waitpid</code> as the test condition of a while loop. Because the first argument is -1, the call to <code id="P700049702700000000000000004515E" data-uri="chapter08.xhtml#P700049702700000000000000004515E" class="pcalibre1 calibre1 pcalibre2">waitpid</code> blocks until an arbitrary child has terminated. As each child terminates, the call to <code id="P700049702700000000000000004515F" data-uri="chapter08.xhtml#P700049702700000000000000004515F" class="pcalibre1 calibre1 pcalibre2">waitpid</code> returns with the nonzero PID of that child. Line 16 checks the exit status of the child. If the child terminated normally—in this case, by calling the <code id="P7000497027000000000000000045160" data-uri="chapter08.xhtml#P7000497027000000000000000045160" class="pcalibre1 calibre1 pcalibre2">exit</code> function—then the parent extracts the exit status and prints it on <code id="P7000497027000000000000000045161" data-uri="chapter08.xhtml#P7000497027000000000000000045161" class="pcalibre1 calibre1 pcalibre2">stdout</code>.</p>
<p id="P7000497027000000000000000045162" data-uri="chapter08.xhtml#P7000497027000000000000000045162" class="pcalibre8 pcalibre1 pcalibre2">When all of the children have been reaped, the next call to <code id="P7000497027000000000000000045163" data-uri="chapter08.xhtml#P7000497027000000000000000045163" class="pcalibre1 calibre1 pcalibre2">waitpid</code> returns -1 and sets <code id="P7000497027000000000000000045164" data-uri="chapter08.xhtml#P7000497027000000000000000045164" class="pcalibre1 calibre1 pcalibre2">errno</code> to ECHILD. Line 24 checks that the <code id="P7000497027000000000000000045165" data-uri="chapter08.xhtml#P7000497027000000000000000045165" class="pcalibre1 calibre1 pcalibre2">waitpid</code> function terminated normally, and prints an error message otherwise. When we run the program on our Linux system, it produces the following output:</p>
<pre id="P7000497027000000000000000045166" data-uri="chapter08.xhtml#P7000497027000000000000000045166" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045167" data-uri="chapter08.xhtml#P7000497027000000000000000045167" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000696D" title="748" data-uri="chapter08.xhtml#P700049702700000000000000000696D" epub:type="pagebreak"></span>linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./waitpid1</i>
child 22966 terminated normally with exit status=100
child 22967 terminated normally with exit status=101
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045168" data-uri="chapter08.xhtml#P7000497027000000000000000045168">Notice that the program reaps its children in no particular order. The order that they were reaped is a property of this specific computer system. On another system, or even another execution on the same system, the two children might have been reaped in the opposite order. This is an example of the <i class="pcalibre17 pcalibre2 pcalibre1">nondeterministic</i> behavior that can make reasoning about concurrency so difficult. Either of the two possible outcomes is equally correct, and as a programmer you may <i class="pcalibre17 pcalibre2 pcalibre1">never</i> assume that one outcome will always occur, no matter how unlikely the other outcome appears to be. The only correct assumption is that each possible outcome is equally likely.</p>
<p id="P7000497027000000000000000045169" data-uri="chapter08.xhtml#P7000497027000000000000000045169" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000697D"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.19 </span></a>shows a simple change that eliminates this nondeterminism in the output order by reaping the children in the same order that they were created by the parent. In line 11, the parent stores the PIDs of its children in order and then waits for each child in this same order by calling <code id="P700049702700000000000000004516A" data-uri="chapter08.xhtml#P700049702700000000000000004516A" class="pcalibre1 calibre1 pcalibre2">waitpid</code> with the appropriate PID in the first argument.</p>

<section id="P7000497027000000000000000006971" data-uri="chapter08.xhtml#P7000497027000000000000000006971" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P700049702700000000000000004516B" data-uri="chapter08.xhtml#P700049702700000000000000004516B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.4 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>
<p id="P700049702700000000000000004516C" data-uri="chapter08.xhtml#P700049702700000000000000004516C" class="pcalibre8 pcalibre1 pcalibre2">Consider the following program:</p>
<p id="P700049702700000000000000004516D" data-uri="chapter08.xhtml#P700049702700000000000000004516D" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitprob1.c</i></p>
<pre id="P700049702700000000000000004516E" data-uri="chapter08.xhtml#P700049702700000000000000004516E" class="calibre2 pcalibre2 pcalibre1">
<code id="P700049702700000000000000004516F" data-uri="chapter08.xhtml#P700049702700000000000000004516F" class="calibre3 pcalibre1 pcalibre2">
1	int main()
2	{
3		int status;
4		pid_t pid;
5	
6		printf("Hello\n");
7		pid = Fork();
8		printf("%d\n", !pid);
9		if (pid != 0) {
10			if (waitpid(-1, &amp;status, 0) &gt; 0) {
11				if (WIFEXITED(status) != 0)
12					printf("%d\n", WEXITSTATUS(status));
13				}
14		}
15		printf("Bye\n");
16		exit(2);
17	}
</code>
</pre>
<p id="P7000497027000000000000000045170" data-uri="chapter08.xhtml#P7000497027000000000000000045170" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitprob1.c</i></p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000045171" data-uri="chapter08.xhtml#P7000497027000000000000000045171">
<li id="P7000497027000000000000000045172" data-uri="chapter08.xhtml#P7000497027000000000000000045172" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045173" data-uri="chapter08.xhtml#P7000497027000000000000000045173" class="pcalibre1 pcalibre2 pcalibre10">How many output lines does this program generate?</p></li>
<li id="P7000497027000000000000000045174" data-uri="chapter08.xhtml#P7000497027000000000000000045174" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045175" data-uri="chapter08.xhtml#P7000497027000000000000000045175" class="pcalibre1 pcalibre2 pcalibre10">What is one possible ordering of these output lines?</p></li>
</ol>
</section>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000697D" data-uri="chapter08.xhtml#P700049702700000000000000000697D">

<p id="P7000497027000000000000000045176" data-uri="chapter08.xhtml#P7000497027000000000000000045176" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000697F" title="749" data-uri="chapter08.xhtml#P700049702700000000000000000697F" epub:type="pagebreak"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitpid2.c</i></p>
<pre id="P7000497027000000000000000045177" data-uri="chapter08.xhtml#P7000497027000000000000000045177" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045178" data-uri="chapter08.xhtml#P7000497027000000000000000045178" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	#define N 2
3
4	int main()
5	{
6		int status, i;
7		pid_t pid[N], retpid;
8	
9		/* Parent creates N children */
10		for (i = 0; i &lt; N; i++)
11			if ((pid[i] = Fork()) == 0) /* Child */
12				exit(100+i);
13	
14		/* Parent reaps N children in order */
15		i = 0;
16		while ((retpid = waitpid(pid[i++], &amp;status, 0)) &gt; 0) {
17			if (WIFEXITED(status))
18				printf("child %d terminated normally with exit status=%d\n",
19					retpid, WEXITSTATUS(status));
20			else
21				printf("child %d terminated abnormally\n", retpid);
22		}
23	
24		/* The only normal termination is if there are no more children */
25		if (errno != ECHILD)
26		unix_error("waitpid error");
27	
28		exit(0);
29	}
</code>
</pre>
<p id="P7000497027000000000000000045179" data-uri="chapter08.xhtml#P7000497027000000000000000045179" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/waitpid2.c</i></p>

<figcaption id="P700049702700000000000000004517A" data-uri="chapter08.xhtml#P700049702700000000000000004517A" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004517B" data-uri="chapter08.xhtml#P700049702700000000000000004517B" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.19 </span>Using <code id="P700049702700000000000000004517C" data-uri="chapter08.xhtml#P700049702700000000000000004517C" class="pcalibre1 calibre1 pcalibre2">waitpid</code> to reap zombie children in the order they were created.</h1></header>
</figcaption>
</figure>
</section>
</section>
<section id="P7000497027000000000000000006986" data-uri="chapter08.xhtml#P7000497027000000000000000006986" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004517D" data-uri="chapter08.xhtml#P700049702700000000000000004517D" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.4.4  </span>Putting Processes to Sleep</h1></header>
<p id="P700049702700000000000000004517E" data-uri="chapter08.xhtml#P700049702700000000000000004517E" class="pcalibre8 pcalibre1 pcalibre2">The sleep function suspends a process for a specified period of time.</p>
<pre id="P700049702700000000000000004517F" data-uri="chapter08.xhtml#P700049702700000000000000004517F" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045180" data-uri="chapter08.xhtml#P7000497027000000000000000045180" class="calibre3 pcalibre1 pcalibre2">
#include &lt;unistd.h&gt;
unsigned int sleep(unsigned int secs);
					Returns: seconds left to sleep
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045181" data-uri="chapter08.xhtml#P7000497027000000000000000045181"><code id="P7000497027000000000000000045182" data-uri="chapter08.xhtml#P7000497027000000000000000045182" class="pcalibre1 calibre1 pcalibre2">Sleep</code> returns zero if the requested amount of time has elapsed, and the number of seconds still left to sleep otherwise. The latter case is possible if the <code id="P7000497027000000000000000045183" data-uri="chapter08.xhtml#P7000497027000000000000000045183" class="pcalibre1 calibre1 pcalibre2">sleep</code> function <span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000698E" title="750" data-uri="chapter08.xhtml#P700049702700000000000000000698E" epub:type="pagebreak"></span>returns prematurely because it was interrupted by a <i class="pcalibre17 pcalibre2 pcalibre1">signal.</i> We will discuss signals in detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006993"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5</span></a>.</p>
<p id="P7000497027000000000000000045184" data-uri="chapter08.xhtml#P7000497027000000000000000045184" class="pcalibre8 pcalibre1 pcalibre2">Another function that we will find useful is the <code id="P7000497027000000000000000045185" data-uri="chapter08.xhtml#P7000497027000000000000000045185" class="pcalibre1 calibre1 pcalibre2">pause</code> function, which puts the calling function to sleep until a signal is received by the process.</p>
<pre id="P7000497027000000000000000045186" data-uri="chapter08.xhtml#P7000497027000000000000000045186" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045187" data-uri="chapter08.xhtml#P7000497027000000000000000045187" class="calibre3 pcalibre1 pcalibre2">
#include &lt;unistd.h&gt;
int pause(void);
Always returns -1
</code>
</pre>

<section id="P7000497027000000000000000006993" data-uri="chapter08.xhtml#P7000497027000000000000000006993" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000045188" data-uri="chapter08.xhtml#P7000497027000000000000000045188" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.5 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>
<p id="P7000497027000000000000000045189" data-uri="chapter08.xhtml#P7000497027000000000000000045189" class="pcalibre8 pcalibre1 pcalibre2">Write a wrapper function for <code id="P700049702700000000000000004518A" data-uri="chapter08.xhtml#P700049702700000000000000004518A" class="pcalibre1 calibre1 pcalibre2">sleep</code>, called <code id="P700049702700000000000000004518B" data-uri="chapter08.xhtml#P700049702700000000000000004518B" class="pcalibre1 calibre1 pcalibre2">snooze</code>, with the following interface:</p>
<pre id="P700049702700000000000000004518C" data-uri="chapter08.xhtml#P700049702700000000000000004518C" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004518D" data-uri="chapter08.xhtml#P700049702700000000000000004518D" class="calibre3 pcalibre1 pcalibre2">unsigned int snooze(unsigned int secs);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004518E" data-uri="chapter08.xhtml#P700049702700000000000000004518E">The <code id="P700049702700000000000000004518F" data-uri="chapter08.xhtml#P700049702700000000000000004518F" class="pcalibre1 calibre1 pcalibre2">snooze</code> function behaves exactly as the <code id="P7000497027000000000000000045190" data-uri="chapter08.xhtml#P7000497027000000000000000045190" class="pcalibre1 calibre1 pcalibre2">sleep</code> function, except that it prints a message describing how long the process actually slept:</p>
<pre id="P7000497027000000000000000045191" data-uri="chapter08.xhtml#P7000497027000000000000000045191" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045192" data-uri="chapter08.xhtml#P7000497027000000000000000045192" class="calibre3 pcalibre1 pcalibre2">Slept for 4 of 5 secs.</code></pre>
</section>
</section>
<section id="P700049702700000000000000000699F" data-uri="chapter08.xhtml#P700049702700000000000000000699F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045193" data-uri="chapter08.xhtml#P7000497027000000000000000045193" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.4.5  </span>Loading and Running Programs</h1></header>
<p id="P7000497027000000000000000045194" data-uri="chapter08.xhtml#P7000497027000000000000000045194" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000045195" data-uri="chapter08.xhtml#P7000497027000000000000000045195" class="pcalibre1 calibre1 pcalibre2">execve</code> function loads and runs a new program in the context of the current process.</p>
<pre id="P7000497027000000000000000045196" data-uri="chapter08.xhtml#P7000497027000000000000000045196" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045197" data-uri="chapter08.xhtml#P7000497027000000000000000045197" class="calibre3 pcalibre1 pcalibre2">
#include &lt;unistd.h&gt;
int execve(const char *filename, const char *argv[],
const char *envp[]);
Does not return if OK; returns -1 on error
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045198" data-uri="chapter08.xhtml#P7000497027000000000000000045198">The <code id="P7000497027000000000000000045199" data-uri="chapter08.xhtml#P7000497027000000000000000045199" class="pcalibre1 calibre1 pcalibre2">execve</code> function loads and runs the executable object file <code id="P700049702700000000000000004519A" data-uri="chapter08.xhtml#P700049702700000000000000004519A" class="pcalibre1 calibre1 pcalibre2">filename</code> with the argument list <code id="P700049702700000000000000004519B" data-uri="chapter08.xhtml#P700049702700000000000000004519B" class="pcalibre1 calibre1 pcalibre2">argv</code> and the environment variable list <code id="P700049702700000000000000004519C" data-uri="chapter08.xhtml#P700049702700000000000000004519C" class="pcalibre1 calibre1 pcalibre2">envp. Execve</code> returns to the calling program only if there is an error, such as not being able to find <code id="P700049702700000000000000004519D" data-uri="chapter08.xhtml#P700049702700000000000000004519D" class="pcalibre1 calibre1 pcalibre2">filename</code>. So unlike <code id="P700049702700000000000000004519E" data-uri="chapter08.xhtml#P700049702700000000000000004519E" class="pcalibre1 calibre1 pcalibre2">fork</code>, which is called once but returns twice, <code id="P700049702700000000000000004519F" data-uri="chapter08.xhtml#P700049702700000000000000004519F" class="pcalibre1 calibre1 pcalibre2">execve</code> is called once and never returns.</p>
<p id="P70004970270000000000000000451A0" data-uri="chapter08.xhtml#P70004970270000000000000000451A0" class="pcalibre8 pcalibre1 pcalibre2">The argument list is represented by the data structure shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000069B1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.20</span></a>. The <code id="P70004970270000000000000000451A1" data-uri="chapter08.xhtml#P70004970270000000000000000451A1" class="pcalibre1 calibre1 pcalibre2">argv</code> variable points to a null-terminated array of pointers, each of which points to an argument string. By convention, <code id="P70004970270000000000000000451A2" data-uri="chapter08.xhtml#P70004970270000000000000000451A2" class="pcalibre1 calibre1 pcalibre2">argv [0]</code> is the name of the executable object file. The list of environment variables is represented by a similar data structure, shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000069B6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.21</span></a>. The <code id="P70004970270000000000000000451A3" data-uri="chapter08.xhtml#P70004970270000000000000000451A3" class="pcalibre1 calibre1 pcalibre2">envp</code> variable points to a null-terminated array of pointers to environment variable strings, each of which is a name-value pair of the form <i class="pcalibre17 pcalibre2 pcalibre1">name=value.</i></p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000069B1" data-uri="chapter08.xhtml#P70004970270000000000000000069B1">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000069B2" title="751" data-uri="chapter08.xhtml#P70004970270000000000000000069B2" epub:type="pagebreak"></span><img alt="A diagram shows the organization of an argument list." id="P70004970270000000000000000451A4" data-uri="P700049702700000000000000000B76E" src="../images/p751-1.png" class="pcalibre252 pcalibre2 pcalibre1"/>
<figcaption id="P70004970270000000000000000451A5" data-uri="chapter08.xhtml#P70004970270000000000000000451A5" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000451A6" data-uri="chapter08.xhtml#P70004970270000000000000000451A6" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.20 </span>Organization of an argument list.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000254CC" data-uri="chapter08.xhtml#P70004970270000000000000000254CC">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000451A7" data-uri="chapter08.xhtml#P70004970270000000000000000451A7" class="pcalibre8 pcalibre1 pcalibre2">A stack titled argv[] has the following sections from top to bottom:</p>
<ul id="P70004970270000000000000000451A8" data-uri="chapter08.xhtml#P70004970270000000000000000451A8" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000451A9" data-uri="chapter08.xhtml#P70004970270000000000000000451A9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451AA" data-uri="chapter08.xhtml#P70004970270000000000000000451AA" class="pcalibre1 pcalibre2 pcalibre10">argv[0] (input argv, output “ls”)</p></li>
<li id="P70004970270000000000000000451AB" data-uri="chapter08.xhtml#P70004970270000000000000000451AB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451AC" data-uri="chapter08.xhtml#P70004970270000000000000000451AC" class="pcalibre1 pcalibre2 pcalibre10">argv[1] (output “-lt”)</p></li>
<li id="P70004970270000000000000000451AD" data-uri="chapter08.xhtml#P70004970270000000000000000451AD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451AE" data-uri="chapter08.xhtml#P70004970270000000000000000451AE" class="pcalibre1 pcalibre2 pcalibre10">Gap</p></li>
<li id="P70004970270000000000000000451AF" data-uri="chapter08.xhtml#P70004970270000000000000000451AF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451B0" data-uri="chapter08.xhtml#P70004970270000000000000000451B0" class="pcalibre1 pcalibre2 pcalibre10">Argv[argc-1] (output “/user/include”)</p></li>
<li id="P70004970270000000000000000451B1" data-uri="chapter08.xhtml#P70004970270000000000000000451B1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451B2" data-uri="chapter08.xhtml#P70004970270000000000000000451B2" class="pcalibre1 pcalibre2 pcalibre10">NULL</p></li>
</ul>
</details>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000069B6" data-uri="chapter08.xhtml#P70004970270000000000000000069B6">
<img alt="A diagram shows the organization of an environment variable list." id="P70004970270000000000000000451B3" data-uri="P700049702700000000000000000B76F" src="../images/p751-2.png" class="pcalibre253 pcalibre1 pcalibre2"/>
<figcaption id="P70004970270000000000000000451B4" data-uri="chapter08.xhtml#P70004970270000000000000000451B4" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000451B5" data-uri="chapter08.xhtml#P70004970270000000000000000451B5" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.21 </span>Organization of an environment variable list.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000254DC" data-uri="chapter08.xhtml#P70004970270000000000000000254DC">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000451B6" data-uri="chapter08.xhtml#P70004970270000000000000000451B6" class="pcalibre8 pcalibre1 pcalibre2">A stack titled envp[] has the following sections from top to bottom:</p>
<ul id="P70004970270000000000000000451B7" data-uri="chapter08.xhtml#P70004970270000000000000000451B7" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000451B8" data-uri="chapter08.xhtml#P70004970270000000000000000451B8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451B9" data-uri="chapter08.xhtml#P70004970270000000000000000451B9" class="pcalibre1 pcalibre2 pcalibre10">envp[0] (input envp, output “PWD=/usr/droh”)</p></li>
<li id="P70004970270000000000000000451BA" data-uri="chapter08.xhtml#P70004970270000000000000000451BA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451BB" data-uri="chapter08.xhtml#P70004970270000000000000000451BB" class="pcalibre1 pcalibre2 pcalibre10">envp[1] (output “PRINTER=iron”)</p></li>
<li id="P70004970270000000000000000451BC" data-uri="chapter08.xhtml#P70004970270000000000000000451BC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451BD" data-uri="chapter08.xhtml#P70004970270000000000000000451BD" class="pcalibre1 pcalibre2 pcalibre10">Gap</p></li>
<li id="P70004970270000000000000000451BE" data-uri="chapter08.xhtml#P70004970270000000000000000451BE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451BF" data-uri="chapter08.xhtml#P70004970270000000000000000451BF" class="pcalibre1 pcalibre2 pcalibre10">envp[n-1] (output “USER=droh”)</p></li>
<li id="P70004970270000000000000000451C0" data-uri="chapter08.xhtml#P70004970270000000000000000451C0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451C1" data-uri="chapter08.xhtml#P70004970270000000000000000451C1" class="pcalibre1 pcalibre2 pcalibre10">NULL</p></li>
</ul>
</details>
</figcaption>
</figure>
<p id="P70004970270000000000000000451C2" data-uri="chapter08.xhtml#P70004970270000000000000000451C2" class="pcalibre8 pcalibre1 pcalibre2">After <code id="P70004970270000000000000000451C3" data-uri="chapter08.xhtml#P70004970270000000000000000451C3" class="pcalibre1 calibre1 pcalibre2">execve</code> loads <code id="P70004970270000000000000000451C4" data-uri="chapter08.xhtml#P70004970270000000000000000451C4" class="pcalibre1 calibre1 pcalibre2">filename</code>, it calls the start-up code described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006385.xhtml#P7000497027000000000000000006385"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">7.9</span></a>. The start-up code sets up the stack and passes control to the main routine of the new program, which has a prototype of the form</p>
<pre id="P70004970270000000000000000451C5" data-uri="chapter08.xhtml#P70004970270000000000000000451C5" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000451C6" data-uri="chapter08.xhtml#P70004970270000000000000000451C6" class="calibre3 pcalibre1 pcalibre2">int main(int arge, char **argv, char **envp);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000451C7" data-uri="chapter08.xhtml#P70004970270000000000000000451C7">or equivalently,</p>
<pre id="P70004970270000000000000000451C8" data-uri="chapter08.xhtml#P70004970270000000000000000451C8" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000451C9" data-uri="chapter08.xhtml#P70004970270000000000000000451C9" class="calibre3 pcalibre1 pcalibre2">int main(int arge, char *argv[], char *envp[]);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000451CA" data-uri="chapter08.xhtml#P70004970270000000000000000451CA">When <code id="P70004970270000000000000000451CB" data-uri="chapter08.xhtml#P70004970270000000000000000451CB" class="pcalibre1 calibre1 pcalibre2">main</code> begins executing, the user stack has the organization shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000069D2"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.22</span></a>. Let's work our way from the bottom of the stack (the highest address) to the top (the lowest address). First are the argument and environment strings. These are followed further up the stack by a null-terminated array of pointers, each of which points to an environment variable string on the stack. The global variable <code id="P70004970270000000000000000451CC" data-uri="chapter08.xhtml#P70004970270000000000000000451CC" class="pcalibre1 calibre1 pcalibre2">environ</code> points to the first of these pointers, <code id="P70004970270000000000000000451CD" data-uri="chapter08.xhtml#P70004970270000000000000000451CD" class="pcalibre1 calibre1 pcalibre2">envp [0]</code>. The environment array is followed by the null-terminated <code id="P70004970270000000000000000451CE" data-uri="chapter08.xhtml#P70004970270000000000000000451CE" class="pcalibre1 calibre1 pcalibre2">argv []</code> array, with each element pointing to an argument string on the stack. At the top of the stack is the stack frame for the system start-up function, <code id="P70004970270000000000000000451CF" data-uri="chapter08.xhtml#P70004970270000000000000000451CF" class="pcalibre1 calibre1 pcalibre2">libc_start_main</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006385.xhtml#P7000497027000000000000000006385"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">7.9</span></a>).</p>
<p id="P70004970270000000000000000451D0" data-uri="chapter08.xhtml#P70004970270000000000000000451D0" class="pcalibre8 pcalibre1 pcalibre2">There are three arguments to function main, each stored in a register according to the x86-64 stack discipline: (1) <code id="P70004970270000000000000000451D1" data-uri="chapter08.xhtml#P70004970270000000000000000451D1" class="pcalibre1 calibre1 pcalibre2">argc</code>, which gives the number of non-null pointers in the <code id="P70004970270000000000000000451D2" data-uri="chapter08.xhtml#P70004970270000000000000000451D2" class="pcalibre1 calibre1 pcalibre2">argv []</code> array; (2) <code id="P70004970270000000000000000451D3" data-uri="chapter08.xhtml#P70004970270000000000000000451D3" class="pcalibre1 calibre1 pcalibre2">argv</code>, which points to the first entry in the <code id="P70004970270000000000000000451D4" data-uri="chapter08.xhtml#P70004970270000000000000000451D4" class="pcalibre1 calibre1 pcalibre2">argv []</code> array; and (3) <code id="P70004970270000000000000000451D5" data-uri="chapter08.xhtml#P70004970270000000000000000451D5" class="pcalibre1 calibre1 pcalibre2">envp</code>, which points to the first entry in the <code id="P70004970270000000000000000451D6" data-uri="chapter08.xhtml#P70004970270000000000000000451D6" class="pcalibre1 calibre1 pcalibre2">envp []</code> array.</p>
<p id="P70004970270000000000000000451D7" data-uri="chapter08.xhtml#P70004970270000000000000000451D7" class="pcalibre8 pcalibre1 pcalibre2">Linux provides several functions for manipulating the environment array:</p>
<pre id="P70004970270000000000000000451D8" data-uri="chapter08.xhtml#P70004970270000000000000000451D8" class="calibre2 pcalibre2 pcalibre1">
<code id="P70004970270000000000000000451D9" data-uri="chapter08.xhtml#P70004970270000000000000000451D9" class="calibre3 pcalibre1 pcalibre2">
#include &lt;stdlib.h&gt;
char *getenv(const char *name);
				Returns: pointer to name if it exists, NULL if no match
</code>
</pre>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000069D2" data-uri="chapter08.xhtml#P70004970270000000000000000069D2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000069D3" title="752" data-uri="chapter08.xhtml#P70004970270000000000000000069D3" epub:type="pagebreak"></span><img alt="A diagram shows the typical organization of the user stack." id="P70004970270000000000000000451DA" data-uri="P700049702700000000000000000B770" src="../images/p752-1.png" class="pcalibre1 pcalibre2 pcalibre254"/>
<figcaption id="P70004970270000000000000000451DB" data-uri="chapter08.xhtml#P70004970270000000000000000451DB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000451DC" data-uri="chapter08.xhtml#P70004970270000000000000000451DC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.22 </span>Typical organization of the user stack when a new program starts.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000025504" data-uri="chapter08.xhtml#P7000497027000000000000000025504">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000451DD" data-uri="chapter08.xhtml#P70004970270000000000000000451DD" class="pcalibre8 pcalibre1 pcalibre2">The sections of the stack are summarized below from bottom to top:</p>
<ul id="P70004970270000000000000000451DE" data-uri="chapter08.xhtml#P70004970270000000000000000451DE" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000451DF" data-uri="chapter08.xhtml#P70004970270000000000000000451DF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451E0" data-uri="chapter08.xhtml#P70004970270000000000000000451E0" class="pcalibre1 pcalibre2 pcalibre10">Future stack frame for main, below top of stack</p></li>
<li id="P70004970270000000000000000451E1" data-uri="chapter08.xhtml#P70004970270000000000000000451E1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451E2" data-uri="chapter08.xhtml#P70004970270000000000000000451E2" class="pcalibre1 pcalibre2 pcalibre10">Stack frame for libc_start_main, labeled argc (in %rdi), above top of stack</p></li>
<li id="P70004970270000000000000000451E3" data-uri="chapter08.xhtml#P70004970270000000000000000451E3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451E4" data-uri="chapter08.xhtml#P70004970270000000000000000451E4" class="pcalibre1 pcalibre2 pcalibre10">Gap</p></li>
<li id="P70004970270000000000000000451E5" data-uri="chapter08.xhtml#P70004970270000000000000000451E5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451E6" data-uri="chapter08.xhtml#P70004970270000000000000000451E6" class="pcalibre1 pcalibre2 pcalibre10">Argv[0], arrow from argv (in %rsi) (arrow to above gap near bottom of stack)</p></li>
<li id="P70004970270000000000000000451E7" data-uri="chapter08.xhtml#P70004970270000000000000000451E7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451E8" data-uri="chapter08.xhtml#P70004970270000000000000000451E8" class="pcalibre1 pcalibre2 pcalibre10">…</p></li>
<li id="P70004970270000000000000000451E9" data-uri="chapter08.xhtml#P70004970270000000000000000451E9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451EA" data-uri="chapter08.xhtml#P70004970270000000000000000451EA" class="pcalibre1 pcalibre2 pcalibre10">argv[argc-1]</p></li>
<li id="P70004970270000000000000000451EB" data-uri="chapter08.xhtml#P70004970270000000000000000451EB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451EC" data-uri="chapter08.xhtml#P70004970270000000000000000451EC" class="pcalibre1 pcalibre2 pcalibre10">argv[argc] = NULL</p></li>
<li id="P70004970270000000000000000451ED" data-uri="chapter08.xhtml#P70004970270000000000000000451ED" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451EE" data-uri="chapter08.xhtml#P70004970270000000000000000451EE" class="pcalibre1 pcalibre2 pcalibre10">envp[0], arrow from environ (global var) and envp (in %rdx), and arrow to bottom of stack</p></li>
<li id="P70004970270000000000000000451EF" data-uri="chapter08.xhtml#P70004970270000000000000000451EF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451F0" data-uri="chapter08.xhtml#P70004970270000000000000000451F0" class="pcalibre1 pcalibre2 pcalibre10">…</p></li>
<li id="P70004970270000000000000000451F1" data-uri="chapter08.xhtml#P70004970270000000000000000451F1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451F2" data-uri="chapter08.xhtml#P70004970270000000000000000451F2" class="pcalibre1 pcalibre2 pcalibre10">envp[n-1]</p></li>
<li id="P70004970270000000000000000451F3" data-uri="chapter08.xhtml#P70004970270000000000000000451F3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451F4" data-uri="chapter08.xhtml#P70004970270000000000000000451F4" class="pcalibre1 pcalibre2 pcalibre10">envp[n] == NULL</p></li>
<li id="P70004970270000000000000000451F5" data-uri="chapter08.xhtml#P70004970270000000000000000451F5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451F6" data-uri="chapter08.xhtml#P70004970270000000000000000451F6" class="pcalibre1 pcalibre2 pcalibre10">Gap</p></li>
<li id="P70004970270000000000000000451F7" data-uri="chapter08.xhtml#P70004970270000000000000000451F7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451F8" data-uri="chapter08.xhtml#P70004970270000000000000000451F8" class="pcalibre1 pcalibre2 pcalibre10">Null-terminated command-line arg strings (arrow from argv[0])</p></li>
<li id="P70004970270000000000000000451F9" data-uri="chapter08.xhtml#P70004970270000000000000000451F9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000451FA" data-uri="chapter08.xhtml#P70004970270000000000000000451FA" class="pcalibre1 pcalibre2 pcalibre10">Null-terminated environment variable strings to bottom of stack (arrow from envp[0])</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000451FB" data-uri="chapter08.xhtml#P70004970270000000000000000451FB">The <code id="P70004970270000000000000000451FC" data-uri="chapter08.xhtml#P70004970270000000000000000451FC" class="pcalibre1 calibre1 pcalibre2">getenv</code> function searches the environment array for a string <code id="P70004970270000000000000000451FD" data-uri="chapter08.xhtml#P70004970270000000000000000451FD" class="pcalibre1 calibre1 pcalibre2">name=<i class="pcalibre17 pcalibre2 pcalibre1">value.</i></code> If found, it returns a pointer to <i class="pcalibre17 pcalibre2 pcalibre1">value;</i> otherwise, it returns <code id="P70004970270000000000000000451FE" data-uri="chapter08.xhtml#P70004970270000000000000000451FE" class="pcalibre1 calibre1 pcalibre2">NULL</code>.</p>
<pre id="P70004970270000000000000000451FF" data-uri="chapter08.xhtml#P70004970270000000000000000451FF" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045200" data-uri="chapter08.xhtml#P7000497027000000000000000045200" class="calibre3 pcalibre1 pcalibre2">
#include &lt;stdlib.h&gt;
int setenv(const char *name, const char *newvalue, int overwrite);
					Returns: 0 on success, -1 on error
void unsetenv(const char *name);
							 Returns: nothing
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045201" data-uri="chapter08.xhtml#P7000497027000000000000000045201">If the environment array contains a string of the form <code id="P7000497027000000000000000045202" data-uri="chapter08.xhtml#P7000497027000000000000000045202" class="pcalibre1 calibre1 pcalibre2">name=<i class="pcalibre17 pcalibre2 pcalibre1">oldvalue</i></code>, then <code id="P7000497027000000000000000045203" data-uri="chapter08.xhtml#P7000497027000000000000000045203" class="pcalibre1 calibre1 pcalibre2">unsetenv</code> deletes it and <code id="P7000497027000000000000000045204" data-uri="chapter08.xhtml#P7000497027000000000000000045204" class="pcalibre1 calibre1 pcalibre2">setenv</code> replaces <i class="pcalibre17 pcalibre2 pcalibre1">oldvalue</i> with <code id="P7000497027000000000000000045205" data-uri="chapter08.xhtml#P7000497027000000000000000045205" class="pcalibre1 calibre1 pcalibre2">newvalue</code>, but only if <code id="P7000497027000000000000000045206" data-uri="chapter08.xhtml#P7000497027000000000000000045206" class="pcalibre1 calibre1 pcalibre2">overwrite</code> is nonzero. If name does not exist, then <code id="P7000497027000000000000000045207" data-uri="chapter08.xhtml#P7000497027000000000000000045207" class="pcalibre1 calibre1 pcalibre2">setenv</code> adds <code id="P7000497027000000000000000045208" data-uri="chapter08.xhtml#P7000497027000000000000000045208" class="pcalibre1 calibre1 pcalibre2">name=newvalue</code> to the array.</p>
<section id="P70004970270000000000000000069E5" data-uri="chapter08.xhtml#P70004970270000000000000000069E5" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000045209" data-uri="chapter08.xhtml#P7000497027000000000000000045209" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.6 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004520A" data-uri="chapter08.xhtml#P700049702700000000000000004520A">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004520B" data-uri="chapter08.xhtml#P700049702700000000000000004520B"><div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004520C" data-uri="chapter08.xhtml#P700049702700000000000000004520C"><p id="P700049702700000000000000004520D" data-uri="chapter08.xhtml#P700049702700000000000000004520D" class="pcalibre1 pcalibre2 pcalibre10">Write a program called <code id="P700049702700000000000000004520E" data-uri="chapter08.xhtml#P700049702700000000000000004520E" class="pcalibre1 calibre1 pcalibre2">myecho</code> that prints its command-line arguments and environment variables. For example:</p></div>
<pre id="P700049702700000000000000004520F" data-uri="chapter08.xhtml#P700049702700000000000000004520F" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000045210" data-uri="chapter08.xhtml#P7000497027000000000000000045210" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./myecho argl arg2</i>
Command-ine arguments:
argv[ 0]: myecho
argv[ 1]: arg1
argv[ 2]: arg2
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000069EE" title="753" data-uri="chapter08.xhtml#P70004970270000000000000000069EE" epub:type="pagebreak"></span>Environment variables :
envp[ 0]: PWD=/usr0/droh/ics/code/ecf
envp [ 1]: TERM=emacs
⋮
envp[25]: USER=droh
envp[26]: SHELL=/usr/local/bin/tcsh
envp[27]: HOME=/usr0/droh
</code>
</pre>
</li>
</ol>
</section>
</section>


<section id="P70004970270000000000000000069EF" data-uri="chapter08.xhtml#P70004970270000000000000000069EF" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045211" data-uri="chapter08.xhtml#P7000497027000000000000000045211" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.4.6 </span>Using <code id="P7000497027000000000000000045212" data-uri="chapter08.xhtml#P7000497027000000000000000045212" class="pcalibre1 calibre1 pcalibre2">fork</code> and <code id="P7000497027000000000000000045213" data-uri="chapter08.xhtml#P7000497027000000000000000045213" class="pcalibre1 calibre1 pcalibre2">execve</code> to Run Programs</h1></header>

<p id="P7000497027000000000000000045214" data-uri="chapter08.xhtml#P7000497027000000000000000045214" class="pcalibre8 pcalibre1 pcalibre2">Programs such as Unix shells and Web servers make heavy use of the <code id="P7000497027000000000000000045215" data-uri="chapter08.xhtml#P7000497027000000000000000045215" class="pcalibre1 calibre1 pcalibre2">fork</code> and <code id="P7000497027000000000000000045216" data-uri="chapter08.xhtml#P7000497027000000000000000045216" class="pcalibre1 calibre1 pcalibre2">execve</code> functions. A <i class="pcalibre17 pcalibre2 pcalibre1">shell</i> is an interactive application-level program that runs other programs on behalf of the user. The original shell was the <code id="P7000497027000000000000000045217" data-uri="chapter08.xhtml#P7000497027000000000000000045217" class="pcalibre1 calibre1 pcalibre2">sh</code> program, which was followed by variants such as <code id="P7000497027000000000000000045218" data-uri="chapter08.xhtml#P7000497027000000000000000045218" class="pcalibre1 calibre1 pcalibre2">csh, tcsh, ksh</code>, and <code id="P7000497027000000000000000045219" data-uri="chapter08.xhtml#P7000497027000000000000000045219" class="pcalibre1 calibre1 pcalibre2">bash</code>. A shell performs a sequence of <i class="pcalibre17 pcalibre2 pcalibre1">read/evaluate</i> steps and then terminates. The read step reads a command line from the user. The evaluate step parses the command line and runs programs on behalf of the user.</p>
<p id="P700049702700000000000000004521A" data-uri="chapter08.xhtml#P700049702700000000000000004521A" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006A09"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.23 </span></a>shows the main routine of a simple shell. The shell prints a command-line prompt, waits for the user to type a command line on <code id="P700049702700000000000000004521B" data-uri="chapter08.xhtml#P700049702700000000000000004521B" class="pcalibre1 calibre1 pcalibre2">stdin</code>, and then evaluates the command line.</p>
<p id="P700049702700000000000000004521C" data-uri="chapter08.xhtml#P700049702700000000000000004521C" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006A1B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.24 </span></a>shows the code that evaluates the command line. Its first task is to call the <code id="P700049702700000000000000004521D" data-uri="chapter08.xhtml#P700049702700000000000000004521D" class="pcalibre1 calibre1 pcalibre2">parseline</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006A24"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.25</span></a>), which parses the space-separated command-line arguments and builds the <code id="P700049702700000000000000004521E" data-uri="chapter08.xhtml#P700049702700000000000000004521E" class="pcalibre1 calibre1 pcalibre2">argv</code> vector that will eventually be passed to <code id="P700049702700000000000000004521F" data-uri="chapter08.xhtml#P700049702700000000000000004521F" class="pcalibre1 calibre1 pcalibre2">execve</code>. The first argument is assumed to be either the name of a built-in shell command that is interpreted immediately, or an executable object file that will be loaded and run in the context of a new child process.</p>
<p id="P7000497027000000000000000045220" data-uri="chapter08.xhtml#P7000497027000000000000000045220" class="pcalibre8 pcalibre1 pcalibre2">If the last argument is an ‘&amp;’ character, then <code id="P7000497027000000000000000045221" data-uri="chapter08.xhtml#P7000497027000000000000000045221" class="pcalibre1 calibre1 pcalibre2">parseline</code> returns 1, indicating that the program should be executed in the <i class="pcalibre17 pcalibre2 pcalibre1">background</i> (the shell does not wait for it to complete). Otherwise, it returns 0, indicating that the program should be run in the <i class="pcalibre17 pcalibre2 pcalibre1">foreground</i> (the shell waits for it to complete).</p>

<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000045222" data-uri="chapter08.xhtml#P7000497027000000000000000045222"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000045223" data-uri="chapter08.xhtml#P7000497027000000000000000045223" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Programs versus processes</h1></header>
<p id="P7000497027000000000000000045224" data-uri="chapter08.xhtml#P7000497027000000000000000045224" class="pcalibre1 pcalibre2 pcalibre10">This is a good place to pause and make sure you understand the distinction between a program and a process. A program is a collection of code and data; programs can exist as object files on disk or as segments in an address space. A process is a specific instance of a program in execution; a program always runs in the context of some process. Understanding this distinction is important if you want to understand the <code id="P7000497027000000000000000045225" data-uri="chapter08.xhtml#P7000497027000000000000000045225" class="pcalibre1 calibre1 pcalibre2">fork</code> and <code id="P7000497027000000000000000045226" data-uri="chapter08.xhtml#P7000497027000000000000000045226" class="pcalibre1 calibre1 pcalibre2">execve</code> functions. The <code id="P7000497027000000000000000045227" data-uri="chapter08.xhtml#P7000497027000000000000000045227" class="pcalibre1 calibre1 pcalibre2">fork</code> function runs the same program in a new child process that is a duplicate of the parent. The <code id="P7000497027000000000000000045228" data-uri="chapter08.xhtml#P7000497027000000000000000045228" class="pcalibre1 calibre1 pcalibre2">execve</code> function loads and runs a new program in the context of the current process. While it overwrites the address space of the current process, it does <i class="pcalibre17 pcalibre2 pcalibre1">not</i> create a new process. The new program still has the same PID, and it inherits all of the file descriptors that were open at the time of the call to the <code id="P7000497027000000000000000045229" data-uri="chapter08.xhtml#P7000497027000000000000000045229" class="pcalibre1 calibre1 pcalibre2">execve</code> function.</p>
</aside>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000006A09" data-uri="chapter08.xhtml#P7000497027000000000000000006A09">
<p id="P700049702700000000000000004522A" data-uri="chapter08.xhtml#P700049702700000000000000004522A" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006A0B" title="754" data-uri="chapter08.xhtml#P7000497027000000000000000006A0B" epub:type="pagebreak"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<pre id="P700049702700000000000000004522B" data-uri="chapter08.xhtml#P700049702700000000000000004522B" class="calibre2 pcalibre2 pcalibre1">
<code id="P700049702700000000000000004522C" data-uri="chapter08.xhtml#P700049702700000000000000004522C" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	#define MAXARGS 128
3	
4	/* Function prototypes */
5	void evaKchar *cmdline);
6	int parseline(char *buf, char **argv);
7	int builtin_command(char **argv);
8	
9	int main()
10	{
11		char cmdline[MAXLINE]; /* Command line */
12	
13		while (1) {
14		/* Read */
15		printf("&gt; ");
16		Fgets(cmdline, MAXLINE, stdin);
17		if (feof(stdin))
18			exit(0);
19	
20		/* Evaluate */
21		eval(cmdline);
22	}
23	}
</code>
</pre>
<p id="P700049702700000000000000004522D" data-uri="chapter08.xhtml#P700049702700000000000000004522D" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<figcaption id="P700049702700000000000000004522E" data-uri="chapter08.xhtml#P700049702700000000000000004522E" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004522F" data-uri="chapter08.xhtml#P700049702700000000000000004522F" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.23 </span>The main routine for a simple shell program.</h1></header>
</figcaption>
</figure>

<p id="P7000497027000000000000000045230" data-uri="chapter08.xhtml#P7000497027000000000000000045230" class="pcalibre8 pcalibre1 pcalibre2">After parsing the command line, the <code id="P7000497027000000000000000045231" data-uri="chapter08.xhtml#P7000497027000000000000000045231" class="pcalibre1 calibre1 pcalibre2">eval</code> function calls the <code id="P7000497027000000000000000045232" data-uri="chapter08.xhtml#P7000497027000000000000000045232" class="pcalibre1 calibre1 pcalibre2">builtin_command</code> function, which checks whether the first command-line argument is a built-in shell command. If so, it interprets the command immediately and returns 1. Otherwise, it returns 0. Our simple shell has just one built-in command, the <code id="P7000497027000000000000000045233" data-uri="chapter08.xhtml#P7000497027000000000000000045233" class="pcalibre1 calibre1 pcalibre2">quit</code> command, which terminates the shell. Real shells have numerous commands, such as <code id="P7000497027000000000000000045234" data-uri="chapter08.xhtml#P7000497027000000000000000045234" class="pcalibre1 calibre1 pcalibre2">pwd, jobs</code>, and <code id="P7000497027000000000000000045235" data-uri="chapter08.xhtml#P7000497027000000000000000045235" class="pcalibre1 calibre1 pcalibre2">fg</code>.</p>
<p id="P7000497027000000000000000045236" data-uri="chapter08.xhtml#P7000497027000000000000000045236" class="pcalibre8 pcalibre1 pcalibre2">If <code id="P7000497027000000000000000045237" data-uri="chapter08.xhtml#P7000497027000000000000000045237" class="pcalibre1 calibre1 pcalibre2">builtin_command</code> returns 0, then the shell creates a child process and executes the requested program inside the child. If the user has asked for the program to run in the background, then the shell returns to the top of the loop and waits for the next command line. Otherwise the shell uses the <code id="P7000497027000000000000000045238" data-uri="chapter08.xhtml#P7000497027000000000000000045238" class="pcalibre1 calibre1 pcalibre2">waitpid</code> function to wait for the job to terminate. When the job terminates, the shell goes on to the next iteration.</p>
<p id="P7000497027000000000000000045239" data-uri="chapter08.xhtml#P7000497027000000000000000045239" class="pcalibre8 pcalibre1 pcalibre2">Notice that this simple shell is flawed because it does not reap any of its background children. Correcting this flaw requires the use of signals, which we describe in the next section.</p>


<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000006A1B" data-uri="chapter08.xhtml#P7000497027000000000000000006A1B">
<p id="P700049702700000000000000004523A" data-uri="chapter08.xhtml#P700049702700000000000000004523A" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006A1D" title="755" data-uri="chapter08.xhtml#P7000497027000000000000000006A1D" epub:type="pagebreak"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<pre id="P700049702700000000000000004523B" data-uri="chapter08.xhtml#P700049702700000000000000004523B" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004523C" data-uri="chapter08.xhtml#P700049702700000000000000004523C" class="calibre3 pcalibre1 pcalibre2">
1	/* eval - Evaluate a command line */
2	void evaKchar *cmdline)
3	{
4		char *argv[MAXARGS];	/* Argument list execve() */
5		char buf[MAXLINE];	/* Holds modified command line */
6		int bg;	/* Should the job run in bg or fg? */
7		pid_t pid;	/* Process id */
8	
9		strcpy(buf, cmdline);
10		bg = parseline(buf, argv);
11		if (argv[0] == NULL)
12			return;	/* Ignore empty lines */
13	
14		if (!builtin_command(argv)) {
15			if ((pid = Fork()) == 0) {	/* Child runs user job */
16				if (execve(argv[0], argv, environ) &lt; 0) {
17					printf("%s: Command not found.\n", argv[0]);
18					exit(0);
19				}
20			}
21	
22			/* Parent waits for foreground job to terminate */
23			if (!bg) {
24				int status;
25				if (waitpid(pid, &amp;status, 0) &lt; 0)
26					unix_error("waitfg: waitpid error");
27			}
28			else
29				printf (%d %s", pid, cmdline);
30		}
31		return;
32	}
33	
34	/* If first arg is a builtin command, run it and return true */
35	int builtin_command(char **argv)
36	{
37		if (!strcmp(argv[0], "quit"))	/* quit command */
38			exit(0);
39		if (!strcmp(argv[0], "&amp;"))	/* Ignore singleton &amp; */
40		return 1;
41		return 0;	/* Not a builtin command */
42	}
</code>
</pre>
<p id="P700049702700000000000000004523D" data-uri="chapter08.xhtml#P700049702700000000000000004523D" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<figcaption id="P700049702700000000000000004523E" data-uri="chapter08.xhtml#P700049702700000000000000004523E" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004523F" data-uri="chapter08.xhtml#P700049702700000000000000004523F" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.24 </span><code id="P7000497027000000000000000045240" data-uri="chapter08.xhtml#P7000497027000000000000000045240" class="pcalibre1 calibre1 pcalibre2">eval</code> evaluates the shell command line.</h1></header>
</figcaption>
</figure>


<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000006A24" data-uri="chapter08.xhtml#P7000497027000000000000000006A24">


<p id="P7000497027000000000000000045241" data-uri="chapter08.xhtml#P7000497027000000000000000045241" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006A26" title="756" data-uri="chapter08.xhtml#P7000497027000000000000000006A26" epub:type="pagebreak"></span>------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<pre id="P7000497027000000000000000045242" data-uri="chapter08.xhtml#P7000497027000000000000000045242" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045243" data-uri="chapter08.xhtml#P7000497027000000000000000045243" class="calibre3 pcalibre1 pcalibre2">
1	/* parseline - Parse the command line and build the argv array */
2	int parseline(char *buf, char **argv)
3	{
4		char *delim;	/* Points to first space delimiter */
5		int argc;	/* Number of args */
6		int bg;	/* Background job? */ 7
7	
8		buf[strlen(buf) -1] = ‘ ’;	/* Replace trailing ‘\n’ with space */
9		while (*buf &amp;&amp; (*buf == ‘ ’)) /* Ignore leading spaces */
10			buf++;
11	
12		/* Build the argv list */
13		argc = 0;
14		while ((delim = strchr(buf, ‘ ’))) {
15			argv [argc++] = buf;
16			*delim = ‘\0’;
17			buf = delim + 1;
18			while (*buf &amp;&amp; (*buf == ‘ ’)) /* Ignore spaces */
19				buf++;
20		}
21		argv [argc] = NULL;
22	
23		if (argc == 0) /* Ignore blank line */
24			return 1;
25	
26		/* Should the job run in the background? */
27		if ((bg = (*argv[argc-1] == ‘&amp;’)) != 0)
28			argv[—argc] = NULL;
29	
30		return bg;
31	}
</code>
</pre>
<p id="P7000497027000000000000000045244" data-uri="chapter08.xhtml#P7000497027000000000000000045244" class="pcalibre8 pcalibre1 pcalibre2">------------------------------------------------------------------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/ecf/shellex.c</i></p>
<figcaption id="P7000497027000000000000000045245" data-uri="chapter08.xhtml#P7000497027000000000000000045245" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045246" data-uri="chapter08.xhtml#P7000497027000000000000000045246" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.25 </span><code id="P7000497027000000000000000045247" data-uri="chapter08.xhtml#P7000497027000000000000000045247" class="pcalibre1 calibre1 pcalibre2">parseline</code> parses a line of input for the shell.</h1></header>
</figcaption>
</figure>
</section>
</section></body></html>
