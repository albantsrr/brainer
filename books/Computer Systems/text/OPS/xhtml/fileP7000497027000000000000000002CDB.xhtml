<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>3.9 Heterogeneous Data Structures</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000002CDB" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000040F3A" data-uri="chapter03.xhtml#P7000497027000000000000000040F3A" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.9 </span>Heterogeneous Data Structures</h1></header>
<p id="P7000497027000000000000000040F3B" data-uri="chapter03.xhtml#P7000497027000000000000000040F3B" class="pcalibre8 pcalibre1 pcalibre2">C provides two mechanisms for creating data types by combining objects of different types: <i class="pcalibre17 pcalibre2 pcalibre1">structures</i>, declared using the keyword <code id="P7000497027000000000000000040F3C" data-uri="chapter03.xhtml#P7000497027000000000000000040F3C" class="pcalibre1 calibre1 pcalibre2">struct</code>, aggregate multiple objects into a single unit; <i class="pcalibre17 pcalibre2 pcalibre1">unions</i>, declared using the keyword <code id="P7000497027000000000000000040F3D" data-uri="chapter03.xhtml#P7000497027000000000000000040F3D" class="pcalibre1 calibre1 pcalibre2">union</code>, allow an object to be referenced using several different types.</p>
<section id="P7000497027000000000000000002CE0" data-uri="chapter03.xhtml#P7000497027000000000000000002CE0" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000040F3E" data-uri="chapter03.xhtml#P7000497027000000000000000040F3E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.9.1 </span>Structures</h1></header>
<p id="P7000497027000000000000000040F3F" data-uri="chapter03.xhtml#P7000497027000000000000000040F3F" class="pcalibre8 pcalibre1 pcalibre2">The C <code id="P7000497027000000000000000040F40" data-uri="chapter03.xhtml#P7000497027000000000000000040F40" class="pcalibre1 calibre1 pcalibre2">struct</code> declaration creates a data type that groups objects of possibly different types into a single object. The different components of a structure are referenced by names. The implementation of structures is similar to that of arrays in that all of the components of a structure are stored in a contiguous region of memory and a pointer to a structure is the address of its first byte. The compiler maintains information about each structure type indicating the byte offset of each field. It generates references to structure elements using these offsets as displacements in memory referencing instructions.</p>
<p id="P7000497027000000000000000040F41" data-uri="chapter03.xhtml#P7000497027000000000000000040F41" class="pcalibre8 pcalibre1 pcalibre2">As an example, consider the following structure declaration:</p>
<pre id="P7000497027000000000000000040F42" data-uri="chapter03.xhtml#P7000497027000000000000000040F42" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F43" data-uri="chapter03.xhtml#P7000497027000000000000000040F43" class="calibre3 pcalibre1 pcalibre2">
struct rec {
	int i;
	int j;
	int a[2];
	int *p;
};
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040F44" data-uri="chapter03.xhtml#P7000497027000000000000000040F44">This structure contains four fields: two 4-byte values of type <code id="P7000497027000000000000000040F45" data-uri="chapter03.xhtml#P7000497027000000000000000040F45" class="pcalibre1 calibre1 pcalibre2">int</code>, a two-element array of type <code id="P7000497027000000000000000040F46" data-uri="chapter03.xhtml#P7000497027000000000000000040F46" class="pcalibre1 calibre1 pcalibre2">int</code>, and an 8-byte integer pointer, giving a total of 24 bytes:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002CEA" data-uri="chapter03.xhtml#P7000497027000000000000000002CEA">
<img alt="A diagram shows four fields: offset 0 to 4 with contents i; offset 4 to 8 with contents j; two offsets from 8 to 16 with contents a[0] and a[1]; offset 16 to 24 with contents p." id="P7000497027000000000000000040F47" data-uri="P700049702700000000000000000B6BC" src="../images/p265-1.png" class="pcalibre1 pcalibre2 pcalibre132"/>

</figure>
<p id="P7000497027000000000000000040F48" data-uri="chapter03.xhtml#P7000497027000000000000000040F48" class="pcalibre8 pcalibre1 pcalibre2">Observe that array a is embedded within the structure. The numbers along the top of the diagram give the byte offsets of the fields from the beginning of the structure.</p>
<p id="P7000497027000000000000000040F49" data-uri="chapter03.xhtml#P7000497027000000000000000040F49" class="pcalibre8 pcalibre1 pcalibre2">To access the fields of a structure, the compiler generates code that adds the appropriate offset to the address of the structure. For example, suppose variable <code id="P7000497027000000000000000040F4A" data-uri="chapter03.xhtml#P7000497027000000000000000040F4A" class="pcalibre1 calibre1 pcalibre2">r</code></p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000002CEF" data-uri="chapter03.xhtml#P7000497027000000000000000002CEF"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000040F4B" data-uri="chapter03.xhtml#P7000497027000000000000000040F4B" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002CF1" title="266" data-uri="chapter03.xhtml#P7000497027000000000000000002CF1" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">New to C? </span>Representing an object as a <code id="P7000497027000000000000000040F4C" data-uri="chapter03.xhtml#P7000497027000000000000000040F4C" class="pcalibre1 pcalibre2 calibre16">struct</code></h1></header>
<p id="P7000497027000000000000000040F4D" data-uri="chapter03.xhtml#P7000497027000000000000000040F4D" class="pcalibre1 pcalibre2 pcalibre40">The <code id="P7000497027000000000000000040F4E" data-uri="chapter03.xhtml#P7000497027000000000000000040F4E" class="pcalibre1 calibre1 pcalibre2">struct</code> data type constructor is the closest thing C provides to the objects of C++ and Java. It allows the programmer to keep information about some entity in a single data structure and to reference that information with names.</p>
<p id="P7000497027000000000000000040F4F" data-uri="chapter03.xhtml#P7000497027000000000000000040F4F" class="pcalibre1 pcalibre2 pcalibre40">For example, a graphics program might represent a rectangle as a structure:</p>
<pre id="P7000497027000000000000000040F50" data-uri="chapter03.xhtml#P7000497027000000000000000040F50" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F51" data-uri="chapter03.xhtml#P7000497027000000000000000040F51" class="calibre3 pcalibre1 pcalibre2">
struct rect {
	long llx;		/* X coordinate of lower-left corner */
	long lly;		/* Y coordinate of lower-left corner */
	unsigned long width;	 /* Width (in pixels)			*/
	unsigned long height;	/* Height (in pixels)			*/
	unsigned color;		/* Coding of color			*/
};
</code></pre>
<p id="P7000497027000000000000000040F52" data-uri="chapter03.xhtml#P7000497027000000000000000040F52" class="pcalibre1 pcalibre2 pcalibre40">We can declare a variable <code id="P7000497027000000000000000040F53" data-uri="chapter03.xhtml#P7000497027000000000000000040F53" class="pcalibre1 calibre1 pcalibre2">r</code> of type <code id="P7000497027000000000000000040F54" data-uri="chapter03.xhtml#P7000497027000000000000000040F54" class="pcalibre1 calibre1 pcalibre2">struct rect</code> and set its field values as follows:</p>
<pre id="P7000497027000000000000000040F55" data-uri="chapter03.xhtml#P7000497027000000000000000040F55" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F56" data-uri="chapter03.xhtml#P7000497027000000000000000040F56" class="calibre3 pcalibre1 pcalibre2">
struct rect r;
r.llx = r.lly = 0;
r.color = 0xFF00FF;
r.width = 10;
r.height = 20;
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P7000497027000000000000000040F57" data-uri="chapter03.xhtml#P7000497027000000000000000040F57">where the expression <code id="P7000497027000000000000000040F58" data-uri="chapter03.xhtml#P7000497027000000000000000040F58" class="pcalibre1 calibre1 pcalibre2">r.llx</code> selects field <code id="P7000497027000000000000000040F59" data-uri="chapter03.xhtml#P7000497027000000000000000040F59" class="pcalibre1 calibre1 pcalibre2">llx</code> of structure <code id="P7000497027000000000000000040F5A" data-uri="chapter03.xhtml#P7000497027000000000000000040F5A" class="pcalibre1 calibre1 pcalibre2">r</code>.</p>
<p id="P7000497027000000000000000040F5B" data-uri="chapter03.xhtml#P7000497027000000000000000040F5B" class="pcalibre1 pcalibre2 pcalibre40">Alternatively, we can both declare the variable and initialize its fields with a single statement:</p>
<pre id="P7000497027000000000000000040F5C" data-uri="chapter03.xhtml#P7000497027000000000000000040F5C" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F5D" data-uri="chapter03.xhtml#P7000497027000000000000000040F5D" class="calibre3 pcalibre1 pcalibre2">
struct rect r = { 0, 0, 0xFF00FF, 10, 20 };
</code></pre>
<p id="P7000497027000000000000000040F5E" data-uri="chapter03.xhtml#P7000497027000000000000000040F5E" class="pcalibre1 pcalibre2 pcalibre40">It is common to pass pointers to structures from one place to another rather than copying them. For example, the following function computes the area of a rectangle, where a pointer to the rectangle <code id="P7000497027000000000000000040F5F" data-uri="chapter03.xhtml#P7000497027000000000000000040F5F" class="pcalibre1 calibre1 pcalibre2">struct</code> is passed to the function:</p>
<pre id="P7000497027000000000000000040F60" data-uri="chapter03.xhtml#P7000497027000000000000000040F60" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F61" data-uri="chapter03.xhtml#P7000497027000000000000000040F61" class="calibre3 pcalibre1 pcalibre2">
long area(struct rect *rp) {
	return (*rp).width * (*rp).height;
}
</code></pre>
<p id="P7000497027000000000000000040F62" data-uri="chapter03.xhtml#P7000497027000000000000000040F62" class="pcalibre1 pcalibre2 pcalibre40">The expression <code id="P7000497027000000000000000040F63" data-uri="chapter03.xhtml#P7000497027000000000000000040F63" class="pcalibre1 calibre1 pcalibre2">(*rp)</code>.width dereferences the pointer and selects the width field of the resulting structure. Parentheses are required, because the compiler would interpret the expression <code id="P7000497027000000000000000040F64" data-uri="chapter03.xhtml#P7000497027000000000000000040F64" class="pcalibre1 calibre1 pcalibre2">*rp.width</code> as <code id="P7000497027000000000000000040F65" data-uri="chapter03.xhtml#P7000497027000000000000000040F65" class="pcalibre1 calibre1 pcalibre2">*(rp.width)</code>, which is not valid. This combination of dereferencing and field selection is so common that C provides an alternative notation using -&gt;. That is, <code id="P7000497027000000000000000040F66" data-uri="chapter03.xhtml#P7000497027000000000000000040F66" class="pcalibre1 calibre1 pcalibre2">rp-&gt;width</code> is equivalent to the expression <code id="P7000497027000000000000000040F67" data-uri="chapter03.xhtml#P7000497027000000000000000040F67" class="pcalibre1 calibre1 pcalibre2">(*rp).width.</code> For example, we can write a function that rotates a rectangle counterclockwise by 90 degrees as</p>
<pre id="P7000497027000000000000000040F68" data-uri="chapter03.xhtml#P7000497027000000000000000040F68" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F69" data-uri="chapter03.xhtml#P7000497027000000000000000040F69" class="calibre3 pcalibre1 pcalibre2">
void rotate_left(struct rect *rp) {
	/* Exchange width and height */
	long t = rp-&gt;height;
	rp-&gt;height = rp-&gt;width;
	rp-&gt;width = t;
	/* Shift to new lower-left corner */
	rp-&gt;llx -= t;
}
</code></pre>
<p id="P7000497027000000000000000040F6A" data-uri="chapter03.xhtml#P7000497027000000000000000040F6A" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002D11" title="267" data-uri="chapter03.xhtml#P7000497027000000000000000002D11" epub:type="pagebreak"></span>The objects of C++ and Java are more elaborate than structures in C, in that they also associate a set of <i class="pcalibre17 pcalibre2 pcalibre1">methods</i> with an object that can be invoked to perform computation. In C, we would simply write these as ordinary functions, such as the functions <code id="P7000497027000000000000000040F6B" data-uri="chapter03.xhtml#P7000497027000000000000000040F6B" class="pcalibre1 calibre1 pcalibre2">area</code> and <code id="P7000497027000000000000000040F6C" data-uri="chapter03.xhtml#P7000497027000000000000000040F6C" class="pcalibre1 calibre1 pcalibre2">rotate_left</code> shown previously.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040F6D" data-uri="chapter03.xhtml#P7000497027000000000000000040F6D">of type <code id="P7000497027000000000000000040F6E" data-uri="chapter03.xhtml#P7000497027000000000000000040F6E" class="pcalibre1 calibre1 pcalibre2">struct rec *</code> is in register <code id="P7000497027000000000000000040F6F" data-uri="chapter03.xhtml#P7000497027000000000000000040F6F" class="pcalibre1 calibre1 pcalibre2">%rdi</code>. Then the following code copies element <code id="P7000497027000000000000000040F70" data-uri="chapter03.xhtml#P7000497027000000000000000040F70" class="pcalibre1 calibre1 pcalibre2">r-&gt;i</code> to element <code id="P7000497027000000000000000040F71" data-uri="chapter03.xhtml#P7000497027000000000000000040F71" class="pcalibre1 calibre1 pcalibre2">r-&gt;j</code>:</p>
<pre id="P7000497027000000000000000040F72" data-uri="chapter03.xhtml#P7000497027000000000000000040F72" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F73" data-uri="chapter03.xhtml#P7000497027000000000000000040F73" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">Registers: r in %rdi</i>
1	movl	(%rdi), %eax		<i class="pcalibre17 pcalibre2 pcalibre1">Get r-&gt;i</i>
2	movl	%eax, 4(%rdi)		<i class="pcalibre17 pcalibre2 pcalibre1">Store in r-&gt;j</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040F74" data-uri="chapter03.xhtml#P7000497027000000000000000040F74">Since the offset of field <code id="P7000497027000000000000000040F75" data-uri="chapter03.xhtml#P7000497027000000000000000040F75" class="pcalibre1 calibre1 pcalibre2">i</code> is 0, the address of this field is simply the value of <code id="P7000497027000000000000000040F76" data-uri="chapter03.xhtml#P7000497027000000000000000040F76" class="pcalibre1 calibre1 pcalibre2">r</code>. To store into field <code id="P7000497027000000000000000040F77" data-uri="chapter03.xhtml#P7000497027000000000000000040F77" class="pcalibre1 calibre1 pcalibre2">j</code>, the code adds offset 4 to the address of <code id="P7000497027000000000000000040F78" data-uri="chapter03.xhtml#P7000497027000000000000000040F78" class="pcalibre1 calibre1 pcalibre2">r</code>.</p>
<p id="P7000497027000000000000000040F79" data-uri="chapter03.xhtml#P7000497027000000000000000040F79" class="pcalibre8 pcalibre1 pcalibre2">To generate a pointer to an object within a structure, we can simply add the field's offset to the structure address. For example, we can generate the pointer <code id="P7000497027000000000000000040F7A" data-uri="chapter03.xhtml#P7000497027000000000000000040F7A" class="pcalibre1 calibre1 pcalibre2">&amp;(r-&gt;a[1])</code> by adding offset 8 + 4 Â· 1 = 12. For pointer <code id="P7000497027000000000000000040F7B" data-uri="chapter03.xhtml#P7000497027000000000000000040F7B" class="pcalibre1 calibre1 pcalibre2">r</code> in register <code id="P7000497027000000000000000040F7C" data-uri="chapter03.xhtml#P7000497027000000000000000040F7C" class="pcalibre1 calibre1 pcalibre2">%rdi</code> and long integer variable <code id="P7000497027000000000000000040F7D" data-uri="chapter03.xhtml#P7000497027000000000000000040F7D" class="pcalibre1 calibre1 pcalibre2">i</code> in register <code id="P7000497027000000000000000040F7E" data-uri="chapter03.xhtml#P7000497027000000000000000040F7E" class="pcalibre1 calibre1 pcalibre2">%rsi</code>, we can generate the pointer value <code id="P7000497027000000000000000040F7F" data-uri="chapter03.xhtml#P7000497027000000000000000040F7F" class="pcalibre1 calibre1 pcalibre2">&amp;(r-&gt;a[i])</code> with the single instruction</p>
<pre id="P7000497027000000000000000040F80" data-uri="chapter03.xhtml#P7000497027000000000000000040F80" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F81" data-uri="chapter03.xhtml#P7000497027000000000000000040F81" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">Registers: r in %rdi, i %rsi</i>
1	leaq	 8(%rdi,%rsi,4), %rax	<i class="pcalibre17 pcalibre2 pcalibre1">Set %rax to &amp;r-&gt;a[i]</i>
</code></pre>
<p id="P7000497027000000000000000040F82" data-uri="chapter03.xhtml#P7000497027000000000000000040F82" class="pcalibre8 pcalibre1 pcalibre2">As a final example, the following code implements the statement</p>
<pre id="P7000497027000000000000000040F83" data-uri="chapter03.xhtml#P7000497027000000000000000040F83" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F84" data-uri="chapter03.xhtml#P7000497027000000000000000040F84" class="calibre3 pcalibre1 pcalibre2">
r-&gt;p = &amp;r-&gt;a[r-&gt;i + r-&gt;j];
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040F85" data-uri="chapter03.xhtml#P7000497027000000000000000040F85">starting with <code id="P7000497027000000000000000040F86" data-uri="chapter03.xhtml#P7000497027000000000000000040F86" class="pcalibre1 calibre1 pcalibre2">r</code> in register <code id="P7000497027000000000000000040F87" data-uri="chapter03.xhtml#P7000497027000000000000000040F87" class="pcalibre1 calibre1 pcalibre2">%rdi:</code></p>
<pre id="P7000497027000000000000000040F88" data-uri="chapter03.xhtml#P7000497027000000000000000040F88" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F89" data-uri="chapter03.xhtml#P7000497027000000000000000040F89" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">Registers: r in %rdi</i>
1	movl	 4(%rdi), %eax		<i class="pcalibre17 pcalibre2 pcalibre1">Get r-&gt;j</i>
2	addl	 (%rdi), %eax		<i class="pcalibre17 pcalibre2 pcalibre1">Add r-&gt;i</i>
3	cltq				<i class="pcalibre17 pcalibre2 pcalibre1">Extend to 8 bytes</i>
4	leaq	 8(%rdi,%rax,4), %rax	<i class="pcalibre17 pcalibre2 pcalibre1">Compute &amp;r-&gt;a[r-&gt;i + r-&gt;j]</i>
5	movq	%rax, 16(%rdi)		<i class="pcalibre17 pcalibre2 pcalibre1">Store in r-&gt;p</i>
</code></pre>
<p id="P7000497027000000000000000040F8A" data-uri="chapter03.xhtml#P7000497027000000000000000040F8A" class="pcalibre8 pcalibre1 pcalibre2">As these examples show, the selection of the different fields of a structure is handled completely at compile time. The machine code contains no information about the field declarations or the names of the fields.</p>
<section id="P7000497027000000000000000002D32" data-uri="chapter03.xhtml#P7000497027000000000000000002D32" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000040F8B" data-uri="chapter03.xhtml#P7000497027000000000000000040F8B" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002D34" title="268" data-uri="chapter03.xhtml#P7000497027000000000000000002D34" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.41 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003838">343</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000040F8C" data-uri="chapter03.xhtml#P7000497027000000000000000040F8C">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000040F8D" data-uri="chapter03.xhtml#P7000497027000000000000000040F8D">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000040F8E" data-uri="chapter03.xhtml#P7000497027000000000000000040F8E"><p id="P7000497027000000000000000040F8F" data-uri="chapter03.xhtml#P7000497027000000000000000040F8F" class="pcalibre1 pcalibre2 pcalibre10">Consider the following structure declaration:</p>
<pre id="P7000497027000000000000000040F90" data-uri="chapter03.xhtml#P7000497027000000000000000040F90" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F91" data-uri="chapter03.xhtml#P7000497027000000000000000040F91" class="calibre3 pcalibre1 pcalibre2">
struct prob {
	int *p;
	struct {
	  int x;
	  int y;
	} s;
	struct prob *next;
};
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000040F92" data-uri="chapter03.xhtml#P7000497027000000000000000040F92">This declaration illustrates that one structure can be embedded within another, just as arrays can be embedded within structures and arrays can be embedded within arrays.</p>
<p id="P7000497027000000000000000040F93" data-uri="chapter03.xhtml#P7000497027000000000000000040F93" class="pcalibre1 pcalibre2 pcalibre10">The following procedure (with some expressions omitted) operates on this structure:</p>
<pre id="P7000497027000000000000000040F94" data-uri="chapter03.xhtml#P7000497027000000000000000040F94" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F95" data-uri="chapter03.xhtml#P7000497027000000000000000040F95" class="calibre3 pcalibre1 pcalibre2">
void sp_init(struct prob *sp) {
	sp-&gt;s.x =	__________;
	sp-&gt;p =		__________;
	sp-&gt;next=	__________;
}
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000040F96" data-uri="chapter03.xhtml#P7000497027000000000000000040F96">
<li id="P7000497027000000000000000040F97" data-uri="chapter03.xhtml#P7000497027000000000000000040F97" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040F98" data-uri="chapter03.xhtml#P7000497027000000000000000040F98" class="pcalibre1 pcalibre2 pcalibre10">What are the offsets (in bytes) of the following fields?</p>
<pre id="P7000497027000000000000000040F99" data-uri="chapter03.xhtml#P7000497027000000000000000040F99" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040F9A" data-uri="chapter03.xhtml#P7000497027000000000000000040F9A" class="calibre3 pcalibre1 pcalibre2">
p:	__________
s.x:	 __________
s.y:	__________
next:	__________
</code></pre>
</li>
<li id="P7000497027000000000000000040F9B" data-uri="chapter03.xhtml#P7000497027000000000000000040F9B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040F9C" data-uri="chapter03.xhtml#P7000497027000000000000000040F9C" class="pcalibre1 pcalibre2 pcalibre10">How many total bytes does the structure require?</p></li>
<li id="P7000497027000000000000000040F9D" data-uri="chapter03.xhtml#P7000497027000000000000000040F9D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040F9E" data-uri="chapter03.xhtml#P7000497027000000000000000040F9E" class="pcalibre1 pcalibre2 pcalibre10">The compiler generates the following assembly code for <code id="P7000497027000000000000000040F9F" data-uri="chapter03.xhtml#P7000497027000000000000000040F9F" class="pcalibre1 calibre1 pcalibre2">sp_init:</code></p>
<pre id="P7000497027000000000000000040FA0" data-uri="chapter03.xhtml#P7000497027000000000000000040FA0" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040FA1" data-uri="chapter03.xhtml#P7000497027000000000000000040FA1" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">void sp_init(struct prob *sp)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">sp in %rdi</i>
1	sp_init:
2	movl	12(%rdi), %eax
3	movl	%eax, 8(%rdi)
4	leaq	8(%rdi), %rax
5	movq	%rax, (%rdi)
6	movq	%rdi, 16(%rdi)
7	ret
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000040FA2" data-uri="chapter03.xhtml#P7000497027000000000000000040FA2">On the basis of this information, fill in the missing expressions in the code for <code id="P7000497027000000000000000040FA3" data-uri="chapter03.xhtml#P7000497027000000000000000040FA3" class="pcalibre1 calibre1 pcalibre2">sp_init.</code></p>
</li></ol></div>
</li></ol>
</section>
<section id="P7000497027000000000000000002D4D" data-uri="chapter03.xhtml#P7000497027000000000000000002D4D" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000040FA4" data-uri="chapter03.xhtml#P7000497027000000000000000040FA4" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002D4F" title="269" data-uri="chapter03.xhtml#P7000497027000000000000000002D4F" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.42 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003838">343</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000040FA5" data-uri="chapter03.xhtml#P7000497027000000000000000040FA5">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000040FA6" data-uri="chapter03.xhtml#P7000497027000000000000000040FA6">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000040FA7" data-uri="chapter03.xhtml#P7000497027000000000000000040FA7"><p id="P7000497027000000000000000040FA8" data-uri="chapter03.xhtml#P7000497027000000000000000040FA8" class="pcalibre1 pcalibre2 pcalibre10">The following code shows the declaration of a structure of type <code id="P7000497027000000000000000040FA9" data-uri="chapter03.xhtml#P7000497027000000000000000040FA9" class="pcalibre1 calibre1 pcalibre2">ELE</code> and the prototype for a function <code id="P7000497027000000000000000040FAA" data-uri="chapter03.xhtml#P7000497027000000000000000040FAA" class="pcalibre1 calibre1 pcalibre2">fun</code>:</p>
<pre id="P7000497027000000000000000040FAB" data-uri="chapter03.xhtml#P7000497027000000000000000040FAB" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040FAC" data-uri="chapter03.xhtml#P7000497027000000000000000040FAC" class="calibre3 pcalibre1 pcalibre2">
struct ELE {
	long v;
	struct ELE *p;
};

long fun(struct ELE *ptr);
</code></pre>
<p id="P7000497027000000000000000040FAD" data-uri="chapter03.xhtml#P7000497027000000000000000040FAD" class="pcalibre1 pcalibre2 pcalibre10">When the code for <code id="P7000497027000000000000000040FAE" data-uri="chapter03.xhtml#P7000497027000000000000000040FAE" class="pcalibre1 calibre1 pcalibre2">fun</code> is compiled, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the following assembly code:</p>
<pre id="P7000497027000000000000000040FAF" data-uri="chapter03.xhtml#P7000497027000000000000000040FAF" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040FB0" data-uri="chapter03.xhtml#P7000497027000000000000000040FB0" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long fun(struct ELE *ptr)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">ptr in %rdi</i>
1	fun:
2	movl	$0, %eax
3	jmp	.L2
4	L3:
5	addq	(%rdi), %rax
6	movq	8(%rdi), %rdi
7	.L2:
8	testq	%rdi, %rdi
9	jne	.L3
10	rep; ret
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000040FB1" data-uri="chapter03.xhtml#P7000497027000000000000000040FB1">
<li id="P7000497027000000000000000040FB2" data-uri="chapter03.xhtml#P7000497027000000000000000040FB2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040FB3" data-uri="chapter03.xhtml#P7000497027000000000000000040FB3" class="pcalibre1 pcalibre2 pcalibre10">Use your reverse engineering skills to write C code for <code id="P7000497027000000000000000040FB4" data-uri="chapter03.xhtml#P7000497027000000000000000040FB4" class="pcalibre1 calibre1 pcalibre2">fun</code>.</p></li>
<li id="P7000497027000000000000000040FB5" data-uri="chapter03.xhtml#P7000497027000000000000000040FB5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040FB6" data-uri="chapter03.xhtml#P7000497027000000000000000040FB6" class="pcalibre1 pcalibre2 pcalibre10">Describe the data structure that this structure implements and the operation performed by <code id="P7000497027000000000000000040FB7" data-uri="chapter03.xhtml#P7000497027000000000000000040FB7" class="pcalibre1 calibre1 pcalibre2">fun</code>.</p></li>
</ol>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000002D63" data-uri="chapter03.xhtml#P7000497027000000000000000002D63" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000040FB8" data-uri="chapter03.xhtml#P7000497027000000000000000040FB8" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.9.2 </span>Unions</h1></header>
<p id="P7000497027000000000000000040FB9" data-uri="chapter03.xhtml#P7000497027000000000000000040FB9" class="pcalibre8 pcalibre1 pcalibre2">Unions provide a way to circumvent the type system of C, allowing a single object to be referenced according to multiple types. The syntax of a union declaration is identical to that for structures, but its semantics are very different. Rather than having the different fields reference different blocks of memory, they all reference the same block.</p>
<p id="P7000497027000000000000000040FBA" data-uri="chapter03.xhtml#P7000497027000000000000000040FBA" class="pcalibre8 pcalibre1 pcalibre2">Consider the following declarations:</p>
<pre id="P7000497027000000000000000040FBB" data-uri="chapter03.xhtml#P7000497027000000000000000040FBB" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040FBC" data-uri="chapter03.xhtml#P7000497027000000000000000040FBC" class="calibre3 pcalibre1 pcalibre2">
struct S3 {
	char c;
	int i[2];
	double v;
};
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002D69" title="270" data-uri="chapter03.xhtml#P7000497027000000000000000002D69" epub:type="pagebreak"></span>union U3 {
	char c;
	int i[2];
	double v;
};
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040FBD" data-uri="chapter03.xhtml#P7000497027000000000000000040FBD">When compiled on an x86-64 Linux machine, the offsets of the fields, as well as the total size of data types <code id="P7000497027000000000000000040FBE" data-uri="chapter03.xhtml#P7000497027000000000000000040FBE" class="pcalibre1 calibre1 pcalibre2">S3</code> and <code id="P7000497027000000000000000040FBF" data-uri="chapter03.xhtml#P7000497027000000000000000040FBF" class="pcalibre1 calibre1 pcalibre2">U3</code>, are as shown in the following table:</p>
<table id="P7000497027000000000000000040FC0" data-uri="chapter03.xhtml#P7000497027000000000000000040FC0" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000040FC1" data-uri="chapter03.xhtml#P7000497027000000000000000040FC1" class="pcalibre1 pcalibre2 calibre5">Type</th>
<th id="P7000497027000000000000000040FC2" data-uri="chapter03.xhtml#P7000497027000000000000000040FC2" class="pcalibre1 pcalibre2 calibre5"><code id="P7000497027000000000000000040FC3" data-uri="chapter03.xhtml#P7000497027000000000000000040FC3" class="calibre3 pcalibre1 pcalibre2">c</code></th>
<th id="P7000497027000000000000000040FC4" data-uri="chapter03.xhtml#P7000497027000000000000000040FC4" class="pcalibre1 pcalibre2 calibre5"><code id="P7000497027000000000000000040FC5" data-uri="chapter03.xhtml#P7000497027000000000000000040FC5" class="calibre3 pcalibre1 pcalibre2">i</code></th>
<th id="P7000497027000000000000000040FC6" data-uri="chapter03.xhtml#P7000497027000000000000000040FC6" class="pcalibre1 pcalibre2 calibre5"><code id="P7000497027000000000000000040FC7" data-uri="chapter03.xhtml#P7000497027000000000000000040FC7" class="calibre3 pcalibre1 pcalibre2">v</code></th>
<th id="P7000497027000000000000000040FC8" data-uri="chapter03.xhtml#P7000497027000000000000000040FC8" class="pcalibre1 pcalibre2 calibre5">Size</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000040FC9" data-uri="chapter03.xhtml#P7000497027000000000000000040FC9" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000040FCA" data-uri="chapter03.xhtml#P7000497027000000000000000040FCA" class="calibre3 pcalibre1 pcalibre2">S3</code></td>
<td id="P7000497027000000000000000040FCB" data-uri="chapter03.xhtml#P7000497027000000000000000040FCB" class="pcalibre1 pcalibre2 calibre7">0</td>
<td id="P7000497027000000000000000040FCC" data-uri="chapter03.xhtml#P7000497027000000000000000040FCC" class="pcalibre1 pcalibre2 calibre7">4</td>
<td id="P7000497027000000000000000040FCD" data-uri="chapter03.xhtml#P7000497027000000000000000040FCD" class="pcalibre1 pcalibre2 calibre7">16</td>
<td id="P7000497027000000000000000040FCE" data-uri="chapter03.xhtml#P7000497027000000000000000040FCE" class="pcalibre1 pcalibre2 calibre7">24</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000040FCF" data-uri="chapter03.xhtml#P7000497027000000000000000040FCF" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000040FD0" data-uri="chapter03.xhtml#P7000497027000000000000000040FD0" class="calibre3 pcalibre1 pcalibre2">U3</code></td>
<td id="P7000497027000000000000000040FD1" data-uri="chapter03.xhtml#P7000497027000000000000000040FD1" class="pcalibre1 pcalibre2 calibre7">0</td>
<td id="P7000497027000000000000000040FD2" data-uri="chapter03.xhtml#P7000497027000000000000000040FD2" class="pcalibre1 pcalibre2 calibre7">0</td>
<td id="P7000497027000000000000000040FD3" data-uri="chapter03.xhtml#P7000497027000000000000000040FD3" class="pcalibre1 pcalibre2 calibre7">0</td>
<td id="P7000497027000000000000000040FD4" data-uri="chapter03.xhtml#P7000497027000000000000000040FD4" class="pcalibre1 pcalibre2 calibre7">8</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040FD5" data-uri="chapter03.xhtml#P7000497027000000000000000040FD5">(We will see shortly why <code id="P7000497027000000000000000040FD6" data-uri="chapter03.xhtml#P7000497027000000000000000040FD6" class="pcalibre1 calibre1 pcalibre2">i</code> has offset 4 in <code id="P7000497027000000000000000040FD7" data-uri="chapter03.xhtml#P7000497027000000000000000040FD7" class="pcalibre1 calibre1 pcalibre2">S3</code> rather than 1, and why <code id="P7000497027000000000000000040FD8" data-uri="chapter03.xhtml#P7000497027000000000000000040FD8" class="pcalibre1 calibre1 pcalibre2">v</code> has offset 16, rather than 9 or 12.) For pointer <code id="P7000497027000000000000000040FD9" data-uri="chapter03.xhtml#P7000497027000000000000000040FD9" class="pcalibre1 calibre1 pcalibre2">p</code> of type union <code id="P7000497027000000000000000040FDA" data-uri="chapter03.xhtml#P7000497027000000000000000040FDA" class="pcalibre1 calibre1 pcalibre2">U3</code> *, references <code id="P7000497027000000000000000040FDB" data-uri="chapter03.xhtml#P7000497027000000000000000040FDB" class="pcalibre1 calibre1 pcalibre2">p-&gt;c, p-&gt;i[0]</code>, and <code id="P7000497027000000000000000040FDC" data-uri="chapter03.xhtml#P7000497027000000000000000040FDC" class="pcalibre1 calibre1 pcalibre2">p-&gt;v</code> would all reference the beginning of the data structure. Observe also that the overall size of a union equals the maximum size of any of its fields.</p>
<p id="P7000497027000000000000000040FDD" data-uri="chapter03.xhtml#P7000497027000000000000000040FDD" class="pcalibre8 pcalibre1 pcalibre2">Unions can be useful in several contexts. However, they can also lead to nasty bugs, since they bypass the safety provided by the C type system. One application is when we know in advance that the use of two different fields in a data structure will be mutually exclusive. Then, declaring these two fields as part of a union rather than a structure will reduce the total space allocated.</p>
<p id="P7000497027000000000000000040FDE" data-uri="chapter03.xhtml#P7000497027000000000000000040FDE" class="pcalibre8 pcalibre1 pcalibre2">For example, suppose we want to implement a binary tree data structure where each leaf node has two <code id="P7000497027000000000000000040FDF" data-uri="chapter03.xhtml#P7000497027000000000000000040FDF" class="pcalibre1 calibre1 pcalibre2">double</code> data values and each internal node has pointers to two children but no data. If we declare this as</p>
<pre id="P7000497027000000000000000040FE0" data-uri="chapter03.xhtml#P7000497027000000000000000040FE0" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040FE1" data-uri="chapter03.xhtml#P7000497027000000000000000040FE1" class="calibre3 pcalibre1 pcalibre2">
struct node_s {
	struct node_s *left;
	struct node_s *right;
	double data[2];
};
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040FE2" data-uri="chapter03.xhtml#P7000497027000000000000000040FE2">then every node requires 32 bytes, with half the bytes wasted for each type of node. On the other hand, if we declare a node as</p>
<pre id="P7000497027000000000000000040FE3" data-uri="chapter03.xhtml#P7000497027000000000000000040FE3" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040FE4" data-uri="chapter03.xhtml#P7000497027000000000000000040FE4" class="calibre3 pcalibre1 pcalibre2">
union node_u {
	struct {
	  union node_u *left;
	  union node_u *right;
	} internal;
	double data[2];
};
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040FE5" data-uri="chapter03.xhtml#P7000497027000000000000000040FE5">then every node will require just 16 bytes. If <code id="P7000497027000000000000000040FE6" data-uri="chapter03.xhtml#P7000497027000000000000000040FE6" class="pcalibre1 calibre1 pcalibre2">n</code> is a pointer to a node of type union <code id="P7000497027000000000000000040FE7" data-uri="chapter03.xhtml#P7000497027000000000000000040FE7" class="pcalibre1 calibre1 pcalibre2">node_u *</code>, we would reference the data of a leaf node as <code id="P7000497027000000000000000040FE8" data-uri="chapter03.xhtml#P7000497027000000000000000040FE8" class="pcalibre1 calibre1 pcalibre2">n-&gt;data[0]</code> and <code id="P7000497027000000000000000040FE9" data-uri="chapter03.xhtml#P7000497027000000000000000040FE9" class="pcalibre1 calibre1 pcalibre2">n-&gt;data[1]</code>, and the children of an internal node as <code id="P7000497027000000000000000040FEA" data-uri="chapter03.xhtml#P7000497027000000000000000040FEA" class="pcalibre1 calibre1 pcalibre2">n-&gt;internal.left</code> and <code id="P7000497027000000000000000040FEB" data-uri="chapter03.xhtml#P7000497027000000000000000040FEB" class="pcalibre1 calibre1 pcalibre2">n-&gt;internal.right.</code></p>
<p id="P7000497027000000000000000040FEC" data-uri="chapter03.xhtml#P7000497027000000000000000040FEC" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002D9A" title="271" data-uri="chapter03.xhtml#P7000497027000000000000000002D9A" epub:type="pagebreak"></span>With this encoding, however, there is no way to determine whether a given node is a leaf or an internal node. A common method is to introduce an enumerated type defining the different possible choices for the union, and then create a structure containing a tag field and the union:</p>
<pre id="P7000497027000000000000000040FED" data-uri="chapter03.xhtml#P7000497027000000000000000040FED" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040FEE" data-uri="chapter03.xhtml#P7000497027000000000000000040FEE" class="calibre3 pcalibre1 pcalibre2">
typedef enum { N_LEAF, N_INTERNAL } nodetype_t;

struct node_t {
	nodetype_t type;
	union {
	  struct {
	  	struct node_t *left;
	  	struct node_t *right;
	  } internal;
	  double data[2];
	} info;
};
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040FEF" data-uri="chapter03.xhtml#P7000497027000000000000000040FEF">This structure requires a total of 24 bytes: 4 for <code id="P7000497027000000000000000040FF0" data-uri="chapter03.xhtml#P7000497027000000000000000040FF0" class="pcalibre1 calibre1 pcalibre2">type</code>, and either 8 each for <code id="P7000497027000000000000000040FF1" data-uri="chapter03.xhtml#P7000497027000000000000000040FF1" class="pcalibre1 calibre1 pcalibre2">info.internal.left</code> and <code id="P7000497027000000000000000040FF2" data-uri="chapter03.xhtml#P7000497027000000000000000040FF2" class="pcalibre1 calibre1 pcalibre2">info.internal.right</code> or 16 for <code id="P7000497027000000000000000040FF3" data-uri="chapter03.xhtml#P7000497027000000000000000040FF3" class="pcalibre1 calibre1 pcalibre2">info.data.</code> As we will discuss shortly, an additional 4 bytes of padding is required between the field for type and the union elements, bringing the total structure size to 4 + 4 + 16 = 24. In this case, the savings gain of using a union is small relative to the awkwardness of the resulting code. For data structures with more fields, the savings can be more compelling.</p>
<p id="P7000497027000000000000000040FF4" data-uri="chapter03.xhtml#P7000497027000000000000000040FF4" class="pcalibre8 pcalibre1 pcalibre2">Unions can also be used to access the bit patterns of different data types. For example, suppose we use a simple cast to convert a value d of type <code id="P7000497027000000000000000040FF5" data-uri="chapter03.xhtml#P7000497027000000000000000040FF5" class="pcalibre1 calibre1 pcalibre2">double</code> to a value <code id="P7000497027000000000000000040FF6" data-uri="chapter03.xhtml#P7000497027000000000000000040FF6" class="pcalibre1 calibre1 pcalibre2">u</code> of type unsigned <code id="P7000497027000000000000000040FF7" data-uri="chapter03.xhtml#P7000497027000000000000000040FF7" class="pcalibre1 calibre1 pcalibre2">long</code>:</p>
<pre id="P7000497027000000000000000040FF8" data-uri="chapter03.xhtml#P7000497027000000000000000040FF8" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040FF9" data-uri="chapter03.xhtml#P7000497027000000000000000040FF9" class="calibre3 pcalibre1 pcalibre2">
unsigned long u = (unsigned long) d;
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040FFA" data-uri="chapter03.xhtml#P7000497027000000000000000040FFA">Value <code id="P7000497027000000000000000040FFB" data-uri="chapter03.xhtml#P7000497027000000000000000040FFB" class="pcalibre1 calibre1 pcalibre2">u</code> will be an integer representation of <code id="P7000497027000000000000000040FFC" data-uri="chapter03.xhtml#P7000497027000000000000000040FFC" class="pcalibre1 calibre1 pcalibre2">d</code>. Except for the case where <code id="P7000497027000000000000000040FFD" data-uri="chapter03.xhtml#P7000497027000000000000000040FFD" class="pcalibre1 calibre1 pcalibre2">d</code> is 0.0, the bit representation of <code id="P7000497027000000000000000040FFE" data-uri="chapter03.xhtml#P7000497027000000000000000040FFE" class="pcalibre1 calibre1 pcalibre2">u</code> will be very different from that of <code id="P7000497027000000000000000040FFF" data-uri="chapter03.xhtml#P7000497027000000000000000040FFF" class="pcalibre1 calibre1 pcalibre2">d</code>. Now consider the following code to generate a value of type <code id="P7000497027000000000000000041000" data-uri="chapter03.xhtml#P7000497027000000000000000041000" class="pcalibre1 calibre1 pcalibre2">unsigned</code> long from a <code id="P7000497027000000000000000041001" data-uri="chapter03.xhtml#P7000497027000000000000000041001" class="pcalibre1 calibre1 pcalibre2">double</code>:</p>
<pre id="P7000497027000000000000000041002" data-uri="chapter03.xhtml#P7000497027000000000000000041002" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041003" data-uri="chapter03.xhtml#P7000497027000000000000000041003" class="calibre3 pcalibre1 pcalibre2">
unsigned long double2bits(double d) {
	union {
	  double d;
	  unsigned long u;
	} temp;
	temp.d = d;
	return temp.u;
};
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041004" data-uri="chapter03.xhtml#P7000497027000000000000000041004">In this code, we store the argument in the union using one data type and access it using another. The result will be that <code id="P7000497027000000000000000041005" data-uri="chapter03.xhtml#P7000497027000000000000000041005" class="pcalibre1 calibre1 pcalibre2">u</code> will have the same bit representation as <code id="P7000497027000000000000000041006" data-uri="chapter03.xhtml#P7000497027000000000000000041006" class="pcalibre1 calibre1 pcalibre2">d</code>, including fields for the sign bit, the exponent, and the significand, as described in <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002DB5" title="272" data-uri="chapter03.xhtml#P7000497027000000000000000002DB5" epub:type="pagebreak"></span><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000003080.xhtml#P7000497027000000000000000003080"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.11</span></a>. The numeric value of <code id="P7000497027000000000000000041007" data-uri="chapter03.xhtml#P7000497027000000000000000041007" class="pcalibre1 calibre1 pcalibre2">u</code> will bear no relation to that of <code id="P7000497027000000000000000041008" data-uri="chapter03.xhtml#P7000497027000000000000000041008" class="pcalibre1 calibre1 pcalibre2">d</code>, except for the case when <code id="P7000497027000000000000000041009" data-uri="chapter03.xhtml#P7000497027000000000000000041009" class="pcalibre1 calibre1 pcalibre2">d</code> is 0.0.</p>
<p id="P700049702700000000000000004100A" data-uri="chapter03.xhtml#P700049702700000000000000004100A" class="pcalibre8 pcalibre1 pcalibre2">When using unions to combine data types of different sizes, byte-ordering issues can become important. For example, suppose we write a procedure that will create an 8-byte <code id="P700049702700000000000000004100B" data-uri="chapter03.xhtml#P700049702700000000000000004100B" class="pcalibre1 calibre1 pcalibre2">double</code> using the bit patterns given by two 4-byte <code id="P700049702700000000000000004100C" data-uri="chapter03.xhtml#P700049702700000000000000004100C" class="pcalibre1 calibre1 pcalibre2">unsigned</code> values:</p>
<pre id="P700049702700000000000000004100D" data-uri="chapter03.xhtml#P700049702700000000000000004100D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004100E" data-uri="chapter03.xhtml#P700049702700000000000000004100E" class="calibre3 pcalibre1 pcalibre2">
double uu2double(unsigned word0, unsigned word1)
{
	union {
	  double d;
	  unsigned u[2];
	} temp;
	temp.u[0] = word0;
	temp.u[1] = word1;
	return temp.d;
}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004100F" data-uri="chapter03.xhtml#P700049702700000000000000004100F">On a little-endian machine, such as an x86-64 processor, argument <code id="P7000497027000000000000000041010" data-uri="chapter03.xhtml#P7000497027000000000000000041010" class="pcalibre1 calibre1 pcalibre2">word0</code> will become the low-order 4 bytes of <code id="P7000497027000000000000000041011" data-uri="chapter03.xhtml#P7000497027000000000000000041011" class="pcalibre1 calibre1 pcalibre2">d</code>, while <code id="P7000497027000000000000000041012" data-uri="chapter03.xhtml#P7000497027000000000000000041012" class="pcalibre1 calibre1 pcalibre2">word1</code> will become the high-order 4 bytes. On a big-endian machine, the role of the two arguments will be reversed.</p>
<section id="P7000497027000000000000000002DC2" data-uri="chapter03.xhtml#P7000497027000000000000000002DC2" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041013" data-uri="chapter03.xhtml#P7000497027000000000000000041013" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.43 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003855">344</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041014" data-uri="chapter03.xhtml#P7000497027000000000000000041014">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041015" data-uri="chapter03.xhtml#P7000497027000000000000000041015">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041016" data-uri="chapter03.xhtml#P7000497027000000000000000041016"><p id="P7000497027000000000000000041017" data-uri="chapter03.xhtml#P7000497027000000000000000041017" class="pcalibre1 pcalibre2 pcalibre10">Suppose you are given the job of checking that a C compiler generates the proper code for structure and union access. You write the following structure declaration:</p>
<pre id="P7000497027000000000000000041018" data-uri="chapter03.xhtml#P7000497027000000000000000041018" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041019" data-uri="chapter03.xhtml#P7000497027000000000000000041019" class="calibre3 pcalibre1 pcalibre2">
typedef union {
	struct {
	  long u;
	  short v;
	  char w;
	} t1;
	struct {
	  int a[2];
	  char *p;
	} t2;
} u_type;
</code></pre>
<p id="P700049702700000000000000004101A" data-uri="chapter03.xhtml#P700049702700000000000000004101A" class="pcalibre1 pcalibre2 pcalibre10">You write a series of functions of the form</p>
<pre id="P700049702700000000000000004101B" data-uri="chapter03.xhtml#P700049702700000000000000004101B" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004101C" data-uri="chapter03.xhtml#P700049702700000000000000004101C" class="calibre3 pcalibre1 pcalibre2">
void get(u_type *up, <i class="pcalibre17 pcalibre2 pcalibre1">type</i> *dest) {
	*dest = <i class="pcalibre17 pcalibre2 pcalibre1">expr</i>;
}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P700049702700000000000000004101D" data-uri="chapter03.xhtml#P700049702700000000000000004101D">with different access expressions <i class="pcalibre17 pcalibre2 pcalibre1">expr</i> and with destination data type <i class="pcalibre17 pcalibre2 pcalibre1">type</i> set according to type associated with <i class="pcalibre17 pcalibre2 pcalibre1">expr</i>. You then examine the code generated when compiling the functions to see if they match your expectations.</p>
<p id="P700049702700000000000000004101E" data-uri="chapter03.xhtml#P700049702700000000000000004101E" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002DCF" title="273" data-uri="chapter03.xhtml#P7000497027000000000000000002DCF" epub:type="pagebreak"></span>Suppose in these functions that <code id="P700049702700000000000000004101F" data-uri="chapter03.xhtml#P700049702700000000000000004101F" class="pcalibre1 calibre1 pcalibre2">up</code> and <code id="P7000497027000000000000000041020" data-uri="chapter03.xhtml#P7000497027000000000000000041020" class="pcalibre1 calibre1 pcalibre2">dest</code> are loaded into registers <code id="P7000497027000000000000000041021" data-uri="chapter03.xhtml#P7000497027000000000000000041021" class="pcalibre1 calibre1 pcalibre2">%rdi</code> and <code id="P7000497027000000000000000041022" data-uri="chapter03.xhtml#P7000497027000000000000000041022" class="pcalibre1 calibre1 pcalibre2">%rsi</code>, respectively. Fill in the following table with data type <i class="pcalibre17 pcalibre2 pcalibre1">type</i> and sequences of one to three instructions to compute the expression and store the result at <code id="P7000497027000000000000000041023" data-uri="chapter03.xhtml#P7000497027000000000000000041023" class="pcalibre1 calibre1 pcalibre2">dest</code>.</p>
<table id="P7000497027000000000000000041024" data-uri="chapter03.xhtml#P7000497027000000000000000041024" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000041025" data-uri="chapter03.xhtml#P7000497027000000000000000041025" class="pcalibre1 pcalibre2 calibre5"><i class="pcalibre17 pcalibre2 pcalibre1">expr</i></th>
<th id="P7000497027000000000000000041026" data-uri="chapter03.xhtml#P7000497027000000000000000041026" class="pcalibre1 pcalibre2 calibre5"><i class="pcalibre17 pcalibre2 pcalibre1">type</i></th>
<th id="P7000497027000000000000000041027" data-uri="chapter03.xhtml#P7000497027000000000000000041027" class="pcalibre1 pcalibre2 calibre5">Code</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041028" data-uri="chapter03.xhtml#P7000497027000000000000000041028" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041029" data-uri="chapter03.xhtml#P7000497027000000000000000041029" class="calibre3 pcalibre1 pcalibre2">up-&gt;t1.u</code></td>
<td id="P700049702700000000000000004102A" data-uri="chapter03.xhtml#P700049702700000000000000004102A" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004102B" data-uri="chapter03.xhtml#P700049702700000000000000004102B" class="calibre3 pcalibre1 pcalibre2">long</code></td>
<td id="P700049702700000000000000004102C" data-uri="chapter03.xhtml#P700049702700000000000000004102C" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004102D" data-uri="chapter03.xhtml#P700049702700000000000000004102D" class="calibre3 pcalibre1 pcalibre2">movq (%rdi), %rax</code><br class="pcalibre1 pcalibre2 pcalibre7"/><code id="P700049702700000000000000004102E" data-uri="chapter03.xhtml#P700049702700000000000000004102E" class="calibre3 pcalibre1 pcalibre2">movq %rax, (%rsi)</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004102F" data-uri="chapter03.xhtml#P700049702700000000000000004102F" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041030" data-uri="chapter03.xhtml#P7000497027000000000000000041030" class="calibre3 pcalibre1 pcalibre2">up-&gt;t1.v</code></td>
<td id="P7000497027000000000000000041031" data-uri="chapter03.xhtml#P7000497027000000000000000041031" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P7000497027000000000000000041032" data-uri="chapter03.xhtml#P7000497027000000000000000041032" class="pcalibre1 pcalibre2 calibre7">____________________<br class="pcalibre1 pcalibre2 pcalibre7"/>____________________<br class="pcalibre1 pcalibre2 pcalibre7"/>____________________</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041033" data-uri="chapter03.xhtml#P7000497027000000000000000041033" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041034" data-uri="chapter03.xhtml#P7000497027000000000000000041034" class="calibre3 pcalibre1 pcalibre2">up-&gt;t1.w</code></td>
<td id="P7000497027000000000000000041035" data-uri="chapter03.xhtml#P7000497027000000000000000041035" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P7000497027000000000000000041036" data-uri="chapter03.xhtml#P7000497027000000000000000041036" class="pcalibre1 pcalibre2 calibre7">____________________<br class="pcalibre1 pcalibre2 pcalibre7"/>____________________<br class="pcalibre1 pcalibre2 pcalibre7"/>____________________</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041037" data-uri="chapter03.xhtml#P7000497027000000000000000041037" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041038" data-uri="chapter03.xhtml#P7000497027000000000000000041038" class="calibre3 pcalibre1 pcalibre2">up-&gt;t2.a</code></td>
<td id="P7000497027000000000000000041039" data-uri="chapter03.xhtml#P7000497027000000000000000041039" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P700049702700000000000000004103A" data-uri="chapter03.xhtml#P700049702700000000000000004103A" class="pcalibre1 pcalibre2 calibre7">____________________<br class="pcalibre1 pcalibre2 pcalibre7"/>____________________<br class="pcalibre1 pcalibre2 pcalibre7"/>____________________</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004103B" data-uri="chapter03.xhtml#P700049702700000000000000004103B" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004103C" data-uri="chapter03.xhtml#P700049702700000000000000004103C" class="calibre3 pcalibre1 pcalibre2">up-&gt;t2.a[up-&gt;t1.u]</code></td>
<td id="P700049702700000000000000004103D" data-uri="chapter03.xhtml#P700049702700000000000000004103D" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P700049702700000000000000004103E" data-uri="chapter03.xhtml#P700049702700000000000000004103E" class="pcalibre1 pcalibre2 calibre7">____________________<br class="pcalibre1 pcalibre2 pcalibre7"/>____________________<br class="pcalibre1 pcalibre2 pcalibre7"/>____________________</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004103F" data-uri="chapter03.xhtml#P700049702700000000000000004103F" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041040" data-uri="chapter03.xhtml#P7000497027000000000000000041040" class="calibre3 pcalibre1 pcalibre2">*up-&gt;t2.p</code></td>
<td id="P7000497027000000000000000041041" data-uri="chapter03.xhtml#P7000497027000000000000000041041" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P7000497027000000000000000041042" data-uri="chapter03.xhtml#P7000497027000000000000000041042" class="pcalibre1 pcalibre2 calibre7">____________________<br class="pcalibre1 pcalibre2 pcalibre7"/>____________________<br class="pcalibre1 pcalibre2 pcalibre7"/>____________________</td>
</tr>
</tbody>
</table>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000002DF4" data-uri="chapter03.xhtml#P7000497027000000000000000002DF4" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041043" data-uri="chapter03.xhtml#P7000497027000000000000000041043" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.9.3 </span>Data Alignment</h1></header>
<p id="P7000497027000000000000000041044" data-uri="chapter03.xhtml#P7000497027000000000000000041044" class="pcalibre8 pcalibre1 pcalibre2">Many computer systems place restrictions on the allowable addresses for the primitive data types, requiring that the address for some objects must be a multiple of some value <var class="pcalibre17 pcalibre2 pcalibre1">K</var> (typically 2, 4, or 8). Such <i class="pcalibre17 pcalibre2 pcalibre1">alignment restrictions</i> simplify the design of the hardware forming the interface between the processor and the memory system. For example, suppose a processor always fetches 8 bytes from memory with an address that must be a multiple of 8. If we can guarantee that any double will be aligned to have its address be a multiple of 8, then the value can be read or written with a single memory operation. Otherwise, we may need to perform two memory accesses, since the object might be split across two 8-byte memory blocks.</p>
<p id="P7000497027000000000000000041045" data-uri="chapter03.xhtml#P7000497027000000000000000041045" class="pcalibre8 pcalibre1 pcalibre2">The x86-64 hardware will work correctly regardless of the alignment of data. However, Intel recommends that data be aligned to improve memory system performance. Their alignment rule is based on the principle that any primitive object of <var class="pcalibre17 pcalibre2 pcalibre1">K</var> bytes must have an address that is a multiple of <var class="pcalibre17 pcalibre2 pcalibre1">K</var>. We can see that this rule leads to the following alignments:</p>
<table id="P7000497027000000000000000041046" data-uri="chapter03.xhtml#P7000497027000000000000000041046" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000041047" data-uri="chapter03.xhtml#P7000497027000000000000000041047" class="pcalibre1 pcalibre2 calibre5"><var class="pcalibre17 pcalibre2 pcalibre1">K</var></th>
<th id="P7000497027000000000000000041048" data-uri="chapter03.xhtml#P7000497027000000000000000041048" class="pcalibre1 pcalibre2 calibre5">Types</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041049" data-uri="chapter03.xhtml#P7000497027000000000000000041049" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P700049702700000000000000004104A" data-uri="chapter03.xhtml#P700049702700000000000000004104A" class="pcalibre1 pcalibre2 calibre7">char</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004104B" data-uri="chapter03.xhtml#P700049702700000000000000004104B" class="pcalibre1 pcalibre2 calibre7">2</td>
<td id="P700049702700000000000000004104C" data-uri="chapter03.xhtml#P700049702700000000000000004104C" class="pcalibre1 pcalibre2 calibre7">short</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004104D" data-uri="chapter03.xhtml#P700049702700000000000000004104D" class="pcalibre1 pcalibre2 calibre7">4</td>
<td id="P700049702700000000000000004104E" data-uri="chapter03.xhtml#P700049702700000000000000004104E" class="pcalibre1 pcalibre2 calibre7">int, float</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004104F" data-uri="chapter03.xhtml#P700049702700000000000000004104F" class="pcalibre1 pcalibre2 calibre7">8</td>
<td id="P7000497027000000000000000041050" data-uri="chapter03.xhtml#P7000497027000000000000000041050" class="pcalibre1 pcalibre2 calibre7">long, double, char *</td>
</tr>
</tbody>
</table>
<p id="P7000497027000000000000000041051" data-uri="chapter03.xhtml#P7000497027000000000000000041051" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002E04" title="274" data-uri="chapter03.xhtml#P7000497027000000000000000002E04" epub:type="pagebreak"></span>Alignment is enforced by making sure that every data type is organized and allocated in such a way that every object within the type satisfies its alignment restrictions. The compiler places directives in the assembly code indicating the desired alignment for global data. For example, the assembly-code declaration of the jump table on page 235 contains the following directive on line 2:</p>
<pre id="P7000497027000000000000000041052" data-uri="chapter03.xhtml#P7000497027000000000000000041052" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041053" data-uri="chapter03.xhtml#P7000497027000000000000000041053" class="calibre3 pcalibre1 pcalibre2">
.align 8
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041054" data-uri="chapter03.xhtml#P7000497027000000000000000041054">This ensures that the data following it (in this case the start of the jump table) will start with an address that is a multiple of 8. Since each table entry is 8 bytes long, the successive elements will obey the 8-byte alignment restriction.</p>
<p id="P7000497027000000000000000041055" data-uri="chapter03.xhtml#P7000497027000000000000000041055" class="pcalibre8 pcalibre1 pcalibre2">For code involving structures, the compiler may need to insert gaps in the field allocation to ensure that each structure element satisfies its alignment requirement. The structure will then have some required alignment for its starting address.</p>
<p id="P7000497027000000000000000041056" data-uri="chapter03.xhtml#P7000497027000000000000000041056" class="pcalibre8 pcalibre1 pcalibre2">For example, consider the structure declaration</p>
<pre id="P7000497027000000000000000041057" data-uri="chapter03.xhtml#P7000497027000000000000000041057" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041058" data-uri="chapter03.xhtml#P7000497027000000000000000041058" class="calibre3 pcalibre1 pcalibre2">
struct S1 {
	int i;
	char c;
	int j;
};
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041059" data-uri="chapter03.xhtml#P7000497027000000000000000041059">Suppose the compiler used the minimal 9-byte allocation, diagrammed as follows:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002E0D" data-uri="chapter03.xhtml#P7000497027000000000000000002E0D">
<img alt="A diagram shows three fields: offset 0 to 4 with contents i; offset 4 to 5 with contents c; offset 5 to 9 with contents j." id="P700049702700000000000000004105A" data-uri="P700049702700000000000000000B6BE" src="../images/p274-1.png" class="pcalibre1 pcalibre2 pcalibre133"/>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004105B" data-uri="chapter03.xhtml#P700049702700000000000000004105B">Then it would be impossible to satisfy the 4-byte alignment requirement for both fields <code id="P700049702700000000000000004105C" data-uri="chapter03.xhtml#P700049702700000000000000004105C" class="pcalibre1 calibre1 pcalibre2">i</code> (offset 0) and <code id="P700049702700000000000000004105D" data-uri="chapter03.xhtml#P700049702700000000000000004105D" class="pcalibre1 calibre1 pcalibre2">j</code> (offset 5). Instead, the compiler inserts a 3-byte gap (shown here as shaded in blue) between fields <code id="P700049702700000000000000004105E" data-uri="chapter03.xhtml#P700049702700000000000000004105E" class="pcalibre1 calibre1 pcalibre2">c</code> and <code id="P700049702700000000000000004105F" data-uri="chapter03.xhtml#P700049702700000000000000004105F" class="pcalibre1 calibre1 pcalibre2">j</code>:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002E14" data-uri="chapter03.xhtml#P7000497027000000000000000002E14">
<img alt="A diagram shows four fields: offset 0 to 4 with contents i; offset 4 to 5 with contents c; offset 5 to 8 with a blue gap; offset 8 to 12 with contents j." id="P7000497027000000000000000041060" data-uri="P700049702700000000000000000B6BF" src="../images/p274-2.png" class="pcalibre1 pcalibre134 pcalibre2"/>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041061" data-uri="chapter03.xhtml#P7000497027000000000000000041061">As a result, <code id="P7000497027000000000000000041062" data-uri="chapter03.xhtml#P7000497027000000000000000041062" class="pcalibre1 calibre1 pcalibre2">j</code> has offset 8, and the overall structure size is 12 bytes. Furthermore, the compiler must ensure that any pointer <code id="P7000497027000000000000000041063" data-uri="chapter03.xhtml#P7000497027000000000000000041063" class="pcalibre1 calibre1 pcalibre2">p</code> of type <code id="P7000497027000000000000000041064" data-uri="chapter03.xhtml#P7000497027000000000000000041064" class="pcalibre1 calibre1 pcalibre2">struct S1*</code> satisfies a 4-byte alignment. Using our earlier notation, let pointer <code id="P7000497027000000000000000041065" data-uri="chapter03.xhtml#P7000497027000000000000000041065" class="pcalibre1 calibre1 pcalibre2">p</code> have value <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P7000497027000000000000000041066" data-uri="chapter03.xhtml#P7000497027000000000000000041066" class="pcalibre1 pcalibre2 pcalibre110">p</code></sub>. Then <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P7000497027000000000000000041067" data-uri="chapter03.xhtml#P7000497027000000000000000041067" class="pcalibre1 pcalibre2 pcalibre110">p</code></sub> must be a multiple of 4. This guarantees that both <code id="P7000497027000000000000000041068" data-uri="chapter03.xhtml#P7000497027000000000000000041068" class="pcalibre1 calibre1 pcalibre2">p-&gt;i</code> (address <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P7000497027000000000000000041069" data-uri="chapter03.xhtml#P7000497027000000000000000041069" class="pcalibre1 pcalibre2 pcalibre110">p</code></sub>) and <code id="P700049702700000000000000004106A" data-uri="chapter03.xhtml#P700049702700000000000000004106A" class="pcalibre1 calibre1 pcalibre2">p-&gt;j</code> (address <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P700049702700000000000000004106B" data-uri="chapter03.xhtml#P700049702700000000000000004106B" class="pcalibre1 pcalibre2 pcalibre110">p</code></sub> + 8) will satisfy their 4-byte alignment requirements.</p>
<p id="P700049702700000000000000004106C" data-uri="chapter03.xhtml#P700049702700000000000000004106C" class="pcalibre8 pcalibre1 pcalibre2">In addition, the compiler may need to add padding to the end of the structure so that each element in an array of structures will satisfy its alignment requirement. For example, consider the following structure declaration:</p>
<pre id="P700049702700000000000000004106D" data-uri="chapter03.xhtml#P700049702700000000000000004106D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004106E" data-uri="chapter03.xhtml#P700049702700000000000000004106E" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002E24" title="275" data-uri="chapter03.xhtml#P7000497027000000000000000002E24" epub:type="pagebreak"></span>struct S2 {
	int i;
	int j;
	char c;
};
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004106F" data-uri="chapter03.xhtml#P700049702700000000000000004106F">If we pack this structure into 9 bytes, we can still satisfy the alignment requirements for fields <code id="P7000497027000000000000000041070" data-uri="chapter03.xhtml#P7000497027000000000000000041070" class="pcalibre1 calibre1 pcalibre2">i</code> and <code id="P7000497027000000000000000041071" data-uri="chapter03.xhtml#P7000497027000000000000000041071" class="pcalibre1 calibre1 pcalibre2">j</code> by making sure that the starting address of the structure satisfies a 4-byte alignment requirement. Consider, however, the following declaration:</p>
<code id="P7000497027000000000000000041072" data-uri="chapter03.xhtml#P7000497027000000000000000041072" class="pcalibre1 calibre1 pcalibre2">struct S2 d[4];</code>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041073" data-uri="chapter03.xhtml#P7000497027000000000000000041073">With the 9-byte allocation, it is not possible to satisfy the alignment requirement for each element of <code id="P7000497027000000000000000041074" data-uri="chapter03.xhtml#P7000497027000000000000000041074" class="pcalibre1 calibre1 pcalibre2">d</code>, because these elements will have addresses <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P7000497027000000000000000041075" data-uri="chapter03.xhtml#P7000497027000000000000000041075" class="pcalibre1 pcalibre2 pcalibre110">d</code></sub>, <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P7000497027000000000000000041076" data-uri="chapter03.xhtml#P7000497027000000000000000041076" class="pcalibre1 pcalibre2 pcalibre110">d</code></sub> + 9, <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P7000497027000000000000000041077" data-uri="chapter03.xhtml#P7000497027000000000000000041077" class="pcalibre1 pcalibre2 pcalibre110">d</code></sub> + 18, and <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P7000497027000000000000000041078" data-uri="chapter03.xhtml#P7000497027000000000000000041078" class="pcalibre1 pcalibre2 pcalibre110">d</code></sub> + 27. Instead, the compiler allocates 12 bytes for structure <code id="P7000497027000000000000000041079" data-uri="chapter03.xhtml#P7000497027000000000000000041079" class="pcalibre1 calibre1 pcalibre2">S2</code>, with the final 3 bytes being wasted space:</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002E30" data-uri="chapter03.xhtml#P7000497027000000000000000002E30">
<img alt="A diagram shows four fields: offset 0 to 4 with contents i; offset 4 to 8 with contents j; offset 8 to 9 with contents c; offset 9 to 12 with a blue gap." id="P700049702700000000000000004107A" data-uri="P700049702700000000000000000B6C0" src="../images/p275-1.png" class="pcalibre1 pcalibre134 pcalibre2"/>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004107B" data-uri="chapter03.xhtml#P700049702700000000000000004107B">That way, the elements of <code id="P700049702700000000000000004107C" data-uri="chapter03.xhtml#P700049702700000000000000004107C" class="pcalibre1 calibre1 pcalibre2">d</code> will have addresses <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P700049702700000000000000004107D" data-uri="chapter03.xhtml#P700049702700000000000000004107D" class="pcalibre1 pcalibre2 pcalibre110">d</code></sub>, <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P700049702700000000000000004107E" data-uri="chapter03.xhtml#P700049702700000000000000004107E" class="pcalibre1 pcalibre2 pcalibre110">d</code></sub> + 12, <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P700049702700000000000000004107F" data-uri="chapter03.xhtml#P700049702700000000000000004107F" class="pcalibre1 pcalibre2 pcalibre110">d</code></sub> + 24, and <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P7000497027000000000000000041080" data-uri="chapter03.xhtml#P7000497027000000000000000041080" class="pcalibre1 pcalibre2 pcalibre110">d</code></sub> + 36. As long as <var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14"><code id="P7000497027000000000000000041081" data-uri="chapter03.xhtml#P7000497027000000000000000041081" class="pcalibre1 pcalibre2 pcalibre110">d</code></sub> is a multiple of 4, all of the alignment restrictions will be satisfied.</p>
<section id="P7000497027000000000000000002E39" data-uri="chapter03.xhtml#P7000497027000000000000000002E39" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041082" data-uri="chapter03.xhtml#P7000497027000000000000000041082" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.44 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P700049702700000000000000000389F">345</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041083" data-uri="chapter03.xhtml#P7000497027000000000000000041083">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041084" data-uri="chapter03.xhtml#P7000497027000000000000000041084">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041085" data-uri="chapter03.xhtml#P7000497027000000000000000041085"><p id="P7000497027000000000000000041086" data-uri="chapter03.xhtml#P7000497027000000000000000041086" class="pcalibre1 pcalibre2 pcalibre10">For each of the following structure declarations, determine the offset of each field, the total size of the structure, and its alignment requirement for x86-64:</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000041087" data-uri="chapter03.xhtml#P7000497027000000000000000041087">
<li id="P7000497027000000000000000041088" data-uri="chapter03.xhtml#P7000497027000000000000000041088" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041089" data-uri="chapter03.xhtml#P7000497027000000000000000041089" class="pcalibre1 pcalibre2 pcalibre10"><code id="P700049702700000000000000004108A" data-uri="chapter03.xhtml#P700049702700000000000000004108A" class="pcalibre1 calibre1 pcalibre2">struct P1 { int i; char c; int j; char d; };</code></p></li>
<li id="P700049702700000000000000004108B" data-uri="chapter03.xhtml#P700049702700000000000000004108B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004108C" data-uri="chapter03.xhtml#P700049702700000000000000004108C" class="pcalibre1 pcalibre2 pcalibre10"><code id="P700049702700000000000000004108D" data-uri="chapter03.xhtml#P700049702700000000000000004108D" class="pcalibre1 calibre1 pcalibre2">struct P2 { int i; char c; char d; long j; };</code></p></li>
<li id="P700049702700000000000000004108E" data-uri="chapter03.xhtml#P700049702700000000000000004108E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004108F" data-uri="chapter03.xhtml#P700049702700000000000000004108F" class="pcalibre1 pcalibre2 pcalibre10"><code id="P7000497027000000000000000041090" data-uri="chapter03.xhtml#P7000497027000000000000000041090" class="pcalibre1 calibre1 pcalibre2">struct P3 { short w[3]; char c[3] };</code></p></li>
<li id="P7000497027000000000000000041091" data-uri="chapter03.xhtml#P7000497027000000000000000041091" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041092" data-uri="chapter03.xhtml#P7000497027000000000000000041092" class="pcalibre1 pcalibre2 pcalibre10"><code id="P7000497027000000000000000041093" data-uri="chapter03.xhtml#P7000497027000000000000000041093" class="pcalibre1 calibre1 pcalibre2">struct P4 { short w[5]; char *c[3] };</code></p></li>
<li id="P7000497027000000000000000041094" data-uri="chapter03.xhtml#P7000497027000000000000000041094" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041095" data-uri="chapter03.xhtml#P7000497027000000000000000041095" class="pcalibre1 pcalibre2 pcalibre10"><code id="P7000497027000000000000000041096" data-uri="chapter03.xhtml#P7000497027000000000000000041096" class="pcalibre1 calibre1 pcalibre2">struct P5 { struct P3 a[2]; struct P2 t };</code></p></li>
</ol>
</div></li></ol>
</section>
<section id="P7000497027000000000000000002E4F" data-uri="chapter03.xhtml#P7000497027000000000000000002E4F" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041097" data-uri="chapter03.xhtml#P7000497027000000000000000041097" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.45 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P700049702700000000000000000389F">345</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041098" data-uri="chapter03.xhtml#P7000497027000000000000000041098">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041099" data-uri="chapter03.xhtml#P7000497027000000000000000041099">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004109A" data-uri="chapter03.xhtml#P700049702700000000000000004109A"><p id="P700049702700000000000000004109B" data-uri="chapter03.xhtml#P700049702700000000000000004109B" class="pcalibre1 pcalibre2 pcalibre10">Answer the following for the structure declaration</p>
<pre id="P700049702700000000000000004109C" data-uri="chapter03.xhtml#P700049702700000000000000004109C" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004109D" data-uri="chapter03.xhtml#P700049702700000000000000004109D" class="calibre3 pcalibre1 pcalibre2">
struct {
	char	*a;
	short	b;
	double	c;
	char	d;
	float	e;
	char	f;
</code></pre>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000002E57" data-uri="chapter03.xhtml#P7000497027000000000000000002E57"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P700049702700000000000000004109E" data-uri="chapter03.xhtml#P700049702700000000000000004109E" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002E59" title="276" data-uri="chapter03.xhtml#P7000497027000000000000000002E59" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>A case of mandatory alignment</h1></header>
<p id="P700049702700000000000000004109F" data-uri="chapter03.xhtml#P700049702700000000000000004109F" class="pcalibre1 pcalibre2 pcalibre10">For most x86-64 instructions, keeping data aligned improves efficiency, but it does not affect program behavior. On the other hand, some models of Intel and AMD processors will not work correctly with unaligned data for some of the SSE instructions implementing multimedia operations. These instructions operate on 16-byte blocks of data, and the instructions that transfer data between the SSE unit and memory require the memory addresses to be multiples of 16. Any attempt to access memory with an address that does not satisfy this alignment will lead to an <i class="pcalibre17 pcalibre2 pcalibre1">exception</i> (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000066A6.xhtml#P70004970270000000000000000066A6"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.1</span></a>), with the default behavior for the program to terminate.</p>
<p id="P70004970270000000000000000410A0" data-uri="chapter03.xhtml#P70004970270000000000000000410A0" class="pcalibre1 pcalibre2 pcalibre10">As a result, any compiler and run-time system for an x86-64 processor must ensure that any memory allocated to hold a data structure that may be read from or stored into an SSE register must satisfy a 16-byte alignment. This requirement has the following two consequences:</p>
<ul id="P70004970270000000000000000410A1" data-uri="chapter03.xhtml#P70004970270000000000000000410A1" class="pcalibre1 pcalibre2 pcalibre117">
<li id="P70004970270000000000000000410A2" data-uri="chapter03.xhtml#P70004970270000000000000000410A2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410A3" data-uri="chapter03.xhtml#P70004970270000000000000000410A3" class="pcalibre1 pcalibre2 pcalibre10">The starting address for any block generated by a memory allocation function (<code id="P70004970270000000000000000410A4" data-uri="chapter03.xhtml#P70004970270000000000000000410A4" class="pcalibre1 calibre1 pcalibre2">alloca, malloc, calloc</code>, or <code id="P70004970270000000000000000410A5" data-uri="chapter03.xhtml#P70004970270000000000000000410A5" class="pcalibre1 calibre1 pcalibre2">realloc</code>) must be a multiple of 16.</p></li>
<li id="P70004970270000000000000000410A6" data-uri="chapter03.xhtml#P70004970270000000000000000410A6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410A7" data-uri="chapter03.xhtml#P70004970270000000000000000410A7" class="pcalibre1 pcalibre2 pcalibre10">The stack frame for most functions must be aligned on a 16-byte boundary. (This requirement has a number of exceptions.)</p></li>
</ul>
<p id="P70004970270000000000000000410A8" data-uri="chapter03.xhtml#P70004970270000000000000000410A8" class="pcalibre1 pcalibre2 pcalibre10">More recent versions of x86-64 processors implement the AVX multimedia instructions. In addition to providing a superset of the SSE instructions, processors supporting AVX also do not have a mandatory alignment requirement.</p>
</aside>
<pre id="P70004970270000000000000000410A9" data-uri="chapter03.xhtml#P70004970270000000000000000410A9" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000410AA" data-uri="chapter03.xhtml#P70004970270000000000000000410AA" class="calibre3 pcalibre1 pcalibre2">
long	g;
int	h;
} rec;
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000410AB" data-uri="chapter03.xhtml#P70004970270000000000000000410AB">
<li id="P70004970270000000000000000410AC" data-uri="chapter03.xhtml#P70004970270000000000000000410AC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410AD" data-uri="chapter03.xhtml#P70004970270000000000000000410AD" class="pcalibre1 pcalibre2 pcalibre10">What are the byte offsets of all the fields in the structure?</p></li>
<li id="P70004970270000000000000000410AE" data-uri="chapter03.xhtml#P70004970270000000000000000410AE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410AF" data-uri="chapter03.xhtml#P70004970270000000000000000410AF" class="pcalibre1 pcalibre2 pcalibre10">What is the total size of the structure?</p></li>
<li id="P70004970270000000000000000410B0" data-uri="chapter03.xhtml#P70004970270000000000000000410B0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410B1" data-uri="chapter03.xhtml#P70004970270000000000000000410B1" class="pcalibre1 pcalibre2 pcalibre10">Rearrange the fields of the structure to minimize wasted space, and then show the byte offsets and total size for the rearranged structure.</p></li>
</ol>
</div></li></ol>
</section>
</section>
</section></body></html>
