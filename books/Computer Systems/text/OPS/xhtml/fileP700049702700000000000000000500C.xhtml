<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.14 Identifying and Eliminating Performance Bottlenecks</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P700049702700000000000000000500C" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P70004970270000000000000000437B6" data-uri="chapter05.xhtml#P70004970270000000000000000437B6" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.14 </span>Identifying and Eliminating Performance Bottlenecks</h1></header>
<p id="P70004970270000000000000000437B7" data-uri="chapter05.xhtml#P70004970270000000000000000437B7" class="pcalibre8 pcalibre1 pcalibre2">Up to this point, we have only considered optimizing small programs, where there is some clear place in the program that limits its performance and therefore should be the focus of our optimization efforts. When working with large programs, even knowing where to focus our optimization efforts can be difficult. In this section, we describe how to use <i class="pcalibre17 pcalibre2 pcalibre1">code profilers</i>, analysis tools that collect performance data about a program as it executes. We also discuss some general principles of code optimization, including the implications of Amdahl's law, introduced in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000204"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">1.9.1</span></a>.</p>
<section id="P700049702700000000000000000500F" data-uri="chapter05.xhtml#P700049702700000000000000000500F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000437B8" data-uri="chapter05.xhtml#P70004970270000000000000000437B8" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.14.1 </span>Program Profiling</h1></header>
<p id="P70004970270000000000000000437B9" data-uri="chapter05.xhtml#P70004970270000000000000000437B9" class="pcalibre8 pcalibre1 pcalibre2">Program <i class="pcalibre17 pcalibre2 pcalibre1">profiling</i> involves running a version of a program in which instrumentation code has been incorporated to determine how much time the different parts of the program require. It can be very useful for identifying the parts of a program we should focus on in our optimization efforts. One strength of profiling is that it can be performed while running the actual program on realistic benchmark data.</p>
<p id="P70004970270000000000000000437BA" data-uri="chapter05.xhtml#P70004970270000000000000000437BA" class="pcalibre8 pcalibre1 pcalibre2">Unix systems provide the profiling program <span class="pcalibre1 pcalibre29 pcalibre2">gprof</span>. This program generates two forms of information. First, it determines how much CPU time was spent for each of the functions in the program. Second, it computes a count of how many times each function gets called, categorized by which function performs the call. Both forms of information can be quite useful. The timings give a sense of <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005013" title="563" data-uri="chapter05.xhtml#P7000497027000000000000000005013" epub:type="pagebreak"></span>the relative importance of the different functions in determining the overall run time. The calling information allows us to understand the dynamic behavior of the program.</p>
<p id="P70004970270000000000000000437BB" data-uri="chapter05.xhtml#P70004970270000000000000000437BB" class="pcalibre8 pcalibre1 pcalibre2">Profiling with <span class="pcalibre1 pcalibre29 pcalibre2">gprof </span>requires three steps, as shown for a C program <code id="P70004970270000000000000000437BC" data-uri="chapter05.xhtml#P70004970270000000000000000437BC" class="pcalibre1 calibre1 pcalibre2">prog.c</code>, which runs with command-line argument <code id="P70004970270000000000000000437BD" data-uri="chapter05.xhtml#P70004970270000000000000000437BD" class="pcalibre1 calibre1 pcalibre2">file.txt</code>:</p>
<ol id="P70004970270000000000000000437BE" data-uri="chapter05.xhtml#P70004970270000000000000000437BE" class="pcalibre1 calibre19 pcalibre2">
<li id="P70004970270000000000000000437BF" data-uri="chapter05.xhtml#P70004970270000000000000000437BF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000437C0" data-uri="chapter05.xhtml#P70004970270000000000000000437C0" class="pcalibre1 pcalibre2 pcalibre10">The program must be compiled and linked for profiling. With <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>(and other C compilers), this involves simply including the run-time flag <code id="P70004970270000000000000000437C1" data-uri="chapter05.xhtml#P70004970270000000000000000437C1" class="pcalibre1 calibre1 pcalibre2">−pg</code> on the command line. It is important to ensure that the compiler does not attempt to perform any optimizations via inline substitution, or else the calls to functions may not be tabulated accurately. We use optimization flag <code id="P70004970270000000000000000437C2" data-uri="chapter05.xhtml#P70004970270000000000000000437C2" class="pcalibre1 calibre1 pcalibre2">−Og</code>, guaranteeing that function calls will be tracked properly.</p>
<pre id="P70004970270000000000000000437C3" data-uri="chapter05.xhtml#P70004970270000000000000000437C3" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000437C4" data-uri="chapter05.xhtml#P70004970270000000000000000437C4" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -Og -pg prog.c -o prog</i></code></pre></li>
<li id="P70004970270000000000000000437C5" data-uri="chapter05.xhtml#P70004970270000000000000000437C5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000437C6" data-uri="chapter05.xhtml#P70004970270000000000000000437C6" class="pcalibre1 pcalibre2 pcalibre10">The program is then executed as usual:</p>
<pre id="P70004970270000000000000000437C7" data-uri="chapter05.xhtml#P70004970270000000000000000437C7" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000437C8" data-uri="chapter05.xhtml#P70004970270000000000000000437C8" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./prog file.txt</i></code></pre>
<p id="P70004970270000000000000000437C9" data-uri="chapter05.xhtml#P70004970270000000000000000437C9" class="pcalibre1 pcalibre2 pcalibre10">It runs slightly (around a factor of 2) slower than normal, but otherwise the only difference is that it generates a file <code id="P70004970270000000000000000437CA" data-uri="chapter05.xhtml#P70004970270000000000000000437CA" class="pcalibre1 calibre1 pcalibre2">gmon.out</code>.</p></li>
<li id="P70004970270000000000000000437CB" data-uri="chapter05.xhtml#P70004970270000000000000000437CB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000437CC" data-uri="chapter05.xhtml#P70004970270000000000000000437CC" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre29 pcalibre2">gprof </span>is invoked to analyze the data in <code id="P70004970270000000000000000437CD" data-uri="chapter05.xhtml#P70004970270000000000000000437CD" class="pcalibre1 calibre1 pcalibre2">gmon.out</code>:</p>
<pre id="P70004970270000000000000000437CE" data-uri="chapter05.xhtml#P70004970270000000000000000437CE" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000437CF" data-uri="chapter05.xhtml#P70004970270000000000000000437CF" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gprof prog</i></code></pre></li>
</ol>
<p id="P70004970270000000000000000437D0" data-uri="chapter05.xhtml#P70004970270000000000000000437D0" class="pcalibre8 pcalibre1 pcalibre2">The first part of the profile report lists the times spent executing the different functions, sorted in descending order. As an example, the following listing shows this part of the report for the three most time-consuming functions in a program:</p>
<pre id="P70004970270000000000000000437D1" data-uri="chapter05.xhtml#P70004970270000000000000000437D1" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000437D2" data-uri="chapter05.xhtml#P70004970270000000000000000437D2" class="calibre3 pcalibre1 pcalibre2">
%	 cumulative	self		self	total	
time	seconds		seconds	calls	s/call	s/call	name
97.58	 203.66		 203.66     1	203.66	 203.66 sort_words
2.32	 208.50		   4.85 965027	  0.00	   0.00	find_ele_rec
0.14	 208.81		   0.30	12511031  0.00	   0.00	Strien
</code></pre>
<p id="P70004970270000000000000000437D3" data-uri="chapter05.xhtml#P70004970270000000000000000437D3" class="pcalibre8 pcalibre1 pcalibre2">Each row represents the time spent for all calls to some function. The first column indicates the percentage of the overall time spent on the function. The second shows the cumulative time spent by the functions up to and including the one on this row. The third shows the time spent on this particular function, and the fourth shows how many times it was called (not counting recursive calls). In our example, the function <code id="P70004970270000000000000000437D4" data-uri="chapter05.xhtml#P70004970270000000000000000437D4" class="pcalibre1 calibre1 pcalibre2">sort_words</code> was called only once, but this single call required 203.66 seconds, while the function <code id="P70004970270000000000000000437D5" data-uri="chapter05.xhtml#P70004970270000000000000000437D5" class="pcalibre1 calibre1 pcalibre2">find_ele_rec</code> was called 965,027 times (not including recursive calls), requiring a total of 4.85 seconds. Function <code id="P70004970270000000000000000437D6" data-uri="chapter05.xhtml#P70004970270000000000000000437D6" class="pcalibre1 calibre1 pcalibre2">Strlen</code> computes the length of a string by calling the library function <code id="P70004970270000000000000000437D7" data-uri="chapter05.xhtml#P70004970270000000000000000437D7" class="pcalibre1 calibre1 pcalibre2">strlen</code>. Library function calls are normally not shown in the results by <span class="pcalibre1 pcalibre29 pcalibre2">gprof</span>. Their times are usually reported as part of the function calling them. By creating the "wrapper function" <code id="P70004970270000000000000000437D8" data-uri="chapter05.xhtml#P70004970270000000000000000437D8" class="pcalibre1 calibre1 pcalibre2">Strlen</code>, we can reliably track the calls to <code id="P70004970270000000000000000437D9" data-uri="chapter05.xhtml#P70004970270000000000000000437D9" class="pcalibre1 calibre1 pcalibre2">strlen</code>, showing that it was called 12,511,031 times but only requiring a total of 0.30 seconds.</p>
<p id="P70004970270000000000000000437DA" data-uri="chapter05.xhtml#P70004970270000000000000000437DA" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005034" title="564" data-uri="chapter05.xhtml#P7000497027000000000000000005034" epub:type="pagebreak"></span>The second part of the profile report shows the calling history of the functions. The following is the history for a recursive function <code id="P70004970270000000000000000437DB" data-uri="chapter05.xhtml#P70004970270000000000000000437DB" class="pcalibre1 calibre1 pcalibre2">find_ele_rec</code>:</p>
<pre id="P70004970270000000000000000437DC" data-uri="chapter05.xhtml#P70004970270000000000000000437DC" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000437DD" data-uri="chapter05.xhtml#P70004970270000000000000000437DD" class="calibre3 pcalibre1 pcalibre2">
				158655725	find_ele_rec [5]
		4.85	0.10	965027/965027	insert_string [4]
[5]	2.4	4.85	0.10	965027+158655725	find_ele_rec [5]
		0.08	0.01	363039/363039	save_string [8]
		0.00	0.01	363039/363039	new_ele [12]
				158655725	find_ele_rec [5]
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000437DE" data-uri="chapter05.xhtml#P70004970270000000000000000437DE">This history shows both the functions that called <code id="P70004970270000000000000000437DF" data-uri="chapter05.xhtml#P70004970270000000000000000437DF" class="pcalibre1 calibre1 pcalibre2">find_ele_rec</code>, as well as the functions that it called. The first two lines show the calls to the function: 158,655,725 calls by itself recursively, and 965,027 calls by function <code id="P70004970270000000000000000437E0" data-uri="chapter05.xhtml#P70004970270000000000000000437E0" class="pcalibre1 calibre1 pcalibre2">insert_string</code> (which is itself called 965,027 times). Function <code id="P70004970270000000000000000437E1" data-uri="chapter05.xhtml#P70004970270000000000000000437E1" class="pcalibre1 calibre1 pcalibre2">find_ele_rec</code>, in turn, called two other functions, <code id="P70004970270000000000000000437E2" data-uri="chapter05.xhtml#P70004970270000000000000000437E2" class="pcalibre1 calibre1 pcalibre2">save_string</code> and <code id="P70004970270000000000000000437E3" data-uri="chapter05.xhtml#P70004970270000000000000000437E3" class="pcalibre1 calibre1 pcalibre2">new_ele</code>, each a total of 363,039 times.</p>
<p id="P70004970270000000000000000437E4" data-uri="chapter05.xhtml#P70004970270000000000000000437E4" class="pcalibre8 pcalibre1 pcalibre2">From these call data, we can often infer useful information about the program behavior. For example, the function <code id="P70004970270000000000000000437E5" data-uri="chapter05.xhtml#P70004970270000000000000000437E5" class="pcalibre1 calibre1 pcalibre2">find_ele_rec</code> is a recursive procedure that scans the linked list for a hash bucket looking for a particular string. For this function, comparing the number of recursive calls with the number of top-level calls provides statistical information about the lengths of the traversals through these lists. Given that their ratio is 164.4:1, we can infer that the program scanned an average of around 164 elements each time.</p>
<p id="P70004970270000000000000000437E6" data-uri="chapter05.xhtml#P70004970270000000000000000437E6" class="pcalibre8 pcalibre1 pcalibre2">Some properties of <span class="pcalibre1 pcalibre29 pcalibre2">gprof </span>are worth noting:</p>
<ul id="P70004970270000000000000000437E7" data-uri="chapter05.xhtml#P70004970270000000000000000437E7" class="pcalibre1 calibre9 pcalibre2">
<li id="P70004970270000000000000000437E8" data-uri="chapter05.xhtml#P70004970270000000000000000437E8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000437E9" data-uri="chapter05.xhtml#P70004970270000000000000000437E9" class="pcalibre1 pcalibre2 pcalibre10">The timing is not very precise. It is based on a simple <i class="pcalibre17 pcalibre2 pcalibre1">interval counting</i> scheme in which the compiled program maintains a counter for each function recording the time spent executing that function. The operating system causes the program to be interrupted at some regular time interval <i class="pcalibre17 pcalibre2 pcalibre1">δ</i>. Typical values of <i class="pcalibre17 pcalibre2 pcalibre1">δ</i> range between 1.0 and 10.0 milliseconds. It then determines what function the program was executing when the interrupt occurred and increments the counter for that function by <i class="pcalibre17 pcalibre2 pcalibre1">δ</i>. Of course, it may happen that this function just started executing and will shortly be completed, but it is assigned the full cost of the execution since the previous interrupt. Some other function may run between two interrupts and therefore not be charged any time at all.</p>
<p id="P70004970270000000000000000437EA" data-uri="chapter05.xhtml#P70004970270000000000000000437EA" class="pcalibre1 pcalibre2 pcalibre63">Over a long duration, this scheme works reasonably well. Statistically, every function should be charged according to the relative time spent executing it. For programs that run for less than around 1 second, however, the numbers should be viewed as only rough estimates.</p></li>
<li id="P70004970270000000000000000437EB" data-uri="chapter05.xhtml#P70004970270000000000000000437EB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000437EC" data-uri="chapter05.xhtml#P70004970270000000000000000437EC" class="pcalibre1 pcalibre2 pcalibre10">The calling information is quite reliable, assuming no inline substitutions have been performed. The compiled program maintains a counter for each combination of caller and callee. The appropriate counter is incremented every time a procedure is called.</p></li>
<li id="P70004970270000000000000000437ED" data-uri="chapter05.xhtml#P70004970270000000000000000437ED" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000437EE" data-uri="chapter05.xhtml#P70004970270000000000000000437EE" class="pcalibre1 pcalibre2 pcalibre10">By default, the timings for library functions are not shown. Instead, these times are incorporated into the times for the calling functions.</p></li>
</ul>
</section>
<section id="P7000497027000000000000000005049" data-uri="chapter05.xhtml#P7000497027000000000000000005049" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000437EF" data-uri="chapter05.xhtml#P70004970270000000000000000437EF" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000504B" title="565" data-uri="chapter05.xhtml#P700049702700000000000000000504B" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">5.14.2 </span>Using a Profiler to Guide Optimization</h1></header>
<p id="P70004970270000000000000000437F0" data-uri="chapter05.xhtml#P70004970270000000000000000437F0" class="pcalibre8 pcalibre1 pcalibre2">As an example of using a profiler to guide program optimization, we created an application that involves several different tasks and data structures. This application analyzes the <i class="pcalibre17 pcalibre2 pcalibre1">n-gram</i> statistics of a text document, where an <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-gram is a sequence of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> words occurring in a document. For <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 1, we collect statistics on individual words, for <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 2 on pairs of words, and so on. For a given value of <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, our program reads a text file, creates a table of unique <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams and how many times each one occurs, then sorts the <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams in descending order of occurrence.</p>
<p id="P70004970270000000000000000437F1" data-uri="chapter05.xhtml#P70004970270000000000000000437F1" class="pcalibre8 pcalibre1 pcalibre2">As a benchmark, we ran it on a file consisting of the complete works of William Shakespeare, totaling 965,028 words, of which 23,706 are unique. We found that for <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 1, even a poorly written analysis program can readily process the entire file in under 1 second, and so we set <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 2 to make things more challenging. For the case of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 2, <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams are referred to as <i class="pcalibre17 pcalibre2 pcalibre1">bigrams</i> (pronounced "bye-grams"). We determined that Shakespeare's works contain 363,039 unique bigrams. The most common is "I am," occurring 1,892 times. Perhaps his most famous bigram, "to be," occurs 1,020 times. Fully 266,018 of the bigrams occur only once.</p>
<p id="P70004970270000000000000000437F2" data-uri="chapter05.xhtml#P70004970270000000000000000437F2" class="pcalibre8 pcalibre1 pcalibre2">Our program consists of the following parts. We created multiple versions, starting with simple algorithms for the different parts and then replacing them with more sophisticated ones:</p>
<ol id="P70004970270000000000000000437F3" data-uri="chapter05.xhtml#P70004970270000000000000000437F3" class="pcalibre1 calibre19 pcalibre2">
<li id="P70004970270000000000000000437F4" data-uri="chapter05.xhtml#P70004970270000000000000000437F4" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000437F5" data-uri="chapter05.xhtml#P70004970270000000000000000437F5" class="pcalibre1 pcalibre2 pcalibre10">Each word is read from the file and converted to lowercase. Our initial version used the function <code id="P70004970270000000000000000437F6" data-uri="chapter05.xhtml#P70004970270000000000000000437F6" class="pcalibre1 calibre1 pcalibre2">lower1</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000049CE.xhtml#P7000497027000000000000000004A11"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.7</span></a>), which we know to have quadratic run time due to repeated calls to <code id="P70004970270000000000000000437F7" data-uri="chapter05.xhtml#P70004970270000000000000000437F7" class="pcalibre1 calibre1 pcalibre2">strlen</code>.</p></li>
<li id="P70004970270000000000000000437F8" data-uri="chapter05.xhtml#P70004970270000000000000000437F8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000437F9" data-uri="chapter05.xhtml#P70004970270000000000000000437F9" class="pcalibre1 pcalibre2 pcalibre10">A hash function is applied to the string to create a number between 0 and <var class="pcalibre17 pcalibre2 pcalibre1">s</var> − 1, for a hash table with <var class="pcalibre17 pcalibre2 pcalibre1">s</var> buckets. Our initial function simply summed the ASCII codes for the characters modulo <i class="pcalibre17 pcalibre2 pcalibre1">s.</i></p></li>
<li id="P70004970270000000000000000437FA" data-uri="chapter05.xhtml#P70004970270000000000000000437FA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000437FB" data-uri="chapter05.xhtml#P70004970270000000000000000437FB" class="pcalibre1 pcalibre2 pcalibre10">Each hash bucket is organized as a linked list. The program scans down this list looking for a matching entry. If one is found, the frequency for this <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-gram is incremented. Otherwise, a new list element is created. Our initial version performed this operation recursively, inserting new elements at the end of the list.</p></li>
<li id="P70004970270000000000000000437FC" data-uri="chapter05.xhtml#P70004970270000000000000000437FC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000437FD" data-uri="chapter05.xhtml#P70004970270000000000000000437FD" class="pcalibre1 pcalibre2 pcalibre10">Once the table has been generated, we sort all of the elements according to the frequencies. Our initial version used insertion sort.</p></li>
</ol>
<p id="P70004970270000000000000000437FE" data-uri="chapter05.xhtml#P70004970270000000000000000437FE" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005064"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.38</span></a> shows the profile results for six different versions of our <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-gram-frequency analysis program. For each version, we divide the time into the following categories:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P70004970270000000000000000437FF" data-uri="chapter05.xhtml#P70004970270000000000000000437FF">
<li id="P7000497027000000000000000043800" data-uri="chapter05.xhtml#P7000497027000000000000000043800" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043801" data-uri="chapter05.xhtml#P7000497027000000000000000043801" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Sort. </span>Sorting <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams by frequency</p></li>
<li id="P7000497027000000000000000043802" data-uri="chapter05.xhtml#P7000497027000000000000000043802" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043803" data-uri="chapter05.xhtml#P7000497027000000000000000043803" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">List. </span>Scanning the linked list for a matching <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-gram, inserting a new element if necessary</p></li>
<li id="P7000497027000000000000000043804" data-uri="chapter05.xhtml#P7000497027000000000000000043804" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043805" data-uri="chapter05.xhtml#P7000497027000000000000000043805" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Lower. </span>Converting strings to lowercase</p></li>
<li id="P7000497027000000000000000043806" data-uri="chapter05.xhtml#P7000497027000000000000000043806" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043807" data-uri="chapter05.xhtml#P7000497027000000000000000043807" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Strlen. </span>Computing string lengths</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000005064" data-uri="chapter05.xhtml#P7000497027000000000000000005064">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005065" title="566" data-uri="chapter05.xhtml#P7000497027000000000000000005065" epub:type="pagebreak"></span>
<img alt="Two graphs depict profile results." id="P7000497027000000000000000043808" data-uri="P700049702700000000000000000B727" src="../images/p566-1.png" class="pcalibre1 pcalibre2 calibre50"/>
<figcaption id="P7000497027000000000000000043809" data-uri="chapter05.xhtml#P7000497027000000000000000043809" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004380A" data-uri="chapter05.xhtml#P700049702700000000000000004380A" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.38 </span>Profile results for different versions of bigram-frequency counting program.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004380B" data-uri="chapter05.xhtml#P700049702700000000000000004380B"><p id="P700049702700000000000000004380C" data-uri="chapter05.xhtml#P700049702700000000000000004380C" class="pcalibre1 pcalibre2 pcalibre10">Time is divided according to the different major operations in the program.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000023AFC" data-uri="chapter05.xhtml#P7000497027000000000000000023AFC">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P700049702700000000000000004380D" data-uri="chapter05.xhtml#P700049702700000000000000004380D" class="pcalibre1 pcalibre2 pcalibre40">Two graphs each have bars for Initial, Quicksort, Iter first, Iter last, Big table, Better hash, and Linear lower, rising to various CPU seconds. Each bar is divided into sort, list, lower, strlen, hash, and reset. The data are summarized below.</p>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P700049702700000000000000004380E" data-uri="chapter05.xhtml#P700049702700000000000000004380E">
<li id="P700049702700000000000000004380F" data-uri="chapter05.xhtml#P700049702700000000000000004380F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043810" data-uri="chapter05.xhtml#P7000497027000000000000000043810" class="pcalibre1 pcalibre2 pcalibre40">All versions: a bar for initial rises to about 210 CPU seconds, with about 200 CPU seconds as sort and about 10 as list. The other bars are all less than 20 CPU seconds.</p></li>
<li id="P7000497027000000000000000043811" data-uri="chapter05.xhtml#P7000497027000000000000000043811" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043812" data-uri="chapter05.xhtml#P7000497027000000000000000043812" class="pcalibre1 pcalibre2 pcalibre40">All but the slowest version: bars are divided approximately as summarized below.</p>
<ul id="P7000497027000000000000000043813" data-uri="chapter05.xhtml#P7000497027000000000000000043813" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000043814" data-uri="chapter05.xhtml#P7000497027000000000000000043814" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043815" data-uri="chapter05.xhtml#P7000497027000000000000000043815" class="pcalibre1 pcalibre2 pcalibre40">Quicksort: 5.5 seconds, with 5 seconds as list and 0.4 as strlen</p></li>
<li id="P7000497027000000000000000043816" data-uri="chapter05.xhtml#P7000497027000000000000000043816" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043817" data-uri="chapter05.xhtml#P7000497027000000000000000043817" class="pcalibre1 pcalibre2 pcalibre40">Iter first: 6 seconds, with 5.5 as list and 0.3 as strlen</p></li>
<li id="P7000497027000000000000000043818" data-uri="chapter05.xhtml#P7000497027000000000000000043818" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043819" data-uri="chapter05.xhtml#P7000497027000000000000000043819" class="pcalibre1 pcalibre2 pcalibre40">Iter last: 5.3 seconds, with 5 as list and 0.2 as strlen</p></li>
<li id="P700049702700000000000000004381A" data-uri="chapter05.xhtml#P700049702700000000000000004381A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004381B" data-uri="chapter05.xhtml#P700049702700000000000000004381B" class="pcalibre1 pcalibre2 pcalibre40">Big table: 5.1 seconds, with 4.5 as list and 0.2 as strlen</p></li>
<li id="P700049702700000000000000004381C" data-uri="chapter05.xhtml#P700049702700000000000000004381C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004381D" data-uri="chapter05.xhtml#P700049702700000000000000004381D" class="pcalibre1 pcalibre2 pcalibre40">Better hash: 0.7 seconds, with 0.4 as strlen</p></li>
<li id="P700049702700000000000000004381E" data-uri="chapter05.xhtml#P700049702700000000000000004381E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004381F" data-uri="chapter05.xhtml#P700049702700000000000000004381F" class="pcalibre1 pcalibre2 pcalibre40">Linear lower: 0.2 seconds</p></li>
</ul></li>
</ol>
</details>
</figcaption></figure></li>
<li id="P7000497027000000000000000043820" data-uri="chapter05.xhtml#P7000497027000000000000000043820" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043821" data-uri="chapter05.xhtml#P7000497027000000000000000043821" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Hash. </span>Computing the hash function</p></li>
<li id="P7000497027000000000000000043822" data-uri="chapter05.xhtml#P7000497027000000000000000043822" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043823" data-uri="chapter05.xhtml#P7000497027000000000000000043823" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Rest. </span>The sum of all other functions</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043824" data-uri="chapter05.xhtml#P7000497027000000000000000043824">As part (a) of the figure shows, our initial version required 3.5 minutes, with most of the time spent sorting. This is not surprising, since insertion sort has quadratic run time and the program sorted 363,039 values.</p>
<p id="P7000497027000000000000000043825" data-uri="chapter05.xhtml#P7000497027000000000000000043825" class="pcalibre8 pcalibre1 pcalibre2">In our next version, we performed sorting using the library function <code id="P7000497027000000000000000043826" data-uri="chapter05.xhtml#P7000497027000000000000000043826" class="pcalibre1 calibre1 pcalibre2">qsort</code>, which is based on the quicksort algorithm [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B468">98</a>]. It has an expected run time of <var class="pcalibre17 pcalibre2 pcalibre1">O</var>(<var class="pcalibre17 pcalibre2 pcalibre1">n</var> log <var class="pcalibre17 pcalibre2 pcalibre1">n</var>). This version is labeled "Quicksort" in the figure. The more efficient sorting algorithm reduces the time spent sorting to become negligible, and the overall run time to around 5.4 seconds. Part (b) of the figure shows the times for the remaining version on a scale where we can see them more clearly.</p>
<p id="P7000497027000000000000000043827" data-uri="chapter05.xhtml#P7000497027000000000000000043827" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005073" title="567" data-uri="chapter05.xhtml#P7000497027000000000000000005073" epub:type="pagebreak"></span>With improved sorting, we now find that list scanning becomes the bottleneck. Thinking that the inefficiency is due to the recursive structure of the function, we replaced it by an iterative one, shown as "Iter first." Surprisingly, the run time increases to around 7.5 seconds. On closer study, we find a subtle difference between the two list functions. The recursive version inserted new elements at the end of the list, while the iterative one inserted them at the front. To maximize performance, we want the most frequent <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams to occur near the beginning of the lists. That way, the function will quickly locate the common cases. Assuming that <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams are spread uniformly throughout the document, we would expect the first occurrence of a frequent one to come before that of a less frequent one. By inserting new <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams at the end, the first function tended to order <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams in descending order of frequency, while the second function tended to do just the opposite. We therefore created a third list-scanning function that uses iteration but inserts new elements at the end of this list. With this version, shown as "Iter last," the time dropped to around 5.3 seconds, slightly better than with the recursive version. These measurements demonstrate the importance of running experiments on a program as part of an optimization effort. We initially assumed that converting recursive code to iterative code would improve its performance and did not consider the distinction between adding to the end or to the beginning of a list.</p>
<p id="P7000497027000000000000000043828" data-uri="chapter05.xhtml#P7000497027000000000000000043828" class="pcalibre8 pcalibre1 pcalibre2">Next, we consider the hash table structure. The initial version had only 1,021 buckets (typically, the number of buckets is chosen to be a prime number to enhance the ability of the hash function to distribute keys uniformly among the buckets). For a table with 363,039 entries, this would imply an average <i class="pcalibre17 pcalibre2 pcalibre1">load</i> of 363,039/1,021 = 355.6. That explains why so much of the time is spent performing list operations—the searches involve testing a significant number of candidate <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-grams. It also explains why the performance is so sensitive to the list ordering. We then increased the number of buckets to 199,999, reducing the average load to 1.8. Oddly enough, however, our overall run time only drops to 5.1 seconds, a difference of only 0.2 seconds.</p>
<p id="P7000497027000000000000000043829" data-uri="chapter05.xhtml#P7000497027000000000000000043829" class="pcalibre8 pcalibre1 pcalibre2">On further inspection, we can see that the minimal performance gain with a larger table was due to a poor choice of hash function. Simply summing the character codes for a string does not produce a very wide range of values. In particular, the maximum code value for a letter is 122, and so a string of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> characters will generate a sum of at most 122<var class="pcalibre17 pcalibre2 pcalibre1">n</var>. The longest bigram in our document, "honorificabilitudinitatibus*** thou" sums to just 3,371, and so most of the buckets in our hash table will go unused. In addition, a commutative hash function, such as addition, does not differentiate among the different possible orderings of characters with a string. For example, the words "rat" and "tar" will generate the same sums.</p>
<p id="P700049702700000000000000004382A" data-uri="chapter05.xhtml#P700049702700000000000000004382A" class="pcalibre8 pcalibre1 pcalibre2">We switched to a hash function that uses shift and <span class="pcalibre1 pcalibre29 pcalibre2">exclusive-or </span>operations. With this version, shown as "Better hash," the time drops to 0.6 seconds. A more systematic approach would be to study the distribution of keys among the buckets more carefully, making sure that it comes close to what one would expect if the hash function had a uniform output distribution.</p>
<p id="P700049702700000000000000004382B" data-uri="chapter05.xhtml#P700049702700000000000000004382B" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005078" title="568" data-uri="chapter05.xhtml#P7000497027000000000000000005078" epub:type="pagebreak"></span>Finally, we have reduced the run time to the point where most of the time is spent in <code id="P700049702700000000000000004382C" data-uri="chapter05.xhtml#P700049702700000000000000004382C" class="pcalibre1 calibre1 pcalibre2">strlen</code>, and most of the calls to <code id="P700049702700000000000000004382D" data-uri="chapter05.xhtml#P700049702700000000000000004382D" class="pcalibre1 calibre1 pcalibre2">strlen</code> occur as part of the lowercase conversion. We have already seen that function <code id="P700049702700000000000000004382E" data-uri="chapter05.xhtml#P700049702700000000000000004382E" class="pcalibre1 calibre1 pcalibre2">lower1</code> has quadratic performance, especially for long strings. The words in this document are short enough to avoid the disastrous consequences of quadratic performance; the longest bigram is just 32 characters. Still, switching to <code id="P700049702700000000000000004382F" data-uri="chapter05.xhtml#P700049702700000000000000004382F" class="pcalibre1 calibre1 pcalibre2">lower2</code>, shown as "Linear lower," yields a significant improvement, with the overall time dropping to around 0.2 seconds.</p>
<p id="P7000497027000000000000000043830" data-uri="chapter05.xhtml#P7000497027000000000000000043830" class="pcalibre8 pcalibre1 pcalibre2">With this exercise, we have shown that code profiling can help drop the time required for a simple application from 3.5 minutes down to 0.2 seconds, yielding a performance gain of around 1,000×. The profiler helps us focus our attention on the most time-consuming parts of the program and also provides useful information about the procedure call structure. Some of the bottlenecks in our code, such as using a quadratic sort routine, are easy to anticipate, while others, such as whether to append to the beginning or end of a list, emerge only through a careful analysis.</p>
<p id="P7000497027000000000000000043831" data-uri="chapter05.xhtml#P7000497027000000000000000043831" class="pcalibre8 pcalibre1 pcalibre2">We can see that profiling is a useful tool to have in the toolbox, but it should not be the only one. The timing measurements are imperfect, especially for shorter (less than 1 second) run times. More significantly, the results apply only to the particular data tested. For example, if we had run the original function on data consisting of a smaller number of longer strings, we would have found that the lowercase conversion routine was the major performance bottleneck. Even worse, if it only profiled documents with short words, we might never detect hidden bottlenecks such as the quadratic performance of <code id="P7000497027000000000000000043832" data-uri="chapter05.xhtml#P7000497027000000000000000043832" class="pcalibre1 calibre1 pcalibre2">lower1</code>. In general, profiling can help us optimize for <i class="pcalibre17 pcalibre2 pcalibre1">typical</i> cases, assuming we run the program on representative data, but we should also make sure the program will have respectable performance for all possible cases. This mainly involves avoiding algorithms (such as insertion sort) and bad programming practices (such as <code id="P7000497027000000000000000043833" data-uri="chapter05.xhtml#P7000497027000000000000000043833" class="pcalibre1 calibre1 pcalibre2">lower1</code>) that yield poor asymptotic performance.</p>
<p id="P7000497027000000000000000043834" data-uri="chapter05.xhtml#P7000497027000000000000000043834" class="pcalibre8 pcalibre1 pcalibre2">Amdahl's law, described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000204"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">1.9.1</span></a>, provides some additional insights into the performance gains that can be obtained by targeted optimizations. For our <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-gram code, we saw the total execution time drop from 209.0 to 5.4 seconds when we replaced insertion sort by quicksort. The initial version spent 203.7 of its 209.0 seconds performing insertion sort, giving <i class="pcalibre17 pcalibre2 pcalibre1">α</i> = 0.974, the fraction of time subject to speedup. With quicksort, the time spent sorting becomes negligible, giving a predicted speedup of 209/<i class="pcalibre17 pcalibre2 pcalibre1">α</i> = 39.0, close to the measured speedup of 38.5. We were able to gain a large speedup because sorting constituted a very large fraction of the overall execution time. However, when one bottleneck is eliminated, a new one arises, and so gaining additional speedup required focusing on other parts of the program.</p>
</section>
</section></body></html>
