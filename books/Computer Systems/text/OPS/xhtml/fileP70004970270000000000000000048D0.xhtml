<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.1 Capabilities and Limitations of Optimizing Compilers</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P70004970270000000000000000048D0" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000004301E" data-uri="chapter05.xhtml#P700049702700000000000000004301E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.1 </span>Capabilities and Limitations of Optimizing Compilers</h1></header>
<p id="P700049702700000000000000004301F" data-uri="chapter05.xhtml#P700049702700000000000000004301F" class="pcalibre8 pcalibre1 pcalibre2">Modern compilers employ sophisticated algorithms to determine what values are computed in a program and how they are used. They can then exploit opportunities to simplify expressions, to use a single computation in several different places, and to reduce the number of times a given computation must be performed. Most compilers, including <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>, provide users with some control over which optimizations they apply. As discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001DCE.xhtml#P7000497027000000000000000001DCE"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">3</span></a>, the simplest control is to specify the <i class="pcalibre17 pcalibre2 pcalibre1">optimization level.</i> For example, invoking <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>with the command-line option <code id="P7000497027000000000000000043020" data-uri="chapter05.xhtml#P7000497027000000000000000043020" class="pcalibre1 calibre1 pcalibre2">−0g</code> specifies that it should apply a basic set of optimizations.</p>
<p id="P7000497027000000000000000043021" data-uri="chapter05.xhtml#P7000497027000000000000000043021" class="pcalibre8 pcalibre1 pcalibre2">Invoking <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>with option <code id="P7000497027000000000000000043022" data-uri="chapter05.xhtml#P7000497027000000000000000043022" class="pcalibre1 calibre1 pcalibre2">−01</code> or higher (e.g., <code id="P7000497027000000000000000043023" data-uri="chapter05.xhtml#P7000497027000000000000000043023" class="pcalibre1 calibre1 pcalibre2">−02</code> or <code id="P7000497027000000000000000043024" data-uri="chapter05.xhtml#P7000497027000000000000000043024" class="pcalibre1 calibre1 pcalibre2">−03</code>) will cause it to apply more extensive optimizations. These can further improve program performance, but they may expand the program size and they may make the program more difficult to debug using standard debugging tools. For our presentation, we will mostly consider code compiled with optimization level <code id="P7000497027000000000000000043025" data-uri="chapter05.xhtml#P7000497027000000000000000043025" class="pcalibre1 calibre1 pcalibre2">−01</code>, even though level <code id="P7000497027000000000000000043026" data-uri="chapter05.xhtml#P7000497027000000000000000043026" class="pcalibre1 calibre1 pcalibre2">−02</code> has become the accepted standard for most software projects that use <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>. We purposely limit the level of optimization to demonstrate how different ways of writing a function in C can affect the efficiency of the code generated by a compiler. We will find that we can write C code that, when compiled just with option <code id="P7000497027000000000000000043027" data-uri="chapter05.xhtml#P7000497027000000000000000043027" class="pcalibre1 calibre1 pcalibre2">−01</code>, vastly outperforms a more naive version compiled with the highest possible optimization levels.</p>
<p id="P7000497027000000000000000043028" data-uri="chapter05.xhtml#P7000497027000000000000000043028" class="pcalibre8 pcalibre1 pcalibre2">Compilers must be careful to apply only <i class="pcalibre17 pcalibre2 pcalibre1">safe</i> optimizations to a program, meaning that the resulting program will have the exact same behavior as would an unoptimized version for all possible cases the program may encounter, up to the limits of the guarantees provided by the C language standards. Constraining <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000048DC" title="499" data-uri="chapter05.xhtml#P70004970270000000000000000048DC" epub:type="pagebreak"></span>the compiler to perform only safe optimizations eliminates possible sources of undesired run-time behavior, but it also means that the programmer must make more of an effort to write programs in a way that the compiler can then transform into efficient machine-level code. To appreciate the challenges of deciding which program transformations are safe or not, consider the following two procedures:</p>
<pre id="P7000497027000000000000000043029" data-uri="chapter05.xhtml#P7000497027000000000000000043029" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004302A" data-uri="chapter05.xhtml#P700049702700000000000000004302A" class="calibre3 pcalibre1 pcalibre2">
1	void twiddlel(long *xp, long *yp)
2	{
3		*xp += *yp;
4		*xp += *yp;
5	}
6	
7	void twiddle2(long *xp, long *yp)
8	{
9		*xp += 2* *yp;
10	}
</code></pre>
<p id="P700049702700000000000000004302B" data-uri="chapter05.xhtml#P700049702700000000000000004302B" class="pcalibre8 pcalibre1 pcalibre2">At first glance, both procedures seem to have identical behavior. They both add twice the value stored at the location designated by pointer <code id="P700049702700000000000000004302C" data-uri="chapter05.xhtml#P700049702700000000000000004302C" class="pcalibre1 calibre1 pcalibre2">yp</code> to that designated by pointer <code id="P700049702700000000000000004302D" data-uri="chapter05.xhtml#P700049702700000000000000004302D" class="pcalibre1 calibre1 pcalibre2">xp</code>. On the other hand, function <code id="P700049702700000000000000004302E" data-uri="chapter05.xhtml#P700049702700000000000000004302E" class="pcalibre1 calibre1 pcalibre2">twiddle2</code> is more efficient. It requires only three memory references (read <code id="P700049702700000000000000004302F" data-uri="chapter05.xhtml#P700049702700000000000000004302F" class="pcalibre1 calibre1 pcalibre2">*xp</code>, read <code id="P7000497027000000000000000043030" data-uri="chapter05.xhtml#P7000497027000000000000000043030" class="pcalibre1 calibre1 pcalibre2">*yp</code>, write <code id="P7000497027000000000000000043031" data-uri="chapter05.xhtml#P7000497027000000000000000043031" class="pcalibre1 calibre1 pcalibre2">*xp</code>), whereas <code id="P7000497027000000000000000043032" data-uri="chapter05.xhtml#P7000497027000000000000000043032" class="pcalibre1 calibre1 pcalibre2">twiddle1</code> requires six (two reads of <code id="P7000497027000000000000000043033" data-uri="chapter05.xhtml#P7000497027000000000000000043033" class="pcalibre1 calibre1 pcalibre2">*xp</code>, two reads of <code id="P7000497027000000000000000043034" data-uri="chapter05.xhtml#P7000497027000000000000000043034" class="pcalibre1 calibre1 pcalibre2">*yp</code>, and two writes of <code id="P7000497027000000000000000043035" data-uri="chapter05.xhtml#P7000497027000000000000000043035" class="pcalibre1 calibre1 pcalibre2">*xp</code>). Hence, if a compiler is given procedure <code id="P7000497027000000000000000043036" data-uri="chapter05.xhtml#P7000497027000000000000000043036" class="pcalibre1 calibre1 pcalibre2">twiddle1</code> to compile, one might think it could generate more efficient code based on the computations performed by <code id="P7000497027000000000000000043037" data-uri="chapter05.xhtml#P7000497027000000000000000043037" class="pcalibre1 calibre1 pcalibre2">twiddle2</code>.</p>
<p id="P7000497027000000000000000043038" data-uri="chapter05.xhtml#P7000497027000000000000000043038" class="pcalibre8 pcalibre1 pcalibre2">Consider, however, the case in which <code id="P7000497027000000000000000043039" data-uri="chapter05.xhtml#P7000497027000000000000000043039" class="pcalibre1 calibre1 pcalibre2">xp</code> and <code id="P700049702700000000000000004303A" data-uri="chapter05.xhtml#P700049702700000000000000004303A" class="pcalibre1 calibre1 pcalibre2">yp</code> are equal. Then function <code id="P700049702700000000000000004303B" data-uri="chapter05.xhtml#P700049702700000000000000004303B" class="pcalibre1 calibre1 pcalibre2">twiddle1</code> will perform the following computations:</p>
<pre id="P700049702700000000000000004303C" data-uri="chapter05.xhtml#P700049702700000000000000004303C" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004303D" data-uri="chapter05.xhtml#P700049702700000000000000004303D" class="calibre3 pcalibre1 pcalibre2">
3	*xp += *xp; /* Double value at xp */
4	*xp += *xp; /* Double value at xp */
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004303E" data-uri="chapter05.xhtml#P700049702700000000000000004303E">The result will be that the value at <code id="P700049702700000000000000004303F" data-uri="chapter05.xhtml#P700049702700000000000000004303F" class="pcalibre1 calibre1 pcalibre2">xp</code> will be increased by a factor of 4. On the other hand, function <code id="P7000497027000000000000000043040" data-uri="chapter05.xhtml#P7000497027000000000000000043040" class="pcalibre1 calibre1 pcalibre2">twiddle2</code> will perform the following computation:</p>
<pre id="P7000497027000000000000000043041" data-uri="chapter05.xhtml#P7000497027000000000000000043041" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043042" data-uri="chapter05.xhtml#P7000497027000000000000000043042" class="calibre3 pcalibre1 pcalibre2">
9	*xp += 2* *xp; /* Triple value at xp */
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043043" data-uri="chapter05.xhtml#P7000497027000000000000000043043">The result will be that the value at <code id="P7000497027000000000000000043044" data-uri="chapter05.xhtml#P7000497027000000000000000043044" class="pcalibre1 calibre1 pcalibre2">xp</code> will be increased by a factor of 3. The compiler knows nothing about how <code id="P7000497027000000000000000043045" data-uri="chapter05.xhtml#P7000497027000000000000000043045" class="pcalibre1 calibre1 pcalibre2">twiddle1</code> will be called, and so it must assume that arguments <code id="P7000497027000000000000000043046" data-uri="chapter05.xhtml#P7000497027000000000000000043046" class="pcalibre1 calibre1 pcalibre2">xp</code> and <code id="P7000497027000000000000000043047" data-uri="chapter05.xhtml#P7000497027000000000000000043047" class="pcalibre1 calibre1 pcalibre2">yp</code> can be equal. It therefore cannot generate code in the style of <code id="P7000497027000000000000000043048" data-uri="chapter05.xhtml#P7000497027000000000000000043048" class="pcalibre1 calibre1 pcalibre2">twiddle2</code> as an optimized version of <code id="P7000497027000000000000000043049" data-uri="chapter05.xhtml#P7000497027000000000000000043049" class="pcalibre1 calibre1 pcalibre2">twiddle1</code>.</p>
<p id="P700049702700000000000000004304A" data-uri="chapter05.xhtml#P700049702700000000000000004304A" class="pcalibre8 pcalibre1 pcalibre2">The case where two pointers may designate the same memory location is known as <i class="pcalibre17 pcalibre2 pcalibre1">memory aliasing.</i> In performing only safe optimizations, the compiler must assume that different pointers may be aliased. As another example, for a program with pointer variables <code id="P700049702700000000000000004304B" data-uri="chapter05.xhtml#P700049702700000000000000004304B" class="pcalibre1 calibre1 pcalibre2">p</code> and <code id="P700049702700000000000000004304C" data-uri="chapter05.xhtml#P700049702700000000000000004304C" class="pcalibre1 calibre1 pcalibre2">q</code>, consider the following code sequence:</p>
<pre id="P700049702700000000000000004304D" data-uri="chapter05.xhtml#P700049702700000000000000004304D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004304E" data-uri="chapter05.xhtml#P700049702700000000000000004304E" class="calibre3 pcalibre1 pcalibre2">
x = 1000; y = 3000;
*q = y; /* 3000 */
*p = x; /* 1000 */
t1 = *q; /* 1000 or 3000 */
</code></pre>
<p id="P700049702700000000000000004304F" data-uri="chapter05.xhtml#P700049702700000000000000004304F" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004904" title="500" data-uri="chapter05.xhtml#P7000497027000000000000000004904" epub:type="pagebreak"></span>The value computed for <code id="P7000497027000000000000000043050" data-uri="chapter05.xhtml#P7000497027000000000000000043050" class="pcalibre1 calibre1 pcalibre2">t1</code> depends on whether or not pointers <code id="P7000497027000000000000000043051" data-uri="chapter05.xhtml#P7000497027000000000000000043051" class="pcalibre1 calibre1 pcalibre2">p</code> and <code id="P7000497027000000000000000043052" data-uri="chapter05.xhtml#P7000497027000000000000000043052" class="pcalibre1 calibre1 pcalibre2">q</code> are aliased—if not, it will equal 3,000, but if so it will equal 1,000. This leads to one of the major <i class="pcalibre17 pcalibre2 pcalibre1">optimization blockers</i>, aspects of programs that can severely limit the opportunities for a compiler to generate optimized code. If a compiler cannot determine whether or not two pointers may be aliased, it must assume that either case is possible, limiting the set of possible optimizations.</p>
<section id="P7000497027000000000000000004908" data-uri="chapter05.xhtml#P7000497027000000000000000004908" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000043053" data-uri="chapter05.xhtml#P7000497027000000000000000043053" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000005090.xhtml#P70004970270000000000000000050DD">573</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000043054" data-uri="chapter05.xhtml#P7000497027000000000000000043054">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000043055" data-uri="chapter05.xhtml#P7000497027000000000000000043055">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043056" data-uri="chapter05.xhtml#P7000497027000000000000000043056"><p id="P7000497027000000000000000043057" data-uri="chapter05.xhtml#P7000497027000000000000000043057" class="pcalibre1 pcalibre2 pcalibre10">The following problem illustrates the way memory aliasing can cause unexpected program behavior. Consider the following procedure to swap two values:</p>
<pre id="P7000497027000000000000000043058" data-uri="chapter05.xhtml#P7000497027000000000000000043058" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043059" data-uri="chapter05.xhtml#P7000497027000000000000000043059" class="calibre3 pcalibre1 pcalibre2">
1	/* Swap value x at xp with value y at yp */
2	void swap(long *xp, long *yp)
3	{
4		*xp = *xp + *yp; /* x+y */
5		*yp = *xp - *yp; /* x+y-y = x */
6		*xp = *xp - *yp; /* x+y-x = y */
7	}
</code></pre>
<p id="P700049702700000000000000004305A" data-uri="chapter05.xhtml#P700049702700000000000000004305A" class="pcalibre1 pcalibre2 pcalibre10">If this procedure is called with <code id="P700049702700000000000000004305B" data-uri="chapter05.xhtml#P700049702700000000000000004305B" class="pcalibre1 calibre1 pcalibre2">xp</code> equal to <code id="P700049702700000000000000004305C" data-uri="chapter05.xhtml#P700049702700000000000000004305C" class="pcalibre1 calibre1 pcalibre2">yp</code>, what effect will it have?</p></div></li>
</ol>
</section>
<p id="P700049702700000000000000004305D" data-uri="chapter05.xhtml#P700049702700000000000000004305D" class="pcalibre8 pcalibre1 pcalibre2">A second optimization blocker is due to function calls. As an example, consider the following two procedures:</p>
<pre id="P700049702700000000000000004305E" data-uri="chapter05.xhtml#P700049702700000000000000004305E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004305F" data-uri="chapter05.xhtml#P700049702700000000000000004305F" class="calibre3 pcalibre1 pcalibre2">
1	long f();
2	
3	long func1() {
4		return f ()+ f ()+ f ()+ f () ;
5	}
6	
7	long func2() {
8		return 4*f();
9	}
</code></pre>
<p id="P7000497027000000000000000043060" data-uri="chapter05.xhtml#P7000497027000000000000000043060" class="pcalibre8 pcalibre1 pcalibre2">It might seem at first that both compute the same result, but with <code id="P7000497027000000000000000043061" data-uri="chapter05.xhtml#P7000497027000000000000000043061" class="pcalibre1 calibre1 pcalibre2">func2</code> calling <code id="P7000497027000000000000000043062" data-uri="chapter05.xhtml#P7000497027000000000000000043062" class="pcalibre1 calibre1 pcalibre2">f</code> only once, whereas <code id="P7000497027000000000000000043063" data-uri="chapter05.xhtml#P7000497027000000000000000043063" class="pcalibre1 calibre1 pcalibre2">func1</code> calls it four times. It is tempting to generate code in the style of <code id="P7000497027000000000000000043064" data-uri="chapter05.xhtml#P7000497027000000000000000043064" class="pcalibre1 calibre1 pcalibre2">func2</code> when given <code id="P7000497027000000000000000043065" data-uri="chapter05.xhtml#P7000497027000000000000000043065" class="pcalibre1 calibre1 pcalibre2">func1</code> as the source.</p>
<p id="P7000497027000000000000000043066" data-uri="chapter05.xhtml#P7000497027000000000000000043066" class="pcalibre8 pcalibre1 pcalibre2">Consider, however, the following code for f:</p>
<pre id="P7000497027000000000000000043067" data-uri="chapter05.xhtml#P7000497027000000000000000043067" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043068" data-uri="chapter05.xhtml#P7000497027000000000000000043068" class="calibre3 pcalibre1 pcalibre2">
1	long counter = 0;
2	
3	long f() {
4		return counter++;
5	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043069" data-uri="chapter05.xhtml#P7000497027000000000000000043069">This function has a <i class="pcalibre17 pcalibre2 pcalibre1">side effect</i>—it modifies some part of the global program state. Changing the number of times it gets called changes the program behavior. In</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000004920" data-uri="chapter05.xhtml#P7000497027000000000000000004920"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P700049702700000000000000004306A" data-uri="chapter05.xhtml#P700049702700000000000000004306A" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004922" title="501" data-uri="chapter05.xhtml#P7000497027000000000000000004922" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Optimizing function calls by inline substitution</h1></header>
<p id="P700049702700000000000000004306B" data-uri="chapter05.xhtml#P700049702700000000000000004306B" class="pcalibre1 pcalibre2 pcalibre40">Code involving function calls can be optimized by a process known as <i class="pcalibre17 pcalibre2 pcalibre1">inline substitution</i> (or simply "inlining"), where the function call is replaced by the code for the body of the function. For example, we can expand the code for <code id="P700049702700000000000000004306C" data-uri="chapter05.xhtml#P700049702700000000000000004306C" class="pcalibre1 calibre1 pcalibre2">func1</code> by substituting four instantiations of function <code id="P700049702700000000000000004306D" data-uri="chapter05.xhtml#P700049702700000000000000004306D" class="pcalibre1 calibre1 pcalibre2">f</code>:</p>
<pre id="P700049702700000000000000004306E" data-uri="chapter05.xhtml#P700049702700000000000000004306E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004306F" data-uri="chapter05.xhtml#P700049702700000000000000004306F" class="calibre3 pcalibre1 pcalibre2">
1	/* Result of inlining f in func1 */
2	long func1in() {
3		long t = counter++; /* +0 */
4		t += counter++; /* +1 */
5		t += counter++; /* +2 */
6		t += counter++; /* +3 */
7		return t;
8	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P7000497027000000000000000043070" data-uri="chapter05.xhtml#P7000497027000000000000000043070">This transformation both reduces the overhead of the function calls and allows further optimization of the expanded code. For example, the compiler can consolidate the updates of global variable <code id="P7000497027000000000000000043071" data-uri="chapter05.xhtml#P7000497027000000000000000043071" class="pcalibre1 calibre1 pcalibre2">counter</code> in <code id="P7000497027000000000000000043072" data-uri="chapter05.xhtml#P7000497027000000000000000043072" class="pcalibre1 calibre1 pcalibre2">func1</code> in to generate an optimized version of the function:</p>
<pre id="P7000497027000000000000000043073" data-uri="chapter05.xhtml#P7000497027000000000000000043073" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043074" data-uri="chapter05.xhtml#P7000497027000000000000000043074" class="calibre3 pcalibre1 pcalibre2">
1	/* Optimization of inlined code */
2	long func1opt() {
3		long t = 4 * counter + 6;
4		counter += 4;
5		return t;
6	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P7000497027000000000000000043075" data-uri="chapter05.xhtml#P7000497027000000000000000043075">This code faithfully reproduces the behavior of <code id="P7000497027000000000000000043076" data-uri="chapter05.xhtml#P7000497027000000000000000043076" class="pcalibre1 calibre1 pcalibre2">func1</code> for this particular definition of function <code id="P7000497027000000000000000043077" data-uri="chapter05.xhtml#P7000497027000000000000000043077" class="pcalibre1 calibre1 pcalibre2">f</code>.</p>
<p id="P7000497027000000000000000043078" data-uri="chapter05.xhtml#P7000497027000000000000000043078" class="pcalibre1 pcalibre2 pcalibre40">Recent versions of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>attempt this form of optimization, either when directed to with the command-line option <code id="P7000497027000000000000000043079" data-uri="chapter05.xhtml#P7000497027000000000000000043079" class="pcalibre1 calibre1 pcalibre2">-finline</code> or for optimization level <code id="P700049702700000000000000004307A" data-uri="chapter05.xhtml#P700049702700000000000000004307A" class="pcalibre1 calibre1 pcalibre2">−01</code> and higher. Unfortunately, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>only attempts inlining for functions defined within a single file. That means it will not be applied in the common case where a set of library functions is defined in one file but invoked by functions in other files.</p>
<p id="P700049702700000000000000004307B" data-uri="chapter05.xhtml#P700049702700000000000000004307B" class="pcalibre1 pcalibre2 pcalibre10">There are times when it is best to prevent a compiler from performing inline substitution. One is when the code will be evaluated using a symbolic debugger, such as <span class="pcalibre1 pcalibre29 pcalibre2">gdb</span>, as described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002E6D.xhtml#P7000497027000000000000000002EC0"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.10.2</span></a>. If a function call has been optimized away via inline substitution, then any attempt to trace or set a breakpoint for that call will fail. The second is when evaluating the performance of a program by profiling, as is discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000500C.xhtml#P700049702700000000000000000500F"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14.1</span></a>. Calls to functions that have been eliminated by inline substitution will not be profiled correctly.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004307C" data-uri="chapter05.xhtml#P700049702700000000000000004307C">particular, a call to <code id="P700049702700000000000000004307D" data-uri="chapter05.xhtml#P700049702700000000000000004307D" class="pcalibre1 calibre1 pcalibre2">func1</code> would return 0 + 1 + 2 + 3 = 6, whereas a call to <code id="P700049702700000000000000004307E" data-uri="chapter05.xhtml#P700049702700000000000000004307E" class="pcalibre1 calibre1 pcalibre2">func2</code> would return 4 · 0 = 0, assuming both started with global variable counter set to zero.</p>
<p id="P700049702700000000000000004307F" data-uri="chapter05.xhtml#P700049702700000000000000004307F" class="pcalibre8 pcalibre1 pcalibre2">Most compilers do not try to determine whether a function is free of side effects and hence is a candidate for optimizations such as those attempted in <code id="P7000497027000000000000000043080" data-uri="chapter05.xhtml#P7000497027000000000000000043080" class="pcalibre1 calibre1 pcalibre2">func2</code>. Instead, the compiler assumes the worst case and leaves function calls intact.</p>
<p id="P7000497027000000000000000043081" data-uri="chapter05.xhtml#P7000497027000000000000000043081" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000493A" title="502" data-uri="chapter05.xhtml#P700049702700000000000000000493A" epub:type="pagebreak"></span>Among compilers, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>is considered adequate, but not exceptional, in terms of its optimization capabilities. It performs basic optimizations, but it does not perform the radical transformations on programs that more "aggressive" compilers do. As a consequence, programmers using <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>must put more effort into writing programs in a way that simplifies the compiler's task of generating efficient code.</p>
</section></body></html>
