<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>11.4 The Sockets Interface</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000007CC1" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P70004970270000000000000000467FF" data-uri="chapter11.xhtml#P70004970270000000000000000467FF" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4 </span>The Sockets Interface</h1></header>
<p id="P7000497027000000000000000046800" data-uri="chapter11.xhtml#P7000497027000000000000000046800" class="pcalibre8 pcalibre1 pcalibre2">The <i class="pcalibre17 pcalibre2 pcalibre1">sockets interface</i> is a set of functions that are used in conjunction with the Unix I/O functions to build network applications. It has been implemented on most modern systems, including all Unix variants as well as Windows and Macintosh systems. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007CC4"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.12</span></a> gives an overview of the sockets interface in the context of a typical client-server transaction. You should use this picture as a road map when we discuss the individual functions.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007CC4" data-uri="chapter11.xhtml#P7000497027000000000000000007CC4">
<img alt="A diagram illustrates network applications based on the sockets interface." id="P7000497027000000000000000046801" data-uri="P700049702700000000000000000B7C5" src="../images/p932-1.png" class="pcalibre1 pcalibre2 pcalibre306"/>
<figcaption id="P7000497027000000000000000046802" data-uri="chapter11.xhtml#P7000497027000000000000000046802" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046803" data-uri="chapter11.xhtml#P7000497027000000000000000046803" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">11.12 </span>Overview of network applications based on the sockets interface.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000026B70" data-uri="chapter11.xhtml#P7000497027000000000000000026B70">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000046804" data-uri="chapter11.xhtml#P7000497027000000000000000046804" class="pcalibre8 pcalibre1 pcalibre2">A diagram shows a flow of connections under client and server, with the components summarized below.</p>
<ul id="P7000497027000000000000000046805" data-uri="chapter11.xhtml#P7000497027000000000000000046805" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000046806" data-uri="chapter11.xhtml#P7000497027000000000000000046806" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046807" data-uri="chapter11.xhtml#P7000497027000000000000000046807" class="pcalibre1 pcalibre2 pcalibre10">Client</p>
<ul id="P7000497027000000000000000046808" data-uri="chapter11.xhtml#P7000497027000000000000000046808" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000046809" data-uri="chapter11.xhtml#P7000497027000000000000000046809" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004680A" data-uri="chapter11.xhtml#P700049702700000000000000004680A" class="pcalibre1 pcalibre2 pcalibre10">Open_clientfd, including:</p>
<ul id="P700049702700000000000000004680B" data-uri="chapter11.xhtml#P700049702700000000000000004680B" class="pcalibre146 pcalibre2 pcalibre1">
<li id="P700049702700000000000000004680C" data-uri="chapter11.xhtml#P700049702700000000000000004680C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004680D" data-uri="chapter11.xhtml#P700049702700000000000000004680D" class="pcalibre1 pcalibre2 pcalibre10">Getaddrinfo</p></li>
<li id="P700049702700000000000000004680E" data-uri="chapter11.xhtml#P700049702700000000000000004680E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004680F" data-uri="chapter11.xhtml#P700049702700000000000000004680F" class="pcalibre1 pcalibre2 pcalibre10">Socket</p></li>
<li id="P7000497027000000000000000046810" data-uri="chapter11.xhtml#P7000497027000000000000000046810" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046811" data-uri="chapter11.xhtml#P7000497027000000000000000046811" class="pcalibre1 pcalibre2 pcalibre10">Connect (connection request to accept under server)</p></li>
</ul></li>
<li id="P7000497027000000000000000046812" data-uri="chapter11.xhtml#P7000497027000000000000000046812" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046813" data-uri="chapter11.xhtml#P7000497027000000000000000046813" class="pcalibre1 pcalibre2 pcalibre10">Rio_writen (to rio_readlineb under server)</p></li>
<li id="P7000497027000000000000000046814" data-uri="chapter11.xhtml#P7000497027000000000000000046814" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046815" data-uri="chapter11.xhtml#P7000497027000000000000000046815" class="pcalibre1 pcalibre2 pcalibre10">Rio_readlineb (from rio_writen under server)</p></li>
<li id="P7000497027000000000000000046816" data-uri="chapter11.xhtml#P7000497027000000000000000046816" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046817" data-uri="chapter11.xhtml#P7000497027000000000000000046817" class="pcalibre1 pcalibre2 pcalibre10">Close (EOF to rio_readlineb)</p></li>
</ul></li>
<li id="P7000497027000000000000000046818" data-uri="chapter11.xhtml#P7000497027000000000000000046818" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046819" data-uri="chapter11.xhtml#P7000497027000000000000000046819" class="pcalibre1 pcalibre2 pcalibre10">Server:</p>
<ul id="P700049702700000000000000004681A" data-uri="chapter11.xhtml#P700049702700000000000000004681A" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P700049702700000000000000004681B" data-uri="chapter11.xhtml#P700049702700000000000000004681B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004681C" data-uri="chapter11.xhtml#P700049702700000000000000004681C" class="pcalibre1 pcalibre2 pcalibre10">Open_listenfd, including:</p>
<ul id="P700049702700000000000000004681D" data-uri="chapter11.xhtml#P700049702700000000000000004681D" class="pcalibre146 pcalibre2 pcalibre1">
<li id="P700049702700000000000000004681E" data-uri="chapter11.xhtml#P700049702700000000000000004681E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004681F" data-uri="chapter11.xhtml#P700049702700000000000000004681F" class="pcalibre1 pcalibre2 pcalibre10">Getaddrinfo</p></li>
<li id="P7000497027000000000000000046820" data-uri="chapter11.xhtml#P7000497027000000000000000046820" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046821" data-uri="chapter11.xhtml#P7000497027000000000000000046821" class="pcalibre1 pcalibre2 pcalibre10">Socket</p></li>
<li id="P7000497027000000000000000046822" data-uri="chapter11.xhtml#P7000497027000000000000000046822" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046823" data-uri="chapter11.xhtml#P7000497027000000000000000046823" class="pcalibre1 pcalibre2 pcalibre10">Bind</p></li>
<li id="P7000497027000000000000000046824" data-uri="chapter11.xhtml#P7000497027000000000000000046824" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046825" data-uri="chapter11.xhtml#P7000497027000000000000000046825" class="pcalibre1 pcalibre2 pcalibre10">Listen</p></li>
</ul></li>
<li id="P7000497027000000000000000046826" data-uri="chapter11.xhtml#P7000497027000000000000000046826" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046827" data-uri="chapter11.xhtml#P7000497027000000000000000046827" class="pcalibre1 pcalibre2 pcalibre10">Accept (connection request from connect under Client and await connection request from next client from close below)</p></li>
<li id="P7000497027000000000000000046828" data-uri="chapter11.xhtml#P7000497027000000000000000046828" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046829" data-uri="chapter11.xhtml#P7000497027000000000000000046829" class="pcalibre1 pcalibre2 pcalibre10">Rio_readlineb (from rio_writen under client)</p></li>
<li id="P700049702700000000000000004682A" data-uri="chapter11.xhtml#P700049702700000000000000004682A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004682B" data-uri="chapter11.xhtml#P700049702700000000000000004682B" class="pcalibre1 pcalibre2 pcalibre10">Rio_writen (to rio_readlineb under client)</p></li>
<li id="P700049702700000000000000004682C" data-uri="chapter11.xhtml#P700049702700000000000000004682C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004682D" data-uri="chapter11.xhtml#P700049702700000000000000004682D" class="pcalibre1 pcalibre2 pcalibre10">Rio_readlineb (EOF from close under client)</p></li>
<li id="P700049702700000000000000004682E" data-uri="chapter11.xhtml#P700049702700000000000000004682E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004682F" data-uri="chapter11.xhtml#P700049702700000000000000004682F" class="pcalibre1 pcalibre2 pcalibre10">Close (await connection request from next client to accept)</p></li>
</ul></li>
</ul>
</details>
</figcaption>
</figure>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000007CC8" data-uri="chapter11.xhtml#P7000497027000000000000000007CC8"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000046830" data-uri="chapter11.xhtml#P7000497027000000000000000046830" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007CCA" title="933" data-uri="chapter11.xhtml#P7000497027000000000000000007CCA" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>What does the <code id="P7000497027000000000000000046831" data-uri="chapter11.xhtml#P7000497027000000000000000046831" class="pcalibre1 pcalibre2 calibre16">_in</code> suffix mean?</h1></header>
<p id="P7000497027000000000000000046832" data-uri="chapter11.xhtml#P7000497027000000000000000046832" class="pcalibre1 pcalibre2 pcalibre10">The <code id="P7000497027000000000000000046833" data-uri="chapter11.xhtml#P7000497027000000000000000046833" class="pcalibre1 calibre1 pcalibre2">_in</code> suffix is short for <i class="pcalibre17 pcalibre2 pcalibre1">internet</i>, not <i class="pcalibre17 pcalibre2 pcalibre1">input</i>.</p>
</aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007CCE" data-uri="chapter11.xhtml#P7000497027000000000000000007CCE">
<pre id="P7000497027000000000000000046834" data-uri="chapter11.xhtml#P7000497027000000000000000046834" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046835" data-uri="chapter11.xhtml#P7000497027000000000000000046835" class="calibre3 pcalibre1 pcalibre2">
/* IP socket address structure */
struct sockaddr_in {
  uint16_t	sin_family;	/* Protocol family (always AF_INET) */
  uint16_t	sin_port;	/* Port number in network byte order */
  struct in_addr	sin_addr;	/* IP address in network byte order */
  unsigned char	sin_zero[8];	/* Pad to sizeof(struct sockaddr) */
};
/* Generic socket address structure (for connect, bind, and accept) */ struct sockaddr {
  uint16_t	sa_family;	/* Protocol family */
  char		sa_data[14];	/* Address data */
};
</code></pre>
<figcaption id="P7000497027000000000000000046836" data-uri="chapter11.xhtml#P7000497027000000000000000046836" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046837" data-uri="chapter11.xhtml#P7000497027000000000000000046837" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">11.13 </span>Socket address structures.</h1></header>
</figcaption>
</figure>
<section id="P7000497027000000000000000007CD3" data-uri="chapter11.xhtml#P7000497027000000000000000007CD3" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046838" data-uri="chapter11.xhtml#P7000497027000000000000000046838" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.1 </span>Socket Address Structures</h1></header>
<p id="P7000497027000000000000000046839" data-uri="chapter11.xhtml#P7000497027000000000000000046839" class="pcalibre8 pcalibre1 pcalibre2">From the perspective of the Linux kernel, a socket is an end point for communication. From the perspective of a Linux program, a socket is an open file with a corresponding descriptor.</p>
<p id="P700049702700000000000000004683A" data-uri="chapter11.xhtml#P700049702700000000000000004683A" class="pcalibre8 pcalibre1 pcalibre2">Internet socket addresses are stored in 16-byte structures having the type <code id="P700049702700000000000000004683B" data-uri="chapter11.xhtml#P700049702700000000000000004683B" class="pcalibre1 calibre1 pcalibre2">sockaddr_in</code>, shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007CCE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.13</span></a>. For Internet applications, the <code id="P700049702700000000000000004683C" data-uri="chapter11.xhtml#P700049702700000000000000004683C" class="pcalibre1 calibre1 pcalibre2">sin_family</code> field is AF_INET, the <code id="P700049702700000000000000004683D" data-uri="chapter11.xhtml#P700049702700000000000000004683D" class="pcalibre1 calibre1 pcalibre2">sin_port</code> field is a 16-bit port number, and the <code id="P700049702700000000000000004683E" data-uri="chapter11.xhtml#P700049702700000000000000004683E" class="pcalibre1 calibre1 pcalibre2">sin_addr</code> field contains a 32-bit IP address. The IP address and port number are always stored in network (big-endian) byte order.</p>
<p id="P700049702700000000000000004683F" data-uri="chapter11.xhtml#P700049702700000000000000004683F" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046840" data-uri="chapter11.xhtml#P7000497027000000000000000046840" class="pcalibre1 calibre1 pcalibre2">connect, bind</code>, and <code id="P7000497027000000000000000046841" data-uri="chapter11.xhtml#P7000497027000000000000000046841" class="pcalibre1 calibre1 pcalibre2">accept</code> functions require a pointer to a protocol-specific socket address structure. The problem faced by the designers of the sockets interface was how to define these functions to accept any kind of socket address structure. Today, we would use the generic <code id="P7000497027000000000000000046842" data-uri="chapter11.xhtml#P7000497027000000000000000046842" class="pcalibre1 calibre1 pcalibre2">void</code> * pointer, which did not exist in C at that time. Their solution was to define sockets functions to expect a pointer to a generic <code id="P7000497027000000000000000046843" data-uri="chapter11.xhtml#P7000497027000000000000000046843" class="pcalibre1 calibre1 pcalibre2">sockaddr</code> structure (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007CCE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.13</span></a>) and then require applications to cast any pointers to protocol-specific structures to this generic structure. To simplify our code examples, we follow Stevens's lead and define the following type:</p>
<pre id="P7000497027000000000000000046844" data-uri="chapter11.xhtml#P7000497027000000000000000046844" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046845" data-uri="chapter11.xhtml#P7000497027000000000000000046845" class="calibre3 pcalibre1 pcalibre2">typedef struct sockaddr SA;</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046846" data-uri="chapter11.xhtml#P7000497027000000000000000046846"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007CE3" title="934" data-uri="chapter11.xhtml#P7000497027000000000000000007CE3" epub:type="pagebreak"></span>We then use this type whenever we need to cast a <code id="P7000497027000000000000000046847" data-uri="chapter11.xhtml#P7000497027000000000000000046847" class="pcalibre1 calibre1 pcalibre2">sockaddr_in</code> structure to a generic <code id="P7000497027000000000000000046848" data-uri="chapter11.xhtml#P7000497027000000000000000046848" class="pcalibre1 calibre1 pcalibre2">sockaddr</code> structure.</p>
</section>
<section id="P7000497027000000000000000007CE6" data-uri="chapter11.xhtml#P7000497027000000000000000007CE6" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046849" data-uri="chapter11.xhtml#P7000497027000000000000000046849" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.2 </span>The <code id="P700049702700000000000000004684A" data-uri="chapter11.xhtml#P700049702700000000000000004684A" class="pcalibre1 calibre1 pcalibre2">socket</code> Function</h1></header>
<p id="P700049702700000000000000004684B" data-uri="chapter11.xhtml#P700049702700000000000000004684B" class="pcalibre8 pcalibre1 pcalibre2">Clients and servers use the <code id="P700049702700000000000000004684C" data-uri="chapter11.xhtml#P700049702700000000000000004684C" class="pcalibre1 calibre1 pcalibre2">socket</code> function to create a <i class="pcalibre17 pcalibre2 pcalibre1">socket descriptor</i>.</p>
<pre id="P700049702700000000000000004684D" data-uri="chapter11.xhtml#P700049702700000000000000004684D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004684E" data-uri="chapter11.xhtml#P700049702700000000000000004684E" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);
				Returns: nonnegative descriptor if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004684F" data-uri="chapter11.xhtml#P700049702700000000000000004684F">If we wanted the socket to be the end point for a connection, then we could call socket with the following hardcoded arguments:</p>
<pre id="P7000497027000000000000000046850" data-uri="chapter11.xhtml#P7000497027000000000000000046850" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046851" data-uri="chapter11.xhtml#P7000497027000000000000000046851" class="calibre3 pcalibre1 pcalibre2">clientfd = Socket(AF_INET, SOCK_STREAM, 0);</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046852" data-uri="chapter11.xhtml#P7000497027000000000000000046852">where AF_INET indicates that we are using 32-bit IP addresses and SOCK_STREAM indicates that the socket will be an end point for a connection. However, the best practice is to use the <code id="P7000497027000000000000000046853" data-uri="chapter11.xhtml#P7000497027000000000000000046853" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007D50"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.7</span></a>) to generate these parameters automatically, so that the code is protocol-independent. We will show you how to use <code id="P7000497027000000000000000046854" data-uri="chapter11.xhtml#P7000497027000000000000000046854" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> with the <code id="P7000497027000000000000000046855" data-uri="chapter11.xhtml#P7000497027000000000000000046855" class="pcalibre1 calibre1 pcalibre2">socket</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E0B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.8</span></a>.</p>
<p id="P7000497027000000000000000046856" data-uri="chapter11.xhtml#P7000497027000000000000000046856" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046857" data-uri="chapter11.xhtml#P7000497027000000000000000046857" class="pcalibre1 calibre1 pcalibre2">clientfd</code> descriptor returned by <code id="P7000497027000000000000000046858" data-uri="chapter11.xhtml#P7000497027000000000000000046858" class="pcalibre1 calibre1 pcalibre2">socket</code> is only partially opened and cannot yet be used for reading and writing. How we finish opening the socket depends on whether we are a client or a server. The next section describes how we finish opening the socket if we are a client.</p>
</section>
<section id="P7000497027000000000000000007CF7" data-uri="chapter11.xhtml#P7000497027000000000000000007CF7" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046859" data-uri="chapter11.xhtml#P7000497027000000000000000046859" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.3 </span>The <code id="P700049702700000000000000004685A" data-uri="chapter11.xhtml#P700049702700000000000000004685A" class="pcalibre1 calibre1 pcalibre2">connect</code> Function</h1></header>
<p id="P700049702700000000000000004685B" data-uri="chapter11.xhtml#P700049702700000000000000004685B" class="pcalibre8 pcalibre1 pcalibre2">A client establishes a connection with a server by calling the <code id="P700049702700000000000000004685C" data-uri="chapter11.xhtml#P700049702700000000000000004685C" class="pcalibre1 calibre1 pcalibre2">connect</code> function.</p>
<pre id="P700049702700000000000000004685D" data-uri="chapter11.xhtml#P700049702700000000000000004685D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004685E" data-uri="chapter11.xhtml#P700049702700000000000000004685E" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/socket.h&gt;
int connect(int clientfd, const struct sockaddr *addr,
			socklen_t addrlen);
							Returns: 0 if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004685F" data-uri="chapter11.xhtml#P700049702700000000000000004685F">The <code id="P7000497027000000000000000046860" data-uri="chapter11.xhtml#P7000497027000000000000000046860" class="pcalibre1 calibre1 pcalibre2">connect</code> function attempts to establish an Internet connection with the server at socket address <code id="P7000497027000000000000000046861" data-uri="chapter11.xhtml#P7000497027000000000000000046861" class="pcalibre1 calibre1 pcalibre2">addr</code>, where <code id="P7000497027000000000000000046862" data-uri="chapter11.xhtml#P7000497027000000000000000046862" class="pcalibre1 calibre1 pcalibre2">addrlen</code> is <code id="P7000497027000000000000000046863" data-uri="chapter11.xhtml#P7000497027000000000000000046863" class="pcalibre1 calibre1 pcalibre2">sizeof(sockaddr_in)</code>. The <code id="P7000497027000000000000000046864" data-uri="chapter11.xhtml#P7000497027000000000000000046864" class="pcalibre1 calibre1 pcalibre2">connect</code> function blocks until either the connection is successfully established or an error occurs. If successful, the <code id="P7000497027000000000000000046865" data-uri="chapter11.xhtml#P7000497027000000000000000046865" class="pcalibre1 calibre1 pcalibre2">clientfd</code> descriptor is now ready for reading and writing, and the resulting connection is characterized by the socket pair</p>
<pre id="P7000497027000000000000000046866" data-uri="chapter11.xhtml#P7000497027000000000000000046866" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046867" data-uri="chapter11.xhtml#P7000497027000000000000000046867" class="calibre3 pcalibre1 pcalibre2">(x:y, addr.sin_addr:addr.sin_port)</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046868" data-uri="chapter11.xhtml#P7000497027000000000000000046868"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007D08" title="935" data-uri="chapter11.xhtml#P7000497027000000000000000007D08" epub:type="pagebreak"></span>where <code id="P7000497027000000000000000046869" data-uri="chapter11.xhtml#P7000497027000000000000000046869" class="pcalibre1 calibre1 pcalibre2">x</code> is the client's IP address and <code id="P700049702700000000000000004686A" data-uri="chapter11.xhtml#P700049702700000000000000004686A" class="pcalibre1 calibre1 pcalibre2">y</code> is the ephemeral port that uniquely identifies the client process on the client host. As with <code id="P700049702700000000000000004686B" data-uri="chapter11.xhtml#P700049702700000000000000004686B" class="pcalibre1 calibre1 pcalibre2">socket</code>, the best practice is to use <code id="P700049702700000000000000004686C" data-uri="chapter11.xhtml#P700049702700000000000000004686C" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> to supply the arguments to <code id="P700049702700000000000000004686D" data-uri="chapter11.xhtml#P700049702700000000000000004686D" class="pcalibre1 calibre1 pcalibre2">connect</code> (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E0B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.8</span></a>).</p>
</section>
<section id="P7000497027000000000000000007D0E" data-uri="chapter11.xhtml#P7000497027000000000000000007D0E" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004686E" data-uri="chapter11.xhtml#P700049702700000000000000004686E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.4 </span>The <code id="P700049702700000000000000004686F" data-uri="chapter11.xhtml#P700049702700000000000000004686F" class="pcalibre1 calibre1 pcalibre2">bind</code> Function</h1></header>
<p id="P7000497027000000000000000046870" data-uri="chapter11.xhtml#P7000497027000000000000000046870" class="pcalibre8 pcalibre1 pcalibre2">The remaining sockets functions—<code id="P7000497027000000000000000046871" data-uri="chapter11.xhtml#P7000497027000000000000000046871" class="pcalibre1 calibre1 pcalibre2">bind, listen</code>, and <code id="P7000497027000000000000000046872" data-uri="chapter11.xhtml#P7000497027000000000000000046872" class="pcalibre1 calibre1 pcalibre2">accept</code>—are used by servers to establish connections with clients.</p>
<pre id="P7000497027000000000000000046873" data-uri="chapter11.xhtml#P7000497027000000000000000046873" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046874" data-uri="chapter11.xhtml#P7000497027000000000000000046874" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/socket.h&gt;
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
				Returns: 0 if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046875" data-uri="chapter11.xhtml#P7000497027000000000000000046875">The <code id="P7000497027000000000000000046876" data-uri="chapter11.xhtml#P7000497027000000000000000046876" class="pcalibre1 calibre1 pcalibre2">bind</code> function asks the kernel to associate the server's socket address in <code id="P7000497027000000000000000046877" data-uri="chapter11.xhtml#P7000497027000000000000000046877" class="pcalibre1 calibre1 pcalibre2">addr</code> with the socket descriptor <code id="P7000497027000000000000000046878" data-uri="chapter11.xhtml#P7000497027000000000000000046878" class="pcalibre1 calibre1 pcalibre2">sockfd</code>. The <code id="P7000497027000000000000000046879" data-uri="chapter11.xhtml#P7000497027000000000000000046879" class="pcalibre1 calibre1 pcalibre2">addrlen</code> argument is <code id="P700049702700000000000000004687A" data-uri="chapter11.xhtml#P700049702700000000000000004687A" class="pcalibre1 calibre1 pcalibre2">sizeof(sockaddr_in)</code>. As with <code id="P700049702700000000000000004687B" data-uri="chapter11.xhtml#P700049702700000000000000004687B" class="pcalibre1 calibre1 pcalibre2">socket</code> and <code id="P700049702700000000000000004687C" data-uri="chapter11.xhtml#P700049702700000000000000004687C" class="pcalibre1 calibre1 pcalibre2">connect</code>, the best practice is to use <code id="P700049702700000000000000004687D" data-uri="chapter11.xhtml#P700049702700000000000000004687D" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> to supply the arguments to <code id="P700049702700000000000000004687E" data-uri="chapter11.xhtml#P700049702700000000000000004687E" class="pcalibre1 calibre1 pcalibre2">bind</code> (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E0B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4.8</span></a>).</p>
</section>
<section id="P7000497027000000000000000007D20" data-uri="chapter11.xhtml#P7000497027000000000000000007D20" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004687F" data-uri="chapter11.xhtml#P700049702700000000000000004687F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.5 </span>The <code id="P7000497027000000000000000046880" data-uri="chapter11.xhtml#P7000497027000000000000000046880" class="pcalibre1 calibre1 pcalibre2">listen</code> Function</h1></header>
<p id="P7000497027000000000000000046881" data-uri="chapter11.xhtml#P7000497027000000000000000046881" class="pcalibre8 pcalibre1 pcalibre2">Clients are active entities that initiate connection requests. Servers are passive entities that wait for connection requests from clients. By default, the kernel assumes that a descriptor created by the <code id="P7000497027000000000000000046882" data-uri="chapter11.xhtml#P7000497027000000000000000046882" class="pcalibre1 calibre1 pcalibre2">socket</code> function corresponds to an <i class="pcalibre17 pcalibre2 pcalibre1">active socket</i> that will live on the client end of a connection. A server calls the <code id="P7000497027000000000000000046883" data-uri="chapter11.xhtml#P7000497027000000000000000046883" class="pcalibre1 calibre1 pcalibre2">listen</code> function to tell the kernel that the descriptor will be used by a server instead of a client.</p>
<pre id="P7000497027000000000000000046884" data-uri="chapter11.xhtml#P7000497027000000000000000046884" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046885" data-uri="chapter11.xhtml#P7000497027000000000000000046885" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/socket.h&gt;
int listen(int sockfd, int backlog);
				Returns: 0 if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046886" data-uri="chapter11.xhtml#P7000497027000000000000000046886">The <code id="P7000497027000000000000000046887" data-uri="chapter11.xhtml#P7000497027000000000000000046887" class="pcalibre1 calibre1 pcalibre2">listen</code> function converts <code id="P7000497027000000000000000046888" data-uri="chapter11.xhtml#P7000497027000000000000000046888" class="pcalibre1 calibre1 pcalibre2">sockfd</code> from an active socket to a <i class="pcalibre17 pcalibre2 pcalibre1">listening socket</i> that can accept connection requests from clients. The <code id="P7000497027000000000000000046889" data-uri="chapter11.xhtml#P7000497027000000000000000046889" class="pcalibre1 calibre1 pcalibre2">backlog</code> argument is a hint about the number of outstanding connection requests that the kernel should queue up before it starts to refuse requests. The exact meaning of the <code id="P700049702700000000000000004688A" data-uri="chapter11.xhtml#P700049702700000000000000004688A" class="pcalibre1 calibre1 pcalibre2">backlog</code> argument requires an understanding of TCP/IP that is beyond our scope. We will typically set it to a large value, such as 1,024.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007D2D" data-uri="chapter11.xhtml#P7000497027000000000000000007D2D">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007D2E" title="936" data-uri="chapter11.xhtml#P7000497027000000000000000007D2E" epub:type="pagebreak"></span>
<img alt="A diagram illustrates three roles of the listening and connected descriptors." id="P700049702700000000000000004688B" data-uri="P700049702700000000000000000B7C6" src="../images/p936-1.png" class="pcalibre1 pcalibre2 calibre85"/>
<figcaption id="P700049702700000000000000004688C" data-uri="chapter11.xhtml#P700049702700000000000000004688C" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004688D" data-uri="chapter11.xhtml#P700049702700000000000000004688D" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">11.14 </span>The roles of the listening and connected descriptors.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000026BFB" data-uri="chapter11.xhtml#P7000497027000000000000000026BFB">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P700049702700000000000000004688E" data-uri="chapter11.xhtml#P700049702700000000000000004688E" class="pcalibre8 pcalibre1 pcalibre2">The three steps are summarized below.</p>
<ol id="P700049702700000000000000004688F" data-uri="chapter11.xhtml#P700049702700000000000000004688F" class="pcalibre75 pcalibre2 pcalibre1">
<li id="P7000497027000000000000000046890" data-uri="chapter11.xhtml#P7000497027000000000000000046890" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046891" data-uri="chapter11.xhtml#P7000497027000000000000000046891" class="pcalibre1 pcalibre2 pcalibre10">Server blocks in accept, waiting for connection request on listening descriptor listenfd (Client shown with clientfd and server with listenfd(3))</p></li>
<li id="P7000497027000000000000000046892" data-uri="chapter11.xhtml#P7000497027000000000000000046892" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046893" data-uri="chapter11.xhtml#P7000497027000000000000000046893" class="pcalibre1 pcalibre2 pcalibre10">Client makes connection request by calling and blocking in connect. (Connection request from client to listen(3) on server)</p></li>
<li id="P7000497027000000000000000046894" data-uri="chapter11.xhtml#P7000497027000000000000000046894" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046895" data-uri="chapter11.xhtml#P7000497027000000000000000046895" class="pcalibre1 pcalibre2 pcalibre10">Server returns connfd from accept. Client returns from connect. Connection is now established between clientfd and connfd. (Connection between clientfd and connfd(4) on server)</p></li>
</ol>
</details>
</figcaption>
</figure>
</section>
<section id="P7000497027000000000000000007D32" data-uri="chapter11.xhtml#P7000497027000000000000000007D32" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046896" data-uri="chapter11.xhtml#P7000497027000000000000000046896" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.6 </span>The <code id="P7000497027000000000000000046897" data-uri="chapter11.xhtml#P7000497027000000000000000046897" class="pcalibre1 calibre1 pcalibre2">accept</code> Function</h1></header>
<p id="P7000497027000000000000000046898" data-uri="chapter11.xhtml#P7000497027000000000000000046898" class="pcalibre8 pcalibre1 pcalibre2">Servers wait for connection requests from clients by calling the <code id="P7000497027000000000000000046899" data-uri="chapter11.xhtml#P7000497027000000000000000046899" class="pcalibre1 calibre1 pcalibre2">accept</code> function.</p>
<pre id="P700049702700000000000000004689A" data-uri="chapter11.xhtml#P700049702700000000000000004689A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004689B" data-uri="chapter11.xhtml#P700049702700000000000000004689B" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/socket.h&gt;
int accept(int listenfd, struct sockaddr *addr, int *addrlen);
				Returns: nonnegative connected descriptor if OK, −1 on error
</code></pre>
<p id="P700049702700000000000000004689C" data-uri="chapter11.xhtml#P700049702700000000000000004689C" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P700049702700000000000000004689D" data-uri="chapter11.xhtml#P700049702700000000000000004689D" class="pcalibre1 calibre1 pcalibre2">accept</code> function waits for a connection request from a client to arrive on the listening descriptor <code id="P700049702700000000000000004689E" data-uri="chapter11.xhtml#P700049702700000000000000004689E" class="pcalibre1 calibre1 pcalibre2">listenfd</code>, then fills in the client's socket address in <code id="P700049702700000000000000004689F" data-uri="chapter11.xhtml#P700049702700000000000000004689F" class="pcalibre1 calibre1 pcalibre2">addr</code>, and returns a <i class="pcalibre17 pcalibre2 pcalibre1">connected descriptor</i> that can be used to communicate with the client using Unix I/O functions.</p>
<p id="P70004970270000000000000000468A0" data-uri="chapter11.xhtml#P70004970270000000000000000468A0" class="pcalibre8 pcalibre1 pcalibre2">The distinction between a listening descriptor and a connected descriptor confuses many students. The listening descriptor serves as an end point for client connection requests. It is typically created once and exists for the lifetime of the server. The connected descriptor is the end point of the connection that is established between the client and the server. It is created each time the server accepts a connection request and exists only as long as it takes the server to service a client.</p>
<p id="P70004970270000000000000000468A1" data-uri="chapter11.xhtml#P70004970270000000000000000468A1" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007D2D"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.14</span></a> outlines the roles of the listening and connected descriptors. In step 1, the server calls <code id="P70004970270000000000000000468A2" data-uri="chapter11.xhtml#P70004970270000000000000000468A2" class="pcalibre1 calibre1 pcalibre2">accept</code>, which waits for a connection request to arrive on the listening descriptor, which for concreteness we will assume is descriptor 3. Recall that descriptors 0−2 are reserved for the standard files.</p>
<p id="P70004970270000000000000000468A3" data-uri="chapter11.xhtml#P70004970270000000000000000468A3" class="pcalibre8 pcalibre1 pcalibre2">In step 2, the client calls the <code id="P70004970270000000000000000468A4" data-uri="chapter11.xhtml#P70004970270000000000000000468A4" class="pcalibre1 calibre1 pcalibre2">connect</code> function, which sends a connection request to <code id="P70004970270000000000000000468A5" data-uri="chapter11.xhtml#P70004970270000000000000000468A5" class="pcalibre1 calibre1 pcalibre2">listenfd</code>. In step 3, the <code id="P70004970270000000000000000468A6" data-uri="chapter11.xhtml#P70004970270000000000000000468A6" class="pcalibre1 calibre1 pcalibre2">accept</code> function opens a new connected descriptor <code id="P70004970270000000000000000468A7" data-uri="chapter11.xhtml#P70004970270000000000000000468A7" class="pcalibre1 calibre1 pcalibre2">connfd</code> (which we will assume is descriptor 4), establishes the connection between <code id="P70004970270000000000000000468A8" data-uri="chapter11.xhtml#P70004970270000000000000000468A8" class="pcalibre1 calibre1 pcalibre2">clientfd</code> and <code id="P70004970270000000000000000468A9" data-uri="chapter11.xhtml#P70004970270000000000000000468A9" class="pcalibre1 calibre1 pcalibre2">connfd</code>, and then returns <code id="P70004970270000000000000000468AA" data-uri="chapter11.xhtml#P70004970270000000000000000468AA" class="pcalibre1 calibre1 pcalibre2">connfd</code> to the application. The</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000007D48" data-uri="chapter11.xhtml#P7000497027000000000000000007D48"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P70004970270000000000000000468AB" data-uri="chapter11.xhtml#P70004970270000000000000000468AB" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007D4A" title="937" data-uri="chapter11.xhtml#P7000497027000000000000000007D4A" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Why the distinction between listening and connected descriptors?</h1></header>
<p id="P70004970270000000000000000468AC" data-uri="chapter11.xhtml#P70004970270000000000000000468AC" class="pcalibre1 pcalibre2 pcalibre10">You might wonder why the sockets interface makes a distinction between listening and connected descriptors. At first glance, it appears to be an unnecessary complication. However, distinguishing between the two turns out to be quite useful, because it allows us to build concurrent servers that can process many client connections simultaneously. For example, each time a connection request arrives on the listening descriptor, we might fork a new process that communicates with the client over its connected descriptor. You'll learn more about concurrent servers in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">12</span></a>.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000468AD" data-uri="chapter11.xhtml#P70004970270000000000000000468AD">client also returns from the <code id="P70004970270000000000000000468AE" data-uri="chapter11.xhtml#P70004970270000000000000000468AE" class="pcalibre1 calibre1 pcalibre2">connect</code>, and from this point, the client and server can pass data back and forth by reading and writing <code id="P70004970270000000000000000468AF" data-uri="chapter11.xhtml#P70004970270000000000000000468AF" class="pcalibre1 calibre1 pcalibre2">clientfd</code> and <code id="P70004970270000000000000000468B0" data-uri="chapter11.xhtml#P70004970270000000000000000468B0" class="pcalibre1 calibre1 pcalibre2">connfd</code>, respectively.</p>
</section>
<section id="P7000497027000000000000000007D50" data-uri="chapter11.xhtml#P7000497027000000000000000007D50" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000468B1" data-uri="chapter11.xhtml#P70004970270000000000000000468B1" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.7 </span>Host and Service Conversion</h1></header>
<p id="P70004970270000000000000000468B2" data-uri="chapter11.xhtml#P70004970270000000000000000468B2" class="pcalibre8 pcalibre1 pcalibre2">Linux provides some powerful functions, called <code id="P70004970270000000000000000468B3" data-uri="chapter11.xhtml#P70004970270000000000000000468B3" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> and <code id="P70004970270000000000000000468B4" data-uri="chapter11.xhtml#P70004970270000000000000000468B4" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code>, for converting back and forth between binary socket address structures and the string representations of hostnames, host addresses, service names, and port numbers. When used in conjunction with the sockets interface, they allow us to write network programs that are independent of any particular version of the IP protocol.</p>
<section id="P7000497027000000000000000007D55" data-uri="chapter11.xhtml#P7000497027000000000000000007D55" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000468B5" data-uri="chapter11.xhtml#P70004970270000000000000000468B5" epub:type="title">The <code id="P70004970270000000000000000468B6" data-uri="chapter11.xhtml#P70004970270000000000000000468B6" class="pcalibre1 pcalibre2 calibre16">getaddrinfo</code> Function</h1></header>
<p id="P70004970270000000000000000468B7" data-uri="chapter11.xhtml#P70004970270000000000000000468B7" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P70004970270000000000000000468B8" data-uri="chapter11.xhtml#P70004970270000000000000000468B8" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> function converts string representations of hostnames, host addresses, service names, and port numbers into socket address structures. It is the modern replacement for the obsolete <code id="P70004970270000000000000000468B9" data-uri="chapter11.xhtml#P70004970270000000000000000468B9" class="pcalibre1 calibre1 pcalibre2">gethostbyname</code> and <code id="P70004970270000000000000000468BA" data-uri="chapter11.xhtml#P70004970270000000000000000468BA" class="pcalibre1 calibre1 pcalibre2">getservbyname</code> functions. Unlike these functions, it is reentrant (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008577.xhtml#P70004970270000000000000000085BA"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7.2</span></a>) and works with any protocol.</p>
<pre id="P70004970270000000000000000468BB" data-uri="chapter11.xhtml#P70004970270000000000000000468BB" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000468BC" data-uri="chapter11.xhtml#P70004970270000000000000000468BC" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
int getaddrinfo(const char *host, const char *service,
			const struct addrinfo *hints,
			struct addrinfo **result);
					Returns: 0 if OK, nonzero error code on error
void freeaddrinfo(struct addrinfo *result);
				Returns: nothing
const char *gai_strerror(int errcode);
				Returns: error message
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007D5E" data-uri="chapter11.xhtml#P7000497027000000000000000007D5E">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007D5F" title="938" data-uri="chapter11.xhtml#P7000497027000000000000000007D5F" epub:type="pagebreak"></span>
<img alt="A diagram shows lists of data structure returned by getaddrinfo." id="P70004970270000000000000000468BD" data-uri="P700049702700000000000000000B7C7" src="../images/p938-1.png" class="pcalibre1 pcalibre2 calibre86"/>
<figcaption id="P70004970270000000000000000468BE" data-uri="chapter11.xhtml#P70004970270000000000000000468BE" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000468BF" data-uri="chapter11.xhtml#P70004970270000000000000000468BF" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.15 </span>Data structure returned by <code id="P70004970270000000000000000468C0" data-uri="chapter11.xhtml#P70004970270000000000000000468C0" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code>.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000026C2F" data-uri="chapter11.xhtml#P7000497027000000000000000026C2F">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000468C1" data-uri="chapter11.xhtml#P70004970270000000000000000468C1" class="pcalibre8 pcalibre1 pcalibre2">A diagram shows a result leading to a list of addrinfo structs, leading to others as follows:</p>
<ul id="P70004970270000000000000000468C2" data-uri="chapter11.xhtml#P70004970270000000000000000468C2" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000468C3" data-uri="chapter11.xhtml#P70004970270000000000000000468C3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000468C4" data-uri="chapter11.xhtml#P70004970270000000000000000468C4" class="pcalibre1 pcalibre2 pcalibre10">Ai_canonname, to cell under result</p></li>
<li id="P70004970270000000000000000468C5" data-uri="chapter11.xhtml#P70004970270000000000000000468C5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000468C6" data-uri="chapter11.xhtml#P70004970270000000000000000468C6" class="pcalibre1 pcalibre2 pcalibre10">Ai_addr, to socket address struct</p></li>
<li id="P70004970270000000000000000468C7" data-uri="chapter11.xhtml#P70004970270000000000000000468C7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000468C8" data-uri="chapter11.xhtml#P70004970270000000000000000468C8" class="pcalibre1 pcalibre2 pcalibre10">Ai_next, to next list:</p>
<ul id="P70004970270000000000000000468C9" data-uri="chapter11.xhtml#P70004970270000000000000000468C9" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P70004970270000000000000000468CA" data-uri="chapter11.xhtml#P70004970270000000000000000468CA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000468CB" data-uri="chapter11.xhtml#P70004970270000000000000000468CB" class="pcalibre1 pcalibre2 pcalibre10">NULL</p></li>
<li id="P70004970270000000000000000468CC" data-uri="chapter11.xhtml#P70004970270000000000000000468CC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000468CD" data-uri="chapter11.xhtml#P70004970270000000000000000468CD" class="pcalibre1 pcalibre2 pcalibre10">Ai_addr, to socket address struct</p></li>
<li id="P70004970270000000000000000468CE" data-uri="chapter11.xhtml#P70004970270000000000000000468CE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000468CF" data-uri="chapter11.xhtml#P70004970270000000000000000468CF" class="pcalibre1 pcalibre2 pcalibre10">Ai_next, to next list:</p>
<ul id="P70004970270000000000000000468D0" data-uri="chapter11.xhtml#P70004970270000000000000000468D0" class="pcalibre146 pcalibre2 pcalibre1">
<li id="P70004970270000000000000000468D1" data-uri="chapter11.xhtml#P70004970270000000000000000468D1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000468D2" data-uri="chapter11.xhtml#P70004970270000000000000000468D2" class="pcalibre1 pcalibre2 pcalibre10">NULL</p></li>
<li id="P70004970270000000000000000468D3" data-uri="chapter11.xhtml#P70004970270000000000000000468D3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000468D4" data-uri="chapter11.xhtml#P70004970270000000000000000468D4" class="pcalibre1 pcalibre2 pcalibre10">Ai_addr, to socket address struct</p></li>
<li id="P70004970270000000000000000468D5" data-uri="chapter11.xhtml#P70004970270000000000000000468D5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000468D6" data-uri="chapter11.xhtml#P70004970270000000000000000468D6" class="pcalibre1 pcalibre2 pcalibre10">NULL</p></li>
</ul>
</li></ul>
</li></ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000468D7" data-uri="chapter11.xhtml#P70004970270000000000000000468D7">Given <code id="P70004970270000000000000000468D8" data-uri="chapter11.xhtml#P70004970270000000000000000468D8" class="pcalibre1 calibre1 pcalibre2">host</code> and <code id="P70004970270000000000000000468D9" data-uri="chapter11.xhtml#P70004970270000000000000000468D9" class="pcalibre1 calibre1 pcalibre2">service</code> (the two components of a socket address), <code id="P70004970270000000000000000468DA" data-uri="chapter11.xhtml#P70004970270000000000000000468DA" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> returns a <code id="P70004970270000000000000000468DB" data-uri="chapter11.xhtml#P70004970270000000000000000468DB" class="pcalibre1 calibre1 pcalibre2">result</code> that points to a linked list of <code id="P70004970270000000000000000468DC" data-uri="chapter11.xhtml#P70004970270000000000000000468DC" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structures, each of which points to a socket address structure that corresponds to <code id="P70004970270000000000000000468DD" data-uri="chapter11.xhtml#P70004970270000000000000000468DD" class="pcalibre1 calibre1 pcalibre2">host</code> and <code id="P70004970270000000000000000468DE" data-uri="chapter11.xhtml#P70004970270000000000000000468DE" class="pcalibre1 calibre1 pcalibre2">service</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007D5E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.15</span></a>).</p>
<p id="P70004970270000000000000000468DF" data-uri="chapter11.xhtml#P70004970270000000000000000468DF" class="pcalibre8 pcalibre1 pcalibre2">After a client calls <code id="P70004970270000000000000000468E0" data-uri="chapter11.xhtml#P70004970270000000000000000468E0" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code>, it walks this list, trying each socket address in turn until the calls to <code id="P70004970270000000000000000468E1" data-uri="chapter11.xhtml#P70004970270000000000000000468E1" class="pcalibre1 calibre1 pcalibre2">socket</code> and <code id="P70004970270000000000000000468E2" data-uri="chapter11.xhtml#P70004970270000000000000000468E2" class="pcalibre1 calibre1 pcalibre2">connect</code> succeed and the connection is established. Similarly, a server tries each socket address on the list until the calls to <code id="P70004970270000000000000000468E3" data-uri="chapter11.xhtml#P70004970270000000000000000468E3" class="pcalibre1 calibre1 pcalibre2">socket</code> and <code id="P70004970270000000000000000468E4" data-uri="chapter11.xhtml#P70004970270000000000000000468E4" class="pcalibre1 calibre1 pcalibre2">bind</code> succeed and the descriptor is bound to a valid socket address. To avoid memory leaks, the application must eventually free the list by calling <code id="P70004970270000000000000000468E5" data-uri="chapter11.xhtml#P70004970270000000000000000468E5" class="pcalibre1 calibre1 pcalibre2">freeaddrinfo</code>. If <code id="P70004970270000000000000000468E6" data-uri="chapter11.xhtml#P70004970270000000000000000468E6" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> returns a nonzero error code, the application can call <code id="P70004970270000000000000000468E7" data-uri="chapter11.xhtml#P70004970270000000000000000468E7" class="pcalibre1 calibre1 pcalibre2">gai_strerror</code> to convert the code to a message string.</p>
<p id="P70004970270000000000000000468E8" data-uri="chapter11.xhtml#P70004970270000000000000000468E8" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P70004970270000000000000000468E9" data-uri="chapter11.xhtml#P70004970270000000000000000468E9" class="pcalibre1 calibre1 pcalibre2">host</code> argument to <code id="P70004970270000000000000000468EA" data-uri="chapter11.xhtml#P70004970270000000000000000468EA" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> can be either a domain name or a numeric address (e.g., a dotted-decimal IP address). The <code id="P70004970270000000000000000468EB" data-uri="chapter11.xhtml#P70004970270000000000000000468EB" class="pcalibre1 calibre1 pcalibre2">service</code> argument can be either a service name <code id="P70004970270000000000000000468EC" data-uri="chapter11.xhtml#P70004970270000000000000000468EC" class="pcalibre1 calibre1 pcalibre2">(e.g., http)</code> or a decimal port number. If we are not interested in converting the hostname to an address, we can set <code id="P70004970270000000000000000468ED" data-uri="chapter11.xhtml#P70004970270000000000000000468ED" class="pcalibre1 calibre1 pcalibre2">host</code> to NULL. The same holds for <code id="P70004970270000000000000000468EE" data-uri="chapter11.xhtml#P70004970270000000000000000468EE" class="pcalibre1 calibre1 pcalibre2">service</code>. However, at least one of them must be specified.</p>
<p id="P70004970270000000000000000468EF" data-uri="chapter11.xhtml#P70004970270000000000000000468EF" class="pcalibre8 pcalibre1 pcalibre2">The optional <code id="P70004970270000000000000000468F0" data-uri="chapter11.xhtml#P70004970270000000000000000468F0" class="pcalibre1 calibre1 pcalibre2">hints</code> argument is an <code id="P70004970270000000000000000468F1" data-uri="chapter11.xhtml#P70004970270000000000000000468F1" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structure (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007D88"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.16</span></a>) that provides finer control over the list of socket addresses that <code id="P70004970270000000000000000468F2" data-uri="chapter11.xhtml#P70004970270000000000000000468F2" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> returns. When passed as a hints argument, only the <code id="P70004970270000000000000000468F3" data-uri="chapter11.xhtml#P70004970270000000000000000468F3" class="pcalibre1 calibre1 pcalibre2">ai_family, ai_socktype, ai_protocol</code>, and <code id="P70004970270000000000000000468F4" data-uri="chapter11.xhtml#P70004970270000000000000000468F4" class="pcalibre1 calibre1 pcalibre2">ai_flags</code> fields can be set. The other fields must be set to zero (or NULL). In practice, we use <code id="P70004970270000000000000000468F5" data-uri="chapter11.xhtml#P70004970270000000000000000468F5" class="pcalibre1 calibre1 pcalibre2">memset</code> to zero the entire structure and then set a few selected fields:</p>
<ul id="P70004970270000000000000000468F6" data-uri="chapter11.xhtml#P70004970270000000000000000468F6" class="pcalibre1 calibre9 pcalibre2">
<li id="P70004970270000000000000000468F7" data-uri="chapter11.xhtml#P70004970270000000000000000468F7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000468F8" data-uri="chapter11.xhtml#P70004970270000000000000000468F8" class="pcalibre1 pcalibre2 pcalibre10">By default, <code id="P70004970270000000000000000468F9" data-uri="chapter11.xhtml#P70004970270000000000000000468F9" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> can return both IPv4 and IPv6 socket addresses. Setting <code id="P70004970270000000000000000468FA" data-uri="chapter11.xhtml#P70004970270000000000000000468FA" class="pcalibre1 calibre1 pcalibre2">ai_family</code> to AF_INET restricts the list to IPv4 addresses. Setting it to AF_INET6 restricts the list to IPv6 addresses.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007D88" data-uri="chapter11.xhtml#P7000497027000000000000000007D88">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007D89" title="939" data-uri="chapter11.xhtml#P7000497027000000000000000007D89" epub:type="pagebreak"></span>
<pre id="P70004970270000000000000000468FB" data-uri="chapter11.xhtml#P70004970270000000000000000468FB" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000468FC" data-uri="chapter11.xhtml#P70004970270000000000000000468FC" class="calibre3 pcalibre1 pcalibre2">
struct addrinfo {
	int		ai_flags;	/* Hints argument flags */
	int		ai_family;	/* First arg to socket function */
	int		ai_socktype;	/* Second arg to socket function */
	int		ai_protocol;	/* Third arg to socket function */
	char		*ai_canonname;	/* Canonical hostname */
	size_t		ai_addrlen;	/* Size of ai_addr struct */
	struct sockaddr	*ai_addr;	/* Ptr to socket address structure */
struct addrinfo		*ai_next;	/* Ptr to next item in linked list */
};
</code></pre>
<figcaption id="P70004970270000000000000000468FD" data-uri="chapter11.xhtml#P70004970270000000000000000468FD" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000468FE" data-uri="chapter11.xhtml#P70004970270000000000000000468FE" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.16 </span>The <code id="P70004970270000000000000000468FF" data-uri="chapter11.xhtml#P70004970270000000000000000468FF" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structure used by <code id="P7000497027000000000000000046900" data-uri="chapter11.xhtml#P7000497027000000000000000046900" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code>.</h1></header>
</figcaption>
</figure></li>
<li id="P7000497027000000000000000046901" data-uri="chapter11.xhtml#P7000497027000000000000000046901" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046902" data-uri="chapter11.xhtml#P7000497027000000000000000046902" class="pcalibre1 pcalibre2 pcalibre10">By default, for each unique address associated with host, the <code id="P7000497027000000000000000046903" data-uri="chapter11.xhtml#P7000497027000000000000000046903" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> function can return up to three <code id="P7000497027000000000000000046904" data-uri="chapter11.xhtml#P7000497027000000000000000046904" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structures, each with a different <code id="P7000497027000000000000000046905" data-uri="chapter11.xhtml#P7000497027000000000000000046905" class="pcalibre1 calibre1 pcalibre2">ai_socktype</code> field: one for connections, one for datagrams (not covered), and one for raw sockets (not covered). Setting <code id="P7000497027000000000000000046906" data-uri="chapter11.xhtml#P7000497027000000000000000046906" class="pcalibre1 calibre1 pcalibre2">ai_socktype</code> to SOCK_STREAM restricts the list to at most one <code id="P7000497027000000000000000046907" data-uri="chapter11.xhtml#P7000497027000000000000000046907" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structure for each unique address, one whose socket address can be used as the end point of a connection. This is the desired behavior for all of our example programs.</p></li>
<li id="P7000497027000000000000000046908" data-uri="chapter11.xhtml#P7000497027000000000000000046908" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046909" data-uri="chapter11.xhtml#P7000497027000000000000000046909" class="pcalibre1 pcalibre2 pcalibre10">The <code id="P700049702700000000000000004690A" data-uri="chapter11.xhtml#P700049702700000000000000004690A" class="pcalibre1 calibre1 pcalibre2">ai_flags</code> field is a bit mask that further modifies the default behavior. You create it by <span class="pcalibre1 pcalibre29 pcalibre2">or</span>ing combinations of various values. Here are some that we find useful:</p>
<ul class="pcalibre1 pcalibre2 pcalibre126" id="P700049702700000000000000004690B" data-uri="chapter11.xhtml#P700049702700000000000000004690B">
<li id="P700049702700000000000000004690C" data-uri="chapter11.xhtml#P700049702700000000000000004690C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004690D" data-uri="chapter11.xhtml#P700049702700000000000000004690D" class="pcalibre1 pcalibre2 pcalibre40">AI_ADDRCONFIG. This flag is recommended if you are using connections <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3E5">[34]</a>. It asks <code id="P700049702700000000000000004690E" data-uri="chapter11.xhtml#P700049702700000000000000004690E" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> to return IPv4 addresses only if the local host is configured for IPv4. Similarly for IPv6.</p></li>
<li id="P700049702700000000000000004690F" data-uri="chapter11.xhtml#P700049702700000000000000004690F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046910" data-uri="chapter11.xhtml#P7000497027000000000000000046910" class="pcalibre1 pcalibre2 pcalibre40">AI_CANONNAME. By default, the <code id="P7000497027000000000000000046911" data-uri="chapter11.xhtml#P7000497027000000000000000046911" class="pcalibre1 calibre1 pcalibre2">ai_canonname</code> field is NULL. If this flag is set, it instructs <code id="P7000497027000000000000000046912" data-uri="chapter11.xhtml#P7000497027000000000000000046912" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> to point the <code id="P7000497027000000000000000046913" data-uri="chapter11.xhtml#P7000497027000000000000000046913" class="pcalibre1 calibre1 pcalibre2">ai_canonname</code> field in the first <code id="P7000497027000000000000000046914" data-uri="chapter11.xhtml#P7000497027000000000000000046914" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structure in the list to the canonical (official) name of <code id="P7000497027000000000000000046915" data-uri="chapter11.xhtml#P7000497027000000000000000046915" class="pcalibre1 calibre1 pcalibre2">host</code> (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007D5E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.15</span></a>).</p></li>
<li id="P7000497027000000000000000046916" data-uri="chapter11.xhtml#P7000497027000000000000000046916" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046917" data-uri="chapter11.xhtml#P7000497027000000000000000046917" class="pcalibre1 pcalibre2 pcalibre40">AI_NUMERICSERV. By default, the <code id="P7000497027000000000000000046918" data-uri="chapter11.xhtml#P7000497027000000000000000046918" class="pcalibre1 calibre1 pcalibre2">service</code> argument can be a service name or a port number. This flag forces the <code id="P7000497027000000000000000046919" data-uri="chapter11.xhtml#P7000497027000000000000000046919" class="pcalibre1 calibre1 pcalibre2">service</code> argument to be a port number.</p></li>
<li id="P700049702700000000000000004691A" data-uri="chapter11.xhtml#P700049702700000000000000004691A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004691B" data-uri="chapter11.xhtml#P700049702700000000000000004691B" class="pcalibre1 pcalibre2 pcalibre40">AI_PASSIVE. By default, <code id="P700049702700000000000000004691C" data-uri="chapter11.xhtml#P700049702700000000000000004691C" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> returns socket addresses that can be used by clients as active sockets in calls to <code id="P700049702700000000000000004691D" data-uri="chapter11.xhtml#P700049702700000000000000004691D" class="pcalibre1 calibre1 pcalibre2">connect</code>. This flag instructs it to return socket addresses that can be used by servers as listening sockets. In this case, the <code id="P700049702700000000000000004691E" data-uri="chapter11.xhtml#P700049702700000000000000004691E" class="pcalibre1 calibre1 pcalibre2">host</code> argument should be NULL. The address field in the resulting socket address structure(s) will be the <i class="pcalibre17 pcalibre2 pcalibre1">wildcard address</i>, which tells the kernel that this server will accept requests to any of the IP addresses for this host. This is the desired behavior for all of our example servers.</p></li>
</ul></li>
</ul>
<p id="P700049702700000000000000004691F" data-uri="chapter11.xhtml#P700049702700000000000000004691F" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007DAF" title="940" data-uri="chapter11.xhtml#P7000497027000000000000000007DAF" epub:type="pagebreak"></span>When <code id="P7000497027000000000000000046920" data-uri="chapter11.xhtml#P7000497027000000000000000046920" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> creates an <code id="P7000497027000000000000000046921" data-uri="chapter11.xhtml#P7000497027000000000000000046921" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structure in the output list, it fills in each field except for <code id="P7000497027000000000000000046922" data-uri="chapter11.xhtml#P7000497027000000000000000046922" class="pcalibre1 calibre1 pcalibre2">ai_flags</code>. The <code id="P7000497027000000000000000046923" data-uri="chapter11.xhtml#P7000497027000000000000000046923" class="pcalibre1 calibre1 pcalibre2">ai_addr</code> field points to a socket address structure, the <code id="P7000497027000000000000000046924" data-uri="chapter11.xhtml#P7000497027000000000000000046924" class="pcalibre1 calibre1 pcalibre2">ai_addrlen</code> field gives the size of this socket address structure, and the <code id="P7000497027000000000000000046925" data-uri="chapter11.xhtml#P7000497027000000000000000046925" class="pcalibre1 calibre1 pcalibre2">ai_next</code> field points to the next <code id="P7000497027000000000000000046926" data-uri="chapter11.xhtml#P7000497027000000000000000046926" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structure in the list. The other fields describe various attributes of the socket address.</p>
<p id="P7000497027000000000000000046927" data-uri="chapter11.xhtml#P7000497027000000000000000046927" class="pcalibre8 pcalibre1 pcalibre2">One of the elegant aspects of <code id="P7000497027000000000000000046928" data-uri="chapter11.xhtml#P7000497027000000000000000046928" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> is that the fields in an <code id="P7000497027000000000000000046929" data-uri="chapter11.xhtml#P7000497027000000000000000046929" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structure are opaque, in the sense that they can be passed directly to the functions in the sockets interface without any further manipulation by the application code. For example, <code id="P700049702700000000000000004692A" data-uri="chapter11.xhtml#P700049702700000000000000004692A" class="pcalibre1 calibre1 pcalibre2">ai_family, ai_socktype</code>, and <code id="P700049702700000000000000004692B" data-uri="chapter11.xhtml#P700049702700000000000000004692B" class="pcalibre1 calibre1 pcalibre2">ai_protocol</code> can be passed directly to socket. Similarly, <code id="P700049702700000000000000004692C" data-uri="chapter11.xhtml#P700049702700000000000000004692C" class="pcalibre1 calibre1 pcalibre2">ai_addr</code> and <code id="P700049702700000000000000004692D" data-uri="chapter11.xhtml#P700049702700000000000000004692D" class="pcalibre1 calibre1 pcalibre2">ai_addrlen</code> can be passed directly to <code id="P700049702700000000000000004692E" data-uri="chapter11.xhtml#P700049702700000000000000004692E" class="pcalibre1 calibre1 pcalibre2">connect</code> and <code id="P700049702700000000000000004692F" data-uri="chapter11.xhtml#P700049702700000000000000004692F" class="pcalibre1 calibre1 pcalibre2">bind</code>. This powerful property allows us to write clients and servers that are independent of any particular version of the IP protocol.</p>
</section>
<section id="P7000497027000000000000000007DC0" data-uri="chapter11.xhtml#P7000497027000000000000000007DC0" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046930" data-uri="chapter11.xhtml#P7000497027000000000000000046930" epub:type="title">The <code id="P7000497027000000000000000046931" data-uri="chapter11.xhtml#P7000497027000000000000000046931" class="pcalibre1 pcalibre2 calibre16">getnameinfo</code> Function</h1></header>
<p id="P7000497027000000000000000046932" data-uri="chapter11.xhtml#P7000497027000000000000000046932" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046933" data-uri="chapter11.xhtml#P7000497027000000000000000046933" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code> function is the inverse of <code id="P7000497027000000000000000046934" data-uri="chapter11.xhtml#P7000497027000000000000000046934" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code>. It converts a socket address structure to the corresponding host and service name strings. It is the modern replacement for the obsolete <code id="P7000497027000000000000000046935" data-uri="chapter11.xhtml#P7000497027000000000000000046935" class="pcalibre1 calibre1 pcalibre2">gethostbyaddr</code> and <code id="P7000497027000000000000000046936" data-uri="chapter11.xhtml#P7000497027000000000000000046936" class="pcalibre1 calibre1 pcalibre2">getservbyport</code> functions, and unlike those functions, it is reentrant and protocol-independent.</p>
<pre id="P7000497027000000000000000046937" data-uri="chapter11.xhtml#P7000497027000000000000000046937" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046938" data-uri="chapter11.xhtml#P7000497027000000000000000046938" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
int getnameinfo(const struct sockaddr *sa, socklen_t salen,
				char *host, size_t hostlen,
				char *service, size_t servlen, int flags);
									Returns: 0 if OK, nonzero error code on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046939" data-uri="chapter11.xhtml#P7000497027000000000000000046939">The <code id="P700049702700000000000000004693A" data-uri="chapter11.xhtml#P700049702700000000000000004693A" class="pcalibre1 calibre1 pcalibre2">sa</code> argument points to a socket address structure of size <code id="P700049702700000000000000004693B" data-uri="chapter11.xhtml#P700049702700000000000000004693B" class="pcalibre1 calibre1 pcalibre2">salen</code> bytes, <code id="P700049702700000000000000004693C" data-uri="chapter11.xhtml#P700049702700000000000000004693C" class="pcalibre1 calibre1 pcalibre2">host</code> to a buffer of size <code id="P700049702700000000000000004693D" data-uri="chapter11.xhtml#P700049702700000000000000004693D" class="pcalibre1 calibre1 pcalibre2">hostlen</code> bytes, and <code id="P700049702700000000000000004693E" data-uri="chapter11.xhtml#P700049702700000000000000004693E" class="pcalibre1 calibre1 pcalibre2">service</code> to a buffer of size <code id="P700049702700000000000000004693F" data-uri="chapter11.xhtml#P700049702700000000000000004693F" class="pcalibre1 calibre1 pcalibre2">servlen</code> bytes. The <code id="P7000497027000000000000000046940" data-uri="chapter11.xhtml#P7000497027000000000000000046940" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code> function converts the socket address structure <code id="P7000497027000000000000000046941" data-uri="chapter11.xhtml#P7000497027000000000000000046941" class="pcalibre1 calibre1 pcalibre2">sa</code> to the corresponding <code id="P7000497027000000000000000046942" data-uri="chapter11.xhtml#P7000497027000000000000000046942" class="pcalibre1 calibre1 pcalibre2">host</code> and <code id="P7000497027000000000000000046943" data-uri="chapter11.xhtml#P7000497027000000000000000046943" class="pcalibre1 calibre1 pcalibre2">service</code> name strings and copies them to the <code id="P7000497027000000000000000046944" data-uri="chapter11.xhtml#P7000497027000000000000000046944" class="pcalibre1 calibre1 pcalibre2">host</code> and <code id="P7000497027000000000000000046945" data-uri="chapter11.xhtml#P7000497027000000000000000046945" class="pcalibre1 calibre1 pcalibre2">service</code> buffers. If <code id="P7000497027000000000000000046946" data-uri="chapter11.xhtml#P7000497027000000000000000046946" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code> returns a nonzero error code, the application can convert it to a string by calling <code id="P7000497027000000000000000046947" data-uri="chapter11.xhtml#P7000497027000000000000000046947" class="pcalibre1 calibre1 pcalibre2">gai_strerror</code>.</p>
<p id="P7000497027000000000000000046948" data-uri="chapter11.xhtml#P7000497027000000000000000046948" class="pcalibre8 pcalibre1 pcalibre2">If we don't want the hostname, we can <code id="P7000497027000000000000000046949" data-uri="chapter11.xhtml#P7000497027000000000000000046949" class="pcalibre1 calibre1 pcalibre2">set host</code> to NULL and <code id="P700049702700000000000000004694A" data-uri="chapter11.xhtml#P700049702700000000000000004694A" class="pcalibre1 calibre1 pcalibre2">hostlen</code> to zero. The same holds for the service fields. However, one or the other must be set.</p>
<p id="P700049702700000000000000004694B" data-uri="chapter11.xhtml#P700049702700000000000000004694B" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P700049702700000000000000004694C" data-uri="chapter11.xhtml#P700049702700000000000000004694C" class="pcalibre1 calibre1 pcalibre2">flags</code> argument is a bit mask that modifies the default behavior. You create it by <span class="pcalibre1 pcalibre29 pcalibre2">or</span>ing combinations of various values. Here are a couple of useful ones:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P700049702700000000000000004694D" data-uri="chapter11.xhtml#P700049702700000000000000004694D">
<li id="P700049702700000000000000004694E" data-uri="chapter11.xhtml#P700049702700000000000000004694E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004694F" data-uri="chapter11.xhtml#P700049702700000000000000004694F" class="pcalibre1 pcalibre2 pcalibre40">NI_NUMERICHOST. By default, <code id="P7000497027000000000000000046950" data-uri="chapter11.xhtml#P7000497027000000000000000046950" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code> tries to return a domain name in <code id="P7000497027000000000000000046951" data-uri="chapter11.xhtml#P7000497027000000000000000046951" class="pcalibre1 calibre1 pcalibre2">host</code>. Setting this flag will cause it to return a numeric address string instead.</p></li>
<li id="P7000497027000000000000000046952" data-uri="chapter11.xhtml#P7000497027000000000000000046952" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046953" data-uri="chapter11.xhtml#P7000497027000000000000000046953" class="pcalibre1 pcalibre2 pcalibre40">NI_NUMERICSERV. By default, <code id="P7000497027000000000000000046954" data-uri="chapter11.xhtml#P7000497027000000000000000046954" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code> will look in <code id="P7000497027000000000000000046955" data-uri="chapter11.xhtml#P7000497027000000000000000046955" class="pcalibre1 calibre1 pcalibre2">/etc/services</code> and if possible, return a service name instead of a port number. Setting this flag forces it to skip the lookup and simply return the port number.</p></li>
</ul>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007DE7" data-uri="chapter11.xhtml#P7000497027000000000000000007DE7">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007DE8" title="941" data-uri="chapter11.xhtml#P7000497027000000000000000007DE8" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046956" data-uri="chapter11.xhtml#P7000497027000000000000000046956" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046957" data-uri="chapter11.xhtml#P7000497027000000000000000046957" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	
3	int main(int argc, char **argv)
4	{
5		struct addrinfo *p, *listp, hints;
6		char buf[MAXLINE];
7		int rc, flags;
8	
9		if (argc != 2) {
10			fprintf(stderr, "usage: %s &lt;domain name&gt;\n", argv[0]);
11			exit(0);
12		}
13	
14		/* Get a list of addrinfo records */
15		memset(&amp;hints, 0, sizeof(struct addrinfo));
16		hints.ai_family = AF_INET; /* IPv4 only */
17		hints.ai_socktype = SOCK_STREAM; /* Connections only */
18		if ((rc = getaddrinfo(argv[1], NULL, &amp;hints, &amp;listp)) != 0) {
19			fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(rc));
20			exit(1);
21	}
22	
23		/* Walk the list and display each IP address */
24		flags = NI_NUMERICHOST; /* Display address string instead of domain name */
25		for (p = listp; p; p = p-&gt;ai_next) {
26			Getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, NULL, 0, flags);
27			printf("%s\n", buf);
28		}
29	
30		/* Clean up */
31		Freeaddrinfo(listp);
32	
33		exit(0);
34	}
</code></pre>
<figcaption id="P7000497027000000000000000046958" data-uri="chapter11.xhtml#P7000497027000000000000000046958" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046959" data-uri="chapter11.xhtml#P7000497027000000000000000046959" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.17 </span>H<span class="pcalibre1 pcalibre2 pcalibre84">ostinfo</span> displays the mapping of a domain name to its associated IP addresses.</h1></header>
</figcaption>
</figure>
<p id="P700049702700000000000000004695A" data-uri="chapter11.xhtml#P700049702700000000000000004695A" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007DE7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.17</span></a> shows a simple program, called <span class="pcalibre1 pcalibre29 pcalibre2">hostinfo</span>, that uses <code id="P700049702700000000000000004695B" data-uri="chapter11.xhtml#P700049702700000000000000004695B" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> and <code id="P700049702700000000000000004695C" data-uri="chapter11.xhtml#P700049702700000000000000004695C" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code> to display the mapping of a domain name to its associated IP addresses. It is similar to the <span class="pcalibre1 pcalibre29 pcalibre2">nslookup </span>program from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007BFE.xhtml#P7000497027000000000000000007C6B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.3.2</span></a>.</p>
<p id="P700049702700000000000000004695D" data-uri="chapter11.xhtml#P700049702700000000000000004695D" class="pcalibre8 pcalibre1 pcalibre2">First, we initialize the <code id="P700049702700000000000000004695E" data-uri="chapter11.xhtml#P700049702700000000000000004695E" class="pcalibre1 calibre1 pcalibre2">hints</code> structure so that <code id="P700049702700000000000000004695F" data-uri="chapter11.xhtml#P700049702700000000000000004695F" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> returns the addresses we want. In this case, we are looking for 32-bit IP addresses (line 16) <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007DF3" title="942" data-uri="chapter11.xhtml#P7000497027000000000000000007DF3" epub:type="pagebreak"></span>that can be used as end points of connections (line 17). Since we are only asking <code id="P7000497027000000000000000046960" data-uri="chapter11.xhtml#P7000497027000000000000000046960" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> to convert domain names, we call it with a NULL <code id="P7000497027000000000000000046961" data-uri="chapter11.xhtml#P7000497027000000000000000046961" class="pcalibre1 calibre1 pcalibre2">service</code> argument.</p>
<p id="P7000497027000000000000000046962" data-uri="chapter11.xhtml#P7000497027000000000000000046962" class="pcalibre8 pcalibre1 pcalibre2">After the call to <code id="P7000497027000000000000000046963" data-uri="chapter11.xhtml#P7000497027000000000000000046963" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code>, we walk the list of <code id="P7000497027000000000000000046964" data-uri="chapter11.xhtml#P7000497027000000000000000046964" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structures, using <code id="P7000497027000000000000000046965" data-uri="chapter11.xhtml#P7000497027000000000000000046965" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code> to convert each socket address to a dotted-decimal address string. After walking the list, we are careful to free it by calling <code id="P7000497027000000000000000046966" data-uri="chapter11.xhtml#P7000497027000000000000000046966" class="pcalibre1 calibre1 pcalibre2">freeaddrinfo</code> (although for this simple program it is not strictly necessary).</p>
<p id="P7000497027000000000000000046967" data-uri="chapter11.xhtml#P7000497027000000000000000046967" class="pcalibre8 pcalibre1 pcalibre2">When we run <span class="pcalibre1 pcalibre29 pcalibre2">hostinfo</span>, we see that <code id="P7000497027000000000000000046968" data-uri="chapter11.xhtml#P7000497027000000000000000046968" class="pcalibre1 calibre1 pcalibre2"><a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="http://twitter.com">twitter.com</a></code> maps to four IP addresses, which is what we saw using <span class="pcalibre1 pcalibre29 pcalibre2">nslookup </span>in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007BFE.xhtml#P7000497027000000000000000007C6B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">11.3.2</span></a>.</p>
<pre id="P7000497027000000000000000046969" data-uri="chapter11.xhtml#P7000497027000000000000000046969" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004696A" data-uri="chapter11.xhtml#P700049702700000000000000004696A" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./hostinfo twitter.com</i>
199.16.156.102
199.16.156.230
199.16.156.6
199.16.156.70
</code></pre>
<section id="P7000497027000000000000000007DFF" data-uri="chapter11.xhtml#P7000497027000000000000000007DFF" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P700049702700000000000000004696B" data-uri="chapter11.xhtml#P700049702700000000000000004696B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">11.4 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000008021.xhtml#P7000497027000000000000000008049">968</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004696C" data-uri="chapter11.xhtml#P700049702700000000000000004696C">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004696D" data-uri="chapter11.xhtml#P700049702700000000000000004696D">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004696E" data-uri="chapter11.xhtml#P700049702700000000000000004696E"><p id="P700049702700000000000000004696F" data-uri="chapter11.xhtml#P700049702700000000000000004696F" class="pcalibre1 pcalibre2 pcalibre10">The <code id="P7000497027000000000000000046970" data-uri="chapter11.xhtml#P7000497027000000000000000046970" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> and <code id="P7000497027000000000000000046971" data-uri="chapter11.xhtml#P7000497027000000000000000046971" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code> functions subsume the functionality of <code id="P7000497027000000000000000046972" data-uri="chapter11.xhtml#P7000497027000000000000000046972" class="pcalibre1 calibre1 pcalibre2">inet_pton</code> and <code id="P7000497027000000000000000046973" data-uri="chapter11.xhtml#P7000497027000000000000000046973" class="pcalibre1 calibre1 pcalibre2">inet_ntop</code>, respectively, and they provide a higher-level of abstraction that is independent of any particular address format. To convince yourself how handy this is, write a version of <span class="pcalibre1 pcalibre29 pcalibre2">hostinfo </span>(<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007DE7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.17</span></a>) that uses <code id="P7000497027000000000000000046974" data-uri="chapter11.xhtml#P7000497027000000000000000046974" class="pcalibre1 calibre1 pcalibre2">inet_ntop</code> instead of <code id="P7000497027000000000000000046975" data-uri="chapter11.xhtml#P7000497027000000000000000046975" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code> to convert each socket address to a dotted-decimal address string.</p></div></li>
</ol>
</section>
</section>
</section>
<section id="P7000497027000000000000000007E0B" data-uri="chapter11.xhtml#P7000497027000000000000000007E0B" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046976" data-uri="chapter11.xhtml#P7000497027000000000000000046976" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.8 </span>Helper Functions for the Sockets Interface</h1></header>
<p id="P7000497027000000000000000046977" data-uri="chapter11.xhtml#P7000497027000000000000000046977" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046978" data-uri="chapter11.xhtml#P7000497027000000000000000046978" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> function and the sockets interface can seem somewhat daunting when you first learn about them. We find it convenient to wrap them with higher-level helper functions, called <code id="P7000497027000000000000000046979" data-uri="chapter11.xhtml#P7000497027000000000000000046979" class="pcalibre1 calibre1 pcalibre2">open_clientfd</code> and <code id="P700049702700000000000000004697A" data-uri="chapter11.xhtml#P700049702700000000000000004697A" class="pcalibre1 calibre1 pcalibre2">open_listenfd</code>, that clients and servers can use when they want to communicate with each other.</p>
<section id="P7000497027000000000000000007E11" data-uri="chapter11.xhtml#P7000497027000000000000000007E11" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004697B" data-uri="chapter11.xhtml#P700049702700000000000000004697B" epub:type="title">The <code id="P700049702700000000000000004697C" data-uri="chapter11.xhtml#P700049702700000000000000004697C" class="pcalibre1 pcalibre2 calibre16">open_clientfd</code> Function</h1></header>
<p id="P700049702700000000000000004697D" data-uri="chapter11.xhtml#P700049702700000000000000004697D" class="pcalibre8 pcalibre1 pcalibre2">A client establishes a connection with a server by calling <code id="P700049702700000000000000004697E" data-uri="chapter11.xhtml#P700049702700000000000000004697E" class="pcalibre1 calibre1 pcalibre2">open_clientfd</code>.</p>
<pre id="P700049702700000000000000004697F" data-uri="chapter11.xhtml#P700049702700000000000000004697F" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046980" data-uri="chapter11.xhtml#P7000497027000000000000000046980" class="calibre3 pcalibre1 pcalibre2">
#include "csapp.h"
int open_clientfd(char *hostname, char *port);
Returns: descriptor if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046981" data-uri="chapter11.xhtml#P7000497027000000000000000046981">The <code id="P7000497027000000000000000046982" data-uri="chapter11.xhtml#P7000497027000000000000000046982" class="pcalibre1 calibre1 pcalibre2">open_clientfd</code> function establishes a connection with a server running on host <code id="P7000497027000000000000000046983" data-uri="chapter11.xhtml#P7000497027000000000000000046983" class="pcalibre1 calibre1 pcalibre2">hostname</code> and listening for connection requests on port number port. It returns an open socket descriptor that is ready for input and output using the Unix I/O functions. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E1F"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.18</span></a> shows the code for <code id="P7000497027000000000000000046984" data-uri="chapter11.xhtml#P7000497027000000000000000046984" class="pcalibre1 calibre1 pcalibre2">open_clientfd.</code></p>
<p id="P7000497027000000000000000046985" data-uri="chapter11.xhtml#P7000497027000000000000000046985" class="pcalibre8 pcalibre1 pcalibre2">We call <code id="P7000497027000000000000000046986" data-uri="chapter11.xhtml#P7000497027000000000000000046986" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code>, which returns a list of <code id="P7000497027000000000000000046987" data-uri="chapter11.xhtml#P7000497027000000000000000046987" class="pcalibre1 calibre1 pcalibre2">addrinfo</code> structures, each of which points to a socket address structure that is suitable for establishing a connection</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007E1F" data-uri="chapter11.xhtml#P7000497027000000000000000007E1F">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007E20" title="943" data-uri="chapter11.xhtml#P7000497027000000000000000007E20" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046988" data-uri="chapter11.xhtml#P7000497027000000000000000046988" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046989" data-uri="chapter11.xhtml#P7000497027000000000000000046989" class="calibre3 pcalibre1 pcalibre2">
1	int open_clientfd(char *hostname, char *port) {
2		int clientfd;
3		struct addrinfo hints, *listp, *p;
4	
5		/* Get a list of potential server addresses */
6		memset(&amp;hints, 0, sizeof(struct addrinfo));
7		hints.ai_socktype = SOCK_STREAM; /* Open a connection */
8		hints.ai_flags = AI_NUMERICSERV; /* ... using a numeric port arg. */
9		hints.ai_flags |= AI_ADDRCONFIG; /* Recommended for connections */
10		Getaddrinfo(hostname, port, &amp;hints, &amp;listp);
11	
12		/* Walk the list for one that we can successfully connect to */
13		for (p = listp; p; p = p-&gt;ai_next) {
14			/* Create a socket descriptor */
15			if ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0)
16				continue; /* Socket failed, try the next */
17	
18			/* Connect to the server */
19			if (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != −1)
20				break; /* Success */
21			Close(clientfd); /* Connect failed, try another */
22		}
23	
24		/* Clean up */
25		Freeaddrinfo(listp);
26		if (!p) /* All connects failed */
27			return −1;
28		else	/* The last connect succeeded */
29		return clientfd;
30	}
</code></pre>
<figcaption id="P700049702700000000000000004698A" data-uri="chapter11.xhtml#P700049702700000000000000004698A" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004698B" data-uri="chapter11.xhtml#P700049702700000000000000004698B" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.18 </span><code id="P700049702700000000000000004698C" data-uri="chapter11.xhtml#P700049702700000000000000004698C" class="pcalibre1 calibre1 pcalibre2">open_clientfd</code>: Helper function that establishes a connection with a server.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P700049702700000000000000004698D" data-uri="chapter11.xhtml#P700049702700000000000000004698D"><p id="P700049702700000000000000004698E" data-uri="chapter11.xhtml#P700049702700000000000000004698E" class="pcalibre1 pcalibre2 pcalibre10">It is reentrant and protocol-independent.</p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004698F" data-uri="chapter11.xhtml#P700049702700000000000000004698F">with a server running on <code id="P7000497027000000000000000046990" data-uri="chapter11.xhtml#P7000497027000000000000000046990" class="pcalibre1 calibre1 pcalibre2">hostname</code> and listening on <code id="P7000497027000000000000000046991" data-uri="chapter11.xhtml#P7000497027000000000000000046991" class="pcalibre1 calibre1 pcalibre2">port</code>. We then walk the list, trying each list entry in turn, until the calls to <code id="P7000497027000000000000000046992" data-uri="chapter11.xhtml#P7000497027000000000000000046992" class="pcalibre1 calibre1 pcalibre2">socket</code> and <code id="P7000497027000000000000000046993" data-uri="chapter11.xhtml#P7000497027000000000000000046993" class="pcalibre1 calibre1 pcalibre2">connect</code> succeed. If the <code id="P7000497027000000000000000046994" data-uri="chapter11.xhtml#P7000497027000000000000000046994" class="pcalibre1 calibre1 pcalibre2">connect</code> fails, we are careful to close the socket descriptor before trying the next entry. If the <code id="P7000497027000000000000000046995" data-uri="chapter11.xhtml#P7000497027000000000000000046995" class="pcalibre1 calibre1 pcalibre2">connect</code> succeeds, we free the list memory and return the socket descriptor to the client, which can immediately begin using Unix I/O to communicate with the server.</p>
<p id="P7000497027000000000000000046996" data-uri="chapter11.xhtml#P7000497027000000000000000046996" class="pcalibre8 pcalibre1 pcalibre2">Notice how there is no dependence on any particular version of IP anywhere in the code. The arguments to <code id="P7000497027000000000000000046997" data-uri="chapter11.xhtml#P7000497027000000000000000046997" class="pcalibre1 calibre1 pcalibre2">socket</code> and <code id="P7000497027000000000000000046998" data-uri="chapter11.xhtml#P7000497027000000000000000046998" class="pcalibre1 calibre1 pcalibre2">connect</code> are generated for us automatically by <code id="P7000497027000000000000000046999" data-uri="chapter11.xhtml#P7000497027000000000000000046999" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code>, which allows our code to be clean and portable.</p>
</section>
<section id="P7000497027000000000000000007E33" data-uri="chapter11.xhtml#P7000497027000000000000000007E33" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004699A" data-uri="chapter11.xhtml#P700049702700000000000000004699A" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007E35" title="944" data-uri="chapter11.xhtml#P7000497027000000000000000007E35" epub:type="pagebreak"></span>The <code id="P700049702700000000000000004699B" data-uri="chapter11.xhtml#P700049702700000000000000004699B" class="pcalibre1 pcalibre2 calibre16">open_listenfd</code> Function</h1></header>
<p id="P700049702700000000000000004699C" data-uri="chapter11.xhtml#P700049702700000000000000004699C" class="pcalibre8 pcalibre1 pcalibre2">A server creates a listening descriptor that is ready to receive connection requests by calling the <code id="P700049702700000000000000004699D" data-uri="chapter11.xhtml#P700049702700000000000000004699D" class="pcalibre1 calibre1 pcalibre2">open_listenfd</code> function.</p>
<pre id="P700049702700000000000000004699E" data-uri="chapter11.xhtml#P700049702700000000000000004699E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004699F" data-uri="chapter11.xhtml#P700049702700000000000000004699F" class="calibre3 pcalibre1 pcalibre2">
#include "csapp.h"
int open_listenfd(char *port);
Returns: descriptor if OK, −1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000469A0" data-uri="chapter11.xhtml#P70004970270000000000000000469A0">The <code id="P70004970270000000000000000469A1" data-uri="chapter11.xhtml#P70004970270000000000000000469A1" class="pcalibre1 calibre1 pcalibre2">open_listenfd</code> function returns a listening descriptor that is ready to receive connection requests on port <code id="P70004970270000000000000000469A2" data-uri="chapter11.xhtml#P70004970270000000000000000469A2" class="pcalibre1 calibre1 pcalibre2">port</code>. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E55"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.19</span></a> shows the code for <code id="P70004970270000000000000000469A3" data-uri="chapter11.xhtml#P70004970270000000000000000469A3" class="pcalibre1 calibre1 pcalibre2">open_listenfd</code>.</p>
<p id="P70004970270000000000000000469A4" data-uri="chapter11.xhtml#P70004970270000000000000000469A4" class="pcalibre8 pcalibre1 pcalibre2">The style is similar to <code id="P70004970270000000000000000469A5" data-uri="chapter11.xhtml#P70004970270000000000000000469A5" class="pcalibre1 calibre1 pcalibre2">open_clientfd</code>. We call <code id="P70004970270000000000000000469A6" data-uri="chapter11.xhtml#P70004970270000000000000000469A6" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> and then walk the resulting list until the calls to <code id="P70004970270000000000000000469A7" data-uri="chapter11.xhtml#P70004970270000000000000000469A7" class="pcalibre1 calibre1 pcalibre2">socket</code> and <code id="P70004970270000000000000000469A8" data-uri="chapter11.xhtml#P70004970270000000000000000469A8" class="pcalibre1 calibre1 pcalibre2">bind</code> succeed. Note that in line 20 we use the <code id="P70004970270000000000000000469A9" data-uri="chapter11.xhtml#P70004970270000000000000000469A9" class="pcalibre1 calibre1 pcalibre2">setsockopt</code> function (not described here) to configure the server so that it can be terminated, be restarted, and begin accepting connection requests immediately. By default, a restarted server will deny connection requests from clients for approximately 30 seconds, which seriously hinders debugging.</p>
<p id="P70004970270000000000000000469AA" data-uri="chapter11.xhtml#P70004970270000000000000000469AA" class="pcalibre8 pcalibre1 pcalibre2">Since we have called <code id="P70004970270000000000000000469AB" data-uri="chapter11.xhtml#P70004970270000000000000000469AB" class="pcalibre1 calibre1 pcalibre2">getaddrinfo</code> with the AI_PASSIVE flag and a NULL <code id="P70004970270000000000000000469AC" data-uri="chapter11.xhtml#P70004970270000000000000000469AC" class="pcalibre1 calibre1 pcalibre2">host</code> argument, the address field in each socket address structure is set to the wildcard address, which tells the kernel that this server will accept requests to any of the IP addresses for this host.</p>
<p id="P70004970270000000000000000469AD" data-uri="chapter11.xhtml#P70004970270000000000000000469AD" class="pcalibre8 pcalibre1 pcalibre2">Finally, we call the <code id="P70004970270000000000000000469AE" data-uri="chapter11.xhtml#P70004970270000000000000000469AE" class="pcalibre1 calibre1 pcalibre2">listen</code> function to convert <code id="P70004970270000000000000000469AF" data-uri="chapter11.xhtml#P70004970270000000000000000469AF" class="pcalibre1 calibre1 pcalibre2">listenfd</code> to a listening descriptor and return it to the caller. If the <code id="P70004970270000000000000000469B0" data-uri="chapter11.xhtml#P70004970270000000000000000469B0" class="pcalibre1 calibre1 pcalibre2">listen</code> fails, we are careful to avoid a memory leak by closing the descriptor before returning.</p>
</section>
</section>
<section id="P7000497027000000000000000007E4C" data-uri="chapter11.xhtml#P7000497027000000000000000007E4C" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000469B1" data-uri="chapter11.xhtml#P70004970270000000000000000469B1" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.4.9 </span>Example Echo Client and Server</h1></header>
<p id="P70004970270000000000000000469B2" data-uri="chapter11.xhtml#P70004970270000000000000000469B2" class="pcalibre8 pcalibre1 pcalibre2">The best way to learn the sockets interface is to study example code. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E5E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.20</span></a> shows the code for an echo client. After establishing a connection with the server, the client enters a loop that repeatedly reads a text line from standard input, sends the text line to the server, reads the echo line from the server, and prints the result to standard output. The loop terminates when <code id="P70004970270000000000000000469B3" data-uri="chapter11.xhtml#P70004970270000000000000000469B3" class="pcalibre1 calibre1 pcalibre2">fgets</code> encounters EOF on standard input, either because the user typed Ctrl+D at the keyboard or because it has exhausted the text lines in a redirected input file.</p>
<p id="P70004970270000000000000000469B4" data-uri="chapter11.xhtml#P70004970270000000000000000469B4" class="pcalibre8 pcalibre1 pcalibre2">After the loop terminates, the client closes the descriptor. This results in an EOF notification being sent to the server, which it detects when it receives a return code of zero from its <code id="P70004970270000000000000000469B5" data-uri="chapter11.xhtml#P70004970270000000000000000469B5" class="pcalibre1 calibre1 pcalibre2">rio_readlineb</code> function. After closing its descriptor, the client terminates. Since the client's kernel automatically closes all open descriptors when a process terminates, the <code id="P70004970270000000000000000469B6" data-uri="chapter11.xhtml#P70004970270000000000000000469B6" class="pcalibre1 calibre1 pcalibre2">close</code> in line 24 is not necessary. However, it is good programming practice to explicitly close any descriptors that you have opened.</p>
<p id="P70004970270000000000000000469B7" data-uri="chapter11.xhtml#P70004970270000000000000000469B7" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E72"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.21</span></a> shows the main routine for the echo server. After opening the listening descriptor, it enters an infinite loop. Each iteration waits for a connection request from a client, prints the domain name and port of the connected client, and then calls the <code id="P70004970270000000000000000469B8" data-uri="chapter11.xhtml#P70004970270000000000000000469B8" class="pcalibre1 calibre1 pcalibre2">echo</code> function that services the client. After the echo routine returns,</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007E55" data-uri="chapter11.xhtml#P7000497027000000000000000007E55">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007E56" title="945" data-uri="chapter11.xhtml#P7000497027000000000000000007E56" epub:type="pagebreak"></span>
<pre id="P70004970270000000000000000469B9" data-uri="chapter11.xhtml#P70004970270000000000000000469B9" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000469BA" data-uri="chapter11.xhtml#P70004970270000000000000000469BA" class="calibre3 pcalibre1 pcalibre2">
1	int open_listenfd(char *port)
2	{
3		struct addrinfo hints, *listp, *p;
4		int listenfd, optval=1;
5	
6		/* Get a list of potential server addresses */
7		memset(&amp;hints, 0, sizeof(struct addrinfo));
8		hints.ai_socktype = SOCK_STREAM;				/* Accept connections */
9		hints.ai_flags = AI_PASSIVE	|		AI_ADDRCONFIG;	/* ... on any IP address */
10		hints.ai_flags |= AI_NUMERICSERV;				/* ... using port number */
11		Getaddrinfo(NULL, port, &amp;hints, &amp;listp);
12	
13		/* Walk the list for one that we can bind to */
14		for (p = listp; p; p = p-&gt;ai_next) {
15			/* Create a socket descriptor */
16			if ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0)
17				continue; /* Socket failed, try the next */
18	
19			/* Eliminates "Address already in use" error from bind */
20			Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,
21					(const void *)&amp;optval , sizeof(int));
22	
23			/* Bind the descriptor to the address */
24			if (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == 0)
25				break; /* Success */
26			Close(listenfd); /* Bind failed, try the next */
27		}
28	
29		/* Clean up */
30		Freeaddrinfo(listp);
31		if (!p) /* No address worked */
32			return -1;
33	
34		/* Make it a listening socket ready to accept connection requests */
35		if (listen(listenfd, LISTENQ) &lt; 0) {
36			Close(listenfd);
37			return −1;
38		}
39		return listenfd;
40	}
</code></pre>
<figcaption id="P70004970270000000000000000469BB" data-uri="chapter11.xhtml#P70004970270000000000000000469BB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000469BC" data-uri="chapter11.xhtml#P70004970270000000000000000469BC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.19 </span><code id="P70004970270000000000000000469BD" data-uri="chapter11.xhtml#P70004970270000000000000000469BD" class="pcalibre1 calibre1 pcalibre2">open_listenfd</code>: Helper function that opens and returns a listening descriptor.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000469BE" data-uri="chapter11.xhtml#P70004970270000000000000000469BE"><p id="P70004970270000000000000000469BF" data-uri="chapter11.xhtml#P70004970270000000000000000469BF" class="pcalibre1 pcalibre2 pcalibre10">It is reentrant and protocol-independent.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007E5E" data-uri="chapter11.xhtml#P7000497027000000000000000007E5E">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007E5F" title="946" data-uri="chapter11.xhtml#P7000497027000000000000000007E5F" epub:type="pagebreak"></span>
<pre id="P70004970270000000000000000469C0" data-uri="chapter11.xhtml#P70004970270000000000000000469C0" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000469C1" data-uri="chapter11.xhtml#P70004970270000000000000000469C1" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	
3	int main(int argc, char **argv)
4	{
5		int clientfd;
6		char *host, *port, buf[MAXLINE];
7		rio_t rio;
8
9		if (argc != 3) {
10			fprintf(stderr, "usage: %s &lt;host&gt; &lt;port&gt;\n", argv[0]);
11			exit(0);
12		}
13		host = argv[1];
14		port = argv[2];
15	
16		clientfd = Open_clientfd(host, port);
17		Rio_readinitb(,&amp;rio, clientfd);
18	
19		while (Fgets(buf, MAXLINE, stdin) != NULL) {
20			Rio_writen(clientfd, buf, strlen(buf));
21			Rio_readlineb(&amp;rio, buf, MAXLINE);
22			Fputs(buf, stdout);
23		}
24		Close(clientfd);
25		exit(0);
26	}
</code></pre>
<figcaption id="P70004970270000000000000000469C2" data-uri="chapter11.xhtml#P70004970270000000000000000469C2" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000469C3" data-uri="chapter11.xhtml#P70004970270000000000000000469C3" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">11.20 </span>Echo client main routine.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000469C4" data-uri="chapter11.xhtml#P70004970270000000000000000469C4">the main routine closes the connected descriptor. Once the client and server have closed their respective descriptors, the connection is terminated.</p>
<p id="P70004970270000000000000000469C5" data-uri="chapter11.xhtml#P70004970270000000000000000469C5" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P70004970270000000000000000469C6" data-uri="chapter11.xhtml#P70004970270000000000000000469C6" class="pcalibre1 calibre1 pcalibre2">clientaddr</code> variable in line 9 is a socket address structure that is passed to <code id="P70004970270000000000000000469C7" data-uri="chapter11.xhtml#P70004970270000000000000000469C7" class="pcalibre1 calibre1 pcalibre2">accept</code>. Before <code id="P70004970270000000000000000469C8" data-uri="chapter11.xhtml#P70004970270000000000000000469C8" class="pcalibre1 calibre1 pcalibre2">accept</code> returns, it fills in <code id="P70004970270000000000000000469C9" data-uri="chapter11.xhtml#P70004970270000000000000000469C9" class="pcalibre1 calibre1 pcalibre2">clientaddr</code> with the socket address of the client on the other end of the connection. Notice how we declare <code id="P70004970270000000000000000469CA" data-uri="chapter11.xhtml#P70004970270000000000000000469CA" class="pcalibre1 calibre1 pcalibre2">clientaddr</code> as type struct <code id="P70004970270000000000000000469CB" data-uri="chapter11.xhtml#P70004970270000000000000000469CB" class="pcalibre1 calibre1 pcalibre2">sockaddr_storage</code> rather than struct <code id="P70004970270000000000000000469CC" data-uri="chapter11.xhtml#P70004970270000000000000000469CC" class="pcalibre1 calibre1 pcalibre2">sockaddr_in</code>. By definition, the <code id="P70004970270000000000000000469CD" data-uri="chapter11.xhtml#P70004970270000000000000000469CD" class="pcalibre1 calibre1 pcalibre2">sockaddr_storage</code> structure is large enough to hold any type of socket address, which keeps the code protocol-independent.</p>
<p id="P70004970270000000000000000469CE" data-uri="chapter11.xhtml#P70004970270000000000000000469CE" class="pcalibre8 pcalibre1 pcalibre2">Notice that our simple echo server can only handle one client at a time. A server of this type that iterates through clients, one at a time, is called an <i class="pcalibre17 pcalibre2 pcalibre1">iterative server</i>. In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">12</span></a>, we will learn how to build more sophisticated <i class="pcalibre17 pcalibre2 pcalibre1">concurrent servers</i> that can handle multiple clients simultaneously.</p>
<p id="P70004970270000000000000000469CF" data-uri="chapter11.xhtml#P70004970270000000000000000469CF" class="pcalibre8 pcalibre1 pcalibre2">Finally, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007E78"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.22</span></a> shows the code for the <code id="P70004970270000000000000000469D0" data-uri="chapter11.xhtml#P70004970270000000000000000469D0" class="pcalibre1 calibre1 pcalibre2">echo</code> routine, which repeatedly reads and writes lines of text until the <code id="P70004970270000000000000000469D1" data-uri="chapter11.xhtml#P70004970270000000000000000469D1" class="pcalibre1 calibre1 pcalibre2">rio_readlineb</code> function encounters EOF in line 10.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007E72" data-uri="chapter11.xhtml#P7000497027000000000000000007E72">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007E73" title="947" data-uri="chapter11.xhtml#P7000497027000000000000000007E73" epub:type="pagebreak"></span>
<pre id="P70004970270000000000000000469D2" data-uri="chapter11.xhtml#P70004970270000000000000000469D2" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000469D3" data-uri="chapter11.xhtml#P70004970270000000000000000469D3" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	
3	void echo(int connfd);
4	
5	int main(int argc, char **argv)
6	{
7		int listenfd, connfd;
8		socklen_t clientlen;
9		struct sockaddr_storage clientaddr; /* Enough space for any address */
10		char client_hostname[MAXLINE], client_port[MAXLINE];
11	
12		if (argc != 2) {
13			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
14			exit(0);
15		}
16	
17		listenfd = Open_listenfd(argv[1]);
18		while (1) {
19			clientlen = sizeof(struct sockaddr_storage);
20			connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
21			Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname, MAXLINE,
22				client_port, MAXLINE, 0);
23			printf("Connected to (%s, %s)\n", client_hostname, client_port);
24			echo(connfd);
25			Close(connfd);
26		}
27		exit(0);
28	}
</code></pre>
<figcaption id="P70004970270000000000000000469D4" data-uri="chapter11.xhtml#P70004970270000000000000000469D4" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000469D5" data-uri="chapter11.xhtml#P70004970270000000000000000469D5" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">11.21 </span>Iterative echo server main routine.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007E78" data-uri="chapter11.xhtml#P7000497027000000000000000007E78">
<pre id="P70004970270000000000000000469D6" data-uri="chapter11.xhtml#P70004970270000000000000000469D6" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000469D7" data-uri="chapter11.xhtml#P70004970270000000000000000469D7" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	
3	void echo(int connfd)
4	{
5		size_t n;
6		char buf[MAXLINE];
7		rio_t rio; 8
9		Rio_readinitb(&amp;rio, connfd);
10		while((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {
11			printf("server received %d bytes\n", (int)n);
12			Rio_writen(connfd, buf, n);
13		}
14	}
</code></pre>
<figcaption id="P70004970270000000000000000469D8" data-uri="chapter11.xhtml#P70004970270000000000000000469D8" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000469D9" data-uri="chapter11.xhtml#P70004970270000000000000000469D9" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.22 </span><code id="P70004970270000000000000000469DA" data-uri="chapter11.xhtml#P70004970270000000000000000469DA" class="pcalibre1 calibre1 pcalibre2">echo</code> function that reads and echoes text lines.</h1></header>
</figcaption>
</figure>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000007E7E" data-uri="chapter11.xhtml#P7000497027000000000000000007E7E"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P70004970270000000000000000469DB" data-uri="chapter11.xhtml#P70004970270000000000000000469DB" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007E80" title="948" data-uri="chapter11.xhtml#P7000497027000000000000000007E80" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>What does EOF on a connection mean?</h1></header>
<p id="P70004970270000000000000000469DC" data-uri="chapter11.xhtml#P70004970270000000000000000469DC" class="pcalibre1 pcalibre2 pcalibre10">The idea of EOF is often confusing to students, especially in the context of Internet connections. First, we need to understand that there is no such thing as an EOF character. Rather, EOF is a condition that is detected by the kernel. An application finds out about the EOF condition when it receives a zero return code from the read function. For disk files, EOF occurs when the current file position exceeds the file length. For Internet connections, EOF occurs when a process closes its end of the connection. The process at the other end of the connection detects the EOF when it attempts to read past the last byte in the stream.</p>
</aside>
</section>
</section></body></html>
