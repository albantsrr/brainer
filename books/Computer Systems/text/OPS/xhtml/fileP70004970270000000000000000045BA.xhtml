<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>4.6 Summary </title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P70004970270000000000000000045BA" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000042D04" data-uri="chapter04.xhtml#P7000497027000000000000000042D04" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.6 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary </span></h1></header>
<p id="P7000497027000000000000000042D05" data-uri="chapter04.xhtml#P7000497027000000000000000042D05" class="pcalibre8 pcalibre1 pcalibre2">We have seen that the instruction set architecture, or ISA, provides a layer of abstraction between the behavior of a processor—in terms of the set of instructions and their encodings—and how the processor is implemented. The ISA provides a very sequential view of program execution, with one instruction executed to completion before the next one begins.</p>

<aside class="pcalibre31 pcalibre32 pcalibre2" id="P70004970270000000000000000045BD" data-uri="chapter04.xhtml#P70004970270000000000000000045BD"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000042D06" data-uri="chapter04.xhtml#P7000497027000000000000000042D06" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000045BF" title="471" data-uri="chapter04.xhtml#P70004970270000000000000000045BF" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>State-of-the-art microprocessor design</h1></header>
<p id="P7000497027000000000000000042D07" data-uri="chapter04.xhtml#P7000497027000000000000000042D07" class="pcalibre1 pcalibre2 pcalibre40">A five-stage pipeline, such as we have shown with the PIPE processor, represented the state of the art in processor design in the mid-1980s. The prototype RISC processor developed by Patterson's research group at Berkeley formed the basis for the first SPARC processor, developed by Sun Microsystems in 1987. The processor developed by Hennessy's research group at Stanford was commercialized by MIPS Technologies (a company founded by Hennessy) in 1986. Both of these used five-stage pipelines. The Intel i486 processor also uses a five-stage pipeline, although with a different partitioning of responsibilities among the stages, with two decode stages and a combined execute/memory stage <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3D7">[27]</a>.</p>
<p id="P7000497027000000000000000042D08" data-uri="chapter04.xhtml#P7000497027000000000000000042D08" class="pcalibre1 pcalibre2 pcalibre40">These pipelined designs are limited to a throughput of at most one instruction per clock cycle. The CPI (for "cycles per instruction") measure described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000041EB_split_002.xhtml#P7000497027000000000000000004544"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">4.5.9</span></a> can never be less than 1.0. The different stages can only process one instruction at a time. More recent processors support <i class="pcalibre17 pcalibre2 pcalibre1">superscalar</i> operation, meaning that they can achieve a CPI less than 1.0 by fetching, decoding, and executing multiple instructions in parallel. As superscalar processors have become widespread, the accepted performance measure has shifted from CPI to its reciprocal—the average number of instructions executed per cycle, or IPC. It can exceed 1.0 for superscalar processors. The most advanced designs use a technique known as <i class="pcalibre17 pcalibre2 pcalibre1">out-of-order</i> execution to execute multiple instructions in parallel, possibly in a totally different order than they occur in the program, while preserving the overall behavior implied by the sequential ISA model. This form of execution is described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004893.xhtml#P7000497027000000000000000004893"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">5</span></a> as part of our discussion of program optimization.</p>
<p id="P7000497027000000000000000042D09" data-uri="chapter04.xhtml#P7000497027000000000000000042D09" class="pcalibre1 pcalibre2 pcalibre40">Pipelined processors are not just historical artifacts, however. The majority of processors sold are used in embedded systems, controlling automotive functions, consumer products, and other devices where the processor is not directly visible to the system user. In these applications, the simplicity of a pipelined processor, such as the one we have explored in this chapter, reduces its cost and power requirements compared to higher-performance models.</p>
<p id="P7000497027000000000000000042D0A" data-uri="chapter04.xhtml#P7000497027000000000000000042D0A" class="pcalibre1 pcalibre2 pcalibre10">More recently, as multicore processors have gained a following, some have argued that we could get more overall computing power by integrating many simple processors on a single chip rather than a smaller number of more complex ones. This strategy is sometimes referred to as "many-core" processors <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3B4">[10]</a>.</p>
</aside>
<p id="P7000497027000000000000000042D0B" data-uri="chapter04.xhtml#P7000497027000000000000000042D0B" class="pcalibre8 pcalibre1 pcalibre2">We defined the Y86-64 instruction set by starting with the x86-64 instructions and simplifying the data types, address modes, and instruction encoding considerably. The resulting ISA has attributes of both RISC and CISC instruction sets. We then organized the processing required for the different instructions into a series of five stages, where the operations at each stage vary according to the instruction being executed. From this, we constructed the SEQ processor, in which an entire instruction is executed every clock cycle by having it flow through all five stages.</p>
<p id="P7000497027000000000000000042D0C" data-uri="chapter04.xhtml#P7000497027000000000000000042D0C" class="pcalibre8 pcalibre1 pcalibre2">Pipelining improves the throughput performance of a system by letting the different stages operate concurrently. At any given time, multiple operations are being processed by the different stages. In introducing this concurrency, we must be careful to provide the same program-level behavior as would a sequential execution of the program. We introduced pipelining by reordering parts of SEQ to get SEQ+ and then adding pipeline registers to create the PIPE— pipeline.</p>

<aside class="pcalibre31 pcalibre32 pcalibre2" id="P70004970270000000000000000045C6" data-uri="chapter04.xhtml#P70004970270000000000000000045C6"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000042D0D" data-uri="chapter04.xhtml#P7000497027000000000000000042D0D" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000045C8" title="472" data-uri="chapter04.xhtml#P70004970270000000000000000045C8" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Web Aside ARCH:HCL </span>HCL descriptions of Y86-64 processors</h1></header>
<p id="P7000497027000000000000000042D0E" data-uri="chapter04.xhtml#P7000497027000000000000000042D0E" class="pcalibre1 pcalibre2 pcalibre10">In this chapter, we have looked at portions of the HCL code for several simple logic designs and for the control logic for Y86-64 processors SEQ and PIPE. For reference, we provide documentation of the HCL language and complete HCL descriptions for the control logic of the two processors. Each of these descriptions requires only five to seven pages of HCL code, and it is worthwhile to study them in their entirety.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000042D0F" data-uri="chapter04.xhtml#P7000497027000000000000000042D0F">We enhanced the pipeline performance by adding forwarding logic to speed the sending of a result from one instruction to another. Several special cases require additional pipeline control logic to stall or cancel some of the pipeline stages.</p>
<p id="P7000497027000000000000000042D10" data-uri="chapter04.xhtml#P7000497027000000000000000042D10" class="pcalibre8 pcalibre1 pcalibre2">Our design included rudimentary mechanisms to handle exceptions, where we make sure that only instructions up to the excepting instruction affect the programmer-visible state. Implementing a complete handling of exceptions would be significantly more challenging. Properly handling exceptions gets even more complex in systems that employ greater degrees of pipelining and parallelism.</p>
<p id="P7000497027000000000000000042D11" data-uri="chapter04.xhtml#P7000497027000000000000000042D11" class="pcalibre8 pcalibre1 pcalibre2">In this chapter, we have learned several important lessons about processor design:</p>
<ul id="P7000497027000000000000000042D12" data-uri="chapter04.xhtml#P7000497027000000000000000042D12" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000042D13" data-uri="chapter04.xhtml#P7000497027000000000000000042D13" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042D14" data-uri="chapter04.xhtml#P7000497027000000000000000042D14" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Managing complexity is a top priority. </span>We want to make optimum use of the hardware resources to get maximum performance at minimum cost. We did this by creating a very simple and uniform framework for processing all of the different instruction types. With this framework, we could share the hardware units among the logic for processing the different instruction types.</p></li>
<li id="P7000497027000000000000000042D15" data-uri="chapter04.xhtml#P7000497027000000000000000042D15" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042D16" data-uri="chapter04.xhtml#P7000497027000000000000000042D16" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">We do not need to implement the ISA directly. </span>A direct implementation of the ISA would imply a very sequential design. To achieve higher performance, we want to exploit the ability in hardware to perform many operations simultaneously. This led to the use of a pipelined design. By careful design and analysis, we can handle the various pipeline hazards, so that the overall effect of running a program exactly matches what would be obtained with the ISA model.</p></li>
<li id="P7000497027000000000000000042D17" data-uri="chapter04.xhtml#P7000497027000000000000000042D17" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042D18" data-uri="chapter04.xhtml#P7000497027000000000000000042D18" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Hardware designers must be meticulous. </span>Once a chip has been fabricated, it is nearly impossible to correct any errors. It is very important to get the design right on the first try. This means carefully analyzing different instruction types and combinations, even ones that do not seem to make sense, such as popping to the stack pointer. Designs must be thoroughly tested with systematic simulation test programs. In developing the control logic for PIPE, our design had a subtle bug that was uncovered only after a careful and systematic analysis of control combinations.</p></li>
</ul>

<section id="P70004970270000000000000000045D4" data-uri="chapter04.xhtml#P70004970270000000000000000045D4" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000042D19" data-uri="chapter04.xhtml#P7000497027000000000000000042D19" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.6.1 </span>Y86-64 Simulators</h1></header>
<p id="P7000497027000000000000000042D1A" data-uri="chapter04.xhtml#P7000497027000000000000000042D1A" class="pcalibre8 pcalibre1 pcalibre2">The lab materials for this chapter include simulators for the SEQ and PIPE processors. Each simulator has two versions:</p>
<ul id="P7000497027000000000000000042D1B" data-uri="chapter04.xhtml#P7000497027000000000000000042D1B" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000042D1C" data-uri="chapter04.xhtml#P7000497027000000000000000042D1C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042D1D" data-uri="chapter04.xhtml#P7000497027000000000000000042D1D" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000045DA" title="473" data-uri="chapter04.xhtml#P70004970270000000000000000045DA" epub:type="pagebreak"></span>The GUI (graphic user interface) version displays the memory, program code, and processor state in graphic windows. This provides a way to readily see how the instructions flow through the processors. The control panel also allows you to reset, single-step, or run the simulator interactively.</p></li>
<li id="P7000497027000000000000000042D1E" data-uri="chapter04.xhtml#P7000497027000000000000000042D1E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042D1F" data-uri="chapter04.xhtml#P7000497027000000000000000042D1F" class="pcalibre1 pcalibre2 pcalibre10">The text version runs the same simulator, but it only displays information by printing to the terminal. This version is not as useful for debugging, but it allows automated testing of the processor.</p></li>
</ul>
<p id="P7000497027000000000000000042D20" data-uri="chapter04.xhtml#P7000497027000000000000000042D20" class="pcalibre8 pcalibre1 pcalibre2">The control logic for the simulators is generated by translating the HCL declarations of the logic blocks into C code. This code is then compiled and linked with the rest of the simulation code. This combination makes it possible for you to test out variants of the original designs using the simulators. Testing scripts are also available that thoroughly exercise the different instructions and the different hazard possibilities.</p>
</section>
</section></body></html>
