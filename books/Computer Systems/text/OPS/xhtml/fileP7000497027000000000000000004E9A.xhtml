<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.11 Some Limiting Factors</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000004E9A" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000004360B" data-uri="chapter05.xhtml#P700049702700000000000000004360B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.11 </span>Some Limiting Factors</h1></header>
<p id="P700049702700000000000000004360C" data-uri="chapter05.xhtml#P700049702700000000000000004360C" class="pcalibre8 pcalibre1 pcalibre2">We have seen that the critical path in a data-flow graph representation of a program indicates a fundamental lower bound on the time required to execute a program. That is, if there is some chain of data dependencies in a program where the sum of all of the latencies along that chain equals <var class="pcalibre17 pcalibre2 pcalibre1">T</var>, then the program will require at least <var class="pcalibre17 pcalibre2 pcalibre1">T</var> cycles to execute.</p>
<p id="P700049702700000000000000004360D" data-uri="chapter05.xhtml#P700049702700000000000000004360D" class="pcalibre8 pcalibre1 pcalibre2">We have also seen that the throughput bounds of the functional units also impose a lower bound on the execution time for a program. That is, assume that a program requires a total of <var class="pcalibre17 pcalibre2 pcalibre1">N</var> computations of some operation, that the microprocessor has <var class="pcalibre17 pcalibre2 pcalibre1">C</var> functional units capable of performing that operation, and that these units have an issue time of <var class="pcalibre17 pcalibre2 pcalibre1">I</var>. Then the program will require at least <i class="pcalibre17 pcalibre2 pcalibre1">N · I/C</i> cycles to execute.</p>
<p id="P700049702700000000000000004360E" data-uri="chapter05.xhtml#P700049702700000000000000004360E" class="pcalibre8 pcalibre1 pcalibre2">In this section, we will consider some other factors that limit the performance of programs on actual machines.</p>
<section id="P7000497027000000000000000004E9F" data-uri="chapter05.xhtml#P7000497027000000000000000004E9F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004360F" data-uri="chapter05.xhtml#P700049702700000000000000004360F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.11.1 </span>Register Spilling</h1></header>
<p id="P7000497027000000000000000043610" data-uri="chapter05.xhtml#P7000497027000000000000000043610" class="pcalibre8 pcalibre1 pcalibre2">The benefits of loop parallelism are limited by the ability to express the computation in assembly code. If a program has a degree of parallelism <var class="pcalibre17 pcalibre2 pcalibre1">P</var> that exceeds the number of available registers, then the compiler will resort to <i class="pcalibre17 pcalibre2 pcalibre1">spilling</i>, storing some of the temporary values in memory, typically by allocating space on the run-time stack. As an example, the following measurements compare the result of extending the multiple accumulator scheme of <code id="P7000497027000000000000000043611" data-uri="chapter05.xhtml#P7000497027000000000000000043611" class="pcalibre1 calibre1 pcalibre2">combine6</code> to the cases of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 10 and <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 20:</p>
<table id="P7000497027000000000000000043612" data-uri="chapter05.xhtml#P7000497027000000000000000043612" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043613" data-uri="chapter05.xhtml#P7000497027000000000000000043613" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P7000497027000000000000000043614" data-uri="chapter05.xhtml#P7000497027000000000000000043614" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P7000497027000000000000000043615" data-uri="chapter05.xhtml#P7000497027000000000000000043615" class="pcalibre1 pcalibre2 calibre5"/>
<th colspan="2" id="P7000497027000000000000000043616" data-uri="chapter05.xhtml#P7000497027000000000000000043616" class="pcalibre1 pcalibre2 calibre5">Integer</th>
<th colspan="2" id="P7000497027000000000000000043617" data-uri="chapter05.xhtml#P7000497027000000000000000043617" class="pcalibre1 pcalibre2 calibre5">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043618" data-uri="chapter05.xhtml#P7000497027000000000000000043618" class="pcalibre1 pcalibre2 calibre5">Function</th>
<th id="P7000497027000000000000000043619" data-uri="chapter05.xhtml#P7000497027000000000000000043619" class="pcalibre1 pcalibre2 calibre5">Page</th>
<th id="P700049702700000000000000004361A" data-uri="chapter05.xhtml#P700049702700000000000000004361A" class="pcalibre1 pcalibre2 calibre5">Method</th>
<th id="P700049702700000000000000004361B" data-uri="chapter05.xhtml#P700049702700000000000000004361B" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P700049702700000000000000004361C" data-uri="chapter05.xhtml#P700049702700000000000000004361C" class="pcalibre1 pcalibre2 calibre5">*</th>
<th id="P700049702700000000000000004361D" data-uri="chapter05.xhtml#P700049702700000000000000004361D" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P700049702700000000000000004361E" data-uri="chapter05.xhtml#P700049702700000000000000004361E" class="pcalibre1 pcalibre2 calibre5">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004361F" data-uri="chapter05.xhtml#P700049702700000000000000004361F" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000043620" data-uri="chapter05.xhtml#P7000497027000000000000000043620" class="calibre3 pcalibre1 pcalibre2">combine6</code></td>
<td id="P7000497027000000000000000043621" data-uri="chapter05.xhtml#P7000497027000000000000000043621" class="pcalibre1 pcalibre2 calibre7">537</td>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td class="pcalibre1 pcalibre2 calibre7"/>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7"/>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td id="P7000497027000000000000000043622" data-uri="chapter05.xhtml#P7000497027000000000000000043622" class="pcalibre1 pcalibre2 calibre7">10 × 10 unrolling</td>
<td id="P7000497027000000000000000043623" data-uri="chapter05.xhtml#P7000497027000000000000000043623" class="pcalibre1 pcalibre2 calibre7">0.55</td>
<td id="P7000497027000000000000000043624" data-uri="chapter05.xhtml#P7000497027000000000000000043624" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P7000497027000000000000000043625" data-uri="chapter05.xhtml#P7000497027000000000000000043625" class="pcalibre1 pcalibre2 calibre7">1.01</td>
<td id="P7000497027000000000000000043626" data-uri="chapter05.xhtml#P7000497027000000000000000043626" class="pcalibre1 pcalibre2 calibre7">0.52</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td class="pcalibre1 pcalibre2 calibre7"/>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td id="P7000497027000000000000000043627" data-uri="chapter05.xhtml#P7000497027000000000000000043627" class="pcalibre1 pcalibre2 calibre7">20 × 20 unrolling</td>
<td id="P7000497027000000000000000043628" data-uri="chapter05.xhtml#P7000497027000000000000000043628" class="pcalibre1 pcalibre2 calibre7">0.83</td>
<td id="P7000497027000000000000000043629" data-uri="chapter05.xhtml#P7000497027000000000000000043629" class="pcalibre1 pcalibre2 calibre7">1.03</td>
<td id="P700049702700000000000000004362A" data-uri="chapter05.xhtml#P700049702700000000000000004362A" class="pcalibre1 pcalibre2 calibre7">1.02</td>
<td id="P700049702700000000000000004362B" data-uri="chapter05.xhtml#P700049702700000000000000004362B" class="pcalibre1 pcalibre2 calibre7">0.68</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P700049702700000000000000004362C" data-uri="chapter05.xhtml#P700049702700000000000000004362C" class="pcalibre1 pcalibre2 calibre7">Throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td id="P700049702700000000000000004362D" data-uri="chapter05.xhtml#P700049702700000000000000004362D" class="pcalibre1 pcalibre2 calibre7">0.50</td>
<td id="P700049702700000000000000004362E" data-uri="chapter05.xhtml#P700049702700000000000000004362E" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P700049702700000000000000004362F" data-uri="chapter05.xhtml#P700049702700000000000000004362F" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P7000497027000000000000000043630" data-uri="chapter05.xhtml#P7000497027000000000000000043630" class="pcalibre1 pcalibre2 calibre7">0.50</td>
</tr>
</tbody>
</table>
<p id="P7000497027000000000000000043631" data-uri="chapter05.xhtml#P7000497027000000000000000043631" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004EC3" title="549" data-uri="chapter05.xhtml#P7000497027000000000000000004EC3" epub:type="pagebreak"></span>We can see that none of the CPEs improve with this increased unrolling, and some even get worse. Modern x86-64 processors have 16 integer registers and can make use of the 16 YMM registers to store floating-point data. Once the number of loop variables exceeds the number of available registers, the program must allocate some on the stack.</p>
<p id="P7000497027000000000000000043632" data-uri="chapter05.xhtml#P7000497027000000000000000043632" class="pcalibre8 pcalibre1 pcalibre2">As an example, the following snippet of code shows how accumulator <code id="P7000497027000000000000000043633" data-uri="chapter05.xhtml#P7000497027000000000000000043633" class="pcalibre1 calibre1 pcalibre2">acc0</code> is updated in the inner loop of the code with 10 × 10 unrolling:</p>
<pre id="P7000497027000000000000000043634" data-uri="chapter05.xhtml#P7000497027000000000000000043634" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043635" data-uri="chapter05.xhtml#P7000497027000000000000000043635" class="calibre3 pcalibre1 pcalibre2">
<i class="pcalibre17 pcalibre2 pcalibre1">Updating of accumulator acc0 in 10 x 10 urolling</i>
vmulsd (%rdx), %xmm0, %xmm0	<i class="pcalibre17 pcalibre2 pcalibre1">acc0 *= data[i]</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043636" data-uri="chapter05.xhtml#P7000497027000000000000000043636">We can see that the accumulator is kept in register <code id="P7000497027000000000000000043637" data-uri="chapter05.xhtml#P7000497027000000000000000043637" class="pcalibre1 calibre1 pcalibre2">%xmm0</code>, and so the program can simply read <code id="P7000497027000000000000000043638" data-uri="chapter05.xhtml#P7000497027000000000000000043638" class="pcalibre1 calibre1 pcalibre2">data[i]</code> from memory and multiply it by this register.</p>
<p id="P7000497027000000000000000043639" data-uri="chapter05.xhtml#P7000497027000000000000000043639" class="pcalibre8 pcalibre1 pcalibre2">The comparable part of the code for 20 × 20 unrolling has a much different form:</p>
<pre id="P700049702700000000000000004363A" data-uri="chapter05.xhtml#P700049702700000000000000004363A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004363B" data-uri="chapter05.xhtml#P700049702700000000000000004363B" class="calibre3 pcalibre1 pcalibre2">
<i class="pcalibre17 pcalibre2 pcalibre1">Updating of accumulator acc0 in 20 x 20 unrolling</i>
vmovsd 40(%rsp), %xmm0
vmulsd (%rdx), %xmm0, %xmm0
vmovsd %xmm0, 40(%rsp)
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004363C" data-uri="chapter05.xhtml#P700049702700000000000000004363C">The accumulator is kept as a local variable on the stack, at offset 40 from the stack pointer. The program must read both its value and the value of <code id="P700049702700000000000000004363D" data-uri="chapter05.xhtml#P700049702700000000000000004363D" class="pcalibre1 calibre1 pcalibre2">data[i]</code> from memory, multiply them, and store the result back to memory.</p>
<p id="P700049702700000000000000004363E" data-uri="chapter05.xhtml#P700049702700000000000000004363E" class="pcalibre8 pcalibre1 pcalibre2">Once a compiler must resort to register spilling, any advantage of maintaining multiple accumulators will most likely be lost. Fortunately, x86-64 has enough registers that most loops will become throughput limited before this occurs.</p>
</section>
<section id="P7000497027000000000000000004ED1" data-uri="chapter05.xhtml#P7000497027000000000000000004ED1" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004363F" data-uri="chapter05.xhtml#P700049702700000000000000004363F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.11.2 </span>Branch Prediction and Misprediction Penalties</h1></header>
<p id="P7000497027000000000000000043640" data-uri="chapter05.xhtml#P7000497027000000000000000043640" class="pcalibre8 pcalibre1 pcalibre2">We demonstrated via experiments in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.6.6</span></a> that a conditional branch can incur a significant <i class="pcalibre17 pcalibre2 pcalibre1">misprediction penalty</i> when the branch prediction logic does not correctly anticipate whether or not a branch will be taken. Now that we have learned something about how processors operate, we can understand where this penalty arises.</p>
<p id="P7000497027000000000000000043641" data-uri="chapter05.xhtml#P7000497027000000000000000043641" class="pcalibre8 pcalibre1 pcalibre2">Modern processors work well ahead of the currently executing instructions, reading new instructions from memory and decoding them to determine what operations to perform on what operands. This <i class="pcalibre17 pcalibre2 pcalibre1">instruction pipelining</i> works well as long as the instructions follow in a simple sequence. When a branch is encountered, the processor must guess which way the branch will go. For the case of a conditional jump, this means predicting whether or not the branch will be taken. For an instruction such as an indirect jump (as we saw in the code to jump to an address specified by a jump table entry) or a procedure return, this means predicting the target address. In this discussion, we focus on conditional branches.</p>
<p id="P7000497027000000000000000043642" data-uri="chapter05.xhtml#P7000497027000000000000000043642" class="pcalibre8 pcalibre1 pcalibre2">In a processor that employs <i class="pcalibre17 pcalibre2 pcalibre1">speculative execution</i>, the processor begins executing the instructions at the predicted branch target. It does this in a way that avoids modifying any actual register or memory locations until the actual outcome has been determined. If the prediction is correct, the processor can then <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004ED6" title="550" data-uri="chapter05.xhtml#P7000497027000000000000000004ED6" epub:type="pagebreak"></span>"commit" the results of the speculatively executed instructions by storing them in registers or memory. If the prediction is incorrect, the processor must discard all of the speculatively executed results and restart the instruction fetch process at the correct location. The misprediction penalty is incurred in doing this, because the instruction pipeline must be refilled before useful results are generated.</p>
<p id="P7000497027000000000000000043643" data-uri="chapter05.xhtml#P7000497027000000000000000043643" class="pcalibre8 pcalibre1 pcalibre2">We saw in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.6.6</span></a> that recent versions of x86 processors, including all processors capable of executing x86-64 programs, have <i class="pcalibre17 pcalibre2 pcalibre1">conditional move</i> instructions. <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>can generate code that uses these instructions when compiling conditional statements and expressions, rather than the more traditional realizations based on conditional transfers of control. The basic idea for translating into conditional moves is to compute the values along both branches of a conditional expression or statement and then use conditional moves to select the desired value. We saw in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000041EB_split_001.xhtml#P70004970270000000000000000043A8"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">4.5.7</span></a> that conditional move instructions can be implemented as part of the pipelined processing of ordinary instructions. There is no need to guess whether or not the condition will hold, and hence no penalty for guessing incorrectly.</p>
<p id="P7000497027000000000000000043644" data-uri="chapter05.xhtml#P7000497027000000000000000043644" class="pcalibre8 pcalibre1 pcalibre2">How, then, can a C programmer make sure that branch misprediction penalties do not hamper a program's efficiency? Given the 19-cycle misprediction penalty we measured for the reference machine, the stakes are very high. There is no simple answer to this question, but the following general principles apply.</p>
<section id="P7000497027000000000000000004ED9" data-uri="chapter05.xhtml#P7000497027000000000000000004ED9" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000043645" data-uri="chapter05.xhtml#P7000497027000000000000000043645" epub:type="title">Do Not Be Overly Concerned about Predictable Branches</h1></header>
<p id="P7000497027000000000000000043646" data-uri="chapter05.xhtml#P7000497027000000000000000043646" class="pcalibre8 pcalibre1 pcalibre2">We have seen that the effect of a mispredicted branch can be very high, but that does not mean that all program branches will slow a program down. In fact, the branch prediction logic found in modern processors is very good at discerning regular patterns and long-term trends for the different branch instructions. For example, the loop-closing branches in our combining routines would typically be predicted as being taken, and hence would only incur a misprediction penalty on the last time around.</p>
<p id="P7000497027000000000000000043647" data-uri="chapter05.xhtml#P7000497027000000000000000043647" class="pcalibre8 pcalibre1 pcalibre2">As another example, consider the results we observed when shifting from <code id="P7000497027000000000000000043648" data-uri="chapter05.xhtml#P7000497027000000000000000043648" class="pcalibre1 calibre1 pcalibre2">combine2</code> to <code id="P7000497027000000000000000043649" data-uri="chapter05.xhtml#P7000497027000000000000000043649" class="pcalibre1 calibre1 pcalibre2">combine3</code>, when we took the function <code id="P700049702700000000000000004364A" data-uri="chapter05.xhtml#P700049702700000000000000004364A" class="pcalibre1 calibre1 pcalibre2">get_vec_element</code> out of the inner loop of the function, as is reproduced below:</p>
<table id="P700049702700000000000000004364B" data-uri="chapter05.xhtml#P700049702700000000000000004364B" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P700049702700000000000000004364C" data-uri="chapter05.xhtml#P700049702700000000000000004364C" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P700049702700000000000000004364D" data-uri="chapter05.xhtml#P700049702700000000000000004364D" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P700049702700000000000000004364E" data-uri="chapter05.xhtml#P700049702700000000000000004364E" class="pcalibre1 pcalibre2 calibre5"/>
<th colspan="2" id="P700049702700000000000000004364F" data-uri="chapter05.xhtml#P700049702700000000000000004364F" class="pcalibre1 pcalibre2 calibre5">Integer</th>
<th colspan="2" id="P7000497027000000000000000043650" data-uri="chapter05.xhtml#P7000497027000000000000000043650" class="pcalibre1 pcalibre2 calibre5">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043651" data-uri="chapter05.xhtml#P7000497027000000000000000043651" class="pcalibre1 pcalibre2 calibre5">Function</th>
<th id="P7000497027000000000000000043652" data-uri="chapter05.xhtml#P7000497027000000000000000043652" class="pcalibre1 pcalibre2 calibre5">Page</th>
<th id="P7000497027000000000000000043653" data-uri="chapter05.xhtml#P7000497027000000000000000043653" class="pcalibre1 pcalibre2 calibre5">Method</th>
<th id="P7000497027000000000000000043654" data-uri="chapter05.xhtml#P7000497027000000000000000043654" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P7000497027000000000000000043655" data-uri="chapter05.xhtml#P7000497027000000000000000043655" class="pcalibre1 pcalibre2 calibre5">*</th>
<th id="P7000497027000000000000000043656" data-uri="chapter05.xhtml#P7000497027000000000000000043656" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P7000497027000000000000000043657" data-uri="chapter05.xhtml#P7000497027000000000000000043657" class="pcalibre1 pcalibre2 calibre5">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043658" data-uri="chapter05.xhtml#P7000497027000000000000000043658" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000043659" data-uri="chapter05.xhtml#P7000497027000000000000000043659" class="calibre3 pcalibre1 pcalibre2">combine2</code></td>
<td id="P700049702700000000000000004365A" data-uri="chapter05.xhtml#P700049702700000000000000004365A" class="pcalibre1 pcalibre2 calibre7">509</td>
<td id="P700049702700000000000000004365B" data-uri="chapter05.xhtml#P700049702700000000000000004365B" class="pcalibre1 pcalibre2 calibre7">Move <code id="P700049702700000000000000004365C" data-uri="chapter05.xhtml#P700049702700000000000000004365C" class="calibre3 pcalibre1 pcalibre2">vec_length</code></td>
<td id="P700049702700000000000000004365D" data-uri="chapter05.xhtml#P700049702700000000000000004365D" class="pcalibre1 pcalibre2 calibre7">7.02</td>
<td id="P700049702700000000000000004365E" data-uri="chapter05.xhtml#P700049702700000000000000004365E" class="pcalibre1 pcalibre2 calibre7">9.03</td>
<td id="P700049702700000000000000004365F" data-uri="chapter05.xhtml#P700049702700000000000000004365F" class="pcalibre1 pcalibre2 calibre7">9.02</td>
<td id="P7000497027000000000000000043660" data-uri="chapter05.xhtml#P7000497027000000000000000043660" class="pcalibre1 pcalibre2 calibre7">11.03</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043661" data-uri="chapter05.xhtml#P7000497027000000000000000043661" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000043662" data-uri="chapter05.xhtml#P7000497027000000000000000043662" class="calibre3 pcalibre1 pcalibre2">combine3</code></td>
<td id="P7000497027000000000000000043663" data-uri="chapter05.xhtml#P7000497027000000000000000043663" class="pcalibre1 pcalibre2 calibre7">513</td>
<td id="P7000497027000000000000000043664" data-uri="chapter05.xhtml#P7000497027000000000000000043664" class="pcalibre1 pcalibre2 calibre7">Direct data access</td>
<td id="P7000497027000000000000000043665" data-uri="chapter05.xhtml#P7000497027000000000000000043665" class="pcalibre1 pcalibre2 calibre7">7.17</td>
<td id="P7000497027000000000000000043666" data-uri="chapter05.xhtml#P7000497027000000000000000043666" class="pcalibre1 pcalibre2 calibre7">9.02</td>
<td id="P7000497027000000000000000043667" data-uri="chapter05.xhtml#P7000497027000000000000000043667" class="pcalibre1 pcalibre2 calibre7">9.02</td>
<td id="P7000497027000000000000000043668" data-uri="chapter05.xhtml#P7000497027000000000000000043668" class="pcalibre1 pcalibre2 calibre7">11.03</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043669" data-uri="chapter05.xhtml#P7000497027000000000000000043669">The CPE did not improve, even though the transformation eliminated two conditionals on each iteration that check whether the vector index is within bounds. For this function, the checks always succeed, and hence they are highly predictable.</p>
<p id="P700049702700000000000000004366A" data-uri="chapter05.xhtml#P700049702700000000000000004366A" class="pcalibre8 pcalibre1 pcalibre2">As a way to measure the performance impact of bounds checking, consider the following combining code, where we have modified the inner loop of <code id="P700049702700000000000000004366B" data-uri="chapter05.xhtml#P700049702700000000000000004366B" class="pcalibre1 calibre1 pcalibre2">combine4</code> by replacing the access to the data element with the result of performing an inline substitution of the code for <code id="P700049702700000000000000004366C" data-uri="chapter05.xhtml#P700049702700000000000000004366C" class="pcalibre1 calibre1 pcalibre2">get_vec_element</code>. We will call this new version <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004F02" title="551" data-uri="chapter05.xhtml#P7000497027000000000000000004F02" epub:type="pagebreak"></span><code id="P700049702700000000000000004366D" data-uri="chapter05.xhtml#P700049702700000000000000004366D" class="pcalibre1 calibre1 pcalibre2">combine4b</code>. This code performs bounds checking and also references the vector elements through the vector data structure.</p>
<pre id="P700049702700000000000000004366E" data-uri="chapter05.xhtml#P700049702700000000000000004366E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004366F" data-uri="chapter05.xhtml#P700049702700000000000000004366F" class="calibre3 pcalibre1 pcalibre2">
1	/* Include bounds check in loop */
2	void combine4b(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		data_t acc = IDENT;
7	
8		for (i = 0; i &lt; length; i++) {
9			if (i &gt;= 0 &amp;&amp; i &lt; v-&gt;len) {
10				acc = acc OP v-&gt;data[i];
11			}
12		}
13		*dest = acc;
14	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043670" data-uri="chapter05.xhtml#P7000497027000000000000000043670">We can then directly compare the CPE for the functions with and without bounds checking:</p>
<table id="P7000497027000000000000000043671" data-uri="chapter05.xhtml#P7000497027000000000000000043671" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043672" data-uri="chapter05.xhtml#P7000497027000000000000000043672" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P7000497027000000000000000043673" data-uri="chapter05.xhtml#P7000497027000000000000000043673" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P7000497027000000000000000043674" data-uri="chapter05.xhtml#P7000497027000000000000000043674" class="pcalibre1 pcalibre2 calibre5"/>
<th colspan="2" id="P7000497027000000000000000043675" data-uri="chapter05.xhtml#P7000497027000000000000000043675" class="pcalibre1 pcalibre2 calibre5">Integer</th>
<th colspan="2" id="P7000497027000000000000000043676" data-uri="chapter05.xhtml#P7000497027000000000000000043676" class="pcalibre1 pcalibre2 calibre5">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043677" data-uri="chapter05.xhtml#P7000497027000000000000000043677" class="pcalibre1 pcalibre2 calibre5">Function</th>
<th id="P7000497027000000000000000043678" data-uri="chapter05.xhtml#P7000497027000000000000000043678" class="pcalibre1 pcalibre2 calibre5">Page</th>
<th id="P7000497027000000000000000043679" data-uri="chapter05.xhtml#P7000497027000000000000000043679" class="pcalibre1 pcalibre2 calibre5">Method</th>
<th id="P700049702700000000000000004367A" data-uri="chapter05.xhtml#P700049702700000000000000004367A" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P700049702700000000000000004367B" data-uri="chapter05.xhtml#P700049702700000000000000004367B" class="pcalibre1 pcalibre2 calibre5">*</th>
<th id="P700049702700000000000000004367C" data-uri="chapter05.xhtml#P700049702700000000000000004367C" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P700049702700000000000000004367D" data-uri="chapter05.xhtml#P700049702700000000000000004367D" class="pcalibre1 pcalibre2 calibre5">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004367E" data-uri="chapter05.xhtml#P700049702700000000000000004367E" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004367F" data-uri="chapter05.xhtml#P700049702700000000000000004367F" class="calibre3 pcalibre1 pcalibre2">combine4</code></td>
<td id="P7000497027000000000000000043680" data-uri="chapter05.xhtml#P7000497027000000000000000043680" class="pcalibre1 pcalibre2 calibre7">515</td>
<td id="P7000497027000000000000000043681" data-uri="chapter05.xhtml#P7000497027000000000000000043681" class="pcalibre1 pcalibre2 calibre7">No bounds checking</td>
<td id="P7000497027000000000000000043682" data-uri="chapter05.xhtml#P7000497027000000000000000043682" class="pcalibre1 pcalibre2 calibre7">1.27</td>
<td id="P7000497027000000000000000043683" data-uri="chapter05.xhtml#P7000497027000000000000000043683" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P7000497027000000000000000043684" data-uri="chapter05.xhtml#P7000497027000000000000000043684" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P7000497027000000000000000043685" data-uri="chapter05.xhtml#P7000497027000000000000000043685" class="pcalibre1 pcalibre2 calibre7">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043686" data-uri="chapter05.xhtml#P7000497027000000000000000043686" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000043687" data-uri="chapter05.xhtml#P7000497027000000000000000043687" class="calibre3 pcalibre1 pcalibre2">combine4b</code></td>
<td id="P7000497027000000000000000043688" data-uri="chapter05.xhtml#P7000497027000000000000000043688" class="pcalibre1 pcalibre2 calibre7">515</td>
<td id="P7000497027000000000000000043689" data-uri="chapter05.xhtml#P7000497027000000000000000043689" class="pcalibre1 pcalibre2 calibre7">Bounds checking</td>
<td id="P700049702700000000000000004368A" data-uri="chapter05.xhtml#P700049702700000000000000004368A" class="pcalibre1 pcalibre2 calibre7">2.02</td>
<td id="P700049702700000000000000004368B" data-uri="chapter05.xhtml#P700049702700000000000000004368B" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P700049702700000000000000004368C" data-uri="chapter05.xhtml#P700049702700000000000000004368C" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P700049702700000000000000004368D" data-uri="chapter05.xhtml#P700049702700000000000000004368D" class="pcalibre1 pcalibre2 calibre7">5.01</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004368E" data-uri="chapter05.xhtml#P700049702700000000000000004368E">The version with bounds checking is slightly slower for the case of integer addition, but it achieves the same performance for the other three cases. The performance of these cases is limited by the latencies of their respective combining operations. The additional computation required to perform bounds checking can take place in parallel with the combining operations. The processor is able to predict the outcomes of these branches, and so none of this evaluation has much effect on the fetching and processing of the instructions that form the critical path in the program execution.</p>
</section>
<section id="P7000497027000000000000000004F25" data-uri="chapter05.xhtml#P7000497027000000000000000004F25" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004368F" data-uri="chapter05.xhtml#P700049702700000000000000004368F" epub:type="title">Write Code Suitable for Implementation with Conditional Moves</h1></header>
<p id="P7000497027000000000000000043690" data-uri="chapter05.xhtml#P7000497027000000000000000043690" class="pcalibre8 pcalibre1 pcalibre2">Branch prediction is only reliable for regular patterns. Many tests in a program are completely unpredictable, dependent on arbitrary features of the data, such as whether a number is negative or positive. For these, the branch prediction logic will do very poorly. For inherently unpredictable cases, program performance can be greatly enhanced if the compiler is able to generate code using conditional data transfers rather than conditional control transfers. This cannot be controlled directly by the C programmer, but some ways of expressing conditional behavior can be more directly translated into conditional moves than others.</p>
<p id="P7000497027000000000000000043691" data-uri="chapter05.xhtml#P7000497027000000000000000043691" class="pcalibre8 pcalibre1 pcalibre2">We have found that <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>is able to generate conditional moves for code written in a more "functional" style, where we use conditional operations to compute <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004F29" title="552" data-uri="chapter05.xhtml#P7000497027000000000000000004F29" epub:type="pagebreak"></span>values and then update the program state with these values, as opposed to a more "imperative" style, where we use conditionals to selectively update program state.</p>
<p id="P7000497027000000000000000043692" data-uri="chapter05.xhtml#P7000497027000000000000000043692" class="pcalibre8 pcalibre1 pcalibre2">There are no strict rules for these two styles, and so we illustrate with an example. Suppose we are given two arrays of integers <var class="pcalibre17 pcalibre2 pcalibre1">a</var> and <var class="pcalibre17 pcalibre2 pcalibre1">b</var>, and at each position <var class="pcalibre17 pcalibre2 pcalibre1">i</var>, we want to set <code id="P7000497027000000000000000043693" data-uri="chapter05.xhtml#P7000497027000000000000000043693" class="pcalibre1 calibre1 pcalibre2">a[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> to the minimum of <code id="P7000497027000000000000000043694" data-uri="chapter05.xhtml#P7000497027000000000000000043694" class="pcalibre1 calibre1 pcalibre2">a[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> and <code id="P7000497027000000000000000043695" data-uri="chapter05.xhtml#P7000497027000000000000000043695" class="pcalibre1 calibre1 pcalibre2">b[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code>, and <code id="P7000497027000000000000000043696" data-uri="chapter05.xhtml#P7000497027000000000000000043696" class="pcalibre1 calibre1 pcalibre2">b[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> to the maximum.</p>
<p id="P7000497027000000000000000043697" data-uri="chapter05.xhtml#P7000497027000000000000000043697" class="pcalibre8 pcalibre1 pcalibre2">An imperative style of implementing this function is to check at each position <var class="pcalibre17 pcalibre2 pcalibre1">i</var> and swap the two elements if they are out of order:</p>
<pre id="P7000497027000000000000000043698" data-uri="chapter05.xhtml#P7000497027000000000000000043698" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043699" data-uri="chapter05.xhtml#P7000497027000000000000000043699" class="calibre3 pcalibre1 pcalibre2">
1	/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */
2	void minmax1(long a[], long b[], long n) {
3		long i;
4		for (i = 0; i &lt; n; i++) {
5			if (a[i] &gt; b[i]) {
6				long t = a[i];
7				a[i] = b[i];
8				b[i] = t;
9			}
10		}
11	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004369A" data-uri="chapter05.xhtml#P700049702700000000000000004369A">Our measurements for this function show a CPE of around 13.5 for random data and 2.5-3.5 for predictable data, an indication of a misprediction penalty of around 20 cycles.</p>
<p id="P700049702700000000000000004369B" data-uri="chapter05.xhtml#P700049702700000000000000004369B" class="pcalibre8 pcalibre1 pcalibre2">A functional style of implementing this function is to compute the minimum and maximum values at each position <var class="pcalibre17 pcalibre2 pcalibre1">i</var> and then assign these values to <code id="P700049702700000000000000004369C" data-uri="chapter05.xhtml#P700049702700000000000000004369C" class="pcalibre1 calibre1 pcalibre2">a[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> and <code id="P700049702700000000000000004369D" data-uri="chapter05.xhtml#P700049702700000000000000004369D" class="pcalibre1 calibre1 pcalibre2">b[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code>, respectively:</p>
<pre id="P700049702700000000000000004369E" data-uri="chapter05.xhtml#P700049702700000000000000004369E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004369F" data-uri="chapter05.xhtml#P700049702700000000000000004369F" class="calibre3 pcalibre1 pcalibre2">
1	/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */
2	void minmax2(long a[], long b[], long n) {
3		long i;
4		for (i = 0; i &lt; n; i++) {
5			long min = a[i] &lt; b[i] ? a[i] : b[i];
6			long max = a[i] &lt; b[i] ? b[i] : a[i];
7			a[i] = min;
8			b[i] = max;
9		}
10	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000436A0" data-uri="chapter05.xhtml#P70004970270000000000000000436A0">Our measurements for this function show a CPE of around 4.0 regardless of whether the data are arbitrary or predictable. (We also examined the generated assembly code to make sure that it indeed uses conditional moves.)</p>
<p id="P70004970270000000000000000436A1" data-uri="chapter05.xhtml#P70004970270000000000000000436A1" class="pcalibre8 pcalibre1 pcalibre2">As discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.6.6</span></a>, not all conditional behavior can be implemented with conditional data transfers, and so there are inevitably cases where programmers cannot avoid writing code that will lead to conditional branches for which the processor will do poorly with its branch prediction. But, as we have shown, a little cleverness on the part of the programmer can sometimes make code more amenable to translation into conditional data transfers. This requires some amount <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004F3A" title="553" data-uri="chapter05.xhtml#P7000497027000000000000000004F3A" epub:type="pagebreak"></span>of experimentation, writing different versions of the function and then examining the generated assembly code and measuring performance.</p>
<section id="P7000497027000000000000000004F3B" data-uri="chapter05.xhtml#P7000497027000000000000000004F3B" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P70004970270000000000000000436A2" data-uri="chapter05.xhtml#P70004970270000000000000000436A2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.9 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005148">576</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000436A3" data-uri="chapter05.xhtml#P70004970270000000000000000436A3">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000436A4" data-uri="chapter05.xhtml#P70004970270000000000000000436A4">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000436A5" data-uri="chapter05.xhtml#P70004970270000000000000000436A5"><p id="P70004970270000000000000000436A6" data-uri="chapter05.xhtml#P70004970270000000000000000436A6" class="pcalibre1 pcalibre2 pcalibre10">The traditional implementation of the merge step of mergesort requires three loops [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B468">98</a>]:</p>
<pre id="P70004970270000000000000000436A7" data-uri="chapter05.xhtml#P70004970270000000000000000436A7" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000436A8" data-uri="chapter05.xhtml#P70004970270000000000000000436A8" class="calibre3 pcalibre1 pcalibre2">
1	void merge(long src1[], long src2[], long dest[], long n) {
2		long i1 = 0;
3		long i2 = 0;
4		long id = 0;
5		while (i1 &lt; n &amp;&amp; i2 &lt; n) {
6			if (src1[i1] &lt; src2[i2])
7				dest[id++] = src1[i1++];
8			else
9				dest[id++] = src2[i2++];
10		}
11		while (i1 &lt; n)
12			dest[id++] = src1[i1++];
13		while (i2 &lt; n)
14			dest[id++] = src2[i2++];
15	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000436A9" data-uri="chapter05.xhtml#P70004970270000000000000000436A9">The branches caused by comparing variables <code id="P70004970270000000000000000436AA" data-uri="chapter05.xhtml#P70004970270000000000000000436AA" class="pcalibre1 calibre1 pcalibre2">i1</code> and <code id="P70004970270000000000000000436AB" data-uri="chapter05.xhtml#P70004970270000000000000000436AB" class="pcalibre1 calibre1 pcalibre2">i2</code> to n have good prediction performance—the only mispredictions occur when they first become false. The comparison between values <code id="P70004970270000000000000000436AC" data-uri="chapter05.xhtml#P70004970270000000000000000436AC" class="pcalibre1 calibre1 pcalibre2">src1[i1]</code> and <code id="P70004970270000000000000000436AD" data-uri="chapter05.xhtml#P70004970270000000000000000436AD" class="pcalibre1 calibre1 pcalibre2">src2[i2]</code> (line 6), on the other hand, is highly unpredictable for typical data. This comparison controls a conditional branch, yielding a CPE (where the number of elements is 2<var class="pcalibre17 pcalibre2 pcalibre1">n</var>) of around 15.0 when run on random data.</p>
<p id="P70004970270000000000000000436AE" data-uri="chapter05.xhtml#P70004970270000000000000000436AE" class="pcalibre1 pcalibre2 pcalibre10">Rewrite the code so that the effect of the conditional statement in the first loop (lines 6-9) can be implemented with a conditional move.</p></div></li>
</ol>
</section>
</section>
</section>
</section></body></html>
