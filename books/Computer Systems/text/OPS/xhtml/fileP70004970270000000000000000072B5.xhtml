<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>9.8 Memory Mapping</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P70004970270000000000000000072B5" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000045D75" data-uri="chapter09.xhtml#P7000497027000000000000000045D75" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.8 </span>Memory Mapping</h1></header>
<p id="P7000497027000000000000000045D76" data-uri="chapter09.xhtml#P7000497027000000000000000045D76" class="pcalibre8 pcalibre1 pcalibre2">Linux initializes the contents of a virtual memory area by associating it with an <i class="pcalibre17 pcalibre2 pcalibre1">object</i> on disk, a process known as <i class="pcalibre17 pcalibre2 pcalibre1">memory mapping.</i> Areas can be mapped to one of two types of objects:</p>
<ol id="P7000497027000000000000000045D77" data-uri="chapter09.xhtml#P7000497027000000000000000045D77" class="pcalibre1 calibre19 pcalibre2">
<li id="P7000497027000000000000000045D78" data-uri="chapter09.xhtml#P7000497027000000000000000045D78" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045D79" data-uri="chapter09.xhtml#P7000497027000000000000000045D79" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Regular file in the Linux file system: </span>An area can be mapped to a contiguous section of a regular disk file, such as an executable object file. The file section is divided into page-size pieces, with each piece containing the initial contents of a virtual page. Because of demand paging, none of these virtual pages is actually swapped into physical memory until the CPU first <i class="pcalibre17 pcalibre2 pcalibre1">touches</i> the page (i.e., issues a virtual address that falls within that page's region of the address space). If the area is larger than the file section, then the area is padded with zeros.</p></li>
<li id="P7000497027000000000000000045D7A" data-uri="chapter09.xhtml#P7000497027000000000000000045D7A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045D7B" data-uri="chapter09.xhtml#P7000497027000000000000000045D7B" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Anonymous file: </span>An area can also be mapped to an anonymous file, created by the kernel, that contains all binary zeros. The first time the CPU touches a virtual page in such an area, the kernel finds an appropriate victim page in physical memory, swaps out the victim page if it is dirty, overwrites the victim page with binary zeros, and updates the page table to mark the page as resident. Notice that no data are actually transferred between disk and memory. For this reason, pages in areas that are mapped to anonymous files are sometimes called <i class="pcalibre17 pcalibre2 pcalibre1">demand-zero pages.</i></p></li>
</ol>
<p id="P7000497027000000000000000045D7C" data-uri="chapter09.xhtml#P7000497027000000000000000045D7C" class="pcalibre8 pcalibre1 pcalibre2">In either case, once a virtual page is initialized, it is swapped back and forth between a special <i class="pcalibre17 pcalibre2 pcalibre1">swap file</i> maintained by the kernel. The swap file is also known as the <i class="pcalibre17 pcalibre2 pcalibre1">swap space</i> or the <i class="pcalibre17 pcalibre2 pcalibre1">swap area.</i> An important point to realize is that at any point in time, the swap space bounds the total amount of virtual pages that can be allocated by the currently running processes.</p>
<section id="P70004970270000000000000000072BE" data-uri="chapter09.xhtml#P70004970270000000000000000072BE" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045D7D" data-uri="chapter09.xhtml#P7000497027000000000000000045D7D" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.8.1 </span>Shared Objects Revisited</h1></header>
<p id="P7000497027000000000000000045D7E" data-uri="chapter09.xhtml#P7000497027000000000000000045D7E" class="pcalibre8 pcalibre1 pcalibre2">The idea of memory mapping resulted from a clever insight that if the virtual memory system could be integrated into the conventional file system, then it could provide a simple and efficient way to load programs and data into memory.</p>
<p id="P7000497027000000000000000045D7F" data-uri="chapter09.xhtml#P7000497027000000000000000045D7F" class="pcalibre8 pcalibre1 pcalibre2">As we have seen, the process abstraction promises to provide each process with its own private virtual address space that is protected from errant writes or reads by other processes. However, many processes have identical read-only code areas. For example, each process that runs the Linux shell program bash has the same code area. Further, many programs need to access identical copies of read-only run-time library code. For example, every C program requires functions from the standard C library such as <code id="P7000497027000000000000000045D80" data-uri="chapter09.xhtml#P7000497027000000000000000045D80" class="pcalibre1 calibre1 pcalibre2">printf</code>. It would be extremely wasteful for each process to keep duplicate copies of these commonly used codes in physical <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000072C3" title="834" data-uri="chapter09.xhtml#P70004970270000000000000000072C3" epub:type="pagebreak"></span>memory. Fortunately, memory mapping provides us with a clean mechanism for controlling how objects are shared by multiple processes.</p>
<p id="P7000497027000000000000000045D81" data-uri="chapter09.xhtml#P7000497027000000000000000045D81" class="pcalibre8 pcalibre1 pcalibre2">An object can be mapped into an area of virtual memory as either a <i class="pcalibre17 pcalibre2 pcalibre1">shared object</i> or <i class="pcalibre17 pcalibre2 pcalibre1">a private object.</i> If a process maps a shared object into an area of its virtual address space, then any writes that the process makes to that area are visible to any other processes that have also mapped the shared object into their virtual memory. Further, the changes are also reflected in the original object on disk.</p>
<p id="P7000497027000000000000000045D82" data-uri="chapter09.xhtml#P7000497027000000000000000045D82" class="pcalibre8 pcalibre1 pcalibre2">Changes made to an area mapped to a private object, on the other hand, are not visible to other processes, and any writes that the process makes to the area are <i class="pcalibre17 pcalibre2 pcalibre1">not</i> reflected back to the object on disk. A virtual memory area into which a shared object is mapped is often called a <i class="pcalibre17 pcalibre2 pcalibre1">shared area.</i> Similarly for <i class="pcalibre17 pcalibre2 pcalibre1">a private area.</i></p>
<p id="P7000497027000000000000000045D83" data-uri="chapter09.xhtml#P7000497027000000000000000045D83" class="pcalibre8 pcalibre1 pcalibre2">Suppose that process 1 maps a shared object into an area of its virtual memory, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000072C7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.29(a)</span></a>. Now suppose that process 2 maps the same shared object</p>
<figure id="P70004970270000000000000000072C7" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000072C7">
<img alt="Diagram (a) shows shared object mapped to process 1 virtual memory (shared with physical memory). Diagram (b) shows shared object mapped to process 1 and process 2 virtual memory." id="P7000497027000000000000000045D84" data-uri="P700049702700000000000000000B798" src="../images/p834-1.png" class="pcalibre1 pcalibre2 calibre75"/>
<figcaption id="P7000497027000000000000000045D85" data-uri="chapter09.xhtml#P7000497027000000000000000045D85" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045D86" data-uri="chapter09.xhtml#P7000497027000000000000000045D86" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.29 </span>A shared object.</h1></header><div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000045D87" data-uri="chapter09.xhtml#P7000497027000000000000000045D87"><p id="P7000497027000000000000000045D88" data-uri="chapter09.xhtml#P7000497027000000000000000045D88" class="pcalibre1 pcalibre2 pcalibre10">(a) After process 1 maps the shared object, (b) After process 2 maps the same shared object. (Note that the physical pages are not necessarily contiguous.)</p></div></figcaption>
</figure>
<figure id="P70004970270000000000000000072CD" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000072CD">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000072CE" title="835" data-uri="chapter09.xhtml#P70004970270000000000000000072CE" epub:type="pagebreak"></span>
<img alt="Diagrams illustrate a private copy-on-write object." id="P7000497027000000000000000045D89" data-uri="P700049702700000000000000000B799" src="../images/p835-1.png" class="pcalibre1 pcalibre2 calibre76"/>
<figcaption id="P7000497027000000000000000045D8A" data-uri="chapter09.xhtml#P7000497027000000000000000045D8A" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045D8B" data-uri="chapter09.xhtml#P7000497027000000000000000045D8B" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.30 </span>A private copy-on-write object.</h1></header><div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000045D8C" data-uri="chapter09.xhtml#P7000497027000000000000000045D8C"><p id="P7000497027000000000000000045D8D" data-uri="chapter09.xhtml#P7000497027000000000000000045D8D" class="pcalibre1 pcalibre2 pcalibre10">(a) After both processes have mapped the private copy-on-write object, (b) After process 2 writes to a page in the private area.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000260DB" data-uri="chapter09.xhtml#P70004970270000000000000000260DB">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ul id="P7000497027000000000000000045D8E" data-uri="chapter09.xhtml#P7000497027000000000000000045D8E" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000045D8F" data-uri="chapter09.xhtml#P7000497027000000000000000045D8F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045D90" data-uri="chapter09.xhtml#P7000497027000000000000000045D90" class="pcalibre1 pcalibre2 pcalibre10">Diagram (a) shows private copy-on-write object mapped to process 1 and process 2 virtual memory.</p></li>
<li id="P7000497027000000000000000045D91" data-uri="chapter09.xhtml#P7000497027000000000000000045D91" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045D92" data-uri="chapter09.xhtml#P7000497027000000000000000045D92" class="pcalibre1 pcalibre2 pcalibre10">Diagram (b) shows private copy-on-write object mapped to process 1 and process 2 virtual memory. The copy-on-write segment is repeated in physical memory, which is then mapped as write to private copy-on-write page on process 2 virtual memory.</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045D93" data-uri="chapter09.xhtml#P7000497027000000000000000045D93">into its address space (not necessarily at the same virtual address as process 1), as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000072C7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.29(b)</span></a>.</p>
<p id="P7000497027000000000000000045D94" data-uri="chapter09.xhtml#P7000497027000000000000000045D94" class="pcalibre8 pcalibre1 pcalibre2">Since each object has a unique filename, the kernel can quickly determine that process 1 has already mapped this object and can point the page table entries in process 2 to the appropriate physical pages. The key point is that only a single copy of the shared object needs to be stored in physical memory, even though the object is mapped into multiple shared areas. For convenience, we have shown the physical pages as being contiguous, but of course this is not true in general.</p>
<p id="P7000497027000000000000000045D95" data-uri="chapter09.xhtml#P7000497027000000000000000045D95" class="pcalibre8 pcalibre1 pcalibre2">Private objects are mapped into virtual memory using a clever technique known as <i class="pcalibre17 pcalibre2 pcalibre1">copy-on-write.</i> A private object begins life in exactly the same way as a shared object, with only one copy of the private object stored in physical memory. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000072CD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.30(a)</span></a> shows a case where two processes have mapped a private object into different areas of their virtual memories but share the same <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000072D7" title="836" data-uri="chapter09.xhtml#P70004970270000000000000000072D7" epub:type="pagebreak"></span>physical copy of the object. For each process that maps the private object, the page table entries for the corresponding private area are flagged as read-only, and the area struct is flagged <i class="pcalibre17 pcalibre2 pcalibre1">as private copy-on-write.</i> So long as neither process attempts to write to its respective private area, they continue to share a single copy of the object in physical memory. However, as soon as a process attempts to write to some page in the private area, the write triggers a protection fault.</p>
<p id="P7000497027000000000000000045D96" data-uri="chapter09.xhtml#P7000497027000000000000000045D96" class="pcalibre8 pcalibre1 pcalibre2">When the fault handler notices that the protection exception was caused by the process trying to write to a page in a private copy-on-write area, it creates a new copy of the page in physical memory, updates the page table entry to point to the new copy, and then restores write permissions to the page, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000072CD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.30(b)</span></a>. When the fault handler returns, the CPU re-executes the write, which now proceeds normally on the newly created page.</p>
<p id="P7000497027000000000000000045D97" data-uri="chapter09.xhtml#P7000497027000000000000000045D97" class="pcalibre8 pcalibre1 pcalibre2">By deferring the copying of the pages in private objects until the last possible moment, copy-on-write makes the most efficient use of scarce physical memory.</p>
</section>
<section id="P70004970270000000000000000072DA" data-uri="chapter09.xhtml#P70004970270000000000000000072DA" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045D98" data-uri="chapter09.xhtml#P7000497027000000000000000045D98" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.8.2 </span>The <code id="P7000497027000000000000000045D99" data-uri="chapter09.xhtml#P7000497027000000000000000045D99" class="pcalibre1 calibre1 pcalibre2">fork</code> Function Revisited</h1></header>
<p id="P7000497027000000000000000045D9A" data-uri="chapter09.xhtml#P7000497027000000000000000045D9A" class="pcalibre8 pcalibre1 pcalibre2">Now that we understand virtual memory and memory mapping, we can get a clear idea of how the <code id="P7000497027000000000000000045D9B" data-uri="chapter09.xhtml#P7000497027000000000000000045D9B" class="pcalibre1 calibre1 pcalibre2">fork</code> function creates a new process with its own independent virtual address space.</p>
<p id="P7000497027000000000000000045D9C" data-uri="chapter09.xhtml#P7000497027000000000000000045D9C" class="pcalibre8 pcalibre1 pcalibre2">When the <code id="P7000497027000000000000000045D9D" data-uri="chapter09.xhtml#P7000497027000000000000000045D9D" class="pcalibre1 calibre1 pcalibre2">fork</code> function is called by the <i class="pcalibre17 pcalibre2 pcalibre1">current process</i>, the kernel creates various data structures for the <i class="pcalibre17 pcalibre2 pcalibre1">new process</i> and assigns it a unique PID. To create the virtual memory for the new process, it creates exact copies of the current process's <code id="P7000497027000000000000000045D9E" data-uri="chapter09.xhtml#P7000497027000000000000000045D9E" class="pcalibre1 calibre1 pcalibre2">mm_struct</code>, area structs, and page tables. It flags each page in both processes as read-only, and flags each area struct in both processes as private copy-on-write.</p>
<p id="P7000497027000000000000000045D9F" data-uri="chapter09.xhtml#P7000497027000000000000000045D9F" class="pcalibre8 pcalibre1 pcalibre2">When the <code id="P7000497027000000000000000045DA0" data-uri="chapter09.xhtml#P7000497027000000000000000045DA0" class="pcalibre1 calibre1 pcalibre2">fork</code> returns in the new process, the new process now has an exact copy of the virtual memory as it existed when the fork was called. When either of the processes performs any subsequent writes, the copy-on-write mechanism creates new pages, thus preserving the abstraction of a private address space for each process.</p>
</section>
<section id="P70004970270000000000000000072E4" data-uri="chapter09.xhtml#P70004970270000000000000000072E4" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045DA1" data-uri="chapter09.xhtml#P7000497027000000000000000045DA1" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.8.3 </span>The execve Function Revisited</h1></header>
<p id="P7000497027000000000000000045DA2" data-uri="chapter09.xhtml#P7000497027000000000000000045DA2" class="pcalibre8 pcalibre1 pcalibre2">Virtual memory and memory mapping also play key roles in the process of loading programs into memory. Now that we understand these concepts, we can understand how the <code id="P7000497027000000000000000045DA3" data-uri="chapter09.xhtml#P7000497027000000000000000045DA3" class="pcalibre1 calibre1 pcalibre2">execve</code> function really loads and executes programs. Suppose that the program running in the current process makes the following call:</p>
<pre id="P7000497027000000000000000045DA4" data-uri="chapter09.xhtml#P7000497027000000000000000045DA4" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045DA5" data-uri="chapter09.xhtml#P7000497027000000000000000045DA5" class="calibre3 pcalibre1 pcalibre2">
execve("a.out", NULL, NULL);
</code></pre>
<p id="P7000497027000000000000000045DA6" data-uri="chapter09.xhtml#P7000497027000000000000000045DA6" class="pcalibre8 pcalibre1 pcalibre2">As you learned in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">8</span></a>, the <code id="P7000497027000000000000000045DA7" data-uri="chapter09.xhtml#P7000497027000000000000000045DA7" class="pcalibre1 calibre1 pcalibre2">execve</code> function loads and runs the program contained in the executable object file <code id="P7000497027000000000000000045DA8" data-uri="chapter09.xhtml#P7000497027000000000000000045DA8" class="pcalibre1 calibre1 pcalibre2">a.out</code> within the current process, effectively replacing the current program with the <code id="P7000497027000000000000000045DA9" data-uri="chapter09.xhtml#P7000497027000000000000000045DA9" class="pcalibre1 calibre1 pcalibre2">a.out</code> program. Loading and running <code id="P7000497027000000000000000045DAA" data-uri="chapter09.xhtml#P7000497027000000000000000045DAA" class="pcalibre1 calibre1 pcalibre2">a.out</code> requires the following steps:</p>
<figure id="P70004970270000000000000000072EF" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000072EF">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000072F0" title="837" data-uri="chapter09.xhtml#P70004970270000000000000000072F0" epub:type="pagebreak"></span>
<img alt="A diagram illustrates how the loader maps the areas of the user address space." id="P7000497027000000000000000045DAB" data-uri="P700049702700000000000000000B79A" src="../images/p837-1.png" class="pcalibre1 pcalibre2 pcalibre279"/>
<figcaption id="P7000497027000000000000000045DAC" data-uri="chapter09.xhtml#P7000497027000000000000000045DAC" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045DAD" data-uri="chapter09.xhtml#P7000497027000000000000000045DAD" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.31 </span>How the loader maps the areas of the user address space.</h1></header>

<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000260FC" data-uri="chapter09.xhtml#P70004970270000000000000000260FC">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045DAE" data-uri="chapter09.xhtml#P7000497027000000000000000045DAE" class="pcalibre8 pcalibre1 pcalibre2">A diagram of a stack has the following areas, listed from bottom to top:</p>
<ul id="P7000497027000000000000000045DAF" data-uri="chapter09.xhtml#P7000497027000000000000000045DAF" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000045DB0" data-uri="chapter09.xhtml#P7000497027000000000000000045DB0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DB1" data-uri="chapter09.xhtml#P7000497027000000000000000045DB1" class="pcalibre1 pcalibre2 pcalibre10">Gap from 0</p></li>
<li id="P7000497027000000000000000045DB2" data-uri="chapter09.xhtml#P7000497027000000000000000045DB2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DB3" data-uri="chapter09.xhtml#P7000497027000000000000000045DB3" class="pcalibre1 pcalibre2 pcalibre10">Code (.text) and Initialized data (.data); together part of a.out and private, file-backed</p></li>
<li id="P7000497027000000000000000045DB4" data-uri="chapter09.xhtml#P7000497027000000000000000045DB4" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DB5" data-uri="chapter09.xhtml#P7000497027000000000000000045DB5" class="pcalibre1 pcalibre2 pcalibre10">Uninitialized data (.bss) (private, demand-zero)</p></li>
<li id="P7000497027000000000000000045DB6" data-uri="chapter09.xhtml#P7000497027000000000000000045DB6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DB7" data-uri="chapter09.xhtml#P7000497027000000000000000045DB7" class="pcalibre1 pcalibre2 pcalibre10">Run-time heap (via malloc) (private, demand-zero)</p></li>
<li id="P7000497027000000000000000045DB8" data-uri="chapter09.xhtml#P7000497027000000000000000045DB8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DB9" data-uri="chapter09.xhtml#P7000497027000000000000000045DB9" class="pcalibre1 pcalibre2 pcalibre10">Gap</p></li>
<li id="P7000497027000000000000000045DBA" data-uri="chapter09.xhtml#P7000497027000000000000000045DBA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DBB" data-uri="chapter09.xhtml#P7000497027000000000000000045DBB" class="pcalibre1 pcalibre2 pcalibre10">Memory-mapped region for shared libraries (libc.so containing .data and .text; shared, file-backed)</p></li>
<li id="P7000497027000000000000000045DBC" data-uri="chapter09.xhtml#P7000497027000000000000000045DBC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DBD" data-uri="chapter09.xhtml#P7000497027000000000000000045DBD" class="pcalibre1 pcalibre2 pcalibre10">Gap</p></li>
<li id="P7000497027000000000000000045DBE" data-uri="chapter09.xhtml#P7000497027000000000000000045DBE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DBF" data-uri="chapter09.xhtml#P7000497027000000000000000045DBF" class="pcalibre1 pcalibre2 pcalibre10">User stack (private, demand-zero).</p></li>
</ul>
</details>
</figcaption>
</figure>
<ol id="P7000497027000000000000000045DC0" data-uri="chapter09.xhtml#P7000497027000000000000000045DC0" class="pcalibre1 calibre19 pcalibre2">
<li id="P7000497027000000000000000045DC1" data-uri="chapter09.xhtml#P7000497027000000000000000045DC1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DC2" data-uri="chapter09.xhtml#P7000497027000000000000000045DC2" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Delete existing user areas. </span>Delete the existing area structs in the user portion of the current process's virtual address.</p></li>
<li id="P7000497027000000000000000045DC3" data-uri="chapter09.xhtml#P7000497027000000000000000045DC3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DC4" data-uri="chapter09.xhtml#P7000497027000000000000000045DC4" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Map private areas. </span>Create new area structs for the code, data, bss, and stack areas of the new program. All of these new areas are private copy-on-write. The code and data areas are mapped to the <code id="P7000497027000000000000000045DC5" data-uri="chapter09.xhtml#P7000497027000000000000000045DC5" class="pcalibre1 calibre1 pcalibre2">.text</code> and <code id="P7000497027000000000000000045DC6" data-uri="chapter09.xhtml#P7000497027000000000000000045DC6" class="pcalibre1 calibre1 pcalibre2">.data</code> sections of the <code id="P7000497027000000000000000045DC7" data-uri="chapter09.xhtml#P7000497027000000000000000045DC7" class="pcalibre1 calibre1 pcalibre2">a.out</code> file. The bss area is demand-zero, mapped to an anonymous file whose size is contained in <code id="P7000497027000000000000000045DC8" data-uri="chapter09.xhtml#P7000497027000000000000000045DC8" class="pcalibre1 calibre1 pcalibre2">a.out</code>. The stack and heap area are also demand-zero, initially of zero length. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000072EF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.31</span></a> summarizes the different mappings of the private areas.</p></li>
<li id="P7000497027000000000000000045DC9" data-uri="chapter09.xhtml#P7000497027000000000000000045DC9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DCA" data-uri="chapter09.xhtml#P7000497027000000000000000045DCA" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Map shared areas. </span>If the <code id="P7000497027000000000000000045DCB" data-uri="chapter09.xhtml#P7000497027000000000000000045DCB" class="pcalibre1 calibre1 pcalibre2">a.out</code> program was linked with shared objects, such as the standard C library <code id="P7000497027000000000000000045DCC" data-uri="chapter09.xhtml#P7000497027000000000000000045DCC" class="pcalibre1 calibre1 pcalibre2">libc.so</code>, then these objects are dynamically linked into the program, and then mapped into the shared region of the user's virtual address space.</p></li>
<li id="P7000497027000000000000000045DCD" data-uri="chapter09.xhtml#P7000497027000000000000000045DCD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DCE" data-uri="chapter09.xhtml#P7000497027000000000000000045DCE" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Set the program counter (PC). </span>The last thing that <code id="P7000497027000000000000000045DCF" data-uri="chapter09.xhtml#P7000497027000000000000000045DCF" class="pcalibre1 calibre1 pcalibre2">execve</code> does is to set the program counter in the current process's context to point to the entry point in the code area.</p></li>
</ol>
<p id="P7000497027000000000000000045DD0" data-uri="chapter09.xhtml#P7000497027000000000000000045DD0" class="pcalibre8 pcalibre1 pcalibre2">The next time this process is scheduled, it will begin execution from the entry point. Linux will swap in code and data pages as needed.</p>
</section>
<section id="P7000497027000000000000000007305" data-uri="chapter09.xhtml#P7000497027000000000000000007305" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045DD1" data-uri="chapter09.xhtml#P7000497027000000000000000045DD1" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.8.4 </span>User-Level Memory Mapping with the <code id="P7000497027000000000000000045DD2" data-uri="chapter09.xhtml#P7000497027000000000000000045DD2" class="pcalibre1 calibre1 pcalibre2">mmap</code> Function</h1></header>
<p id="P7000497027000000000000000045DD3" data-uri="chapter09.xhtml#P7000497027000000000000000045DD3" class="pcalibre8 pcalibre1 pcalibre2">Linux processes can use the <code id="P7000497027000000000000000045DD4" data-uri="chapter09.xhtml#P7000497027000000000000000045DD4" class="pcalibre1 calibre1 pcalibre2">mmap</code> function to create new areas of virtual memory and to map objects into these areas.</p>
<figure id="P700049702700000000000000000730A" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P700049702700000000000000000730A">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000730B" title="838" data-uri="chapter09.xhtml#P700049702700000000000000000730B" epub:type="pagebreak"></span>
<img alt="A diagram shows a mapping of a section between the following: disk file specified by file descriptor fd, with length (bytes) beginning at offset (bytes); process virtual memory with length (bytes) beginning at start (or address chosen by the kernel), higher than offset." id="P7000497027000000000000000045DD5" data-uri="P700049702700000000000000000B79B" src="../images/p838-1.png" class="pcalibre280 pcalibre1 pcalibre2"/>
<figcaption id="P7000497027000000000000000045DD6" data-uri="chapter09.xhtml#P7000497027000000000000000045DD6" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045DD7" data-uri="chapter09.xhtml#P7000497027000000000000000045DD7" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.32 </span>Visual interpretation of <code id="P7000497027000000000000000045DD8" data-uri="chapter09.xhtml#P7000497027000000000000000045DD8" class="pcalibre1 calibre1 pcalibre2">mmap</code> arguments.</h1></header></figcaption>
</figure>
<pre id="P7000497027000000000000000045DD9" data-uri="chapter09.xhtml#P7000497027000000000000000045DD9" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045DDA" data-uri="chapter09.xhtml#P7000497027000000000000000045DDA" class="calibre3 pcalibre1 pcalibre2">
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;

void *mmap(void *start, size_t length, int prot, int flags,
			 int fd, off_t offset);
				Returns: pointer to mapped area if OK, MAP_FAILED (–1) on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045DDB" data-uri="chapter09.xhtml#P7000497027000000000000000045DDB">The <code id="P7000497027000000000000000045DDC" data-uri="chapter09.xhtml#P7000497027000000000000000045DDC" class="pcalibre1 calibre1 pcalibre2">mmap</code> function asks the kernel to create a new virtual memory area, preferably one that starts at address <code id="P7000497027000000000000000045DDD" data-uri="chapter09.xhtml#P7000497027000000000000000045DDD" class="pcalibre1 calibre1 pcalibre2">start</code>, and to map a contiguous chunk of the object specified by file descriptor <code id="P7000497027000000000000000045DDE" data-uri="chapter09.xhtml#P7000497027000000000000000045DDE" class="pcalibre1 calibre1 pcalibre2">fd</code> to the new area. The contiguous object chunk has a size of length bytes and starts at an <code id="P7000497027000000000000000045DDF" data-uri="chapter09.xhtml#P7000497027000000000000000045DDF" class="pcalibre1 calibre1 pcalibre2">offset</code> of offset bytes from the beginning of the file. The <code id="P7000497027000000000000000045DE0" data-uri="chapter09.xhtml#P7000497027000000000000000045DE0" class="pcalibre1 calibre1 pcalibre2">start</code> address is merely a hint, and is usually specified as NULL. For our purposes, we will always assume a NULL start address. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000730A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.32</span></a> depicts the meaning of these arguments.</p>
<p id="P7000497027000000000000000045DE1" data-uri="chapter09.xhtml#P7000497027000000000000000045DE1" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000045DE2" data-uri="chapter09.xhtml#P7000497027000000000000000045DE2" class="pcalibre1 calibre1 pcalibre2">prot</code> argument contains bits that describe the access permissions of the newly mapped virtual memory area (i.e., the <code id="P7000497027000000000000000045DE3" data-uri="chapter09.xhtml#P7000497027000000000000000045DE3" class="pcalibre1 calibre1 pcalibre2">vm_prot</code> bits in the corresponding area struct).</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P7000497027000000000000000045DE4" data-uri="chapter09.xhtml#P7000497027000000000000000045DE4">
<li id="P7000497027000000000000000045DE5" data-uri="chapter09.xhtml#P7000497027000000000000000045DE5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DE6" data-uri="chapter09.xhtml#P7000497027000000000000000045DE6" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">PROT_EXEC. </span>Pages in the area consist of instructions that may be executed by the CPU.</p></li>
<li id="P7000497027000000000000000045DE7" data-uri="chapter09.xhtml#P7000497027000000000000000045DE7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DE8" data-uri="chapter09.xhtml#P7000497027000000000000000045DE8" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">PROT_READ. </span>Pages in the area may be read.</p></li>
<li id="P7000497027000000000000000045DE9" data-uri="chapter09.xhtml#P7000497027000000000000000045DE9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DEA" data-uri="chapter09.xhtml#P7000497027000000000000000045DEA" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">PROT_WRITE. </span>Pages in the area may be written.</p></li>
<li id="P7000497027000000000000000045DEB" data-uri="chapter09.xhtml#P7000497027000000000000000045DEB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045DEC" data-uri="chapter09.xhtml#P7000497027000000000000000045DEC" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">PROT_NONE. </span>Pages in the area cannot be accessed.</p></li>
</ul>
<p id="P7000497027000000000000000045DED" data-uri="chapter09.xhtml#P7000497027000000000000000045DED" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000045DEE" data-uri="chapter09.xhtml#P7000497027000000000000000045DEE" class="pcalibre1 calibre1 pcalibre2">flags</code> argument consists of bits that describe the type of the mapped object. If the MAP_ANON flag bit is set, then the backing store is an anonymous object and the corresponding virtual pages are demand-zero. MAP_PRIVATE indicates a private copy-on-write object, and MAP_SHARED indicates a shared object. For example,</p>
<pre id="P7000497027000000000000000045DEF" data-uri="chapter09.xhtml#P7000497027000000000000000045DEF" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045DF0" data-uri="chapter09.xhtml#P7000497027000000000000000045DF0" class="calibre3 pcalibre1 pcalibre2">
bufp = Mmap(NULL, size, PROT_READ, MAP_PRIVATEIMAP_ANON, 0, 0);
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045DF1" data-uri="chapter09.xhtml#P7000497027000000000000000045DF1"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007329" title="839" data-uri="chapter09.xhtml#P7000497027000000000000000007329" epub:type="pagebreak"></span>asks the kernel to create a new read-only, private, demand-zero area of virtual memory containing size bytes. If the call is successful, then <code id="P7000497027000000000000000045DF2" data-uri="chapter09.xhtml#P7000497027000000000000000045DF2" class="pcalibre1 calibre1 pcalibre2">bufp</code> contains the address of the new area.</p>
<p id="P7000497027000000000000000045DF3" data-uri="chapter09.xhtml#P7000497027000000000000000045DF3" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000045DF4" data-uri="chapter09.xhtml#P7000497027000000000000000045DF4" class="pcalibre1 calibre1 pcalibre2">munmap</code> function deletes regions of virtual memory:</p>
<pre id="P7000497027000000000000000045DF5" data-uri="chapter09.xhtml#P7000497027000000000000000045DF5" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045DF6" data-uri="chapter09.xhtml#P7000497027000000000000000045DF6" class="calibre3 pcalibre1 pcalibre2">
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;

int munmap(void *start, size_t length);
											Returns: 0 if OK, –1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045DF7" data-uri="chapter09.xhtml#P7000497027000000000000000045DF7">The <code id="P7000497027000000000000000045DF8" data-uri="chapter09.xhtml#P7000497027000000000000000045DF8" class="pcalibre1 calibre1 pcalibre2">munmap</code> function deletes the area starting at virtual address <code id="P7000497027000000000000000045DF9" data-uri="chapter09.xhtml#P7000497027000000000000000045DF9" class="pcalibre1 calibre1 pcalibre2">start</code> and consisting of the next <code id="P7000497027000000000000000045DFA" data-uri="chapter09.xhtml#P7000497027000000000000000045DFA" class="pcalibre1 calibre1 pcalibre2">length</code> bytes. Subsequent references to the deleted region result in segmentation faults.</p>
<section id="P7000497027000000000000000007333" data-uri="chapter09.xhtml#P7000497027000000000000000007333" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000045DFB" data-uri="chapter09.xhtml#P7000497027000000000000000045DFB" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">9.5 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P70004970270000000000000000077D5">882</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000045DFC" data-uri="chapter09.xhtml#P7000497027000000000000000045DFC">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000045DFD" data-uri="chapter09.xhtml#P7000497027000000000000000045DFD">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000045DFE" data-uri="chapter09.xhtml#P7000497027000000000000000045DFE"><p id="P7000497027000000000000000045DFF" data-uri="chapter09.xhtml#P7000497027000000000000000045DFF" class="pcalibre1 pcalibre2 pcalibre10">Write a C program <code id="P7000497027000000000000000045E00" data-uri="chapter09.xhtml#P7000497027000000000000000045E00" class="pcalibre1 calibre1 pcalibre2">mmapcopy.c</code> that uses <code id="P7000497027000000000000000045E01" data-uri="chapter09.xhtml#P7000497027000000000000000045E01" class="pcalibre1 calibre1 pcalibre2">mmap</code> to copy an arbitrary-size disk file to <code id="P7000497027000000000000000045E02" data-uri="chapter09.xhtml#P7000497027000000000000000045E02" class="pcalibre1 calibre1 pcalibre2">stdout</code>. The name of the input file should be passed as a command-line argument.</p></div></li></ol>
</section>
</section>
</section></body></html>
