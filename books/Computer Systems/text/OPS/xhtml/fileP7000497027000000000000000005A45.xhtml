<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>6.6 Putting It Together: The Impact of Caches on Program Performance</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000005A45" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000004419E" data-uri="chapter06.xhtml#P700049702700000000000000004419E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">6.6 </span>Putting It Together: The Impact of Caches on Program Performance</h1></header>
<p id="P700049702700000000000000004419F" data-uri="chapter06.xhtml#P700049702700000000000000004419F" class="pcalibre8 pcalibre1 pcalibre2">This section wraps up our discussion of the memory hierarchy by studying the impact that caches have on the performance of programs running on real machines.</p>
<section id="P7000497027000000000000000005A48" data-uri="chapter06.xhtml#P7000497027000000000000000005A48" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000441A0" data-uri="chapter06.xhtml#P70004970270000000000000000441A0" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">6.6.1 </span>The Memory Mountain</h1></header>
<p id="P70004970270000000000000000441A1" data-uri="chapter06.xhtml#P70004970270000000000000000441A1" class="pcalibre8 pcalibre1 pcalibre2">The rate that a program reads data from the memory system is called the <i class="pcalibre17 pcalibre2 pcalibre1">read throughput</i>, or sometimes the <i class="pcalibre17 pcalibre2 pcalibre1">read bandwidth</i>. If a program reads <var class="pcalibre17 pcalibre2 pcalibre1">n</var> bytes over a period of <var class="pcalibre17 pcalibre2 pcalibre1">s</var> seconds, then the read throughput over that period is <i class="pcalibre17 pcalibre2 pcalibre1">n/s</i>, typically expressed in units of megabytes per second (MB/s).</p>
<p id="P70004970270000000000000000441A2" data-uri="chapter06.xhtml#P70004970270000000000000000441A2" class="pcalibre8 pcalibre1 pcalibre2">If we were to write a program that issued a sequence of read requests from a tight program loop, then the measured read throughput would give us some insight into the performance of the memory system for that particular sequence of reads. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005A68"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.40</span></a> shows a pair of functions that measure the read throughput for a particular read sequence.</p>
<p id="P70004970270000000000000000441A3" data-uri="chapter06.xhtml#P70004970270000000000000000441A3" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P70004970270000000000000000441A4" data-uri="chapter06.xhtml#P70004970270000000000000000441A4" class="pcalibre1 calibre1 pcalibre2">test</code> function generates the read sequence by scanning the first <code id="P70004970270000000000000000441A5" data-uri="chapter06.xhtml#P70004970270000000000000000441A5" class="pcalibre1 calibre1 pcalibre2">elems</code> elements of an array with a stride of <code id="P70004970270000000000000000441A6" data-uri="chapter06.xhtml#P70004970270000000000000000441A6" class="pcalibre1 calibre1 pcalibre2">stride</code>. To increase the available parallelism in the inner loop, it uses 4 × 4 unrolling (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004D16.xhtml#P7000497027000000000000000004D16"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">5.9</span></a>). The <code id="P70004970270000000000000000441A7" data-uri="chapter06.xhtml#P70004970270000000000000000441A7" class="pcalibre1 calibre1 pcalibre2">run</code> function is a wrapper that calls the <code id="P70004970270000000000000000441A8" data-uri="chapter06.xhtml#P70004970270000000000000000441A8" class="pcalibre1 calibre1 pcalibre2">test</code> function and returns the measured read throughput. The call to the <code id="P70004970270000000000000000441A9" data-uri="chapter06.xhtml#P70004970270000000000000000441A9" class="pcalibre1 calibre1 pcalibre2">test</code> function in line 37 warms the cache. The <code id="P70004970270000000000000000441AA" data-uri="chapter06.xhtml#P70004970270000000000000000441AA" class="pcalibre1 calibre1 pcalibre2">fcyc2</code> function in line 38 calls the <code id="P70004970270000000000000000441AB" data-uri="chapter06.xhtml#P70004970270000000000000000441AB" class="pcalibre1 calibre1 pcalibre2">test</code> function with arguments <code id="P70004970270000000000000000441AC" data-uri="chapter06.xhtml#P70004970270000000000000000441AC" class="pcalibre1 calibre1 pcalibre2">elems</code> and estimates the running time of the <code id="P70004970270000000000000000441AD" data-uri="chapter06.xhtml#P70004970270000000000000000441AD" class="pcalibre1 calibre1 pcalibre2">test</code> function in CPU cycles. Notice that the <code id="P70004970270000000000000000441AE" data-uri="chapter06.xhtml#P70004970270000000000000000441AE" class="pcalibre1 calibre1 pcalibre2">size</code> argument to the <code id="P70004970270000000000000000441AF" data-uri="chapter06.xhtml#P70004970270000000000000000441AF" class="pcalibre1 calibre1 pcalibre2">run</code> function is in units of bytes, while the corresponding <code id="P70004970270000000000000000441B0" data-uri="chapter06.xhtml#P70004970270000000000000000441B0" class="pcalibre1 calibre1 pcalibre2">elems</code> argument to the <code id="P70004970270000000000000000441B1" data-uri="chapter06.xhtml#P70004970270000000000000000441B1" class="pcalibre1 calibre1 pcalibre2">test</code> function is in units of array elements. Also, notice that line 39 computes MB/s as 10<sup class="pcalibre1 pcalibre2 pcalibre85">6</sup> bytes/s, as opposed to 2<sup class="pcalibre1 pcalibre2 pcalibre85">20</sup> bytes/s.</p>
<p id="P70004970270000000000000000441B2" data-uri="chapter06.xhtml#P70004970270000000000000000441B2" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P70004970270000000000000000441B3" data-uri="chapter06.xhtml#P70004970270000000000000000441B3" class="pcalibre1 calibre1 pcalibre2">size</code> and <code id="P70004970270000000000000000441B4" data-uri="chapter06.xhtml#P70004970270000000000000000441B4" class="pcalibre1 calibre1 pcalibre2">stride</code> arguments to the <code id="P70004970270000000000000000441B5" data-uri="chapter06.xhtml#P70004970270000000000000000441B5" class="pcalibre1 calibre1 pcalibre2">run</code> function allow us to control the degree of temporal and spatial locality in the resulting read sequence. Smaller values of <code id="P70004970270000000000000000441B6" data-uri="chapter06.xhtml#P70004970270000000000000000441B6" class="pcalibre1 calibre1 pcalibre2">size</code> result in a smaller working set size, and thus better temporal locality. Smaller values of <code id="P70004970270000000000000000441B7" data-uri="chapter06.xhtml#P70004970270000000000000000441B7" class="pcalibre1 calibre1 pcalibre2">stride</code> result in better spatial locality. If we call the <code id="P70004970270000000000000000441B8" data-uri="chapter06.xhtml#P70004970270000000000000000441B8" class="pcalibre1 calibre1 pcalibre2">run</code> function repeatedly with different values of <code id="P70004970270000000000000000441B9" data-uri="chapter06.xhtml#P70004970270000000000000000441B9" class="pcalibre1 calibre1 pcalibre2">size</code> and <code id="P70004970270000000000000000441BA" data-uri="chapter06.xhtml#P70004970270000000000000000441BA" class="pcalibre1 calibre1 pcalibre2">stride</code>, then we can recover a fascinating two-dimensional function of read throughput versus temporal and spatial locality. This function is called a <i class="pcalibre17 pcalibre2 pcalibre1">memory mountain</i> [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B484">112</a>].</p>
<p id="P70004970270000000000000000441BB" data-uri="chapter06.xhtml#P70004970270000000000000000441BB" class="pcalibre8 pcalibre1 pcalibre2">Every computer has a unique memory mountain that characterizes the capabilities of its memory system. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005A75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.41</span></a> shows the memory mountain for an Intel Core i7 Haswell system. In this example, the <code id="P70004970270000000000000000441BC" data-uri="chapter06.xhtml#P70004970270000000000000000441BC" class="pcalibre1 calibre1 pcalibre2">size</code> varies from 16 KB to 128 MB, and the <code id="P70004970270000000000000000441BD" data-uri="chapter06.xhtml#P70004970270000000000000000441BD" class="pcalibre1 calibre1 pcalibre2">stride</code> varies from 1 to 12 elements, where each element is an 8-byte <code id="P70004970270000000000000000441BE" data-uri="chapter06.xhtml#P70004970270000000000000000441BE" class="pcalibre1 calibre1 pcalibre2">long int.</code></p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000005A68" data-uri="chapter06.xhtml#P7000497027000000000000000005A68">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005A69" title="640" data-uri="chapter06.xhtml#P7000497027000000000000000005A69" epub:type="pagebreak"></span>
<p id="P70004970270000000000000000441BF" data-uri="chapter06.xhtml#P70004970270000000000000000441BF" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/mountain/mountain.c</i></p>
<pre id="P70004970270000000000000000441C0" data-uri="chapter06.xhtml#P70004970270000000000000000441C0" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000441C1" data-uri="chapter06.xhtml#P70004970270000000000000000441C1" class="calibre3 pcalibre1 pcalibre2">
1 long data[MAXELEMS];	/* The global array we'll be traversing */
2
3	/* test - Iterate over first "elems" elements of array "data" with
4		* stride of "stride", using 4 x 4 loop unrolling.
5	*/
6	int test(int elems, int stride)
7	{
8		long i, sx2 = stride*2, sx3 = stride*3, sx4 = stride*4;
9		long acc0 = 0, acc1 = 0, acc2 = 0, acc3 = 0;
10		long length = elems;
11		long limit = length - sx4;
12
13		/* Combine 4 elements at a time */
14		for (i = 0; i &lt; limit; i += sx4) {
15			acc0 = acc0 + data[i];
16			acc1 = acc1 + data[i+stride];
17			acc2 = acc2 + data[i+sx2];
18			acc3 = acc3 + data[i+sx3];
19		}
20
21		/* Finish any remaining elements */
22		for (; i &lt; length; i++) {
23			acc0 = acc0 + data[i];
24		}
25		return ((acc0 + acc1) + (acc2 + acc3));
26	}
27
28	/* run - Run test(elems, stride) and return read throughput (MB/s).
29	*	"size" is in bytes, "stride" is in array elements, and Mhz is
30	*	CPU clock frequency in Mhz.
31	*/
32	double run(int size, int stride, double Mhz)
33	{
34		double cycles;
35		int elems = size / sizeof(double);
36
37	test(elems, stride);	/* Warm up the cache */
38	cycles = fcyc2(test, elems, stride, 0);	/* Call test(elems,stride) */
39	return (size / stride) / (cycles / Mhz);	/* Convert cycles to MB/s */
40	}
</code></pre>
<p id="P70004970270000000000000000441C2" data-uri="chapter06.xhtml#P70004970270000000000000000441C2" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/mountain/mountain.c</i></p>
<figcaption id="P70004970270000000000000000441C3" data-uri="chapter06.xhtml#P70004970270000000000000000441C3" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000441C4" data-uri="chapter06.xhtml#P70004970270000000000000000441C4" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">6.40 </span>Functions that measure and compute read throughput.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000441C5" data-uri="chapter06.xhtml#P70004970270000000000000000441C5"><p id="P70004970270000000000000000441C6" data-uri="chapter06.xhtml#P70004970270000000000000000441C6" class="pcalibre1 pcalibre2 pcalibre10">We can generate a memory mountain for a particular computer by calling the <code id="P70004970270000000000000000441C7" data-uri="chapter06.xhtml#P70004970270000000000000000441C7" class="pcalibre1 calibre1 pcalibre2">run</code> function with different values of <code id="P70004970270000000000000000441C8" data-uri="chapter06.xhtml#P70004970270000000000000000441C8" class="pcalibre1 calibre1 pcalibre2">size</code> (which corresponds to temporal locality) and <code id="P70004970270000000000000000441C9" data-uri="chapter06.xhtml#P70004970270000000000000000441C9" class="pcalibre1 calibre1 pcalibre2">stride</code> (which corresponds to spatial locality).</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000005A75" data-uri="chapter06.xhtml#P7000497027000000000000000005A75">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005A76" title="641" data-uri="chapter06.xhtml#P7000497027000000000000000005A76" epub:type="pagebreak"></span>
<img alt="A graph illustrates a memory mountains." id="P70004970270000000000000000441CA" data-uri="P700049702700000000000000000B74A" src="../images/p641-1.png" class="pcalibre1 pcalibre2 calibre59"/>
<figcaption id="P70004970270000000000000000441CB" data-uri="chapter06.xhtml#P70004970270000000000000000441CB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000441CC" data-uri="chapter06.xhtml#P70004970270000000000000000441CC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">6.41 </span>A memory mountain.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000441CD" data-uri="chapter06.xhtml#P70004970270000000000000000441CD"><p id="P70004970270000000000000000441CE" data-uri="chapter06.xhtml#P70004970270000000000000000441CE" class="pcalibre1 pcalibre2 pcalibre10">Shows read throughput as a function of temporal and spatial locality.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000244D3" data-uri="chapter06.xhtml#P70004970270000000000000000244D3">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000441CF" data-uri="chapter06.xhtml#P70004970270000000000000000441CF" class="pcalibre1 pcalibre2 pcalibre10">A graph has three axes: Read throughput (MB/s) as the height, Stride (x8 bytes) as the width, and Size (bytes) as the depth. The data is shown for Core I7 Haswell with 2.1 GHz, 32 KB L1 d-cache, 256 KB L2 cache, 8 MB L3 cache, and 64 B block size. The slopes of spatial locality have read throughput decreasing with stride and increasing with size. The ridge of temporal locality are numbered L1, L2, L3, and Mem with read throughput decreasing as size decreases from around size 32 K to around 32 M, from about stride s5 to s11.</p>
</details>
</figcaption>
</figure>
<p id="P70004970270000000000000000441D0" data-uri="chapter06.xhtml#P70004970270000000000000000441D0" class="pcalibre8 pcalibre1 pcalibre2">The geography of the Core i7 mountain reveals a rich structure. Perpendicular to the <code id="P70004970270000000000000000441D1" data-uri="chapter06.xhtml#P70004970270000000000000000441D1" class="pcalibre1 calibre1 pcalibre2">size</code> axis are four <i class="pcalibre17 pcalibre2 pcalibre1">ridges</i> that correspond to the regions of temporal locality where the working set fits entirely in the L1 cache, L2 cache, L3 cache, and main memory, respectively. Notice that there is more than an order of magnitude difference between the highest peak of the L1 ridge, where the CPU reads at a rate of over 14 GB/s, and the lowest point of the main memory ridge, where the CPU reads at a rate of 900 MB/s.</p>
<p id="P70004970270000000000000000441D2" data-uri="chapter06.xhtml#P70004970270000000000000000441D2" class="pcalibre8 pcalibre1 pcalibre2">On each of the L2, L3, and main memory ridges, there is a slope of spatial locality that falls downhill as the stride increases and spatial locality decreases. Notice that even when the working set is too large to fit in any of the caches, the highest point on the main memory ridge is a factor of 8 higher than its lowest point. So even when a program has poor temporal locality, spatial locality can still come to the rescue and make a significant difference.</p>
<p id="P70004970270000000000000000441D3" data-uri="chapter06.xhtml#P70004970270000000000000000441D3" class="pcalibre8 pcalibre1 pcalibre2">There is a particularly interesting flat ridge line that extends perpendicular to the stride axis for a stride of 1, where the read throughput is a relatively flat 12 GB/s, even though the working set exceeds the capacities of L1 and L2. This is apparently due to a hardware <i class="pcalibre17 pcalibre2 pcalibre1">prefetching</i> mechanism in the Core i7 memory system that automatically identifies sequential stride-1 reference patterns and attempts to fetch those blocks into the cache before they are accessed. While the</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000005A80" data-uri="chapter06.xhtml#P7000497027000000000000000005A80">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005A81" title="642" data-uri="chapter06.xhtml#P7000497027000000000000000005A81" epub:type="pagebreak"></span>
<img alt="A graph of read throughput versus working set size is divided into four regions." id="P70004970270000000000000000441D4" data-uri="P700049702700000000000000000B74B" src="../images/p641-2.png" class="pcalibre1 pcalibre2 calibre60"/>
<figcaption id="P70004970270000000000000000441D5" data-uri="chapter06.xhtml#P70004970270000000000000000441D5" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000441D6" data-uri="chapter06.xhtml#P70004970270000000000000000441D6" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">6.42 </span>Ridges of temporal locality in the memory mountain.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000441D7" data-uri="chapter06.xhtml#P70004970270000000000000000441D7"><p id="P70004970270000000000000000441D8" data-uri="chapter06.xhtml#P70004970270000000000000000441D8" class="pcalibre1 pcalibre2 pcalibre10">The graph shows a slice through <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005A75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">6.41</span></a> with <code id="P70004970270000000000000000441D9" data-uri="chapter06.xhtml#P70004970270000000000000000441D9" class="pcalibre1 calibre1 pcalibre2">stride</code> = 8.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000244DF" data-uri="chapter06.xhtml#P70004970270000000000000000244DF">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000441DA" data-uri="chapter06.xhtml#P70004970270000000000000000441DA" class="pcalibre8 pcalibre1 pcalibre2">A graph of read throughput (MB/s) versus working set size (bytes) divided into four regions, as summarized below.</p>
<ul id="P70004970270000000000000000441DB" data-uri="chapter06.xhtml#P70004970270000000000000000441DB" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000441DC" data-uri="chapter06.xhtml#P70004970270000000000000000441DC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000441DD" data-uri="chapter06.xhtml#P70004970270000000000000000441DD" class="pcalibre1 pcalibre2 pcalibre10">Main memory region: read throughput increases from around 1,2000 MB/s at 128 M to around 1,500 MB/s at 16 M.</p></li>
<li id="P70004970270000000000000000441DE" data-uri="chapter06.xhtml#P70004970270000000000000000441DE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000441DF" data-uri="chapter06.xhtml#P70004970270000000000000000441DF" class="pcalibre1 pcalibre2 pcalibre10">L3 cache region: read throughput increases from around 1,500 MB/s at 8 M to around 2,500 at 512 K.</p></li>
<li id="P70004970270000000000000000441E0" data-uri="chapter06.xhtml#P70004970270000000000000000441E0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000441E1" data-uri="chapter06.xhtml#P70004970270000000000000000441E1" class="pcalibre1 pcalibre2 pcalibre10">L2 cache region: read throughput increases from nearly 4,000 MB/s at 256 K to nearly 5,000 MB/s at 64 K.</p></li>
<li id="P70004970270000000000000000441E2" data-uri="chapter06.xhtml#P70004970270000000000000000441E2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000441E3" data-uri="chapter06.xhtml#P70004970270000000000000000441E3" class="pcalibre1 pcalibre2 pcalibre10">L1 cache region: read throughput decreases from around 12,500 MB/s at 32 K to nearly 11,000 MB/s at 16 K.</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000441E4" data-uri="chapter06.xhtml#P70004970270000000000000000441E4">details of the particular prefetching algorithm are not documented, it is clear from the memory mountain that the algorithm works best for small strides—yet another reason to favor sequential stride-1 accesses in your code.</p>
<p id="P70004970270000000000000000441E5" data-uri="chapter06.xhtml#P70004970270000000000000000441E5" class="pcalibre8 pcalibre1 pcalibre2">If we take a slice through the mountain, holding the stride constant as in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005A80"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.42</span></a>, we can see the impact of cache size and temporal locality on performance. For sizes up to 32 KB, the working set fits entirely in the L1 d-cache, and thus reads are served from L1 at throughput of about 12 GB/s. For sizes up to 256 KB, the working set fits entirely in the unified L2 cache, and for sizes up to 8 MB, the working set fits entirely in the unified L3 cache. Larger working set sizes are served primarily from main memory.</p>
<p id="P70004970270000000000000000441E6" data-uri="chapter06.xhtml#P70004970270000000000000000441E6" class="pcalibre8 pcalibre1 pcalibre2">The dips in read throughputs at the leftmost edges of the L2 and L3 cache regions—where the working set sizes of 256 KB and 8 MB are equal to their respective cache sizes—are interesting. It is not entirely clear why these dips occur. The only way to be sure is to perform a detailed cache simulation, but it is likely that the drops are caused by conflicts with other code and data lines.</p>
<p id="P70004970270000000000000000441E7" data-uri="chapter06.xhtml#P70004970270000000000000000441E7" class="pcalibre8 pcalibre1 pcalibre2">Slicing through the memory mountain in the opposite direction, holding the working set size constant, gives us some insight into the impact of spatial locality on the read throughput. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005A8D"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.43</span></a> shows the slice for a fixed working set size of 4 MB. This slice cuts along the L3 ridge in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005A75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.41</span></a>, where the working set fits entirely in the L3 cache but is too large for the L2 cache.</p>
<p id="P70004970270000000000000000441E8" data-uri="chapter06.xhtml#P70004970270000000000000000441E8" class="pcalibre8 pcalibre1 pcalibre2">Notice how the read throughput decreases steadily as the stride increases from one to eight words. In this region of the mountain, a read miss in L2 causes a block to be transferred from L3 to L2. This is followed by some number of hits</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000005A8D" data-uri="chapter06.xhtml#P7000497027000000000000000005A8D">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005A8E" title="643" data-uri="chapter06.xhtml#P7000497027000000000000000005A8E" epub:type="pagebreak"></span>
<img alt="A graph shows read throughput decreasing with stride, from about 11,500 MB/s at s1 to near 2,000 by s8, with one access per cache line from s8 to s11." id="P70004970270000000000000000441E9" data-uri="P700049702700000000000000000B74C" src="../images/p643-1.png" class="pcalibre1 pcalibre228 pcalibre2"/>
<figcaption id="P70004970270000000000000000441EA" data-uri="chapter06.xhtml#P70004970270000000000000000441EA" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000441EB" data-uri="chapter06.xhtml#P70004970270000000000000000441EB" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">6.43 </span>A slope of spatial locality.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000441EC" data-uri="chapter06.xhtml#P70004970270000000000000000441EC"><p id="P70004970270000000000000000441ED" data-uri="chapter06.xhtml#P70004970270000000000000000441ED" class="pcalibre1 pcalibre2 pcalibre10">The graph shows a slice through <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005A75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">6.41</span></a> with <code id="P70004970270000000000000000441EE" data-uri="chapter06.xhtml#P70004970270000000000000000441EE" class="pcalibre1 calibre1 pcalibre2">size</code> = 4 MB.</p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000441EF" data-uri="chapter06.xhtml#P70004970270000000000000000441EF">on the block in L2, depending on the stride. As the stride increases, the ratio of L2 misses to L2 hits increases. Since misses are served more slowly than hits, the read throughput decreases. Once the stride reaches eight 8-byte words, which on this system equals the block size of 64 bytes, every read request misses in L2 and must be served from L3. Thus, the read throughput for strides of at least eight is a constant rate determined by the rate that cache blocks can be transferred from L3 into L2.</p>
<p id="P70004970270000000000000000441F0" data-uri="chapter06.xhtml#P70004970270000000000000000441F0" class="pcalibre8 pcalibre1 pcalibre2">To summarize our discussion of the memory mountain, the performance of the memory system is not characterized by a single number. Instead, it is a mountain of temporal and spatial locality whose elevations can vary by over an order of magnitude. Wise programmers try to structure their programs so that they run in the peaks instead of the valleys. The aim is to exploit temporal locality so that heavily used words are fetched from the L1 cache, and to exploit spatial locality so that as many words as possible are accessed from a single L1 cache line.</p>
<section id="P7000497027000000000000000005A97" data-uri="chapter06.xhtml#P7000497027000000000000000005A97" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000441F1" data-uri="chapter06.xhtml#P70004970270000000000000000441F1" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">6.21 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000005E52.xhtml#P7000497027000000000000000005F85">666</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000441F2" data-uri="chapter06.xhtml#P70004970270000000000000000441F2">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000441F3" data-uri="chapter06.xhtml#P70004970270000000000000000441F3">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000441F4" data-uri="chapter06.xhtml#P70004970270000000000000000441F4"><p id="P70004970270000000000000000441F5" data-uri="chapter06.xhtml#P70004970270000000000000000441F5" class="pcalibre1 pcalibre2 pcalibre10">Use the memory mountain in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005A75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.41</span></a> to estimate the time, in CPU cycles, to read an 8-byte word from the L1 d-cache.</p></div></li>
</ol>
</section>
</section>
<section id="P7000497027000000000000000005A9D" data-uri="chapter06.xhtml#P7000497027000000000000000005A9D" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000441F6" data-uri="chapter06.xhtml#P70004970270000000000000000441F6" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">6.6.2 </span>Rearranging Loops to Increase Spatial Locality</h1></header>
<p id="P70004970270000000000000000441F7" data-uri="chapter06.xhtml#P70004970270000000000000000441F7" class="pcalibre8 pcalibre1 pcalibre2">Consider the problem of multiplying a pair of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> × <var class="pcalibre17 pcalibre2 pcalibre1">n</var> matrices: <var class="pcalibre17 pcalibre2 pcalibre1">C</var> = <i class="pcalibre17 pcalibre2 pcalibre1">AB</i>. For example, if <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 2, then</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P70004970270000000000000000441F8" data-uri="chapter06.xhtml#P70004970270000000000000000441F8">
<m:math display="block" alttext="" data-uri="" altimg-width="243" altimg-height="37" altimg="../images/ch06-09.png"><m:mrow><m:mrow><m:mo>[</m:mo> <m:mrow><m:mtable><m:mtr><m:mtd><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow> <m:mo>]</m:mo></m:mrow><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo> <m:mrow><m:mtable><m:mtr><m:mtd><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow> <m:mo>]</m:mo></m:mrow><m:mtext> </m:mtext><m:mrow><m:mo>[</m:mo> <m:mrow><m:mtable><m:mtr><m:mtd><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow> <m:mo>]</m:mo></m:mrow></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000441F9" data-uri="chapter06.xhtml#P70004970270000000000000000441F9"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005AA2" title="644" data-uri="chapter06.xhtml#P7000497027000000000000000005AA2" epub:type="pagebreak"></span>where</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P70004970270000000000000000441FA" data-uri="chapter06.xhtml#P70004970270000000000000000441FA">
<m:math display="block" alttext="" data-uri="" altimg-width="131" altimg-height="91" altimg="../images/ch06-10.png"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000441FB" data-uri="chapter06.xhtml#P70004970270000000000000000441FB">A matrix multiply function is usually implemented using three nested loops, which are identified by their indices <i class="pcalibre17 pcalibre2 pcalibre1">i, j</i>, and <i class="pcalibre17 pcalibre2 pcalibre1">k.</i> If we permute the loops and make some other minor code changes, we can create the six functionally equivalent versions of matrix multiply shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005AB5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.44</span></a>. Each version is uniquely identified by the ordering of its loops.</p>
<p id="P70004970270000000000000000441FC" data-uri="chapter06.xhtml#P70004970270000000000000000441FC" class="pcalibre8 pcalibre1 pcalibre2">At a high level, the six versions are quite similar. If addition is associative, then each version computes an identical result.<a class="pcalibre1 pcalibre2 pcalibre56 pcalibre16 pcalibre14 pcalibre15" id="r__P7000497027000000000000000005FAE" epub:type="noteref" href="#P7000497027000000000000000005FAE">1</a> Each version performs <var class="pcalibre17 pcalibre2 pcalibre1">O</var>(<var class="pcalibre17 pcalibre2 pcalibre1">n</var><sup class="pcalibre1 pcalibre2 pcalibre85">3</sup>) total operations and an identical number of adds and multiplies. Each of the <var class="pcalibre17 pcalibre2 pcalibre1">n</var><sup class="pcalibre1 pcalibre2 pcalibre85">2</sup> elements of <var class="pcalibre17 pcalibre2 pcalibre1">A</var> and <var class="pcalibre17 pcalibre2 pcalibre1">B</var> is read <var class="pcalibre17 pcalibre2 pcalibre1">n</var> times. Each of the <var class="pcalibre17 pcalibre2 pcalibre1">n</var><sup class="pcalibre1 pcalibre2 pcalibre85">2</sup> elements of <var class="pcalibre17 pcalibre2 pcalibre1">C</var> is computed by summing <var class="pcalibre17 pcalibre2 pcalibre1">n</var> values. However, if we analyze the behavior of the innermost loop iterations, we find that there are differences in the number of accesses and the locality. For the purposes of this analysis, we make the following assumptions:</p><aside class="pcalibre2 pcalibre32 pcalibre57" id="P7000497027000000000000000005FAE" data-uri="chapter06.xhtml#P7000497027000000000000000005FAE" epub:type="footnote"><p class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre58 pcalibre2"><a href="#r__P7000497027000000000000000005FAE" class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13">1. </a></span>As we learned in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000000279.xhtml#P7000497027000000000000000000279"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre58 pcalibre2">2</span></a>, floating-point addition is commutative, but in general not associative. In practice, if the matrices do not mix extremely large values with extremely small ones, as often is true when the matrices store physical properties, then the assumption of associativity is reasonable.</p></aside>
<ul id="P70004970270000000000000000441FD" data-uri="chapter06.xhtml#P70004970270000000000000000441FD" class="pcalibre1 calibre9 pcalibre2">
<li id="P70004970270000000000000000441FE" data-uri="chapter06.xhtml#P70004970270000000000000000441FE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000441FF" data-uri="chapter06.xhtml#P70004970270000000000000000441FF" class="pcalibre1 pcalibre2 pcalibre10">Each array is an <var class="pcalibre17 pcalibre2 pcalibre1">n</var> × <var class="pcalibre17 pcalibre2 pcalibre1">n</var> array of <code id="P7000497027000000000000000044200" data-uri="chapter06.xhtml#P7000497027000000000000000044200" class="pcalibre1 calibre1 pcalibre2">double</code>, with <code id="P7000497027000000000000000044201" data-uri="chapter06.xhtml#P7000497027000000000000000044201" class="pcalibre1 calibre1 pcalibre2">sizeof(<code id="P7000497027000000000000000044202" data-uri="chapter06.xhtml#P7000497027000000000000000044202" class="calibre3 pcalibre1 pcalibre2">double</code>) = 8</code>.</p></li>
<li id="P7000497027000000000000000044203" data-uri="chapter06.xhtml#P7000497027000000000000000044203" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044204" data-uri="chapter06.xhtml#P7000497027000000000000000044204" class="pcalibre1 pcalibre2 pcalibre10">There is a single cache with a 32-byte block size (<var class="pcalibre17 pcalibre2 pcalibre1">B</var> = 32).</p></li>
<li id="P7000497027000000000000000044205" data-uri="chapter06.xhtml#P7000497027000000000000000044205" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044206" data-uri="chapter06.xhtml#P7000497027000000000000000044206" class="pcalibre1 pcalibre2 pcalibre10">The array size <var class="pcalibre17 pcalibre2 pcalibre1">n</var> is so large that a single matrix row does not fit in the L1 cache.</p></li>
<li id="P7000497027000000000000000044207" data-uri="chapter06.xhtml#P7000497027000000000000000044207" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044208" data-uri="chapter06.xhtml#P7000497027000000000000000044208" class="pcalibre1 pcalibre2 pcalibre10">The compiler stores local variables in registers, and thus references to local variables inside loops do not require any load or store instructions.</p></li>
</ul>
<p id="P7000497027000000000000000044209" data-uri="chapter06.xhtml#P7000497027000000000000000044209" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005AD9"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.45</span></a> summarizes the results of our inner-loop analysis. Notice that the six versions pair up into three equivalence classes, which we denote by the pair of matrices that are accessed in the inner loop. For example, versions <i class="pcalibre17 pcalibre2 pcalibre1">ijk</i> and <i class="pcalibre17 pcalibre2 pcalibre1">jik</i> are members of class <i class="pcalibre17 pcalibre2 pcalibre1">AB</i> because they reference arrays <var class="pcalibre17 pcalibre2 pcalibre1">A</var> and <var class="pcalibre17 pcalibre2 pcalibre1">B</var> (but not <var class="pcalibre17 pcalibre2 pcalibre1">C</var>) in their innermost loop. For each class, we have counted the number of loads (reads) and stores (writes) in each inner-loop iteration, the number of references to <i class="pcalibre17 pcalibre2 pcalibre1">A, B</i>, and <var class="pcalibre17 pcalibre2 pcalibre1">C</var> that will miss in the cache in each loop iteration, and the total number of cache misses per iteration.</p>
<p id="P700049702700000000000000004420A" data-uri="chapter06.xhtml#P700049702700000000000000004420A" class="pcalibre8 pcalibre1 pcalibre2">The inner loops of the class <i class="pcalibre17 pcalibre2 pcalibre1">AB</i> routines (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005AB5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.44(a)</span></a> and <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005AB5"><span class="pcalibre1 pcalibre21 pcalibre2">(b)</span></a>) scan a row of array <var class="pcalibre17 pcalibre2 pcalibre1">A</var> with a stride of 1. Since each cache block holds four 8-byte words, the miss rate for <var class="pcalibre17 pcalibre2 pcalibre1">A</var> is 0.25 misses per iteration. On the other hand, the inner loop scans a column of <var class="pcalibre17 pcalibre2 pcalibre1">B</var> with a stride of <i class="pcalibre17 pcalibre2 pcalibre1">n.</i> Since <var class="pcalibre17 pcalibre2 pcalibre1">n</var> is large, each access of array <var class="pcalibre17 pcalibre2 pcalibre1">B</var> results in a miss, for a total of 1.25 misses per iteration.</p>
<p id="P700049702700000000000000004420B" data-uri="chapter06.xhtml#P700049702700000000000000004420B" class="pcalibre8 pcalibre1 pcalibre2">The inner loops in the class <i class="pcalibre17 pcalibre2 pcalibre1">AC</i> routines (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005AB5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.44(c)</span></a> and <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005AB5"><span class="pcalibre1 pcalibre21 pcalibre2">(d)</span></a>) have some problems. Each iteration performs two loads and a store (as opposed to the</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000005AB5" data-uri="chapter06.xhtml#P7000497027000000000000000005AB5">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005AB6" title="645" data-uri="chapter06.xhtml#P7000497027000000000000000005AB6" epub:type="pagebreak"></span>
<p id="P700049702700000000000000004420C" data-uri="chapter06.xhtml#P700049702700000000000000004420C" class="pcalibre8 pcalibre1 pcalibre2">(a) Version <i class="pcalibre17 pcalibre2 pcalibre1">i j k</i></p>
<p id="P700049702700000000000000004420D" data-uri="chapter06.xhtml#P700049702700000000000000004420D" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P700049702700000000000000004420E" data-uri="chapter06.xhtml#P700049702700000000000000004420E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004420F" data-uri="chapter06.xhtml#P700049702700000000000000004420F" class="calibre3 pcalibre1 pcalibre2">
1	for (i = 0; i &lt; n; i++)
2	for (j = 0; j &lt; n; j++) {
3	sum = 0.0;
4	for (k = 0; k &lt; n; k++)
5	sum += A[i][k]*B[k][j];
6	C[i][j] += sum;
7	}
</code></pre>
<p id="P7000497027000000000000000044210" data-uri="chapter06.xhtml#P7000497027000000000000000044210" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<p id="P7000497027000000000000000044211" data-uri="chapter06.xhtml#P7000497027000000000000000044211" class="pcalibre8 pcalibre1 pcalibre2">(b) Version <i class="pcalibre17 pcalibre2 pcalibre1">jik</i></p>
<p id="P7000497027000000000000000044212" data-uri="chapter06.xhtml#P7000497027000000000000000044212" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P7000497027000000000000000044213" data-uri="chapter06.xhtml#P7000497027000000000000000044213" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044214" data-uri="chapter06.xhtml#P7000497027000000000000000044214" class="calibre3 pcalibre1 pcalibre2">
1	for (j = 0; j &lt; n; j++)
2	for (i = 0; i &lt; n; i++) {
3	sum = 0.0;
4	for (k = 0; k &lt; n; k++)
5	sum += A[i][k]*B[k][j];
6	C[i][j] += sum;
7	}
</code></pre>
<p id="P7000497027000000000000000044215" data-uri="chapter06.xhtml#P7000497027000000000000000044215" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<p id="P7000497027000000000000000044216" data-uri="chapter06.xhtml#P7000497027000000000000000044216" class="pcalibre8 pcalibre1 pcalibre2">(c) Version <i class="pcalibre17 pcalibre2 pcalibre1">jki</i></p>
<p id="P7000497027000000000000000044217" data-uri="chapter06.xhtml#P7000497027000000000000000044217" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P7000497027000000000000000044218" data-uri="chapter06.xhtml#P7000497027000000000000000044218" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044219" data-uri="chapter06.xhtml#P7000497027000000000000000044219" class="calibre3 pcalibre1 pcalibre2">
1	for (j = 0; j &lt; n; j++)
2	for (k = 0; k &lt; n; k++) {
3	r = B[k][j];
4	for (i = 0; i &lt; n; i++)
5	C[i][j] += A[i][k]*r;
6	}
</code></pre>
<p id="P700049702700000000000000004421A" data-uri="chapter06.xhtml#P700049702700000000000000004421A" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<p id="P700049702700000000000000004421B" data-uri="chapter06.xhtml#P700049702700000000000000004421B" class="pcalibre8 pcalibre1 pcalibre2">(d) Version <i class="pcalibre17 pcalibre2 pcalibre1">kji</i></p>
<p id="P700049702700000000000000004421C" data-uri="chapter06.xhtml#P700049702700000000000000004421C" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P700049702700000000000000004421D" data-uri="chapter06.xhtml#P700049702700000000000000004421D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004421E" data-uri="chapter06.xhtml#P700049702700000000000000004421E" class="calibre3 pcalibre1 pcalibre2">
1	for (k = 0; k &lt; n; k++)
2	for (j = 0; j &lt; n; j++) {
3	r = B[k][j];
4	for (i = 0; i &lt; n; i++)
5	C[i][j] += A[i][k]*r;
6	}
</code></pre>
<p id="P700049702700000000000000004421F" data-uri="chapter06.xhtml#P700049702700000000000000004421F" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<p id="P7000497027000000000000000044220" data-uri="chapter06.xhtml#P7000497027000000000000000044220" class="pcalibre8 pcalibre1 pcalibre2">(e) Version <i class="pcalibre17 pcalibre2 pcalibre1">kij</i></p>
<p id="P7000497027000000000000000044221" data-uri="chapter06.xhtml#P7000497027000000000000000044221" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P7000497027000000000000000044222" data-uri="chapter06.xhtml#P7000497027000000000000000044222" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044223" data-uri="chapter06.xhtml#P7000497027000000000000000044223" class="calibre3 pcalibre1 pcalibre2">
1	for (k = 0; k &lt; n; k++)
2	for (i = 0; i &lt; n; i++) {
3	r = A[i][k];
4	for (j = 0; j &lt; n; j++)
5	C[i][j] += r*B[k][j];
6	}
</code></pre>
<p id="P7000497027000000000000000044224" data-uri="chapter06.xhtml#P7000497027000000000000000044224" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<p id="P7000497027000000000000000044225" data-uri="chapter06.xhtml#P7000497027000000000000000044225" class="pcalibre8 pcalibre1 pcalibre2">(f) Version <i class="pcalibre17 pcalibre2 pcalibre1">ikj</i></p>
<p id="P7000497027000000000000000044226" data-uri="chapter06.xhtml#P7000497027000000000000000044226" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P7000497027000000000000000044227" data-uri="chapter06.xhtml#P7000497027000000000000000044227" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044228" data-uri="chapter06.xhtml#P7000497027000000000000000044228" class="calibre3 pcalibre1 pcalibre2">
1	for (i = 0; i &lt; n; i++)
2	for (k = 0; k &lt; n; k++) {
3	r = A[i][k];
4	for (j = 0; j &lt; n; j++)
5	C[i][j] += r*B[k][j];
6	}
</code></pre>
<p id="P7000497027000000000000000044229" data-uri="chapter06.xhtml#P7000497027000000000000000044229" class="pcalibre8 pcalibre1 pcalibre2">--------------------------------- <i class="pcalibre17 pcalibre2 pcalibre1">code/mem/matmult/mm.c</i></p>
<figcaption id="P700049702700000000000000004422A" data-uri="chapter06.xhtml#P700049702700000000000000004422A" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004422B" data-uri="chapter06.xhtml#P700049702700000000000000004422B" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">6.44 </span>Six versions of matrix multiply.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P700049702700000000000000004422C" data-uri="chapter06.xhtml#P700049702700000000000000004422C"><p id="P700049702700000000000000004422D" data-uri="chapter06.xhtml#P700049702700000000000000004422D" class="pcalibre1 pcalibre2 pcalibre10">Each version is uniquely identified by the ordering of its loops.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000005AD9" data-uri="chapter06.xhtml#P7000497027000000000000000005AD9">
<table id="P700049702700000000000000004422E" data-uri="chapter06.xhtml#P700049702700000000000000004422E" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th rowspan="2" id="P700049702700000000000000004422F" data-uri="chapter06.xhtml#P700049702700000000000000004422F" class="pcalibre1 pcalibre2 calibre5">Matrix multiply version (class)</th>
<th colspan="6" id="P7000497027000000000000000044230" data-uri="chapter06.xhtml#P7000497027000000000000000044230" class="pcalibre1 pcalibre2 calibre5">Per iteration</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000044231" data-uri="chapter06.xhtml#P7000497027000000000000000044231" class="pcalibre1 pcalibre2 calibre5">Loads</th>
<th id="P7000497027000000000000000044232" data-uri="chapter06.xhtml#P7000497027000000000000000044232" class="pcalibre1 pcalibre2 calibre5">Stores</th>
<th id="P7000497027000000000000000044233" data-uri="chapter06.xhtml#P7000497027000000000000000044233" class="pcalibre1 pcalibre2 calibre5"><var class="pcalibre17 pcalibre2 pcalibre1">A</var> misses</th>
<th id="P7000497027000000000000000044234" data-uri="chapter06.xhtml#P7000497027000000000000000044234" class="pcalibre1 pcalibre2 calibre5"><var class="pcalibre17 pcalibre2 pcalibre1">B</var> misses</th>
<th id="P7000497027000000000000000044235" data-uri="chapter06.xhtml#P7000497027000000000000000044235" class="pcalibre1 pcalibre2 calibre5"><var class="pcalibre17 pcalibre2 pcalibre1">C</var> misses</th>
<th id="P7000497027000000000000000044236" data-uri="chapter06.xhtml#P7000497027000000000000000044236" class="pcalibre1 pcalibre2 calibre5">Total misses</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000044237" data-uri="chapter06.xhtml#P7000497027000000000000000044237" class="pcalibre1 pcalibre2 calibre7"><i class="pcalibre17 pcalibre2 pcalibre1">ijk</i> &amp; <i class="pcalibre17 pcalibre2 pcalibre1">jik</i> (<i class="pcalibre17 pcalibre2 pcalibre1">AB</i>)</td>
<td id="P7000497027000000000000000044238" data-uri="chapter06.xhtml#P7000497027000000000000000044238" class="pcalibre1 pcalibre2 calibre7">2</td>
<td id="P7000497027000000000000000044239" data-uri="chapter06.xhtml#P7000497027000000000000000044239" class="pcalibre1 pcalibre2 calibre7">0</td>
<td id="P700049702700000000000000004423A" data-uri="chapter06.xhtml#P700049702700000000000000004423A" class="pcalibre1 pcalibre2 calibre7">0.25</td>
<td id="P700049702700000000000000004423B" data-uri="chapter06.xhtml#P700049702700000000000000004423B" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P700049702700000000000000004423C" data-uri="chapter06.xhtml#P700049702700000000000000004423C" class="pcalibre1 pcalibre2 calibre7">0.00</td>
<td id="P700049702700000000000000004423D" data-uri="chapter06.xhtml#P700049702700000000000000004423D" class="pcalibre1 pcalibre2 calibre7">1.25</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004423E" data-uri="chapter06.xhtml#P700049702700000000000000004423E" class="pcalibre1 pcalibre2 calibre7"><i class="pcalibre17 pcalibre2 pcalibre1">jki</i> &amp; <i class="pcalibre17 pcalibre2 pcalibre1">kji</i> (<i class="pcalibre17 pcalibre2 pcalibre1">AC</i>)</td>
<td id="P700049702700000000000000004423F" data-uri="chapter06.xhtml#P700049702700000000000000004423F" class="pcalibre1 pcalibre2 calibre7">2</td>
<td id="P7000497027000000000000000044240" data-uri="chapter06.xhtml#P7000497027000000000000000044240" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P7000497027000000000000000044241" data-uri="chapter06.xhtml#P7000497027000000000000000044241" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P7000497027000000000000000044242" data-uri="chapter06.xhtml#P7000497027000000000000000044242" class="pcalibre1 pcalibre2 calibre7">0.00</td>
<td id="P7000497027000000000000000044243" data-uri="chapter06.xhtml#P7000497027000000000000000044243" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P7000497027000000000000000044244" data-uri="chapter06.xhtml#P7000497027000000000000000044244" class="pcalibre1 pcalibre2 calibre7">2.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000044245" data-uri="chapter06.xhtml#P7000497027000000000000000044245" class="pcalibre1 pcalibre2 calibre7"><i class="pcalibre17 pcalibre2 pcalibre1">kij</i> &amp; <i class="pcalibre17 pcalibre2 pcalibre1">ikj</i> (<i class="pcalibre17 pcalibre2 pcalibre1">BC</i>)</td>
<td id="P7000497027000000000000000044246" data-uri="chapter06.xhtml#P7000497027000000000000000044246" class="pcalibre1 pcalibre2 calibre7">2</td>
<td id="P7000497027000000000000000044247" data-uri="chapter06.xhtml#P7000497027000000000000000044247" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P7000497027000000000000000044248" data-uri="chapter06.xhtml#P7000497027000000000000000044248" class="pcalibre1 pcalibre2 calibre7">0.00</td>
<td id="P7000497027000000000000000044249" data-uri="chapter06.xhtml#P7000497027000000000000000044249" class="pcalibre1 pcalibre2 calibre7">0.25</td>
<td id="P700049702700000000000000004424A" data-uri="chapter06.xhtml#P700049702700000000000000004424A" class="pcalibre1 pcalibre2 calibre7">0.25</td>
<td id="P700049702700000000000000004424B" data-uri="chapter06.xhtml#P700049702700000000000000004424B" class="pcalibre1 pcalibre2 calibre7">0.50</td>
</tr>
</tbody>
</table>
<figcaption id="P700049702700000000000000004424C" data-uri="chapter06.xhtml#P700049702700000000000000004424C" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004424D" data-uri="chapter06.xhtml#P700049702700000000000000004424D" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">6.45 </span>Analysis of matrix multiply inner loops.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P700049702700000000000000004424E" data-uri="chapter06.xhtml#P700049702700000000000000004424E"><p id="P700049702700000000000000004424F" data-uri="chapter06.xhtml#P700049702700000000000000004424F" class="pcalibre1 pcalibre2 pcalibre10">The six versions partition into three equivalence classes, denoted by the pair of arrays that are accessed in the inner loop.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000005AFC" data-uri="chapter06.xhtml#P7000497027000000000000000005AFC">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005AFD" title="646" data-uri="chapter06.xhtml#P7000497027000000000000000005AFD" epub:type="pagebreak"></span>
<img alt="A graph of Core I7 matrix multiply performance shows cycles per inner-loop iteration versus array size (n)." id="P7000497027000000000000000044250" data-uri="P700049702700000000000000000B74D" src="../images/p646-1.png" class="pcalibre1 pcalibre2 pcalibre229"/>
<figcaption id="P7000497027000000000000000044251" data-uri="chapter06.xhtml#P7000497027000000000000000044251" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000044252" data-uri="chapter06.xhtml#P7000497027000000000000000044252" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">6.46 </span>Core i7 matrix multiply performance.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000024559" data-uri="chapter06.xhtml#P7000497027000000000000000024559">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000044253" data-uri="chapter06.xhtml#P7000497027000000000000000044253" class="pcalibre8 pcalibre1 pcalibre2">A graph has six lines plotted with cycles per inner-loop iteration over array size (n), as summarized below.</p>
<ul id="P7000497027000000000000000044254" data-uri="chapter06.xhtml#P7000497027000000000000000044254" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000044255" data-uri="chapter06.xhtml#P7000497027000000000000000044255" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044256" data-uri="chapter06.xhtml#P7000497027000000000000000044256" class="pcalibre1 pcalibre2 pcalibre10">Lines jki and kji increase from around 5 cycles from size 50 to size 200 to around 70 cycles by size 700.</p></li>
<li id="P7000497027000000000000000044257" data-uri="chapter06.xhtml#P7000497027000000000000000044257" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044258" data-uri="chapter06.xhtml#P7000497027000000000000000044258" class="pcalibre1 pcalibre2 pcalibre10">Lines ijk and jik increase from between 4 and 5 cycles from size 50 to size 400 to around 25 cycles by size 700.</p></li>
<li id="P7000497027000000000000000044259" data-uri="chapter06.xhtml#P7000497027000000000000000044259" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004425A" data-uri="chapter06.xhtml#P700049702700000000000000004425A" class="pcalibre1 pcalibre2 pcalibre10">Lines kij and ikj remain around 2 cycles from size 50 to size 700.</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004425B" data-uri="chapter06.xhtml#P700049702700000000000000004425B">class <i class="pcalibre17 pcalibre2 pcalibre1">AB</i> routines, which perform two loads and no stores). Second, the inner loop scans the columns of <var class="pcalibre17 pcalibre2 pcalibre1">A</var> and <var class="pcalibre17 pcalibre2 pcalibre1">C</var> with a stride of <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. The result is a miss on each load, for a total of two misses per iteration. Notice that interchanging the loops has decreased the amount of spatial locality compared to the class <i class="pcalibre17 pcalibre2 pcalibre1">AB</i> routines.</p>
<p id="P700049702700000000000000004425C" data-uri="chapter06.xhtml#P700049702700000000000000004425C" class="pcalibre8 pcalibre1 pcalibre2">The <i class="pcalibre17 pcalibre2 pcalibre1">BC</i> routines (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005AB5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.44(e)</span></a> and <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005AB5"><span class="pcalibre1 pcalibre21 pcalibre2">(f)</span></a>) present an interesting trade-off: With two loads and a store, they require one more memory operation than the <i class="pcalibre17 pcalibre2 pcalibre1">AB</i> routines. On the other hand, since the inner loop scans both <var class="pcalibre17 pcalibre2 pcalibre1">B</var> and <var class="pcalibre17 pcalibre2 pcalibre1">C</var> row-wise with a stride-1 access pattern, the miss rate on each array is only 0.25 misses per iteration, for a total of 0.50 misses per iteration.</p>
<p id="P700049702700000000000000004425D" data-uri="chapter06.xhtml#P700049702700000000000000004425D" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005AFC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">6.46</span></a> summarizes the performance of different versions of matrix multiply on a Core i7 system. The graph plots the measured number of CPU cycles per inner-loop iteration as a function of array size (<var class="pcalibre17 pcalibre2 pcalibre1">n</var>).</p>
<p id="P700049702700000000000000004425E" data-uri="chapter06.xhtml#P700049702700000000000000004425E" class="pcalibre8 pcalibre1 pcalibre2">There are a number of interesting points to notice about this graph:</p>
<ul id="P700049702700000000000000004425F" data-uri="chapter06.xhtml#P700049702700000000000000004425F" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000044260" data-uri="chapter06.xhtml#P7000497027000000000000000044260" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044261" data-uri="chapter06.xhtml#P7000497027000000000000000044261" class="pcalibre1 pcalibre2 pcalibre10">For large values of <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, the fastest version runs almost 40 times faster than the slowest version, even though each performs the same number of floating-point arithmetic operations.</p></li>
<li id="P7000497027000000000000000044262" data-uri="chapter06.xhtml#P7000497027000000000000000044262" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044263" data-uri="chapter06.xhtml#P7000497027000000000000000044263" class="pcalibre1 pcalibre2 pcalibre10">Pairs of versions with the same number of memory references and misses per iteration have almost identical measured performance.</p></li>
<li id="P7000497027000000000000000044264" data-uri="chapter06.xhtml#P7000497027000000000000000044264" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044265" data-uri="chapter06.xhtml#P7000497027000000000000000044265" class="pcalibre1 pcalibre2 pcalibre10">The two versions with the worst memory behavior, in terms of the number of accesses and misses per iteration, run significantly slower than the other four versions, which have fewer misses or fewer accesses, or both.</p></li>
<li id="P7000497027000000000000000044266" data-uri="chapter06.xhtml#P7000497027000000000000000044266" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044267" data-uri="chapter06.xhtml#P7000497027000000000000000044267" class="pcalibre1 pcalibre2 pcalibre10">Miss rate, in this case, is a better predictor of performance than the total number of memory accesses. For example, the class <i class="pcalibre17 pcalibre2 pcalibre1">BC</i> routines, with 0.5 misses per iteration, perform much better than the class <i class="pcalibre17 pcalibre2 pcalibre1">AB</i> routines, with 1.25 misses per iteration, even though the class <i class="pcalibre17 pcalibre2 pcalibre1">BC</i> routines perform more</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000005B0E" data-uri="chapter06.xhtml#P7000497027000000000000000005B0E"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000044268" data-uri="chapter06.xhtml#P7000497027000000000000000044268" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000005B10" title="647" data-uri="chapter06.xhtml#P7000497027000000000000000005B10" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Web Aside MEM:BLOCKING </span>Using blocking to increase temporal locality</h1></header>
<p id="P7000497027000000000000000044269" data-uri="chapter06.xhtml#P7000497027000000000000000044269" class="pcalibre1 pcalibre2 pcalibre10">There is an interesting technique called <i class="pcalibre17 pcalibre2 pcalibre1">blocking</i> that can improve the temporal locality of inner loops. The general idea of blocking is to organize the data structures in a program into large chunks called <i class="pcalibre17 pcalibre2 pcalibre1">blocks.</i> (In this context, "block" refers to an application-level chunk of data, <i class="pcalibre17 pcalibre2 pcalibre1">not</i> to a cache block.) The program is structured so that it loads a chunk into the L1 cache, does all the reads and writes that it needs to on that chunk, then discards the chunk, loads in the next chunk, and so on.</p>
<p id="P700049702700000000000000004426A" data-uri="chapter06.xhtml#P700049702700000000000000004426A" class="pcalibre1 pcalibre2 pcalibre63">Unlike the simple loop transformations for improving spatial locality, blocking makes the code harder to read and understand. For this reason, it is best suited for optimizing compilers or frequently executed library routines. Blocking does not improve the performance of matrix multiply on the Core i7, because of its sophisticated prefetching hardware. Still, the technique is interesting to study and understand because it is a general concept that can produce big performance gains on systems that don't prefetch.</p>
</aside>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P700049702700000000000000004426B" data-uri="chapter06.xhtml#P700049702700000000000000004426B">memory references in the inner loop (two loads and one store) than the class <i class="pcalibre17 pcalibre2 pcalibre1">AB</i> routines (two loads).</p></li>
<li id="P700049702700000000000000004426C" data-uri="chapter06.xhtml#P700049702700000000000000004426C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004426D" data-uri="chapter06.xhtml#P700049702700000000000000004426D" class="pcalibre1 pcalibre2 pcalibre10">For large values of <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, the performance of the fastest pair of versions (<i class="pcalibre17 pcalibre2 pcalibre1">kij</i> and <i class="pcalibre17 pcalibre2 pcalibre1">ikj</i>) is constant. Even though the array is much larger than any of the SRAM cache memories, the prefetching hardware is smart enough to recognize the stride-1 access pattern, and fast enough to keep up with memory accesses in the tight inner loop. This is a stunning accomplishment by the Intel engineers who designed this memory system, providing even more incentive for programmers to develop programs with good spatial locality.</p></li>
</ul>
</section>
<section id="P7000497027000000000000000005B16" data-uri="chapter06.xhtml#P7000497027000000000000000005B16" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004426E" data-uri="chapter06.xhtml#P700049702700000000000000004426E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">6.6.3 </span>Exploiting Locality in Your Programs</h1></header>
<p id="P700049702700000000000000004426F" data-uri="chapter06.xhtml#P700049702700000000000000004426F" class="pcalibre8 pcalibre1 pcalibre2">As we have seen, the memory system is organized as a hierarchy of storage devices, with smaller, faster devices toward the top and larger, slower devices toward the bottom. Because of this hierarchy, the effective rate that a program can access memory locations is not characterized by a single number. Rather, it is a wildly varying function of program locality (what we have dubbed the memory mountain) that can vary by orders of magnitude. Programs with good locality access most of their data from fast cache memories. Programs with poor locality access most of their data from the relatively slow DRAM main memory.</p>
<p id="P7000497027000000000000000044270" data-uri="chapter06.xhtml#P7000497027000000000000000044270" class="pcalibre8 pcalibre1 pcalibre2">Programmers who understand the nature of the memory hierarchy can exploit this understanding to write more efficient programs, regardless of the specific memory system organization. In particular, we recommend the following techniques:</p>
<ul id="P7000497027000000000000000044271" data-uri="chapter06.xhtml#P7000497027000000000000000044271" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000044272" data-uri="chapter06.xhtml#P7000497027000000000000000044272" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044273" data-uri="chapter06.xhtml#P7000497027000000000000000044273" class="pcalibre1 pcalibre2 pcalibre10">Focus your attention on the inner loops, where the bulk of the computations and memory accesses occur.</p></li>
<li id="P7000497027000000000000000044274" data-uri="chapter06.xhtml#P7000497027000000000000000044274" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044275" data-uri="chapter06.xhtml#P7000497027000000000000000044275" class="pcalibre1 pcalibre2 pcalibre10">Try to maximize the spatial locality in your programs by reading data objects sequentially, with stride 1, in the order they are stored in memory.</p></li>
<li id="P7000497027000000000000000044276" data-uri="chapter06.xhtml#P7000497027000000000000000044276" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044277" data-uri="chapter06.xhtml#P7000497027000000000000000044277" class="pcalibre1 pcalibre2 pcalibre10">Try to maximize the temporal locality in your programs by using a data object as often as possible once it has been read from memory.</p></li>
</ul>
</section>
</section></body></html>
