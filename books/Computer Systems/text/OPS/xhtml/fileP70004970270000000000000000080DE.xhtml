<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>12.2 Concurrent Programming with I/O Multiplexing</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P70004970270000000000000000080DE" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000046BD6" data-uri="chapter12.xhtml#P7000497027000000000000000046BD6" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.2 </span>Concurrent Programming with I/O Multiplexing</h1></header>
<p id="P7000497027000000000000000046BD7" data-uri="chapter12.xhtml#P7000497027000000000000000046BD7" class="pcalibre8 pcalibre1 pcalibre2">Suppose you are asked to write an echo server that can also respond to interactive commands that the user types to standard input. In this case, the server must respond to two independent I/O events: (1) a network client making a connection request, and (2) a user typing a command line at the keyboard. Which event do we wait for first? Neither option is ideal. If we are waiting for a connection request in accept, then we cannot respond to input commands. Similarly, if we are waiting for an input command in read, then we cannot respond to any connection requests.</p>
<p id="P7000497027000000000000000046BD8" data-uri="chapter12.xhtml#P7000497027000000000000000046BD8" class="pcalibre8 pcalibre1 pcalibre2">One solution to this dilemma is a technique called <i class="pcalibre17 pcalibre2 pcalibre1">I/O multiplexing</i>. The basic idea is to use the <code id="P7000497027000000000000000046BD9" data-uri="chapter12.xhtml#P7000497027000000000000000046BD9" class="pcalibre1 calibre1 pcalibre2">select</code> function to ask the kernel to suspend the process, returning control to the application only after one or more I/O events have occurred, as in the following examples:</p>
<ul id="P7000497027000000000000000046BDA" data-uri="chapter12.xhtml#P7000497027000000000000000046BDA" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000046BDB" data-uri="chapter12.xhtml#P7000497027000000000000000046BDB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046BDC" data-uri="chapter12.xhtml#P7000497027000000000000000046BDC" class="pcalibre1 pcalibre2 pcalibre10">Return when any descriptor in the set {0, 4} is ready for reading.</p></li>
<li id="P7000497027000000000000000046BDD" data-uri="chapter12.xhtml#P7000497027000000000000000046BDD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046BDE" data-uri="chapter12.xhtml#P7000497027000000000000000046BDE" class="pcalibre1 pcalibre2 pcalibre10">Return when any descriptor in the set {1, 2, 7} is ready for writing.</p></li>
<li id="P7000497027000000000000000046BDF" data-uri="chapter12.xhtml#P7000497027000000000000000046BDF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046BE0" data-uri="chapter12.xhtml#P7000497027000000000000000046BE0" class="pcalibre1 pcalibre2 pcalibre10">Time out if 152.13 seconds have elapsed waiting for an I/O event to occur.</p></li>
</ul>
<p id="P7000497027000000000000000046BE1" data-uri="chapter12.xhtml#P7000497027000000000000000046BE1" class="pcalibre8 pcalibre1 pcalibre2"><code id="P7000497027000000000000000046BE2" data-uri="chapter12.xhtml#P7000497027000000000000000046BE2" class="pcalibre1 calibre1 pcalibre2">Select</code> is a complicated function with many different usage scenarios. We will only discuss the first scenario: waiting for a set of descriptors to be ready for reading. See [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41E">62</a>, <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>] for a complete discussion.</p>
<pre id="P7000497027000000000000000046BE3" data-uri="chapter12.xhtml#P7000497027000000000000000046BE3" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046BE4" data-uri="chapter12.xhtml#P7000497027000000000000000046BE4" class="calibre3 pcalibre1 pcalibre2">
#include &lt;sys/select.h&gt;
int select(int n, fd_set *fdset, NULL, NULL, NULL);
			   Returns: nonzero count of ready descriptors, --1 on error
FD_ZERO(fd_set *fdset);			/* Clear all bits in fdset */
FD_CLR(int fd, fd_set *fdset);		/* Clear bit fd in fdset */
FD_SET(int fd, fd_set *fdset);		/* Turn on bit fd in fdset */
FD_ISSET(int fd, fd_set *fdset);	/* Is bit fd in fdset on? */
					   Macros for manipulating descriptor sets
</code></pre>
<p id="P7000497027000000000000000046BE5" data-uri="chapter12.xhtml#P7000497027000000000000000046BE5" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000080EF" title="978" data-uri="chapter12.xhtml#P70004970270000000000000000080EF" epub:type="pagebreak"></span>The <code id="P7000497027000000000000000046BE6" data-uri="chapter12.xhtml#P7000497027000000000000000046BE6" class="pcalibre1 calibre1 pcalibre2">select</code> function manipulates sets of type <code id="P7000497027000000000000000046BE7" data-uri="chapter12.xhtml#P7000497027000000000000000046BE7" class="pcalibre1 calibre1 pcalibre2">fd_set</code>, which are known as <i class="pcalibre17 pcalibre2 pcalibre1">descriptor sets</i>. Logically, we think of a descriptor set as a bit vector (introduced in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000002AD_split_000.xhtml#P70004970270000000000000000002AD"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">2.1</span></a>) of size <var class="pcalibre17 pcalibre2 pcalibre1">n</var>:</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000046BE8" data-uri="chapter12.xhtml#P7000497027000000000000000046BE8">
<m:math display="block" alttext="" data-uri="" altimg-width="140" altimg-height="20" altimg="../images/ch12-01.png"><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mi>n</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>b</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>b</m:mi><m:mn>0</m:mn></m:msub></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046BE9" data-uri="chapter12.xhtml#P7000497027000000000000000046BE9">Each bit <i class="pcalibre17 pcalibre2 pcalibre1">b<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> corresponds to descriptor <var class="pcalibre17 pcalibre2 pcalibre1">k</var>. Descriptor <var class="pcalibre17 pcalibre2 pcalibre1">k</var> is a member of the descriptor set if and only if <i class="pcalibre17 pcalibre2 pcalibre1">b<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> = 1. You are only allowed to do three things with descriptor sets: (1) allocate them, (2) assign one variable of this type to another, and (3) modify and inspect them using the FD_ZERO, FD_SET, FD_CLR, and FD_ISSET macros.</p>
<p id="P7000497027000000000000000046BEA" data-uri="chapter12.xhtml#P7000497027000000000000000046BEA" class="pcalibre8 pcalibre1 pcalibre2">For our purposes, the select function takes two inputs: a descriptor set (<code id="P7000497027000000000000000046BEB" data-uri="chapter12.xhtml#P7000497027000000000000000046BEB" class="pcalibre1 calibre1 pcalibre2">fdset</code>) called the <i class="pcalibre17 pcalibre2 pcalibre1">read set</i>, and the cardinality (n) of the read set (actually the maximum cardinality of any descriptor set). The <code id="P7000497027000000000000000046BEC" data-uri="chapter12.xhtml#P7000497027000000000000000046BEC" class="pcalibre1 calibre1 pcalibre2">select</code> function blocks until at least one descriptor in the read set is ready for reading. A descriptor <var class="pcalibre17 pcalibre2 pcalibre1">k</var> is <i class="pcalibre17 pcalibre2 pcalibre1">ready for reading</i> if and only if a request to read 1 byte from that descriptor would not block. As a side effect, <code id="P7000497027000000000000000046BED" data-uri="chapter12.xhtml#P7000497027000000000000000046BED" class="pcalibre1 calibre1 pcalibre2">select</code> modifies the <code id="P7000497027000000000000000046BEE" data-uri="chapter12.xhtml#P7000497027000000000000000046BEE" class="pcalibre1 calibre1 pcalibre2">fd_set</code> pointed to by argument <code id="P7000497027000000000000000046BEF" data-uri="chapter12.xhtml#P7000497027000000000000000046BEF" class="pcalibre1 calibre1 pcalibre2">fdset</code> to indicate a subset of the read set called the <i class="pcalibre17 pcalibre2 pcalibre1">ready set</i>, consisting of the descriptors in the read set that are ready for reading. The value returned by the function indicates the cardinality of the ready set. Note that because of the side effect, we must update the read set every time <code id="P7000497027000000000000000046BF0" data-uri="chapter12.xhtml#P7000497027000000000000000046BF0" class="pcalibre1 calibre1 pcalibre2">select</code> is called.</p>
<p id="P7000497027000000000000000046BF1" data-uri="chapter12.xhtml#P7000497027000000000000000046BF1" class="pcalibre8 pcalibre1 pcalibre2">The best way to understand <code id="P7000497027000000000000000046BF2" data-uri="chapter12.xhtml#P7000497027000000000000000046BF2" class="pcalibre1 calibre1 pcalibre2">select</code> is to study a concrete example. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008109"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.6</span></a> shows how we might use <code id="P7000497027000000000000000046BF3" data-uri="chapter12.xhtml#P7000497027000000000000000046BF3" class="pcalibre1 calibre1 pcalibre2">select</code> to implement an iterative echo server that also accepts user commands on the standard input. We begin by using the <code id="P7000497027000000000000000046BF4" data-uri="chapter12.xhtml#P7000497027000000000000000046BF4" class="pcalibre1 calibre1 pcalibre2">open_listenfd</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E55"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.19</span></a> to open a listening descriptor (line 16), and then using FD_ZERO to create an empty read set (line 18):</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000046BF5" data-uri="chapter12.xhtml#P7000497027000000000000000046BF5">
<img alt="A diagram of read_set (Ø) has 0 within bits 3 (listenfd) to 0 (stdin)." id="P7000497027000000000000000046BF6" data-uri="P700049702700000000000000000B7CC" src="../images/p978-1.png" class="pcalibre312 pcalibre1 pcalibre2"/>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046BF7" data-uri="chapter12.xhtml#P7000497027000000000000000046BF7">Next, in lines 19 and 20, we define the read set to consist of descriptor 0 (standard input) and descriptor 3 (the listening descriptor), respectively:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000046BF8" data-uri="chapter12.xhtml#P7000497027000000000000000046BF8">
<img alt="A diagram of read_set ({0,3}) has 1 within bits 3 (listenfd) to 0 (stdin), and 0 in bits 2 and 1." id="P7000497027000000000000000046BF9" data-uri="P700049702700000000000000000B7CD" src="../images/p978-2.png" class="pcalibre313 pcalibre2 pcalibre1"/>
</figure>
<p id="P7000497027000000000000000046BFA" data-uri="chapter12.xhtml#P7000497027000000000000000046BFA" class="pcalibre8 pcalibre1 pcalibre2">At this point, we begin the typical server loop. But instead of waiting for a connection request by calling the <code id="P7000497027000000000000000046BFB" data-uri="chapter12.xhtml#P7000497027000000000000000046BFB" class="pcalibre1 calibre1 pcalibre2">accept</code> function, we call the <code id="P7000497027000000000000000046BFC" data-uri="chapter12.xhtml#P7000497027000000000000000046BFC" class="pcalibre1 calibre1 pcalibre2">select</code> function, which blocks until either the listening descriptor or standard input is ready for reading (line 24). For example, here is the value of <code id="P7000497027000000000000000046BFD" data-uri="chapter12.xhtml#P7000497027000000000000000046BFD" class="pcalibre1 calibre1 pcalibre2">ready_set</code> that <code id="P7000497027000000000000000046BFE" data-uri="chapter12.xhtml#P7000497027000000000000000046BFE" class="pcalibre1 calibre1 pcalibre2">select</code> would return if the user hit the enter key, thus causing the standard input descriptor to</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008109" data-uri="chapter12.xhtml#P7000497027000000000000000008109">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000810A" title="979" data-uri="chapter12.xhtml#P700049702700000000000000000810A" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000046BFF" data-uri="chapter12.xhtml#P7000497027000000000000000046BFF" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/select.c</i></p>
<pre id="P7000497027000000000000000046C00" data-uri="chapter12.xhtml#P7000497027000000000000000046C00" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046C01" data-uri="chapter12.xhtml#P7000497027000000000000000046C01" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	void echo(int connfd);
3	void command(void);
4	
5	int main(int argc, char **argv)
6	{
7		int listenfd, connfd;
8		socklen_t clientlen;
9		struct sockaddr_storage clientaddr;
10		fd_set read_set, ready_set;
11	
12		if (argc != 2) {
13			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
14			exit(0);
15		}
16		listenfd = Open_listenfd(argv[1]);
17	
18		FD_ZERO(&amp;read_set);			/* Clear read set */
19		FD_SET(STDIN_FILENO, &amp;read_set);	/* Add stdin to read set */
20		FD_SET(listenfd, &amp;read_set);		/* Add listenfd to read set */
21	
22		while (1) {
23			ready_set = read_set;
24			Select(listenfd+1, &amp;ready_set, NULL, NULL, NULL);
25			if (FD_ISSET(STDIN_FILENO, &amp;ready_set))
26				command(); /* Read command line from stdin */
27			if (FD_ISSET(listenfd, &amp;ready_set)) {
28				clientlen = sizeof(struct sockaddr_storage);
29				connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
30				echo(connfd); /* Echo client input until EOF */
31				Close(connfd);
32			}
33		}
34	}
35	
36	void command(void) {
37		char buf[MAXLINE];
38		if (!Fgets(buf, MAXLINE, stdin))
39			exit(0); /* EOF */
40		printf("%s", buf); /* Process the input command */
41	}
</code></pre>
<p id="P7000497027000000000000000046C02" data-uri="chapter12.xhtml#P7000497027000000000000000046C02" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/select.c</i></p>
<figcaption id="P7000497027000000000000000046C03" data-uri="chapter12.xhtml#P7000497027000000000000000046C03" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046C04" data-uri="chapter12.xhtml#P7000497027000000000000000046C04" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.6 </span>An iterative echo server that uses I/O multiplexing.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000046C05" data-uri="chapter12.xhtml#P7000497027000000000000000046C05"><p id="P7000497027000000000000000046C06" data-uri="chapter12.xhtml#P7000497027000000000000000046C06" class="pcalibre1 pcalibre2 pcalibre10">The server uses <code id="P7000497027000000000000000046C07" data-uri="chapter12.xhtml#P7000497027000000000000000046C07" class="pcalibre1 calibre1 pcalibre2">select</code> to wait for connection requests on a listening descriptor and commands on standard input.</p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046C08" data-uri="chapter12.xhtml#P7000497027000000000000000046C08"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000008115" title="980" data-uri="chapter12.xhtml#P7000497027000000000000000008115" epub:type="pagebreak"></span>become ready for reading:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000046C09" data-uri="chapter12.xhtml#P7000497027000000000000000046C09">
<img alt="A diagram of read_set ({0}) shows 1 within bit 0 (stdin) and 0 in bits 3 (listenfd) to 1." id="P7000497027000000000000000046C0A" data-uri="P700049702700000000000000000B7CE" src="../images/p980-1.png" class="pcalibre1 pcalibre2 pcalibre314"/>
</figure>
<p id="P7000497027000000000000000046C0B" data-uri="chapter12.xhtml#P7000497027000000000000000046C0B" class="pcalibre8 pcalibre1 pcalibre2">Once <code id="P7000497027000000000000000046C0C" data-uri="chapter12.xhtml#P7000497027000000000000000046C0C" class="pcalibre1 calibre1 pcalibre2">select</code> returns, we use the FD_ISSET macro to determine which descriptors are ready for reading. If standard input is ready (line 25), we call the <code id="P7000497027000000000000000046C0D" data-uri="chapter12.xhtml#P7000497027000000000000000046C0D" class="pcalibre1 calibre1 pcalibre2">command</code> function, which reads, parses, and responds to the command before returning to the main routine. If the listening descriptor is ready (line 27), we call <code id="P7000497027000000000000000046C0E" data-uri="chapter12.xhtml#P7000497027000000000000000046C0E" class="pcalibre1 calibre1 pcalibre2">accept</code> to get a connected descriptor and then call the echo function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E78"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.22</span></a>, which echoes each line from the client until the client closes its end of the connection.</p>
<p id="P7000497027000000000000000046C0F" data-uri="chapter12.xhtml#P7000497027000000000000000046C0F" class="pcalibre8 pcalibre1 pcalibre2">While this program is a good example of using <code id="P7000497027000000000000000046C10" data-uri="chapter12.xhtml#P7000497027000000000000000046C10" class="pcalibre1 calibre1 pcalibre2">select</code>, it still leaves something to be desired. The problem is that once it connects to a client, it continues echoing input lines until the client closes its end of the connection. Thus, if you type a command to standard input, you will not get a response until the server is finished with the client. A better approach would be to multiplex at a finer granularity, echoing (at most) one text line each time through the server loop.</p>
<section id="P700049702700000000000000000811E" data-uri="chapter12.xhtml#P700049702700000000000000000811E" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046C11" data-uri="chapter12.xhtml#P7000497027000000000000000046C11" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.3 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000046C12" data-uri="chapter12.xhtml#P7000497027000000000000000046C12">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000046C13" data-uri="chapter12.xhtml#P7000497027000000000000000046C13">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000046C14" data-uri="chapter12.xhtml#P7000497027000000000000000046C14"><p id="P7000497027000000000000000046C15" data-uri="chapter12.xhtml#P7000497027000000000000000046C15" class="pcalibre1 pcalibre2 pcalibre10">In Linux systems, typing Ctrl+D indicates EOF on standard input. What happens if you type Ctrl+D to the program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008109"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.6</span></a> while it is blocked in the call to <code id="P7000497027000000000000000046C16" data-uri="chapter12.xhtml#P7000497027000000000000000046C16" class="pcalibre1 calibre1 pcalibre2">select</code>?</p></div></li>
</ol>
</section>
<section id="P7000497027000000000000000008125" data-uri="chapter12.xhtml#P7000497027000000000000000008125" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046C17" data-uri="chapter12.xhtml#P7000497027000000000000000046C17" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.2.1 </span>A Concurrent Event-Driven Server Based on I/O Multiplexing</h1></header>
<p id="P7000497027000000000000000046C18" data-uri="chapter12.xhtml#P7000497027000000000000000046C18" class="pcalibre8 pcalibre1 pcalibre2">I/O multiplexing can be used as the basis for concurrent <i class="pcalibre17 pcalibre2 pcalibre1">event-driven</i> programs, where flows make progress as a result of certain events. The general idea is to model logical flows as state machines. Informally, a <i class="pcalibre17 pcalibre2 pcalibre1">state machine</i> is a collection of <i class="pcalibre17 pcalibre2 pcalibre1">states</i>, <i class="pcalibre17 pcalibre2 pcalibre1">input events</i>, and <i class="pcalibre17 pcalibre2 pcalibre1">transitions</i> that map states and input events to states. Each transition maps an (input state, input event) pair to an output state. A <i class="pcalibre17 pcalibre2 pcalibre1">self-loop</i> is a transition between the same input and output state. State machines are typically drawn as directed graphs, where nodes represent states, directed arcs represent transitions, and arc labels represent input events. A state machine begins execution in some initial state. Each input event triggers a transition from the current state to the next state.</p>
<p id="P7000497027000000000000000046C19" data-uri="chapter12.xhtml#P7000497027000000000000000046C19" class="pcalibre8 pcalibre1 pcalibre2">For each new client <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, a concurrent server based on I/O multiplexing creates a new state machine <i class="pcalibre17 pcalibre2 pcalibre1">s<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> and associates it with connected descriptor <i class="pcalibre17 pcalibre2 pcalibre1">d<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i>. As shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008129"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7</span></a>, each state machine <i class="pcalibre17 pcalibre2 pcalibre1">s<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> has one state ("waiting for descriptor <i class="pcalibre17 pcalibre2 pcalibre1">d<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> to be ready for reading"), one input event ("descriptor <i class="pcalibre17 pcalibre2 pcalibre1">d<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> is ready for reading"), and one transition ("read a text line from descriptor <i class="pcalibre17 pcalibre2 pcalibre1">d<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i>").</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008129" data-uri="chapter12.xhtml#P7000497027000000000000000008129">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000812A" title="981" data-uri="chapter12.xhtml#P700049702700000000000000000812A" epub:type="pagebreak"></span>
<img alt="A diagram illustrates a state machine." id="P7000497027000000000000000046C1A" data-uri="P700049702700000000000000000B7CF" src="../images/p981-1.png" class="pcalibre1 pcalibre2 calibre87"/>
<figcaption id="P7000497027000000000000000046C1B" data-uri="chapter12.xhtml#P7000497027000000000000000046C1B" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046C1C" data-uri="chapter12.xhtml#P7000497027000000000000000046C1C" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.7 </span>State machine for a logical flow in a concurrent event-driven echo server.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000026F8C" data-uri="chapter12.xhtml#P7000497027000000000000000026F8C">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000046C1D" data-uri="chapter12.xhtml#P7000497027000000000000000046C1D" class="pcalibre1 pcalibre2 pcalibre10">A diagram shows a state machine with State: “waiting for descriptor d<sub class="pcalibre1 pcalibre2 calibre14">k</sub> to be ready for reading.” An arrow on the state loops from input event: “descriptor d<sub class="pcalibre1 pcalibre2 calibre14">k</sub> is ready for reading,” back to the state a transition: “read a text line from descriptor d<sub class="pcalibre1 pcalibre2 calibre14">k</sub>.”</p>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000046C1E" data-uri="chapter12.xhtml#P7000497027000000000000000046C1E" class="pcalibre8 pcalibre1 pcalibre2">The server uses the I/O multiplexing, courtesy of the <code id="P7000497027000000000000000046C1F" data-uri="chapter12.xhtml#P7000497027000000000000000046C1F" class="pcalibre1 calibre1 pcalibre2">select</code> function, to detect the occurrence of input events. As each connected descriptor becomes ready for reading, the server executes the transition for the corresponding state machine—in this case, reading and echoing a text line from the descriptor.</p>
<p id="P7000497027000000000000000046C20" data-uri="chapter12.xhtml#P7000497027000000000000000046C20" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008144"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.8</span></a> shows the complete example code for a concurrent event-driven server based on I/O multiplexing. The set of active clients is maintained in a pool structure (lines 3−11). After initializing the pool by calling <code id="P7000497027000000000000000046C21" data-uri="chapter12.xhtml#P7000497027000000000000000046C21" class="pcalibre1 calibre1 pcalibre2">init_pool</code> (line 27), the server enters an infinite loop. During each iteration of this loop, the server calls the <code id="P7000497027000000000000000046C22" data-uri="chapter12.xhtml#P7000497027000000000000000046C22" class="pcalibre1 calibre1 pcalibre2">select</code> function to detect two different kinds of input events: (1) a connection request arriving from a new client, and (2) a connected descriptor for an existing client being ready for reading. When a connection request arrives (line 35), the server opens the connection (line 37) and calls the <code id="P7000497027000000000000000046C23" data-uri="chapter12.xhtml#P7000497027000000000000000046C23" class="pcalibre1 calibre1 pcalibre2">add_client</code> function to add the client to the pool (line 38). Finally, the server calls the <code id="P7000497027000000000000000046C24" data-uri="chapter12.xhtml#P7000497027000000000000000046C24" class="pcalibre1 calibre1 pcalibre2">check_clients</code> function to echo a single text line from each ready connected descriptor (line 42).</p>
<p id="P7000497027000000000000000046C25" data-uri="chapter12.xhtml#P7000497027000000000000000046C25" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046C26" data-uri="chapter12.xhtml#P7000497027000000000000000046C26" class="pcalibre1 calibre1 pcalibre2">init_pool</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000814E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.9</span></a>) initializes the client pool. The <code id="P7000497027000000000000000046C27" data-uri="chapter12.xhtml#P7000497027000000000000000046C27" class="pcalibre1 calibre1 pcalibre2">clientfd</code> array represents a set of connected descriptors, with the integer −1 denoting an available slot. Initially, the set of connected descriptors is empty (lines 5−7), and the listening descriptor is the only descriptor in the <code id="P7000497027000000000000000046C28" data-uri="chapter12.xhtml#P7000497027000000000000000046C28" class="pcalibre1 calibre1 pcalibre2">select</code> read set (lines 10−12).</p>
<p id="P7000497027000000000000000046C29" data-uri="chapter12.xhtml#P7000497027000000000000000046C29" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046C2A" data-uri="chapter12.xhtml#P7000497027000000000000000046C2A" class="pcalibre1 calibre1 pcalibre2">add_client</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008157"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.10</span></a>) adds a new client to the pool of active clients. After finding an empty slot in the <code id="P7000497027000000000000000046C2B" data-uri="chapter12.xhtml#P7000497027000000000000000046C2B" class="pcalibre1 calibre1 pcalibre2">clientfd</code> array, the server adds the connected descriptor to the array and initializes a corresponding R<span class="pcalibre1 pcalibre29 pcalibre2">io </span>read buffer so that we can call <code id="P7000497027000000000000000046C2C" data-uri="chapter12.xhtml#P7000497027000000000000000046C2C" class="pcalibre1 calibre1 pcalibre2">rio_readlineb</code> on the descriptor (lines 8−9). We then add the connected descriptor to the <code id="P7000497027000000000000000046C2D" data-uri="chapter12.xhtml#P7000497027000000000000000046C2D" class="pcalibre1 calibre1 pcalibre2">select</code> read set (line 12), and we update some global properties of the pool. The <code id="P7000497027000000000000000046C2E" data-uri="chapter12.xhtml#P7000497027000000000000000046C2E" class="pcalibre1 calibre1 pcalibre2">maxfd</code> variable (lines 15−16) keeps track of the largest file descriptor for <code id="P7000497027000000000000000046C2F" data-uri="chapter12.xhtml#P7000497027000000000000000046C2F" class="pcalibre1 calibre1 pcalibre2">select</code>. The maxi variable (lines 17−18) keeps track of the largest index into the <code id="P7000497027000000000000000046C30" data-uri="chapter12.xhtml#P7000497027000000000000000046C30" class="pcalibre1 calibre1 pcalibre2">clientfd</code> array so that the <code id="P7000497027000000000000000046C31" data-uri="chapter12.xhtml#P7000497027000000000000000046C31" class="pcalibre1 calibre1 pcalibre2">check_clients</code> function does not have to search the entire array.</p>
<p id="P7000497027000000000000000046C32" data-uri="chapter12.xhtml#P7000497027000000000000000046C32" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046C33" data-uri="chapter12.xhtml#P7000497027000000000000000046C33" class="pcalibre1 calibre1 pcalibre2">check_clients</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000815F"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.11</span></a> echoes a text line from each ready connected descriptor. If we are successful in reading a text line from the descriptor, then we echo that line back to the client (lines 15−18). Notice that in line 15, we are maintaining a cumulative count of total bytes received from all clients. If we detect EOF because the client has closed its end of the connection, then we close our end of the connection (line 23) and remove the descriptor from the pool (lines 24−25).</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008144" data-uri="chapter12.xhtml#P7000497027000000000000000008144">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000008145" title="982" data-uri="chapter12.xhtml#P7000497027000000000000000008145" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000046C34" data-uri="chapter12.xhtml#P7000497027000000000000000046C34" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<pre id="P7000497027000000000000000046C35" data-uri="chapter12.xhtml#P7000497027000000000000000046C35" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046C36" data-uri="chapter12.xhtml#P7000497027000000000000000046C36" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	
3	typedef struct {	/* Represents a pool of connected descriptors */
4	int maxfd;		/* Largest descriptor in read_set */
5	fd_set read_set;	/* Set of all active descriptors */
6	fd_set ready_set;	/* Subset of descriptors ready for reading */
7	int nready;		/* Number of ready descriptors from select */
8	int maxi;		/* High water index into client array */
9	int clientfd[FD_SETSIZE];	/* Set of active descriptors */
10	rio_t clientrio[FD_SETSIZE];	/* Set of active read buffers */
11	} pool;
12	
13	int byte_cnt = 0;	/* Counts total bytes received by server */
14	
15	int main(int argc, char **argv)
16	{
17		int listenfd, connfd;
18		socklen_t clientlen;
19		struct sockaddr_storage clientaddr;
20		static pool pool;
21	
22		if (argc != 2) {
23			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
24			exit(0);
25		}
26		listenfd = Open_listenfd(argv[1]);
27		init_pool(listenfd, &amp;pool); 28
29		while (1) {
30			/* Wait for listening/connected descriptor(s) to become ready */
31			pool.ready_set = pool.read_set;
32			pool.nready = Select(pool.maxfd+1, &amp;pool.ready_set, NULL, NULL, NULL);
33	
34			/* If listening descriptor ready, add new client to pool */
35			if (FD_ISSET(listenfd, &amp;pool.ready_set)) {
36				clientlen = sizeof(struct sockaddr_storage);
37				connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
38				add_client(connfd, &amp;pool);
39			}
40	
41			/* Echo a text line from each ready connected descriptor */
42			check_clients(&amp;pool);
43		}
44	}
</code></pre>
<p id="P7000497027000000000000000046C37" data-uri="chapter12.xhtml#P7000497027000000000000000046C37" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<figcaption id="P7000497027000000000000000046C38" data-uri="chapter12.xhtml#P7000497027000000000000000046C38" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046C39" data-uri="chapter12.xhtml#P7000497027000000000000000046C39" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.8 </span>Concurrent echo server based on I/O multiplexing.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000046C3A" data-uri="chapter12.xhtml#P7000497027000000000000000046C3A"><p id="P7000497027000000000000000046C3B" data-uri="chapter12.xhtml#P7000497027000000000000000046C3B" class="pcalibre1 pcalibre2 pcalibre10">Each server iteration echoes a text line from each ready descriptor.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000814E" data-uri="chapter12.xhtml#P700049702700000000000000000814E">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000814F" title="983" data-uri="chapter12.xhtml#P700049702700000000000000000814F" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000046C3C" data-uri="chapter12.xhtml#P7000497027000000000000000046C3C" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<pre id="P7000497027000000000000000046C3D" data-uri="chapter12.xhtml#P7000497027000000000000000046C3D" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046C3E" data-uri="chapter12.xhtml#P7000497027000000000000000046C3E" class="calibre3 pcalibre1 pcalibre2">
1	void init_pool(int listenfd, pool *p)
2	{
3		/* Initially, there are no connected descriptors */
4		int i;
5		p-&gt;maxi = −1;
6		for (i=0; i&lt; FD_SETSIZE; i++)
7			p-&gt;clientfd[i] = −1;
8	
9		/* Initially, listenfd is only member of select read set */
10		p-&gt;maxfd = listenfd;
11		FD_ZERO(&amp;p-&gt;read_set);
12		FD_SET(listenfd, &amp;p-&gt;read_set);
13	}
</code></pre>
<p id="P7000497027000000000000000046C3F" data-uri="chapter12.xhtml#P7000497027000000000000000046C3F" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<figcaption id="P7000497027000000000000000046C40" data-uri="chapter12.xhtml#P7000497027000000000000000046C40" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046C41" data-uri="chapter12.xhtml#P7000497027000000000000000046C41" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.9 </span><code id="P7000497027000000000000000046C42" data-uri="chapter12.xhtml#P7000497027000000000000000046C42" class="pcalibre1 calibre1 pcalibre2">init_pool</code> initializes the pool of active clients.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008157" data-uri="chapter12.xhtml#P7000497027000000000000000008157">
<p id="P7000497027000000000000000046C43" data-uri="chapter12.xhtml#P7000497027000000000000000046C43" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<pre id="P7000497027000000000000000046C44" data-uri="chapter12.xhtml#P7000497027000000000000000046C44" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046C45" data-uri="chapter12.xhtml#P7000497027000000000000000046C45" class="calibre3 pcalibre1 pcalibre2">
1	void add_client(int connfd, pool *p)
2	{
3		int i;
4		p-&gt;nready−;
5		for (i = 0; i &lt; FD_SETSIZE; i++) /* Find an available slot */
6			if (p-&gt;clientfd[i] &lt; 0) {
7				/* Add connected descriptor to the pool */
8				p-&gt;clientfd[i] = connfd;
9				Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);
10	
11				/* Add the descriptor to descriptor set */
12				FD_SET(connfd, &amp;p-&gt;read_set);
13	
14				/* Update max descriptor and pool high water mark */
15				if (connfd &gt; p-&gt;maxfd)
16					p-&gt;maxfd = connfd;
17				if (i &gt; p-&gt;maxi)
18					p-&gt;maxi = i;
19				break;
20			}
21		if (i == FD_SETSIZE) /* Couldn't find an empty slot */
22			app_error("add_client error: Too many clients");
23	}
</code></pre>
<p id="P7000497027000000000000000046C46" data-uri="chapter12.xhtml#P7000497027000000000000000046C46" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<figcaption id="P7000497027000000000000000046C47" data-uri="chapter12.xhtml#P7000497027000000000000000046C47" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046C48" data-uri="chapter12.xhtml#P7000497027000000000000000046C48" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.10 </span><code id="P7000497027000000000000000046C49" data-uri="chapter12.xhtml#P7000497027000000000000000046C49" class="pcalibre1 calibre1 pcalibre2">add_client</code> adds a new client connection to the pool.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000815F" data-uri="chapter12.xhtml#P700049702700000000000000000815F">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000008160" title="984" data-uri="chapter12.xhtml#P7000497027000000000000000008160" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000046C4A" data-uri="chapter12.xhtml#P7000497027000000000000000046C4A" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<pre id="P7000497027000000000000000046C4B" data-uri="chapter12.xhtml#P7000497027000000000000000046C4B" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046C4C" data-uri="chapter12.xhtml#P7000497027000000000000000046C4C" class="calibre3 pcalibre1 pcalibre2">
1	void check_clients(pool *p)
2	{
3		int i, connfd, n;
4		char buf[MAXLINE];
5		rio_t rio;
6	
7		for (i = 0; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready &gt; 0); i++) {
8			connfd = p-&gt;clientfd[i];
9			rio = p-&gt;clientrio[i];
10	
11			/* If the descriptor is ready, echo a text line from it */
12			if ((connfd &gt; 0) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) {
13				p-&gt;nready−;
14				if ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {
15					byte_cnt += n;
16					printf("Server received %d (%d total) bytes on fd %d\n",
17						n, byte_cnt, connfd);
18					Rio_writen(connfd, buf, n);
19				}
20	
21				/* EOF detected, remove descriptor from pool */
22				else {
23					Close(connfd);
24					FD_CLR(connfd, &amp;p-&gt;read_set);
25					p-&gt;clientfd[i] = −1;
26				}
27			}
28		}
29	}
</code></pre>
<p id="P7000497027000000000000000046C4D" data-uri="chapter12.xhtml#P7000497027000000000000000046C4D" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservers.c</i></p>
<figcaption id="P7000497027000000000000000046C4E" data-uri="chapter12.xhtml#P7000497027000000000000000046C4E" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046C4F" data-uri="chapter12.xhtml#P7000497027000000000000000046C4F" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.11 </span><code id="P7000497027000000000000000046C50" data-uri="chapter12.xhtml#P7000497027000000000000000046C50" class="pcalibre1 calibre1 pcalibre2">check_clients</code> services ready client connections.</h1></header>
</figcaption>
</figure>
<p id="P7000497027000000000000000046C51" data-uri="chapter12.xhtml#P7000497027000000000000000046C51" class="pcalibre8 pcalibre1 pcalibre2">In terms of the finite state model in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008129"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7</span></a>, the <code id="P7000497027000000000000000046C52" data-uri="chapter12.xhtml#P7000497027000000000000000046C52" class="pcalibre1 calibre1 pcalibre2">select</code> function detects input events, and the <code id="P7000497027000000000000000046C53" data-uri="chapter12.xhtml#P7000497027000000000000000046C53" class="pcalibre1 calibre1 pcalibre2">add_client</code> function creates a new logical flow (state machine). The <code id="P7000497027000000000000000046C54" data-uri="chapter12.xhtml#P7000497027000000000000000046C54" class="pcalibre1 calibre1 pcalibre2">check_clients</code> function performs state transitions by echoing input lines, and it also deletes the state machine when the client has finished sending text lines.</p>
<section id="P700049702700000000000000000816C" data-uri="chapter12.xhtml#P700049702700000000000000000816C" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046C55" data-uri="chapter12.xhtml#P7000497027000000000000000046C55" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.4 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000046C56" data-uri="chapter12.xhtml#P7000497027000000000000000046C56">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000046C57" data-uri="chapter12.xhtml#P7000497027000000000000000046C57">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000046C58" data-uri="chapter12.xhtml#P7000497027000000000000000046C58"><p id="P7000497027000000000000000046C59" data-uri="chapter12.xhtml#P7000497027000000000000000046C59" class="pcalibre1 pcalibre2 pcalibre10">In the server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008144"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.8</span></a>, we are careful to reinitialize the <code id="P7000497027000000000000000046C5A" data-uri="chapter12.xhtml#P7000497027000000000000000046C5A" class="pcalibre1 calibre1 pcalibre2">pool.ready_set</code> variable immediately before every call to <code id="P7000497027000000000000000046C5B" data-uri="chapter12.xhtml#P7000497027000000000000000046C5B" class="pcalibre1 calibre1 pcalibre2">select</code>. Why?</p></div></li>
</ol>
</section>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000008174" data-uri="chapter12.xhtml#P7000497027000000000000000008174"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000046C5C" data-uri="chapter12.xhtml#P7000497027000000000000000046C5C" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000008176" title="985" data-uri="chapter12.xhtml#P7000497027000000000000000008176" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Event-driven Web servers</h1></header>
<p id="P7000497027000000000000000046C5D" data-uri="chapter12.xhtml#P7000497027000000000000000046C5D" class="pcalibre1 pcalibre2 pcalibre10">Despite the disadvantages outlined in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008178"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">12.2.2</span></a>, modern high-performance servers such as Node.js, nginx, and Tornado use event-driven programming based on I/O multiplexing, mainly because of the significant performance advantage compared to processes and threads.</p>
</aside>
</section>
<section id="P7000497027000000000000000008178" data-uri="chapter12.xhtml#P7000497027000000000000000008178" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046C5E" data-uri="chapter12.xhtml#P7000497027000000000000000046C5E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.2.2 </span>Pros and Cons of I/O Multiplexing</h1></header>
<p id="P7000497027000000000000000046C5F" data-uri="chapter12.xhtml#P7000497027000000000000000046C5F" class="pcalibre8 pcalibre1 pcalibre2">The server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008144"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.8</span></a> provides a nice example of the advantages and disadvantages of event-driven programming based on I/O multiplexing. One advantage is that event-driven designs give programmers more control over the behavior of their programs than process-based designs. For example, we can imagine writing an event-driven concurrent server that gives preferred service to some clients, which would be difficult for a concurrent server based on processes.</p>
<p id="P7000497027000000000000000046C60" data-uri="chapter12.xhtml#P7000497027000000000000000046C60" class="pcalibre8 pcalibre1 pcalibre2">Another advantage is that an event-driven server based on I/O multiplexing runs in the context of a single process, and thus every logical flow has access to the entire address space of the process. This makes it easy to share data between flows. A related advantage of running as a single process is that you can debug your concurrent server as you would any sequential program, using a familiar debugging tool such as <span class="pcalibre1 pcalibre29 pcalibre2">gdb</span>. Finally, event-driven designs are often significantly more efficient than process-based designs because they do not require a process context switch to schedule a new flow.</p>
<p id="P7000497027000000000000000046C61" data-uri="chapter12.xhtml#P7000497027000000000000000046C61" class="pcalibre8 pcalibre1 pcalibre2">A significant disadvantage of event-driven designs is coding complexity. Our event-driven concurrent echo server requires three times more code than the process-based server. Unfortunately, the complexity increases as the granularity of the concurrency decreases. By <i class="pcalibre17 pcalibre2 pcalibre1">granularity</i>, we mean the number of instructions that each logical flow executes per time slice. For instance, in our example concurrent server, the granularity of concurrency is the number of instructions required to read an entire text line. As long as some logical flow is busy reading a text line, no other logical flow can make progress. This is fine for our example, but it makes our event-driven server vulnerable to a malicious client that sends only a partial text line and then halts. Modifying an event-driven server to handle partial text lines is a nontrivial task, but it is handled cleanly and automatically by a process-based design. Another significant disadvantage of event-based designs is that they cannot fully utilize multi-core processors.</p>
</section>
</section></body></html>
