<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>7.6 Symbol Resolution</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000006160" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P70004970270000000000000000448F7" data-uri="chapter07.xhtml#P70004970270000000000000000448F7" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">7.6 </span>Symbol Resolution</h1></header>
<p id="P70004970270000000000000000448F8" data-uri="chapter07.xhtml#P70004970270000000000000000448F8" class="pcalibre8 pcalibre1 pcalibre2">The linker resolves symbol references by associating each reference with exactly one symbol definition from the symbol tables of its input relocatable object files. Symbol resolution is straightforward for references to local symbols that are defined in the same module as the reference. The compiler allows only one definition of each local symbol per module. The compiler also ensures that static local variables, which get local linker symbols, have unique names.</p>
<p id="P70004970270000000000000000448F9" data-uri="chapter07.xhtml#P70004970270000000000000000448F9" class="pcalibre8 pcalibre1 pcalibre2">Resolving references to global symbols, however, is trickier. When the compiler encounters a symbol (either a variable or function name) that is not defined in the current module, it assumes that it is defined in some other module, generates a linker symbol table entry, and leaves it for the linker to handle. If the linker is unable to find a definition for the referenced symbol in any of its input modules, it prints an (often cryptic) error message and terminates. For example, if we try to compile and link the following source file on a Linux machine,</p>
<pre id="P70004970270000000000000000448FA" data-uri="chapter07.xhtml#P70004970270000000000000000448FA" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000448FB" data-uri="chapter07.xhtml#P70004970270000000000000000448FB" class="calibre3 pcalibre1 pcalibre2">
1	void foo(void); 
2
3	int main() {
4	    foo();
5	    return 0;
6	}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000448FC" data-uri="chapter07.xhtml#P70004970270000000000000000448FC">then the compiler runs without a hitch, but the linker terminates when it cannot resolve the reference to <code id="P70004970270000000000000000448FD" data-uri="chapter07.xhtml#P70004970270000000000000000448FD" class="pcalibre1 calibre1 pcalibre2">foo:</code></p>
<pre id="P70004970270000000000000000448FE" data-uri="chapter07.xhtml#P70004970270000000000000000448FE" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000448FF" data-uri="chapter07.xhtml#P70004970270000000000000000448FF" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -Wall -Og -o linkerror linkerror.c</i>
/tmp/ccSz5uti.o: In function `main':
/tmp/ccSz5uti.o(.text+0x7): undefined reference to `foo'</code></pre>
<p id="P7000497027000000000000000044900" data-uri="chapter07.xhtml#P7000497027000000000000000044900" class="pcalibre8 pcalibre1 pcalibre2">Symbol resolution for global symbols is also tricky because multiple object modules might define global symbols with the same name. In this case, the linker must either flag an error or somehow choose one of the definitions and discard the rest. The approach adopted by Linux systems involves cooperation between the compiler, assembler, and linker and can introduce some baffling bugs to the unwary programmer.</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P700049702700000000000000000616B" data-uri="chapter07.xhtml#P700049702700000000000000000616B"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000044901" data-uri="chapter07.xhtml#P7000497027000000000000000044901" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000616D" title="680" data-uri="chapter07.xhtml#P700049702700000000000000000616D" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Mangling of linker symbols in C++ and Java</h1></header>
<p id="P7000497027000000000000000044902" data-uri="chapter07.xhtml#P7000497027000000000000000044902" class="pcalibre1 pcalibre2 pcalibre40">Both C++ and Java allow overloaded methods that have the same name in the source code but different parameter lists. So how does the linker tell the difference between these different overloaded functions? Overloaded functions in C++ and Java work because the compiler encodes each unique method and parameter list combination into a unique name for the linker. This encoding process is called <i class="pcalibre17 pcalibre2 pcalibre1">mangling</i>, and the inverse process is known as <i class="pcalibre17 pcalibre2 pcalibre1">demangling.</i></p>
<p id="P7000497027000000000000000044903" data-uri="chapter07.xhtml#P7000497027000000000000000044903" class="pcalibre1 pcalibre2 pcalibre10">Happily, C++ and Java use compatible mangling schemes. A mangled class name consists of the integer number of characters in the name followed by the original name. For example, the class <code id="P7000497027000000000000000044904" data-uri="chapter07.xhtml#P7000497027000000000000000044904" class="pcalibre1 calibre1 pcalibre2">Foo</code> is encoded as <code id="P7000497027000000000000000044905" data-uri="chapter07.xhtml#P7000497027000000000000000044905" class="pcalibre1 calibre1 pcalibre2">3Foo</code>. A method is encoded as the original method name, followed by __, followed by the mangled class name, followed by single letter encodings of each argument. For example, <code id="P7000497027000000000000000044906" data-uri="chapter07.xhtml#P7000497027000000000000000044906" class="pcalibre1 calibre1 pcalibre2">Foo::bar(int, long)</code> is encoded as <code id="P7000497027000000000000000044907" data-uri="chapter07.xhtml#P7000497027000000000000000044907" class="pcalibre1 calibre1 pcalibre2">bar_3Fooil</code>. Similar schemes are used to mangle global variable and template names.</p>
</aside>
<section id="P7000497027000000000000000006174" data-uri="chapter07.xhtml#P7000497027000000000000000006174" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000044908" data-uri="chapter07.xhtml#P7000497027000000000000000044908" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">7.6.1 </span>How Linkers Resolve Duplicate Symbol Names</h1></header>
<p id="P7000497027000000000000000044909" data-uri="chapter07.xhtml#P7000497027000000000000000044909" class="pcalibre8 pcalibre1 pcalibre2">The input to the linker is a collection of relocatable object modules. Each of these modules defines a set of symbols, some of which are local (visible only to the module that defines it), and some of which are global (visible to other modules). What happens if multiple modules define global symbols with the same name? Here is the approach that Linux compilation systems use.</p>
<p id="P700049702700000000000000004490A" data-uri="chapter07.xhtml#P700049702700000000000000004490A" class="pcalibre8 pcalibre1 pcalibre2">At compile time, the compiler exports each global symbol to the assembler as either <i class="pcalibre17 pcalibre2 pcalibre1">strong</i> or <i class="pcalibre17 pcalibre2 pcalibre1">weak</i>, and the assembler encodes this information implicitly in the symbol table of the relocatable object file. Functions and initialized global variables get strong symbols. Uninitialized global variables get weak symbols.</p>
<p id="P700049702700000000000000004490B" data-uri="chapter07.xhtml#P700049702700000000000000004490B" class="pcalibre8 pcalibre1 pcalibre2">Given this notion of strong and weak symbols, Linux linkers use the following rules for dealing with duplicate symbol names:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P700049702700000000000000004490C" data-uri="chapter07.xhtml#P700049702700000000000000004490C">
<li id="P700049702700000000000000004490D" data-uri="chapter07.xhtml#P700049702700000000000000004490D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004490E" data-uri="chapter07.xhtml#P700049702700000000000000004490E" class="pcalibre1 pcalibre2 pcalibre40">Rule 1. Multiple strong symbols with the same name are not allowed.</p></li>
<li id="P700049702700000000000000004490F" data-uri="chapter07.xhtml#P700049702700000000000000004490F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044910" data-uri="chapter07.xhtml#P7000497027000000000000000044910" class="pcalibre1 pcalibre2 pcalibre40">Rule 2. Given a strong symbol and multiple weak symbols with the same name, choose the strong symbol.</p></li>
<li id="P7000497027000000000000000044911" data-uri="chapter07.xhtml#P7000497027000000000000000044911" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044912" data-uri="chapter07.xhtml#P7000497027000000000000000044912" class="pcalibre1 pcalibre2 pcalibre40">Rule 3. Given multiple weak symbols with the same name, choose any of the weak symbols.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000044913" data-uri="chapter07.xhtml#P7000497027000000000000000044913">For example, suppose we attempt to compile and link the following two C modules:</p>
<pre id="P7000497027000000000000000044914" data-uri="chapter07.xhtml#P7000497027000000000000000044914" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044915" data-uri="chapter07.xhtml#P7000497027000000000000000044915" class="calibre3 pcalibre1 pcalibre2">
1	/* foo1.c */
2	int main()
3	{
4		return 0;
5	}
1	/* bar1.c */
2	int main()
3	{
4		return 0;
5	}</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000044916" data-uri="chapter07.xhtml#P7000497027000000000000000044916"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006184" title="681" data-uri="chapter07.xhtml#P7000497027000000000000000006184" epub:type="pagebreak"></span>In this case, the linker will generate an error message because the strong symbol main is defined multiple times (rule 1):</p>
<pre id="P7000497027000000000000000044917" data-uri="chapter07.xhtml#P7000497027000000000000000044917" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044918" data-uri="chapter07.xhtml#P7000497027000000000000000044918" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc foo1.c bar1.c</i>
/tmp/ccq2Uxnd.o: In function `main':
bar1.c:(.text+0x0): multiple definition of `main'</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000044919" data-uri="chapter07.xhtml#P7000497027000000000000000044919">Similarly, the linker will generate an error message for the following modules because the strong symbol <code id="P700049702700000000000000004491A" data-uri="chapter07.xhtml#P700049702700000000000000004491A" class="pcalibre1 calibre1 pcalibre2">x</code> is defined twice (rule 1):</p>
<pre id="P700049702700000000000000004491B" data-uri="chapter07.xhtml#P700049702700000000000000004491B" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004491C" data-uri="chapter07.xhtml#P700049702700000000000000004491C" class="calibre3 pcalibre1 pcalibre2">
1	/* foo2.c */
2	int x = 15213;
3
4	int main()
5	{
6		return 0;
7	}
</code></pre>
<pre id="P700049702700000000000000004491D" data-uri="chapter07.xhtml#P700049702700000000000000004491D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004491E" data-uri="chapter07.xhtml#P700049702700000000000000004491E" class="calibre3 pcalibre1 pcalibre2">
1	/* bar2.c */
2	int x = 15213;
3
4	void f()
5	{
6	}</code></pre>
<p id="P700049702700000000000000004491F" data-uri="chapter07.xhtml#P700049702700000000000000004491F" class="pcalibre8 pcalibre1 pcalibre2">However, if <code id="P7000497027000000000000000044920" data-uri="chapter07.xhtml#P7000497027000000000000000044920" class="pcalibre1 calibre1 pcalibre2">x</code> is uninitialized in one module, then the linker will quietly choose the strong symbol defined in the other (rule 2):</p>
<pre id="P7000497027000000000000000044921" data-uri="chapter07.xhtml#P7000497027000000000000000044921" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044922" data-uri="chapter07.xhtml#P7000497027000000000000000044922" class="calibre3 pcalibre1 pcalibre2">
1	/* foo3.c */
2	#include &lt;stdio.h&gt;
3	void f(void);
4
5	int x = 15213;
6
7	int main()
8	{
9		f();
10		printf(″x = %dn″, x);
11		return 0;
12	}
</code></pre>
<pre id="P7000497027000000000000000044923" data-uri="chapter07.xhtml#P7000497027000000000000000044923" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044924" data-uri="chapter07.xhtml#P7000497027000000000000000044924" class="calibre3 pcalibre1 pcalibre2">
1	/* bar3.c */
2	int x;
3
4	void f()
5	{
6		x = 15212;
7	}</code></pre>
<p id="P7000497027000000000000000044925" data-uri="chapter07.xhtml#P7000497027000000000000000044925" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006194" title="682" data-uri="chapter07.xhtml#P7000497027000000000000000006194" epub:type="pagebreak"></span>At run time, function <code id="P7000497027000000000000000044926" data-uri="chapter07.xhtml#P7000497027000000000000000044926" class="pcalibre1 calibre1 pcalibre2">f</code> changes the value of <code id="P7000497027000000000000000044927" data-uri="chapter07.xhtml#P7000497027000000000000000044927" class="pcalibre1 calibre1 pcalibre2">x</code> from 15213 to 15212, which might come as an unwelcome surprise to the author of function <code id="P7000497027000000000000000044928" data-uri="chapter07.xhtml#P7000497027000000000000000044928" class="pcalibre1 calibre1 pcalibre2">main</code>! Notice that the linker normally gives no indication that it has detected multiple definitions of <code id="P7000497027000000000000000044929" data-uri="chapter07.xhtml#P7000497027000000000000000044929" class="pcalibre1 calibre1 pcalibre2">x</code>:</p>
<pre id="P700049702700000000000000004492A" data-uri="chapter07.xhtml#P700049702700000000000000004492A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004492B" data-uri="chapter07.xhtml#P700049702700000000000000004492B" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -o foobar3 foo3.c bar3.c</i>
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1"> ./foobar3</i>
x = 15212</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004492C" data-uri="chapter07.xhtml#P700049702700000000000000004492C">The same thing can happen if there are two weak definitions of <code id="P700049702700000000000000004492D" data-uri="chapter07.xhtml#P700049702700000000000000004492D" class="pcalibre1 calibre1 pcalibre2">x</code> (rule 3):</p>
<pre id="P700049702700000000000000004492E" data-uri="chapter07.xhtml#P700049702700000000000000004492E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004492F" data-uri="chapter07.xhtml#P700049702700000000000000004492F" class="calibre3 pcalibre1 pcalibre2">
1	/* foo4.c */
2	#include &lt;stdio.h&gt;
3	void f(void);
4
5	int x;
6
7	int main()
8	{
9		x = 15213;
10		f();
11		printf(″x = %dn″, x);
12		return 0;
13	}
</code></pre>
<pre id="P7000497027000000000000000044930" data-uri="chapter07.xhtml#P7000497027000000000000000044930" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044931" data-uri="chapter07.xhtml#P7000497027000000000000000044931" class="calibre3 pcalibre1 pcalibre2">
1	/* bar4.c */
2	int x;
3
4	void f()
5	{
6		x = 15212;
7	}</code></pre>
<p id="P7000497027000000000000000044932" data-uri="chapter07.xhtml#P7000497027000000000000000044932" class="pcalibre8 pcalibre1 pcalibre2">The application of rules 2 and 3 can introduce some insidious run-time bugs that are incomprehensible to the unwary programmer, especially if the duplicate symbol definitions have different types. Consider the following example, in which <code id="P7000497027000000000000000044933" data-uri="chapter07.xhtml#P7000497027000000000000000044933" class="pcalibre1 calibre1 pcalibre2">x</code> is inadvertently defined as an <code id="P7000497027000000000000000044934" data-uri="chapter07.xhtml#P7000497027000000000000000044934" class="pcalibre1 calibre1 pcalibre2">int</code> in one module and a double in another:</p>
<pre id="P7000497027000000000000000044935" data-uri="chapter07.xhtml#P7000497027000000000000000044935" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044936" data-uri="chapter07.xhtml#P7000497027000000000000000044936" class="calibre3 pcalibre1 pcalibre2">
1	/* foo5.c */
2	#include &lt;stdio.h&gt;
3	void f(void);
4
5	int y = 15212;
6	int x = 15213;
7
8	int main()
9	{
10		f();
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000061A6" title="683" data-uri="chapter07.xhtml#P70004970270000000000000000061A6" epub:type="pagebreak"></span>11		printf(″x = 0x%x y = 0x%x n″,
12			x, y);
13		return 0;
14	}
</code></pre>
<pre id="P7000497027000000000000000044937" data-uri="chapter07.xhtml#P7000497027000000000000000044937" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044938" data-uri="chapter07.xhtml#P7000497027000000000000000044938" class="calibre3 pcalibre1 pcalibre2">
1	/* bar5.c */
2	double x;
3
4	void f()
5	{
6		x = -0.0;
7	}</code></pre>
<p id="P7000497027000000000000000044939" data-uri="chapter07.xhtml#P7000497027000000000000000044939" class="pcalibre8 pcalibre1 pcalibre2">On an x86-64/Linux machine, <code id="P700049702700000000000000004493A" data-uri="chapter07.xhtml#P700049702700000000000000004493A" class="pcalibre1 calibre1 pcalibre2">doubles</code> are 8 bytes and <code id="P700049702700000000000000004493B" data-uri="chapter07.xhtml#P700049702700000000000000004493B" class="pcalibre1 calibre1 pcalibre2">ints</code> are 4 bytes. On our system, the address of <code id="P700049702700000000000000004493C" data-uri="chapter07.xhtml#P700049702700000000000000004493C" class="pcalibre1 calibre1 pcalibre2">x</code> is <code id="P700049702700000000000000004493D" data-uri="chapter07.xhtml#P700049702700000000000000004493D" class="pcalibre1 calibre1 pcalibre2">0x601020</code> and the address of <code id="P700049702700000000000000004493E" data-uri="chapter07.xhtml#P700049702700000000000000004493E" class="pcalibre1 calibre1 pcalibre2">y</code> is <code id="P700049702700000000000000004493F" data-uri="chapter07.xhtml#P700049702700000000000000004493F" class="pcalibre1 calibre1 pcalibre2">0x601024</code>. Thus, the assignment <code id="P7000497027000000000000000044940" data-uri="chapter07.xhtml#P7000497027000000000000000044940" class="pcalibre1 calibre1 pcalibre2">x</code> = <code id="P7000497027000000000000000044941" data-uri="chapter07.xhtml#P7000497027000000000000000044941" class="pcalibre1 calibre1 pcalibre2">-0.0</code> in line 6 of <code id="P7000497027000000000000000044942" data-uri="chapter07.xhtml#P7000497027000000000000000044942" class="pcalibre1 calibre1 pcalibre2">bar5.c</code> will overwrite the memory locations for <code id="P7000497027000000000000000044943" data-uri="chapter07.xhtml#P7000497027000000000000000044943" class="pcalibre1 calibre1 pcalibre2">x</code> and <code id="P7000497027000000000000000044944" data-uri="chapter07.xhtml#P7000497027000000000000000044944" class="pcalibre1 calibre1 pcalibre2">y</code> (lines 5 and 6 in <code id="P7000497027000000000000000044945" data-uri="chapter07.xhtml#P7000497027000000000000000044945" class="pcalibre1 calibre1 pcalibre2">foo5.c</code>) with the double-precision floating-point representation of negative zero!</p>
<pre id="P7000497027000000000000000044946" data-uri="chapter07.xhtml#P7000497027000000000000000044946" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044947" data-uri="chapter07.xhtml#P7000497027000000000000000044947" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -Wall -0g -o foobar5 foo5.c bar5.c</i>
/usr/bin/ld: Warning: alignment 4 of symbol `x' in /tmp/cclUFK5g.o
is smaller than 8 in /tmp/ccbTLcb9.o
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./foobar5</i>
x = 0x0 y = 0x80000000</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000044948" data-uri="chapter07.xhtml#P7000497027000000000000000044948">This is a subtle and nasty bug, especially because it triggers only a warning from the linker, and because it typically manifests itself much later in the execution of the program, far away from where the error occurred. In a large system with hundreds of modules, a bug of this kind is extremely hard to fix, especially because many programmers are not aware of how linkers work, and because they often ignore compiler warnings. When in doubt, invoke the linker with a flag such as the <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span><code id="P7000497027000000000000000044949" data-uri="chapter07.xhtml#P7000497027000000000000000044949" class="pcalibre1 calibre1 pcalibre2">-fno-common</code> flag, which triggers an error if it encounters multiply-defined global symbols. Or use the <code id="P700049702700000000000000004494A" data-uri="chapter07.xhtml#P700049702700000000000000004494A" class="pcalibre1 calibre1 pcalibre2">-Werror</code> option, which turns all warnings into errors.</p>
<p id="P700049702700000000000000004494B" data-uri="chapter07.xhtml#P700049702700000000000000004494B" class="pcalibre8 pcalibre1 pcalibre2">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000608B.xhtml#P700049702700000000000000000608B"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">7.5</span></a>, we saw how the compiler assigns symbols to COMMON and <code id="P700049702700000000000000004494C" data-uri="chapter07.xhtml#P700049702700000000000000004494C" class="pcalibre1 calibre1 pcalibre2">.bss</code> using a seemingly arbitrary convention. Actually, this convention is due to the fact that in some cases the linker allows multiple modules to define global symbols with the same name. When the compiler is translating some module and encounters a weak global symbol, say, <code id="P700049702700000000000000004494D" data-uri="chapter07.xhtml#P700049702700000000000000004494D" class="pcalibre1 calibre1 pcalibre2">x</code>, it does not know if other modules also define <code id="P700049702700000000000000004494E" data-uri="chapter07.xhtml#P700049702700000000000000004494E" class="pcalibre1 calibre1 pcalibre2">x</code>, and if so, it cannot predict which of the multiple instances of <code id="P700049702700000000000000004494F" data-uri="chapter07.xhtml#P700049702700000000000000004494F" class="pcalibre1 calibre1 pcalibre2">x</code> the linker might choose. So the compiler defers the decision to the linker by assigning <code id="P7000497027000000000000000044950" data-uri="chapter07.xhtml#P7000497027000000000000000044950" class="pcalibre1 calibre1 pcalibre2">x</code> to COMMON. On the other hand, if <code id="P7000497027000000000000000044951" data-uri="chapter07.xhtml#P7000497027000000000000000044951" class="pcalibre1 calibre1 pcalibre2">x</code> is initialized to zero, then it is a strong symbol (and thus must be unique by rule 2), so the compiler can confidently assign it to <code id="P7000497027000000000000000044952" data-uri="chapter07.xhtml#P7000497027000000000000000044952" class="pcalibre1 calibre1 pcalibre2">.bss</code>. Similarly, static symbols are unique by construction, so the compiler can confidently assign them to either <code id="P7000497027000000000000000044953" data-uri="chapter07.xhtml#P7000497027000000000000000044953" class="pcalibre1 calibre1 pcalibre2">.data</code> or <code id="P7000497027000000000000000044954" data-uri="chapter07.xhtml#P7000497027000000000000000044954" class="pcalibre1 calibre1 pcalibre2">.bss</code>.</p>
<section id="P70004970270000000000000000061C5" data-uri="chapter07.xhtml#P70004970270000000000000000061C5" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000044955" data-uri="chapter07.xhtml#P7000497027000000000000000044955" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000061C7" title="684" data-uri="chapter07.xhtml#P70004970270000000000000000061C7" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">7.2 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000065E7.xhtml#P70004970270000000000000000065EF">718</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000044956" data-uri="chapter07.xhtml#P7000497027000000000000000044956">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000044957" data-uri="chapter07.xhtml#P7000497027000000000000000044957">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000044958" data-uri="chapter07.xhtml#P7000497027000000000000000044958"><p id="P7000497027000000000000000044959" data-uri="chapter07.xhtml#P7000497027000000000000000044959" class="pcalibre1 pcalibre2 pcalibre10">In this problem, let <code id="P700049702700000000000000004495A" data-uri="chapter07.xhtml#P700049702700000000000000004495A" class="pcalibre1 calibre1 pcalibre2">REF(x.i) → DEF(x.k)</code> denote that the linker will associate an arbitrary reference to symbol <code id="P700049702700000000000000004495B" data-uri="chapter07.xhtml#P700049702700000000000000004495B" class="pcalibre1 calibre1 pcalibre2">x</code> in module <code id="P700049702700000000000000004495C" data-uri="chapter07.xhtml#P700049702700000000000000004495C" class="pcalibre1 calibre1 pcalibre2">i</code> to the definition of <code id="P700049702700000000000000004495D" data-uri="chapter07.xhtml#P700049702700000000000000004495D" class="pcalibre1 calibre1 pcalibre2">x</code> in module <code id="P700049702700000000000000004495E" data-uri="chapter07.xhtml#P700049702700000000000000004495E" class="pcalibre1 calibre1 pcalibre2">k</code>. For each example that follows, use this notation to indicate how the linker would resolve references to the multiply-defined symbol in each module. If there is a link-time error (rule 1), write "<span class="pcalibre1 pcalibre29 pcalibre2">error</span>". If the linker arbitrarily chooses one of the definitions (rule 3), write "<span class="pcalibre1 pcalibre29 pcalibre2">unknown</span>".</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P700049702700000000000000004495F" data-uri="chapter07.xhtml#P700049702700000000000000004495F">
<li id="P7000497027000000000000000044960" data-uri="chapter07.xhtml#P7000497027000000000000000044960" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044961" data-uri="chapter07.xhtml#P7000497027000000000000000044961" class="pcalibre1 pcalibre2 pcalibre10"></p>
<pre id="P7000497027000000000000000044962" data-uri="chapter07.xhtml#P7000497027000000000000000044962" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044963" data-uri="chapter07.xhtml#P7000497027000000000000000044963" class="calibre3 pcalibre1 pcalibre2">/* Module 1 */		/* Module 2 */
int main()		int main;
{			int p2()
}			{
			}
(a) REF(main.1) → DEF(_____._____)
(b) REF(main.2) → DEF(_____._____)</code></pre></li>
<li id="P7000497027000000000000000044964" data-uri="chapter07.xhtml#P7000497027000000000000000044964" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044965" data-uri="chapter07.xhtml#P7000497027000000000000000044965" class="pcalibre1 pcalibre2 pcalibre10"></p>
<pre id="P7000497027000000000000000044966" data-uri="chapter07.xhtml#P7000497027000000000000000044966" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044967" data-uri="chapter07.xhtml#P7000497027000000000000000044967" class="calibre3 pcalibre1 pcalibre2">/* Module 1 */		/* Module 2 */
void main()		int main = 1;
{			int p2()
}			{
			}
(a) REF(main.1) → DEF(_____._____)
(b) REF(main.2) → DEF(_____._____)</code></pre></li>
<li id="P7000497027000000000000000044968" data-uri="chapter07.xhtml#P7000497027000000000000000044968" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044969" data-uri="chapter07.xhtml#P7000497027000000000000000044969" class="pcalibre1 pcalibre2 pcalibre10"></p>
<pre id="P700049702700000000000000004496A" data-uri="chapter07.xhtml#P700049702700000000000000004496A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004496B" data-uri="chapter07.xhtml#P700049702700000000000000004496B" class="calibre3 pcalibre1 pcalibre2">/* Module 1 */		/* Module 2 */
intx;			doublex=1.0;
void main()		int p2()
{			{
}			}
(a) REF(x.1) → DEF(_____._____)
(b) REF(x.2) → DEF(_____._____)</code></pre>
</li></ol></div></li>
</ol>
</section>
</section>
<section id="P70004970270000000000000000061DE" data-uri="chapter07.xhtml#P70004970270000000000000000061DE" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004496C" data-uri="chapter07.xhtml#P700049702700000000000000004496C" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">7.6.2 </span>Linking with Static Libraries</h1></header>
<p id="P700049702700000000000000004496D" data-uri="chapter07.xhtml#P700049702700000000000000004496D" class="pcalibre8 pcalibre1 pcalibre2">So far, we have assumed that the linker reads a collection of relocatable object files and links them together into an output executable file. In practice, all compilation systems provide a mechanism for packaging related object modules into a single file called a <i class="pcalibre17 pcalibre2 pcalibre1">static library</i>, which can then be supplied as input to the linker. When it builds the output executable, the linker copies only the object modules in the library that are referenced by the application program.</p>
<p id="P700049702700000000000000004496E" data-uri="chapter07.xhtml#P700049702700000000000000004496E" class="pcalibre8 pcalibre1 pcalibre2">Why do systems support the notion of libraries? Consider ISO C99, which defines an extensive collection of standard I/O, string manipulation, and integer math functions such as <code id="P700049702700000000000000004496F" data-uri="chapter07.xhtml#P700049702700000000000000004496F" class="pcalibre1 calibre1 pcalibre2">atoi, printf, scanf, strcpy</code>, and <code id="P7000497027000000000000000044970" data-uri="chapter07.xhtml#P7000497027000000000000000044970" class="pcalibre1 calibre1 pcalibre2">rand</code>. They are available <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000061E4" title="685" data-uri="chapter07.xhtml#P70004970270000000000000000061E4" epub:type="pagebreak"></span>to every C program in the <code id="P7000497027000000000000000044971" data-uri="chapter07.xhtml#P7000497027000000000000000044971" class="pcalibre1 calibre1 pcalibre2">libc.a</code> library. ISO C99 also defines an extensive collection of floating-point math functions such as <code id="P7000497027000000000000000044972" data-uri="chapter07.xhtml#P7000497027000000000000000044972" class="pcalibre1 calibre1 pcalibre2">sin, cos</code>, and <code id="P7000497027000000000000000044973" data-uri="chapter07.xhtml#P7000497027000000000000000044973" class="pcalibre1 calibre1 pcalibre2">sqrt</code> in the <code id="P7000497027000000000000000044974" data-uri="chapter07.xhtml#P7000497027000000000000000044974" class="pcalibre1 calibre1 pcalibre2">libm.a</code> library.</p>
<p id="P7000497027000000000000000044975" data-uri="chapter07.xhtml#P7000497027000000000000000044975" class="pcalibre8 pcalibre1 pcalibre2">Consider the different approaches that compiler developers might use to provide these functions to users without the benefit of static libraries. One approach would be to have the compiler recognize calls to the standard functions and to generate the appropriate code directly. Pascal, which provides a small set of standard functions, takes this approach, but it is not feasible for C, because of the large number of standard functions defined by the C standard. It would add significant complexity to the compiler and would require a new compiler version each time a function was added, deleted, or modified. To application programmers, however, this approach would be quite convenient because the standard functions would always be available.</p>
<p id="P7000497027000000000000000044976" data-uri="chapter07.xhtml#P7000497027000000000000000044976" class="pcalibre8 pcalibre1 pcalibre2">Another approach would be to put all of the standard C functions in a single relocatable object module, say, <code id="P7000497027000000000000000044977" data-uri="chapter07.xhtml#P7000497027000000000000000044977" class="pcalibre1 calibre1 pcalibre2">libc.o</code>, that application programmers could link into their executables:</p>
<pre id="P7000497027000000000000000044978" data-uri="chapter07.xhtml#P7000497027000000000000000044978" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044979" data-uri="chapter07.xhtml#P7000497027000000000000000044979" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc main.c /usr/lib/libc.o</i></code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004497A" data-uri="chapter07.xhtml#P700049702700000000000000004497A">This approach has the advantage that it would decouple the implementation of the standard functions from the implementation of the compiler, and would still be reasonably convenient for programmers. However, a big disadvantage is that every executable file in a system would now contain a complete copy of the collection of standard functions, which would be extremely wasteful of disk space. (On our system, <code id="P700049702700000000000000004497B" data-uri="chapter07.xhtml#P700049702700000000000000004497B" class="pcalibre1 calibre1 pcalibre2">libc.a</code> is about 5 MB and <code id="P700049702700000000000000004497C" data-uri="chapter07.xhtml#P700049702700000000000000004497C" class="pcalibre1 calibre1 pcalibre2">libm.a</code> is about 2 MB.) Worse, each running program would now contain its own copy of these functions in memory, which would be extremely wasteful of memory. Another big disadvantage is that any change to any standard function, no matter how small, would require the library developer to recompile the entire source file, a time-consuming operation that would complicate the development and maintenance of the standard functions.</p>
<p id="P700049702700000000000000004497D" data-uri="chapter07.xhtml#P700049702700000000000000004497D" class="pcalibre8 pcalibre1 pcalibre2">We could address some of these problems by creating a separate relocatable file for each standard function and storing them in a well-known directory. However, this approach would require application programmers to explicitly link the appropriate object modules into their executables, a process that would be error prone and time consuming:</p>
<pre id="P700049702700000000000000004497E" data-uri="chapter07.xhtml#P700049702700000000000000004497E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004497F" data-uri="chapter07.xhtml#P700049702700000000000000004497F" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc main.c /usr/lib/printf.o /usr/lib/scanf.o . . .</i></code></pre>
<p id="P7000497027000000000000000044980" data-uri="chapter07.xhtml#P7000497027000000000000000044980" class="pcalibre8 pcalibre1 pcalibre2">The notion of a static library was developed to resolve the disadvantages of these various approaches. Related functions can be compiled into separate object modules and then packaged in a single static library file. Application programs can then use any of the functions defined in the library by specifying a single filename on the command line. For example, a program that uses functions from the C standard library and the math library could be compiled and linked with a command of the form</p>
<pre id="P7000497027000000000000000044981" data-uri="chapter07.xhtml#P7000497027000000000000000044981" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044982" data-uri="chapter07.xhtml#P7000497027000000000000000044982" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc main.c /usr/lib/libm.a /usr/lib/libc.a</i></code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000061F7" data-uri="chapter07.xhtml#P70004970270000000000000000061F7">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000061F8" title="686" data-uri="chapter07.xhtml#P70004970270000000000000000061F8" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000044983" data-uri="chapter07.xhtml#P7000497027000000000000000044983" class="pcalibre8 pcalibre1 pcalibre2">(a) <code id="P7000497027000000000000000044984" data-uri="chapter07.xhtml#P7000497027000000000000000044984" class="pcalibre1 calibre1 pcalibre2">addvec.o</code></p>
<p id="P7000497027000000000000000044985" data-uri="chapter07.xhtml#P7000497027000000000000000044985" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/link/addvec.c</i></p>
<pre id="P7000497027000000000000000044986" data-uri="chapter07.xhtml#P7000497027000000000000000044986" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044987" data-uri="chapter07.xhtml#P7000497027000000000000000044987" class="calibre3 pcalibre1 pcalibre2">
1	int addcnt = 0; 2
3	void addvec(int *x, int *y,
4				int *z, int n)
5	{
6		int i;
7
8		addcnt++;
9
10		for (i = 0; i &lt; n; i++)
11			z[i] = x[i] + y[i];
12	}
</code></pre>
<p id="P7000497027000000000000000044988" data-uri="chapter07.xhtml#P7000497027000000000000000044988" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/link/addvec.c</i></p>
<p id="P7000497027000000000000000044989" data-uri="chapter07.xhtml#P7000497027000000000000000044989" class="pcalibre8 pcalibre1 pcalibre2">(b) <code id="P700049702700000000000000004498A" data-uri="chapter07.xhtml#P700049702700000000000000004498A" class="pcalibre1 calibre1 pcalibre2">multvec.o</code></p>
<p id="P700049702700000000000000004498B" data-uri="chapter07.xhtml#P700049702700000000000000004498B" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/link/multvec.c</i></p>
<pre id="P700049702700000000000000004498C" data-uri="chapter07.xhtml#P700049702700000000000000004498C" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004498D" data-uri="chapter07.xhtml#P700049702700000000000000004498D" class="calibre3 pcalibre1 pcalibre2">
1	int multcnt = 0;
2
3	void multvec(int *x, int *y,
4			int *z, int n)
5	{
6		int i;
7
8		multcnt++;
9
10		for (i = 0; i &lt; n; i++)
11			z[i] = x[i] * y[i];
12	}
</code></pre>
<p id="P700049702700000000000000004498E" data-uri="chapter07.xhtml#P700049702700000000000000004498E" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/link/multvec.c</i></p>
<figcaption id="P700049702700000000000000004498F" data-uri="chapter07.xhtml#P700049702700000000000000004498F" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000044990" data-uri="chapter07.xhtml#P7000497027000000000000000044990" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">7.6 </span>Member object files in the <code id="P7000497027000000000000000044991" data-uri="chapter07.xhtml#P7000497027000000000000000044991" class="pcalibre1 calibre1 pcalibre2">libvector</code> library.</h1></header>
</figcaption>
</figure>
<p id="P7000497027000000000000000044992" data-uri="chapter07.xhtml#P7000497027000000000000000044992" class="pcalibre8 pcalibre1 pcalibre2">At link time, the linker will only copy the object modules that are referenced by the program, which reduces the size of the executable on disk and in memory. On the other hand, the application programmer only needs to include the names of a few library files. (In fact, C compiler drivers always pass <code id="P7000497027000000000000000044993" data-uri="chapter07.xhtml#P7000497027000000000000000044993" class="pcalibre1 calibre1 pcalibre2">libc.a</code> to the linker, so the reference to <code id="P7000497027000000000000000044994" data-uri="chapter07.xhtml#P7000497027000000000000000044994" class="pcalibre1 calibre1 pcalibre2">libc.a</code> mentioned previously is unnecessary.)</p>
<p id="P7000497027000000000000000044995" data-uri="chapter07.xhtml#P7000497027000000000000000044995" class="pcalibre8 pcalibre1 pcalibre2">On Linux systems, static libraries are stored on disk in a particular file format known as an <i class="pcalibre17 pcalibre2 pcalibre1">archive</i>. An archive is a collection of concatenated relocatable object files, with a header that describes the size and location of each member object file. Archive filenames are denoted with the <code id="P7000497027000000000000000044996" data-uri="chapter07.xhtml#P7000497027000000000000000044996" class="pcalibre1 calibre1 pcalibre2">.a suffix.</code></p>
<p id="P7000497027000000000000000044997" data-uri="chapter07.xhtml#P7000497027000000000000000044997" class="pcalibre8 pcalibre1 pcalibre2">To make our discussion of libraries concrete, consider the pair of vector routines in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000061F7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">7.6</span></a>. Each routine, defined in its own object module, performs a vector operation on a pair of input vectors and stores the result in an output vector. As a side effect, each routine records the number of times it has been called by incrementing a global variable. (This will be useful when we explain the idea of position-independent code in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006428.xhtml#P7000497027000000000000000006428"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">7.12</span></a>.)</p>
<p id="P7000497027000000000000000044998" data-uri="chapter07.xhtml#P7000497027000000000000000044998" class="pcalibre8 pcalibre1 pcalibre2">To create a static library of these functions, we would use the <code id="P7000497027000000000000000044999" data-uri="chapter07.xhtml#P7000497027000000000000000044999" class="pcalibre1 calibre1 pcalibre2"><span class="pcalibre1 pcalibre29 pcalibre2">ar</span></code> tool as follows:</p>
<p id="P700049702700000000000000004499A" data-uri="chapter07.xhtml#P700049702700000000000000004499A" class="pcalibre8 pcalibre1 pcalibre2"><code id="P700049702700000000000000004499B" data-uri="chapter07.xhtml#P700049702700000000000000004499B" class="pcalibre1 calibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -c addvec.c multvec.c</i></code></p>
<p id="P700049702700000000000000004499C" data-uri="chapter07.xhtml#P700049702700000000000000004499C" class="pcalibre8 pcalibre1 pcalibre2"><code id="P700049702700000000000000004499D" data-uri="chapter07.xhtml#P700049702700000000000000004499D" class="pcalibre1 calibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">ar rcs libvector.a addvec.o multvec.o</i></code></p>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004499E" data-uri="chapter07.xhtml#P700049702700000000000000004499E">To use the library, we might write an application such as <code id="P700049702700000000000000004499F" data-uri="chapter07.xhtml#P700049702700000000000000004499F" class="pcalibre1 calibre1 pcalibre2">main2.c</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000621E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">7.7</span></a>, which invokes the <code id="P70004970270000000000000000449A0" data-uri="chapter07.xhtml#P70004970270000000000000000449A0" class="pcalibre1 calibre1 pcalibre2">addvec</code> library routine. The include (or header) file <code id="P70004970270000000000000000449A1" data-uri="chapter07.xhtml#P70004970270000000000000000449A1" class="pcalibre1 calibre1 pcalibre2">vector.h</code> defines the function prototypes for the routines in <code id="P70004970270000000000000000449A2" data-uri="chapter07.xhtml#P70004970270000000000000000449A2" class="pcalibre1 calibre1 pcalibre2">libvector.a</code>,</p>
<p id="P70004970270000000000000000449A3" data-uri="chapter07.xhtml#P70004970270000000000000000449A3" class="pcalibre8 pcalibre1 pcalibre2">To build the executable, we would compile and link the input files <code id="P70004970270000000000000000449A4" data-uri="chapter07.xhtml#P70004970270000000000000000449A4" class="pcalibre1 calibre1 pcalibre2">main2.o</code> and <code id="P70004970270000000000000000449A5" data-uri="chapter07.xhtml#P70004970270000000000000000449A5" class="pcalibre1 calibre1 pcalibre2">libvector.a</code>:</p>
<pre id="P70004970270000000000000000449A6" data-uri="chapter07.xhtml#P70004970270000000000000000449A6" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000449A7" data-uri="chapter07.xhtml#P70004970270000000000000000449A7" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -c main2.c</i>
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -static -o prog2c main2.o . /libvector.a</i></code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000621E" data-uri="chapter07.xhtml#P700049702700000000000000000621E">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000621F" title="687" data-uri="chapter07.xhtml#P700049702700000000000000000621F" epub:type="pagebreak"></span>
<p id="P70004970270000000000000000449A8" data-uri="chapter07.xhtml#P70004970270000000000000000449A8" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/link/main2.c</i></p>
<pre id="P70004970270000000000000000449A9" data-uri="chapter07.xhtml#P70004970270000000000000000449A9" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000449AA" data-uri="chapter07.xhtml#P70004970270000000000000000449AA" class="calibre3 pcalibre1 pcalibre2">
1	#include &lt;stdio.h&gt;
2	#include "vector.h"
3
4	int x[2] = {1, 2};
5	int y[2] = {3, 4};
6	int z[2];
7
8	int main()
9	{
10		addvec(x, y, z, 2);
11		printf("z = [%d %d] n", z[0], z[1]);
12		return 0;
13	}
</code></pre>
<p id="P70004970270000000000000000449AB" data-uri="chapter07.xhtml#P70004970270000000000000000449AB" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/link/main2.c</i></p>
<figcaption id="P70004970270000000000000000449AC" data-uri="chapter07.xhtml#P70004970270000000000000000449AC" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000449AD" data-uri="chapter07.xhtml#P70004970270000000000000000449AD" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">7.7 </span>Example program 2.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000449AE" data-uri="chapter07.xhtml#P70004970270000000000000000449AE"><p id="P70004970270000000000000000449AF" data-uri="chapter07.xhtml#P70004970270000000000000000449AF" class="pcalibre1 pcalibre2 pcalibre10">This program invokes a function in the <code id="P70004970270000000000000000449B0" data-uri="chapter07.xhtml#P70004970270000000000000000449B0" class="pcalibre1 calibre1 pcalibre2">libvector</code> library.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000006229" data-uri="chapter07.xhtml#P7000497027000000000000000006229">
<img alt="A diagram illustrates linking with static libraries." id="P70004970270000000000000000449B1" data-uri="P700049702700000000000000000B75A" src="../images/p687-1.png" class="pcalibre1 pcalibre2 pcalibre237"/>
<figcaption id="P70004970270000000000000000449B2" data-uri="chapter07.xhtml#P70004970270000000000000000449B2" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000449B3" data-uri="chapter07.xhtml#P70004970270000000000000000449B3" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">7.8 </span>Linking with static libraries.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000024CC5" data-uri="chapter07.xhtml#P7000497027000000000000000024CC5">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000449B4" data-uri="chapter07.xhtml#P70004970270000000000000000449B4" class="pcalibre8 pcalibre1 pcalibre2">A diagram shows a flow of files, as listed in order below.</p>
<ul id="P70004970270000000000000000449B5" data-uri="chapter07.xhtml#P70004970270000000000000000449B5" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000449B6" data-uri="chapter07.xhtml#P70004970270000000000000000449B6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449B7" data-uri="chapter07.xhtml#P70004970270000000000000000449B7" class="pcalibre1 pcalibre2 pcalibre10">Source files: main2.c and vector.h</p></li>
<li id="P70004970270000000000000000449B8" data-uri="chapter07.xhtml#P70004970270000000000000000449B8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449B9" data-uri="chapter07.xhtml#P70004970270000000000000000449B9" class="pcalibre1 pcalibre2 pcalibre10">Translators (cpp, cc1, as)</p></li>
<li id="P70004970270000000000000000449BA" data-uri="chapter07.xhtml#P70004970270000000000000000449BA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449BB" data-uri="chapter07.xhtml#P70004970270000000000000000449BB" class="pcalibre1 pcalibre2 pcalibre10">Three relocatable object files:</p>
<ul id="P70004970270000000000000000449BC" data-uri="chapter07.xhtml#P70004970270000000000000000449BC" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P70004970270000000000000000449BD" data-uri="chapter07.xhtml#P70004970270000000000000000449BD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449BE" data-uri="chapter07.xhtml#P70004970270000000000000000449BE" class="pcalibre1 pcalibre2 pcalibre10">Main2.o from translators</p></li>
<li id="P70004970270000000000000000449BF" data-uri="chapter07.xhtml#P70004970270000000000000000449BF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449C0" data-uri="chapter07.xhtml#P70004970270000000000000000449C0" class="pcalibre1 pcalibre2 pcalibre10">Addvec.o from libvector.a</p></li>
<li id="P70004970270000000000000000449C1" data-uri="chapter07.xhtml#P70004970270000000000000000449C1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449C2" data-uri="chapter07.xhtml#P70004970270000000000000000449C2" class="pcalibre1 pcalibre2 pcalibre10">Printf.o and any other modules called by printf.o from libc.a Static libraries</p></li>
</ul></li>
<li id="P70004970270000000000000000449C3" data-uri="chapter07.xhtml#P70004970270000000000000000449C3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449C4" data-uri="chapter07.xhtml#P70004970270000000000000000449C4" class="pcalibre1 pcalibre2 pcalibre10">Linter (ld)</p></li>
<li id="P70004970270000000000000000449C5" data-uri="chapter07.xhtml#P70004970270000000000000000449C5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449C6" data-uri="chapter07.xhtml#P70004970270000000000000000449C6" class="pcalibre1 pcalibre2 pcalibre10">Fully linked executable object file prog2c</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000449C7" data-uri="chapter07.xhtml#P70004970270000000000000000449C7">or equivalently,</p>
<pre id="P70004970270000000000000000449C8" data-uri="chapter07.xhtml#P70004970270000000000000000449C8" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000449C9" data-uri="chapter07.xhtml#P70004970270000000000000000449C9" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -c main2.c</i>
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -static -o prog2c main2.o -L. -lvector</i></code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000449CA" data-uri="chapter07.xhtml#P70004970270000000000000000449CA"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006229"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">7.8</span></a> summarizes the activity of the linker. The <code id="P70004970270000000000000000449CB" data-uri="chapter07.xhtml#P70004970270000000000000000449CB" class="pcalibre1 calibre1 pcalibre2">-static</code> argument tells the compiler driver that the linker should build a fully linked executable object file that can be loaded into memory and run without any further linking at load time. The <code id="P70004970270000000000000000449CC" data-uri="chapter07.xhtml#P70004970270000000000000000449CC" class="pcalibre1 calibre1 pcalibre2">-lvector</code> argument is a shorthand for <code id="P70004970270000000000000000449CD" data-uri="chapter07.xhtml#P70004970270000000000000000449CD" class="pcalibre1 calibre1 pcalibre2">libvector.a</code>, and the <code id="P70004970270000000000000000449CE" data-uri="chapter07.xhtml#P70004970270000000000000000449CE" class="pcalibre1 calibre1 pcalibre2">-L</code>. argument tells the linker to look for <code id="P70004970270000000000000000449CF" data-uri="chapter07.xhtml#P70004970270000000000000000449CF" class="pcalibre1 calibre1 pcalibre2">libvector.a</code> in the current directory.</p>
<p id="P70004970270000000000000000449D0" data-uri="chapter07.xhtml#P70004970270000000000000000449D0" class="pcalibre8 pcalibre1 pcalibre2">When the linker runs, it determines that the <code id="P70004970270000000000000000449D1" data-uri="chapter07.xhtml#P70004970270000000000000000449D1" class="pcalibre1 calibre1 pcalibre2">addvec</code> symbol defined by <code id="P70004970270000000000000000449D2" data-uri="chapter07.xhtml#P70004970270000000000000000449D2" class="pcalibre1 calibre1 pcalibre2">addvec.o</code> is referenced by <code id="P70004970270000000000000000449D3" data-uri="chapter07.xhtml#P70004970270000000000000000449D3" class="pcalibre1 calibre1 pcalibre2">main2.o</code>, so it copies <code id="P70004970270000000000000000449D4" data-uri="chapter07.xhtml#P70004970270000000000000000449D4" class="pcalibre1 calibre1 pcalibre2">addvec.o</code> into the executable. <span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000623B" title="688" data-uri="chapter07.xhtml#P700049702700000000000000000623B" epub:type="pagebreak"></span>Since the program doesn't reference any symbols defined by <code id="P70004970270000000000000000449D5" data-uri="chapter07.xhtml#P70004970270000000000000000449D5" class="pcalibre1 calibre1 pcalibre2">multvec.o</code>, the linker does <i class="pcalibre17 pcalibre2 pcalibre1">not</i> copy this module into the executable. The linker also copies the <code id="P70004970270000000000000000449D6" data-uri="chapter07.xhtml#P70004970270000000000000000449D6" class="pcalibre1 calibre1 pcalibre2">printf.o</code> module from <code id="P70004970270000000000000000449D7" data-uri="chapter07.xhtml#P70004970270000000000000000449D7" class="pcalibre1 calibre1 pcalibre2">libc.a</code>, along with a number of other modules from the C run-time system.</p>
</section>
<section id="P700049702700000000000000000623F" data-uri="chapter07.xhtml#P700049702700000000000000000623F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000449D8" data-uri="chapter07.xhtml#P70004970270000000000000000449D8" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">7.6.3 </span>How Linkers Use Static Libraries to Resolve References</h1></header>
<p id="P70004970270000000000000000449D9" data-uri="chapter07.xhtml#P70004970270000000000000000449D9" class="pcalibre8 pcalibre1 pcalibre2">While static libraries are useful, they are also a source of confusion to programmers because of the way the Linux linker uses them to resolve external references. During the symbol resolution phase, the linker scans the relocatable object files and archives left to right in the same sequential order that they appear on the compiler driver's command line. (The driver automatically translates any <code id="P70004970270000000000000000449DA" data-uri="chapter07.xhtml#P70004970270000000000000000449DA" class="pcalibre1 calibre1 pcalibre2">.c files</code> on the command line into <code id="P70004970270000000000000000449DB" data-uri="chapter07.xhtml#P70004970270000000000000000449DB" class="pcalibre1 calibre1 pcalibre2">.o files</code>.) During this scan, the linker maintains a set <var class="pcalibre17 pcalibre2 pcalibre1">E</var> of relocatable object files that will be merged to form the executable, a set <var class="pcalibre17 pcalibre2 pcalibre1">U</var> of unresolved symbols (i.e., symbols referred to but not yet defined), and a set <var class="pcalibre17 pcalibre2 pcalibre1">D</var> of symbols that have been defined in previous input files. Initially, <var class="pcalibre17 pcalibre2 pcalibre1">E</var>, <var class="pcalibre17 pcalibre2 pcalibre1">U</var>, and <var class="pcalibre17 pcalibre2 pcalibre1">D</var> are empty.</p>
<ul id="P70004970270000000000000000449DC" data-uri="chapter07.xhtml#P70004970270000000000000000449DC" class="pcalibre1 calibre9 pcalibre2">
<li id="P70004970270000000000000000449DD" data-uri="chapter07.xhtml#P70004970270000000000000000449DD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449DE" data-uri="chapter07.xhtml#P70004970270000000000000000449DE" class="pcalibre1 pcalibre2 pcalibre10">For each input file <var class="pcalibre17 pcalibre2 pcalibre1">f</var> on the command line, the linker determines if <var class="pcalibre17 pcalibre2 pcalibre1">f</var> is an object file or an archive. If <var class="pcalibre17 pcalibre2 pcalibre1">f</var> is an object file, the linker adds <var class="pcalibre17 pcalibre2 pcalibre1">f</var> to <var class="pcalibre17 pcalibre2 pcalibre1">E</var>, updates <var class="pcalibre17 pcalibre2 pcalibre1">U</var> and <var class="pcalibre17 pcalibre2 pcalibre1">D</var> to reflect the symbol definitions and references in <var class="pcalibre17 pcalibre2 pcalibre1">f</var>, and proceeds to the next input file.</p></li>
<li id="P70004970270000000000000000449DF" data-uri="chapter07.xhtml#P70004970270000000000000000449DF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449E0" data-uri="chapter07.xhtml#P70004970270000000000000000449E0" class="pcalibre1 pcalibre2 pcalibre10">If <var class="pcalibre17 pcalibre2 pcalibre1">f</var> is an archive, the linker attempts to match the unresolved symbols in <var class="pcalibre17 pcalibre2 pcalibre1">U</var> against the symbols defined by the members of the archive. If some archive member <var class="pcalibre17 pcalibre2 pcalibre1">m</var> defines a symbol that resolves a reference in <var class="pcalibre17 pcalibre2 pcalibre1">U</var>, then <var class="pcalibre17 pcalibre2 pcalibre1">m</var> is added to <var class="pcalibre17 pcalibre2 pcalibre1">E</var>, and the linker updates <var class="pcalibre17 pcalibre2 pcalibre1">U</var> and <var class="pcalibre17 pcalibre2 pcalibre1">D</var> to reflect the symbol definitions and references in <var class="pcalibre17 pcalibre2 pcalibre1">m</var>. This process iterates over the member object files in the archive until a fixed point is reached where <var class="pcalibre17 pcalibre2 pcalibre1">U</var> and <var class="pcalibre17 pcalibre2 pcalibre1">D</var> no longer change. At this point, any member object files not contained in <var class="pcalibre17 pcalibre2 pcalibre1">E</var> are simply discarded and the linker proceeds to the next input file.</p></li>
<li id="P70004970270000000000000000449E1" data-uri="chapter07.xhtml#P70004970270000000000000000449E1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000449E2" data-uri="chapter07.xhtml#P70004970270000000000000000449E2" class="pcalibre1 pcalibre2 pcalibre10">If <var class="pcalibre17 pcalibre2 pcalibre1">U</var> is nonempty when the linker finishes scanning the input files on the command line, it prints an error and terminates. Otherwise, it merges and relocates the object files in <var class="pcalibre17 pcalibre2 pcalibre1">E</var> to build the output executable file.</p></li>
</ul>
<p id="P70004970270000000000000000449E3" data-uri="chapter07.xhtml#P70004970270000000000000000449E3" class="pcalibre8 pcalibre1 pcalibre2">Unfortunately, this algorithm can result in some baffling link-time errors because the ordering of libraries and object files on the command line is significant. If the library that defines a symbol appears on the command line before the object file that references that symbol, then the reference will not be resolved and linking will fail. For example, consider the following:</p>
<pre id="P70004970270000000000000000449E4" data-uri="chapter07.xhtml#P70004970270000000000000000449E4" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000449E5" data-uri="chapter07.xhtml#P70004970270000000000000000449E5" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -static . /libvector.a main2.c</i>
/tmp/cc9XH6Rp.o: In function `main':
/tmp/cc9XH6Rp.o(.text+0x18): undefined reference to `addvec'</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000449E6" data-uri="chapter07.xhtml#P70004970270000000000000000449E6">What happened? When <code id="P70004970270000000000000000449E7" data-uri="chapter07.xhtml#P70004970270000000000000000449E7" class="pcalibre1 calibre1 pcalibre2">libvector.a</code> is processed, <var class="pcalibre17 pcalibre2 pcalibre1">U</var> is empty, so no member object files from <code id="P70004970270000000000000000449E8" data-uri="chapter07.xhtml#P70004970270000000000000000449E8" class="pcalibre1 calibre1 pcalibre2">libvector.a</code> are added to <var class="pcalibre17 pcalibre2 pcalibre1">E</var>. Thus, the reference to <code id="P70004970270000000000000000449E9" data-uri="chapter07.xhtml#P70004970270000000000000000449E9" class="pcalibre1 calibre1 pcalibre2">addvec</code> is never resolved and the linker emits an error message and terminates.</p>
<p id="P70004970270000000000000000449EA" data-uri="chapter07.xhtml#P70004970270000000000000000449EA" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006253" title="689" data-uri="chapter07.xhtml#P7000497027000000000000000006253" epub:type="pagebreak"></span>The general rule for libraries is to place them at the end of the command line. If the members of the different libraries are independent, in that no member references a symbol defined by another member, then the libraries can be placed at the end of the command line in any order. If, on the other hand, the libraries are not independent, then they must be ordered so that for each symbol <var class="pcalibre17 pcalibre2 pcalibre1">s</var> that is referenced externally by a member of an archive, at least one definition of <var class="pcalibre17 pcalibre2 pcalibre1">s</var> follows a reference to <var class="pcalibre17 pcalibre2 pcalibre1">s</var> on the command line. For example, suppose <code id="P70004970270000000000000000449EB" data-uri="chapter07.xhtml#P70004970270000000000000000449EB" class="pcalibre1 calibre1 pcalibre2">foo.c</code> calls functions in <code id="P70004970270000000000000000449EC" data-uri="chapter07.xhtml#P70004970270000000000000000449EC" class="pcalibre1 calibre1 pcalibre2">libx.a</code> and <code id="P70004970270000000000000000449ED" data-uri="chapter07.xhtml#P70004970270000000000000000449ED" class="pcalibre1 calibre1 pcalibre2">libz.a</code> that call functions in <code id="P70004970270000000000000000449EE" data-uri="chapter07.xhtml#P70004970270000000000000000449EE" class="pcalibre1 calibre1 pcalibre2">liby.a</code>. Then <code id="P70004970270000000000000000449EF" data-uri="chapter07.xhtml#P70004970270000000000000000449EF" class="pcalibre1 calibre1 pcalibre2">libx.a</code> and <code id="P70004970270000000000000000449F0" data-uri="chapter07.xhtml#P70004970270000000000000000449F0" class="pcalibre1 calibre1 pcalibre2">libz.a</code> must precede <code id="P70004970270000000000000000449F1" data-uri="chapter07.xhtml#P70004970270000000000000000449F1" class="pcalibre1 calibre1 pcalibre2">liby.a</code> on the command line:</p>
<pre id="P70004970270000000000000000449F2" data-uri="chapter07.xhtml#P70004970270000000000000000449F2" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000449F3" data-uri="chapter07.xhtml#P70004970270000000000000000449F3" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc foo.c libx.a libz.a liby.a</i></code></pre>
<p id="P70004970270000000000000000449F4" data-uri="chapter07.xhtml#P70004970270000000000000000449F4" class="pcalibre8 pcalibre1 pcalibre2">Libraries can be repeated on the command line if necessary to satisfy the dependence requirements. For example, suppose <code id="P70004970270000000000000000449F5" data-uri="chapter07.xhtml#P70004970270000000000000000449F5" class="pcalibre1 calibre1 pcalibre2">foo.c</code> calls a function in <code id="P70004970270000000000000000449F6" data-uri="chapter07.xhtml#P70004970270000000000000000449F6" class="pcalibre1 calibre1 pcalibre2">libx.a</code> that calls a function in <code id="P70004970270000000000000000449F7" data-uri="chapter07.xhtml#P70004970270000000000000000449F7" class="pcalibre1 calibre1 pcalibre2">liby.a</code> that calls a function in <code id="P70004970270000000000000000449F8" data-uri="chapter07.xhtml#P70004970270000000000000000449F8" class="pcalibre1 calibre1 pcalibre2">libx.a</code>. Then <code id="P70004970270000000000000000449F9" data-uri="chapter07.xhtml#P70004970270000000000000000449F9" class="pcalibre1 calibre1 pcalibre2">libx.a</code> must be repeated on the command line:</p>
<pre id="P70004970270000000000000000449FA" data-uri="chapter07.xhtml#P70004970270000000000000000449FA" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000449FB" data-uri="chapter07.xhtml#P70004970270000000000000000449FB" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc foo.c libx.a liby.a libx.a</i></code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000449FC" data-uri="chapter07.xhtml#P70004970270000000000000000449FC">Alternatively, we could combine <code id="P70004970270000000000000000449FD" data-uri="chapter07.xhtml#P70004970270000000000000000449FD" class="pcalibre1 calibre1 pcalibre2">libx.a</code> and <code id="P70004970270000000000000000449FE" data-uri="chapter07.xhtml#P70004970270000000000000000449FE" class="pcalibre1 calibre1 pcalibre2">liby.a</code> into a single archive.</p>
<section id="P7000497027000000000000000006268" data-uri="chapter07.xhtml#P7000497027000000000000000006268" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000449FF" data-uri="chapter07.xhtml#P70004970270000000000000000449FF" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">7.3 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000065E7.xhtml#P70004970270000000000000000065EF">718</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000044A00" data-uri="chapter07.xhtml#P7000497027000000000000000044A00">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000044A01" data-uri="chapter07.xhtml#P7000497027000000000000000044A01">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000044A02" data-uri="chapter07.xhtml#P7000497027000000000000000044A02"><p id="P7000497027000000000000000044A03" data-uri="chapter07.xhtml#P7000497027000000000000000044A03" class="pcalibre1 pcalibre2 pcalibre10">Let <code id="P7000497027000000000000000044A04" data-uri="chapter07.xhtml#P7000497027000000000000000044A04" class="pcalibre1 calibre1 pcalibre2">a</code> and <code id="P7000497027000000000000000044A05" data-uri="chapter07.xhtml#P7000497027000000000000000044A05" class="pcalibre1 calibre1 pcalibre2">b</code> denote object modules or static libraries in the current directory, and let <code id="P7000497027000000000000000044A06" data-uri="chapter07.xhtml#P7000497027000000000000000044A06" class="pcalibre1 calibre1 pcalibre2">a→b</code> denote that <var class="pcalibre17 pcalibre2 pcalibre1">a</var> depends on <var class="pcalibre17 pcalibre2 pcalibre1">b</var>, in the sense that <var class="pcalibre17 pcalibre2 pcalibre1">b</var> defines a symbol that is referenced by <var class="pcalibre17 pcalibre2 pcalibre1">a</var>. For each of the following scenarios, show the minimal command line (i.e., one with the least number of object file and library arguments) that will allow the static linker to resolve all symbol references.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000044A07" data-uri="chapter07.xhtml#P7000497027000000000000000044A07">
<li id="P7000497027000000000000000044A08" data-uri="chapter07.xhtml#P7000497027000000000000000044A08" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044A09" data-uri="chapter07.xhtml#P7000497027000000000000000044A09" class="pcalibre1 pcalibre2 pcalibre10"></p>
<pre id="P7000497027000000000000000044A0A" data-uri="chapter07.xhtml#P7000497027000000000000000044A0A" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044A0B" data-uri="chapter07.xhtml#P7000497027000000000000000044A0B" class="calibre3 pcalibre1 pcalibre2">p.o → libx.a</code></pre></li>
<li id="P7000497027000000000000000044A0C" data-uri="chapter07.xhtml#P7000497027000000000000000044A0C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044A0D" data-uri="chapter07.xhtml#P7000497027000000000000000044A0D" class="pcalibre1 pcalibre2 pcalibre10"></p>
<pre id="P7000497027000000000000000044A0E" data-uri="chapter07.xhtml#P7000497027000000000000000044A0E" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044A0F" data-uri="chapter07.xhtml#P7000497027000000000000000044A0F" class="calibre3 pcalibre1 pcalibre2">p.o → libx.a → liby.a</code></pre></li>
<li id="P7000497027000000000000000044A10" data-uri="chapter07.xhtml#P7000497027000000000000000044A10" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044A11" data-uri="chapter07.xhtml#P7000497027000000000000000044A11" class="pcalibre1 pcalibre2 pcalibre10"></p>
<pre id="P7000497027000000000000000044A12" data-uri="chapter07.xhtml#P7000497027000000000000000044A12" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000044A13" data-uri="chapter07.xhtml#P7000497027000000000000000044A13" class="calibre3 pcalibre1 pcalibre2">p.o → libx.a → liby.a <i class="pcalibre17 pcalibre2 pcalibre1">and</i> liby.a → libx.a → p.o</code></pre>
</li>
</ol></div>
</li></ol>
</section>
</section>
</section></body></html>
