<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>9.12 Summary </title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000007654" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000004614E" data-uri="chapter09.xhtml#P700049702700000000000000004614E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.12 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary </span></h1></header>
<p id="P700049702700000000000000004614F" data-uri="chapter09.xhtml#P700049702700000000000000004614F" class="pcalibre8 pcalibre1 pcalibre2">Virtual memory is an abstraction of main memory. Processors that support virtual memory reference main memory using a form of indirection known as virtual addressing. The processor generates a virtual address, which is translated into a physical address before being sent to the main memory. The translation of addresses from a virtual address space to a physical address space requires close cooperation between hardware and software. Dedicated hardware translates virtual addresses using page tables whose contents are supplied by the operating system.</p>
<p id="P7000497027000000000000000046150" data-uri="chapter09.xhtml#P7000497027000000000000000046150" class="pcalibre8 pcalibre1 pcalibre2">Virtual memory provides three important capabilities. First, it automatically caches recently used contents of the virtual address space stored on disk in main memory. The block in a virtual memory cache is known as a page. A reference to a page on disk triggers a page fault that transfers control to a fault handler in the operating system. The fault handler copies the page from disk to the main memory cache, writing back the evicted page if necessary. Second, virtual memory simplifies memory management, which in turn simplifies linking, sharing data between processes, the allocation of memory for processes, and program loading. Finally, virtual memory simplifies memory protection by incorporating protection bits into every page table entry.</p>
<p id="P7000497027000000000000000046151" data-uri="chapter09.xhtml#P7000497027000000000000000046151" class="pcalibre8 pcalibre1 pcalibre2">The process of address translation must be integrated with the operation of any hardware caches in the system. Most page table entries are located in the L1 cache, but the cost of accessing page table entries from L1 is usually eliminated by an on-chip cache of page table entries called a TLB.</p>
<p id="P7000497027000000000000000046152" data-uri="chapter09.xhtml#P7000497027000000000000000046152" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000765A" title="876" data-uri="chapter09.xhtml#P700049702700000000000000000765A" epub:type="pagebreak"></span>Modern systems initialize chunks of virtual memory by associating them with chunks of files on disk, a process known as memory mapping. Memory mapping provides an efficient mechanism for sharing data, creating new processes, and loading programs. Applications can manually create and delete areas of the virtual address space using the <code id="P7000497027000000000000000046153" data-uri="chapter09.xhtml#P7000497027000000000000000046153" class="pcalibre1 calibre1 pcalibre2">mmap</code> function. However, most programs rely on a dynamic memory allocator such as <code id="P7000497027000000000000000046154" data-uri="chapter09.xhtml#P7000497027000000000000000046154" class="pcalibre1 calibre1 pcalibre2">malloc</code>, which manages memory in an area of the virtual address space called the heap. Dynamic memory allocators are application-level programs with a system-level feel, directly manipulating memory without much help from the type system. Allocators come in two flavors. Explicit allocators require applications to explicitly free their memory blocks. Implicit allocators (garbage collectors) free any unused and unreachable blocks automatically.</p>
<p id="P7000497027000000000000000046155" data-uri="chapter09.xhtml#P7000497027000000000000000046155" class="pcalibre8 pcalibre1 pcalibre2">Managing and using memory is a difficult and error-prone task for C programmers. Examples of common errors include dereferencing bad pointers, reading uninitialized memory, allowing stack buffer overflows, assuming that pointers and the objects they point to are the same size, referencing a pointer instead of the object it points to, misunderstanding pointer arithmetic, referencing nonexistent variables, and introducing memory leaks.</p>
</section></body></html>
