<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>12.1 Concurrent Programming with Processes</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000008097" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000046B9E" data-uri="chapter12.xhtml#P7000497027000000000000000046B9E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.1 </span>Concurrent Programming with Processes</h1></header>
<p id="P7000497027000000000000000046B9F" data-uri="chapter12.xhtml#P7000497027000000000000000046B9F" class="pcalibre8 pcalibre1 pcalibre2">The simplest way to build a concurrent program is with processes, using familiar functions such as <code id="P7000497027000000000000000046BA0" data-uri="chapter12.xhtml#P7000497027000000000000000046BA0" class="pcalibre1 calibre1 pcalibre2">fork, exec</code>, and <code id="P7000497027000000000000000046BA1" data-uri="chapter12.xhtml#P7000497027000000000000000046BA1" class="pcalibre1 calibre1 pcalibre2">waitpid</code>. For example, a natural approach for building a concurrent server is to accept client connection requests in the parent and then create a new child process to service each new client.</p>
<p id="P7000497027000000000000000046BA2" data-uri="chapter12.xhtml#P7000497027000000000000000046BA2" class="pcalibre8 pcalibre1 pcalibre2">To see how this might work, suppose we have two clients and a server that is listening for connection requests on a listening descriptor (say, 3). Now suppose that the server accepts a connection request from client 1 and returns a connected descriptor (say, 4), as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000809E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.1</span></a>. After accepting the connection request, the server forks a child, which gets a complete copy of the server's descriptor table. The child closes its copy of listening descriptor 3, and the parent closes its copy of connected descriptor 4, since they are no longer needed. This gives us the situation shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080A2"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.2</span></a>, where the child process is busy servicing the client.</p>
<p id="P7000497027000000000000000046BA3" data-uri="chapter12.xhtml#P7000497027000000000000000046BA3" class="pcalibre8 pcalibre1 pcalibre2">Since the connected descriptors in the parent and child each point to the same file table entry, it is crucial for the parent to close its copy of the connected</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000809E" data-uri="chapter12.xhtml#P700049702700000000000000000809E">
<img alt="A diagram shows step 1: a connection request from client 1 (which contains clientfd) to listenfd(3) on server (which also has connfd(4)). Client 2 below also contains clientfd." id="P7000497027000000000000000046BA4" data-uri="P700049702700000000000000000B7C8" src="../images/p973-1.png" class="pcalibre309 pcalibre1 pcalibre2"/>
<figcaption id="P7000497027000000000000000046BA5" data-uri="chapter12.xhtml#P7000497027000000000000000046BA5" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046BA6" data-uri="chapter12.xhtml#P7000497027000000000000000046BA6" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.1 </span>Step 1: Server accepts connection request from client.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000080A2" data-uri="chapter12.xhtml#P70004970270000000000000000080A2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000080A3" title="974" data-uri="chapter12.xhtml#P70004970270000000000000000080A3" epub:type="pagebreak"></span>
<img alt="A diagram shows step 2: data transfers between clientfd on client 1 and connfd(4) on Child 1." id="P7000497027000000000000000046BA7" data-uri="P700049702700000000000000000B7C9" src="../images/p974-1.png" class="pcalibre1 pcalibre310 pcalibre2"/>
<figcaption id="P7000497027000000000000000046BA8" data-uri="chapter12.xhtml#P7000497027000000000000000046BA8" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046BA9" data-uri="chapter12.xhtml#P7000497027000000000000000046BA9" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.2 </span>Step 2: Server forks a child process to service the client.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000080A7" data-uri="chapter12.xhtml#P70004970270000000000000000080A7">
<img alt="A diagram shows step 3: data.transfers between clientfd on client 1 and connfd(4) on child 1, and connection request from clientfd on client 2 to listenfd(3) on server (also has connfd(5))." id="P7000497027000000000000000046BAA" data-uri="P700049702700000000000000000B7CA" src="../images/p974-2.png" class="pcalibre1 pcalibre310 pcalibre2"/>
<figcaption id="P7000497027000000000000000046BAB" data-uri="chapter12.xhtml#P7000497027000000000000000046BAB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046BAC" data-uri="chapter12.xhtml#P7000497027000000000000000046BAC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.3 </span>Step 3: Server accepts another connection request.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046BAD" data-uri="chapter12.xhtml#P7000497027000000000000000046BAD">descriptor. Otherwise, the file table entry for connected descriptor 4 will never be released, and the resulting memory leak will eventually consume the available memory and crash the system.</p>
<p id="P7000497027000000000000000046BAE" data-uri="chapter12.xhtml#P7000497027000000000000000046BAE" class="pcalibre8 pcalibre1 pcalibre2">Now suppose that after the parent creates the child for client 1, it accepts a new connection request from client 2 and returns a new connected descriptor (say, 5), as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080A7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.3</span></a>. The parent then forks another child, which begins servicing its client using connected descriptor 5, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080B6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.4</span></a>. At this point, the parent is waiting for the next connection request and the two children are servicing their respective clients concurrently.</p>
<section id="P70004970270000000000000000080AD" data-uri="chapter12.xhtml#P70004970270000000000000000080AD" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046BAF" data-uri="chapter12.xhtml#P7000497027000000000000000046BAF" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.1.1 </span>A Concurrent Server Based on Processes</h1></header>
<p id="P7000497027000000000000000046BB0" data-uri="chapter12.xhtml#P7000497027000000000000000046BB0" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080CF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5</span></a> shows the code for a concurrent echo server based on processes. The echo function called in line 29 comes from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E78"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.22</span></a>. There are several important points to make about this server:</p>
<ul id="P7000497027000000000000000046BB1" data-uri="chapter12.xhtml#P7000497027000000000000000046BB1" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000046BB2" data-uri="chapter12.xhtml#P7000497027000000000000000046BB2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046BB3" data-uri="chapter12.xhtml#P7000497027000000000000000046BB3" class="pcalibre1 pcalibre2 pcalibre10">First, servers typically run for long periods of time, so we must include a SIGCHLD handler that reaps zombie children (lines 4−9). Since SIGCHLD signals are blocked while the SIGCHLD handler is executing, and since Linux signals are not queued, the SIGCHLD handler must be prepared to reap multiple zombie children.</p></li>
<li id="P7000497027000000000000000046BB4" data-uri="chapter12.xhtml#P7000497027000000000000000046BB4" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046BB5" data-uri="chapter12.xhtml#P7000497027000000000000000046BB5" class="pcalibre1 pcalibre2 pcalibre10">Second, the parent and the child must close their respective copies of <code id="P7000497027000000000000000046BB6" data-uri="chapter12.xhtml#P7000497027000000000000000046BB6" class="pcalibre1 calibre1 pcalibre2">connfd</code> (lines 33 and 30, respectively). As we have mentioned, this is especially important</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000080B6" data-uri="chapter12.xhtml#P70004970270000000000000000080B6">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000080B7" title="975" data-uri="chapter12.xhtml#P70004970270000000000000000080B7" epub:type="pagebreak"></span>
<img alt="A diagram shows step 4: data.transfers between clientfd on client 1 and connfd(4) on child 1, and between clientfd on client 2 and connfd(5) on child 2." id="P7000497027000000000000000046BB7" data-uri="P700049702700000000000000000B7CB" src="../images/p975-1.png" class="pcalibre1 pcalibre2 pcalibre311"/>
<figcaption id="P7000497027000000000000000046BB8" data-uri="chapter12.xhtml#P7000497027000000000000000046BB8" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046BB9" data-uri="chapter12.xhtml#P7000497027000000000000000046BB9" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.4 </span>Step 4: Server forks another child to service the new client.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000046BBA" data-uri="chapter12.xhtml#P7000497027000000000000000046BBA">for the parent, which must close its copy of the connected descriptor to avoid a memory leak.</p></li>
<li id="P7000497027000000000000000046BBB" data-uri="chapter12.xhtml#P7000497027000000000000000046BBB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046BBC" data-uri="chapter12.xhtml#P7000497027000000000000000046BBC" class="pcalibre1 pcalibre2 pcalibre10">Finally, because of the reference count in the socket's file table entry, the connection to the client will not be terminated until both the parent's and child's copies of <code id="P7000497027000000000000000046BBD" data-uri="chapter12.xhtml#P7000497027000000000000000046BBD" class="pcalibre1 calibre1 pcalibre2">connfd</code> are closed.</p></li>
</ul>
</section>
<section id="P70004970270000000000000000080BF" data-uri="chapter12.xhtml#P70004970270000000000000000080BF" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046BBE" data-uri="chapter12.xhtml#P7000497027000000000000000046BBE" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.1.2 </span>Pros and Cons of Processes</h1></header>
<p id="P7000497027000000000000000046BBF" data-uri="chapter12.xhtml#P7000497027000000000000000046BBF" class="pcalibre8 pcalibre1 pcalibre2">Processes have a clean model for sharing state information between parents and children: file tables are shared and user address spaces are not. Having separate address spaces for processes is both an advantage and a disadvantage. It is impossible for one process to accidentally overwrite the virtual memory of another process, which eliminates a lot of confusing failures—an obvious advantage.</p>
<p id="P7000497027000000000000000046BC0" data-uri="chapter12.xhtml#P7000497027000000000000000046BC0" class="pcalibre8 pcalibre1 pcalibre2">On the other hand, separate address spaces make it more difficult for processes to share state information. To share information, they must use explicit IPC (interprocess communications) mechanisms. (See the Aside on <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="#P70004970270000000000000000080DB">page 977</a>.) Another disadvantage of process-based designs is that they tend to be slower because the overhead for process control and IPC is high.</p>
<section id="P70004970270000000000000000080C3" data-uri="chapter12.xhtml#P70004970270000000000000000080C3" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046BC1" data-uri="chapter12.xhtml#P7000497027000000000000000046BC1" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.1 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000046BC2" data-uri="chapter12.xhtml#P7000497027000000000000000046BC2">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000046BC3" data-uri="chapter12.xhtml#P7000497027000000000000000046BC3">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000046BC4" data-uri="chapter12.xhtml#P7000497027000000000000000046BC4"><p id="P7000497027000000000000000046BC5" data-uri="chapter12.xhtml#P7000497027000000000000000046BC5" class="pcalibre1 pcalibre2 pcalibre10">After the parent closes the connected descriptor in line 33 of the concurrent server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080CF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5</span></a>, the child is still able to communicate with the client using its copy of the descriptor. Why?</p></div></li>
</ol>
</section>
<section id="P70004970270000000000000000080C9" data-uri="chapter12.xhtml#P70004970270000000000000000080C9" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046BC6" data-uri="chapter12.xhtml#P7000497027000000000000000046BC6" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.2 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000046BC7" data-uri="chapter12.xhtml#P7000497027000000000000000046BC7">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000046BC8" data-uri="chapter12.xhtml#P7000497027000000000000000046BC8">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000046BC9" data-uri="chapter12.xhtml#P7000497027000000000000000046BC9"><p id="P7000497027000000000000000046BCA" data-uri="chapter12.xhtml#P7000497027000000000000000046BCA" class="pcalibre1 pcalibre2 pcalibre10">If we were to delete line 30 of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000080CF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5</span></a>, which closes the connected descriptor, the code would still be correct, in the sense that there would be no memory leak. Why?</p></div></li>
</ol>
</section>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000080CF" data-uri="chapter12.xhtml#P70004970270000000000000000080CF">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000080D0" title="976" data-uri="chapter12.xhtml#P70004970270000000000000000080D0" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000046BCB" data-uri="chapter12.xhtml#P7000497027000000000000000046BCB" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoserverp.c</i></p>
<pre id="P7000497027000000000000000046BCC" data-uri="chapter12.xhtml#P7000497027000000000000000046BCC" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046BCD" data-uri="chapter12.xhtml#P7000497027000000000000000046BCD" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	void echo(int connfd);
3	
4	void sigchld_handler(int sig)
5	{
6		while (waitpid(−1, 0, WNOHANG) &gt; 0)
7			;
8		return;
9	}
10	
11	int main(int argc, char **argv)
12	{
13		int listenfd, connfd;
14		socklen_t clientlen;
15		struct sockaddr_storage clientaddr;
16
17		if (argc != 2) {
18			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
19			exit(0);
20		}
21	
22		Signal(SIGCHLD, sigchld_handler);
23		listenfd = Open_listenfd(argv[1]);
24		while (1) {
25			clientlen = sizeof(struct sockaddr_storage);
26			connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);
27			if (Fork() == 0) {
28				Close(listenfd); /* Child closes its listening socket */
29				echo(connfd);	 /* Child services client */
30				Close(connfd);	 /* Child closes connection with client */
31				exit(0);	 /* Child exits */
32			}
33			Close(connfd); /* Parent closes connected socket (important!) */
34		}
35	}
</code></pre>
<p id="P7000497027000000000000000046BCE" data-uri="chapter12.xhtml#P7000497027000000000000000046BCE" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoserverp.c</i></p>
<figcaption id="P7000497027000000000000000046BCF" data-uri="chapter12.xhtml#P7000497027000000000000000046BCF" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046BD0" data-uri="chapter12.xhtml#P7000497027000000000000000046BD0" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.5 </span>Concurrent echo server based on processes.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000046BD1" data-uri="chapter12.xhtml#P7000497027000000000000000046BD1"><p id="P7000497027000000000000000046BD2" data-uri="chapter12.xhtml#P7000497027000000000000000046BD2" class="pcalibre1 pcalibre2 pcalibre10">The parent forks a child to handle each new connection request.</p></div></figcaption>
</figure>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P70004970270000000000000000080D9" data-uri="chapter12.xhtml#P70004970270000000000000000080D9"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000046BD3" data-uri="chapter12.xhtml#P7000497027000000000000000046BD3" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000080DB" title="977" data-uri="chapter12.xhtml#P70004970270000000000000000080DB" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Unix IPC</h1></header>
<p id="P7000497027000000000000000046BD4" data-uri="chapter12.xhtml#P7000497027000000000000000046BD4" class="pcalibre1 pcalibre2 pcalibre10">You have already encountered several examples of IPC in this text. The <code id="P7000497027000000000000000046BD5" data-uri="chapter12.xhtml#P7000497027000000000000000046BD5" class="pcalibre1 calibre1 pcalibre2">waitpid</code> function and signals from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">8</span></a> are primitive IPC mechanisms that allow processes to send tiny messages to process running on the same host. The sockets interface from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007B7A.xhtml#P7000497027000000000000000007B7A"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">11</span></a> is an important form of IPC that allows processes on different hosts to exchange arbitrary byte streams. However, the term <i class="pcalibre17 pcalibre2 pcalibre1">Unix IPC</i> is typically reserved for a hodgepodge of techniques that allow processes to communicate with other processes that are running on the same host. Examples include pipes, FIFOs, System V shared memory, and System V semaphores. These mechanisms are beyond our scope. The book by Kerrisk [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41E">62</a>] is an excellent reference.</p>
</aside>
</section>
</section></body></html>
