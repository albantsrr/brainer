<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>1.7 The Operating System Manages the Hardware</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000000190" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000003E5A3" data-uri="chapter01.xhtml#P700049702700000000000000003E5A3" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">1.7 </span>The Operating System Manages the Hardware</h1></header>
<p id="P700049702700000000000000003E5A4" data-uri="chapter01.xhtml#P700049702700000000000000003E5A4" class="pcalibre8 pcalibre1 pcalibre2">Back to our <code id="P700049702700000000000000003E5A5" data-uri="chapter01.xhtml#P700049702700000000000000003E5A5" class="pcalibre1 calibre1 pcalibre2">hello</code> example. When the shell loaded and ran the <code id="P700049702700000000000000003E5A6" data-uri="chapter01.xhtml#P700049702700000000000000003E5A6" class="pcalibre1 calibre1 pcalibre2">hello</code> program, and when the <code id="P700049702700000000000000003E5A7" data-uri="chapter01.xhtml#P700049702700000000000000003E5A7" class="pcalibre1 calibre1 pcalibre2">hello</code> program printed its message, neither program accessed the</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000000196" data-uri="chapter01.xhtml#P7000497027000000000000000000196">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000000197" title="15" data-uri="chapter01.xhtml#P7000497027000000000000000000197" epub:type="pagebreak"></span>
<img alt="A diagram of the layered view of a computer system shows Application programs on top and Operating system in the center (each part of the software), and hardware processor, main memory, and I/O devices on bottom." id="P700049702700000000000000003E5A8" data-uri="P700049702700000000000000000B6AB" src="../images/p15-1.png" class="pcalibre1 pcalibre2 pcalibre70"/>
<figcaption id="P700049702700000000000000003E5A9" data-uri="chapter01.xhtml#P700049702700000000000000003E5A9" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000003E5AA" data-uri="chapter01.xhtml#P700049702700000000000000003E5AA" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">1.10 </span>Layered view of a computer system.</h1></header></figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000019B" data-uri="chapter01.xhtml#P700049702700000000000000000019B">
<img alt="A diagram of abstractions shows the hardware components processor, main memory, and I/O devices as Processes, main memory and I/O devices as virtual memory, and I/O devices as Files." id="P700049702700000000000000003E5AB" data-uri="P700049702700000000000000000B6AC" src="../images/p15-2.png" class="pcalibre1 pcalibre2 pcalibre71"/>
<figcaption id="P700049702700000000000000003E5AC" data-uri="chapter01.xhtml#P700049702700000000000000003E5AC" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000003E5AD" data-uri="chapter01.xhtml#P700049702700000000000000003E5AD" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">1.11 </span>Abstractions provided by an operating system.</h1></header></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000003E5AE" data-uri="chapter01.xhtml#P700049702700000000000000003E5AE">keyboard, display, disk, or main memory directly. Rather, they relied on the services provided by the <i class="pcalibre17 pcalibre2 pcalibre1">operating system</i>. We can think of the operating system as a layer of software interposed between the application program and the hardware, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000000196"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">1.10</span></a>. All attempts by an application program to manipulate the hardware must go through the operating system.</p>
<p id="P700049702700000000000000003E5AF" data-uri="chapter01.xhtml#P700049702700000000000000003E5AF" class="pcalibre8 pcalibre1 pcalibre2">The operating system has two primary purposes: (1) to protect the hardware from misuse by runaway applications and (2) to provide applications with simple and uniform mechanisms for manipulating complicated and often wildly different low-level hardware devices. The operating system achieves both goals via the fundamental abstractions shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000019B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">1.11</span></a>: <i class="pcalibre17 pcalibre2 pcalibre1">processes</i>, <i class="pcalibre17 pcalibre2 pcalibre1">virtual memory</i>, and <i class="pcalibre17 pcalibre2 pcalibre1">files</i>. As this figure suggests, files are abstractions for I/O devices, virtual memory is an abstraction for both the main memory and disk I/O devices, and processes are abstractions for the processor, main memory, and I/O devices. We will discuss each in turn.</p>
<section id="P70004970270000000000000000001A1" data-uri="chapter01.xhtml#P70004970270000000000000000001A1" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000003E5B0" data-uri="chapter01.xhtml#P700049702700000000000000003E5B0" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">1.7.1 </span>Processes</h1></header>
<p id="P700049702700000000000000003E5B1" data-uri="chapter01.xhtml#P700049702700000000000000003E5B1" class="pcalibre8 pcalibre1 pcalibre2">When a program such as <code id="P700049702700000000000000003E5B2" data-uri="chapter01.xhtml#P700049702700000000000000003E5B2" class="pcalibre1 calibre1 pcalibre2">hello</code> runs on a modern system, the operating system provides the illusion that the program is the only one running on the system. The program appears to have exclusive use of both the processor, main memory, and I/O devices. The processor appears to execute the instructions in the program, one after the other, without interruption. And the code and data of the program appear to be the only objects in the system's memory. These illusions are provided by the notion of a process, one of the most important and successful ideas in computer science.</p>
<p id="P700049702700000000000000003E5B3" data-uri="chapter01.xhtml#P700049702700000000000000003E5B3" class="pcalibre8 pcalibre1 pcalibre2">A <i class="pcalibre17 pcalibre2 pcalibre1">process</i> is the operating system's abstraction for a running program. Multiple processes can run concurrently on the same system, and each process appears to have exclusive use of the hardware. By <i class="pcalibre17 pcalibre2 pcalibre1">concurrently</i>, we mean that the instructions of one process are interleaved with the instructions of another process. In most systems, there are more processes to run than there are CPUs to run them.</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P70004970270000000000000000001A6" data-uri="chapter01.xhtml#P70004970270000000000000000001A6"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P700049702700000000000000003E5B4" data-uri="chapter01.xhtml#P700049702700000000000000003E5B4" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000001A8" title="16" data-uri="chapter01.xhtml#P70004970270000000000000000001A8" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Unix, Posix, and the Standard Unix Specification</h1></header>
<p id="P700049702700000000000000003E5B5" data-uri="chapter01.xhtml#P700049702700000000000000003E5B5" class="pcalibre1 pcalibre2 pcalibre40">The 1960s was an era of huge, complex operating systems, such as IBM's OS/360 and Honeywell's Multics systems. While OS/360 was one of the most successful software projects in history, Multics dragged on for years and never achieved wide-scale use. Bell Laboratories was an original partner in the Multics project but dropped out in 1969 because of concern over the complexity of the project and the lack of progress. In reaction to their unpleasant Multics experience, a group of Bell Labs researchers—Ken Thompson, Dennis Ritchie, Doug McIlroy, and Joe Ossanna—began work in 1969 on a simpler operating system for a Digital Equipment Corporation PDP-7 computer, written entirely in machine language. Many of the ideas in the new system, such as the hierarchical file system and the notion of a shell as a user-level process, were borrowed from Multics but implemented in a smaller, simpler package. In 1970, Brian Kernighan dubbed the new system "Unix" as a pun on the complexity of "Multics." The kernel was rewritten in C in 1973, and Unix was announced to the outside world in 1974 [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B45E">93</a>].</p>
<p id="P700049702700000000000000003E5B6" data-uri="chapter01.xhtml#P700049702700000000000000003E5B6" class="pcalibre1 pcalibre2 pcalibre40">Because Bell Labs made the source code available to schools with generous terms, Unix developed a large following at universities. The most influential work was done at the University of California at Berkeley in the late 1970s and early 1980s, with Berkeley researchers adding virtual memory and the Internet protocols in a series of releases called Unix 4.xBSD (Berkeley Software Distributimn). Concurrently, Bell Labs was releasing their own versions, which became known as System V Unix. Versions from other vendors, such as the Sun Microsystems Solaris system, were derived from these original BSD and System V versions.</p>
<p id="P700049702700000000000000003E5B7" data-uri="chapter01.xhtml#P700049702700000000000000003E5B7" class="pcalibre1 pcalibre2 pcalibre10">Trouble arose in the mid 1980s as Unix vendors tried to differentiate themselves by adding new and often incompatible features. To combat this trend, IEEE (Institute for Electrical and Electronics Engineers) sponsored an effort to standardize Unix, later dubbed "Posix" by Richard Stallman. The result was a family of standards, known as the Posix standards, that cover such issues as the C language interface for Unix system calls, shell programs and utilities, threads, and network programming. More recently, a separate standardization effort, known as the "Standard Unix Specification," has joined forces with Posix to create a single, unified standard for Unix systems. As a result of these standardization efforts, the differences between Unix versions have largely disappeared.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000003E5B8" data-uri="chapter01.xhtml#P700049702700000000000000003E5B8">Traditional systems could only execute one program at a time, while newer <i class="pcalibre17 pcalibre2 pcalibre1">multi-core</i> processors can execute several programs simultaneously. In either case, a single CPU can appear to execute multiple processes concurrently by having the processor switch among them. The operating system performs this interleaving with a mechanism known as <i class="pcalibre17 pcalibre2 pcalibre1">context switching</i>. To simplify the rest of this discussion, we consider only a <i class="pcalibre17 pcalibre2 pcalibre1">uniprocessor system</i> containing a single CPU. We will return to the discussion of <i class="pcalibre17 pcalibre2 pcalibre1">multiprocessor</i> systems in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000226"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">1.9.2</span></a>.</p>
<p id="P700049702700000000000000003E5B9" data-uri="chapter01.xhtml#P700049702700000000000000003E5B9" class="pcalibre8 pcalibre1 pcalibre2">The operating system keeps track of all the state information that the process needs in order to run. This state, which is known as the <i class="pcalibre17 pcalibre2 pcalibre1">context</i>, includes information such as the current values of the PC, the register file, and the contents of main memory. At any point in time, a uniprocessor system can only execute the code for a single process. When the operating system decides to transfer control from the current process to some new process, it performs a <i class="pcalibre17 pcalibre2 pcalibre1">context switch</i> by saving the context of the current process, restoring the context of the new process, and</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000001AE" data-uri="chapter01.xhtml#P70004970270000000000000000001AE">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000001AF" title="17" data-uri="chapter01.xhtml#P70004970270000000000000000001AF" epub:type="pagebreak"></span>
<img alt="A diagram illustrates process context switching." id="P700049702700000000000000003E5BA" data-uri="P700049702700000000000000000B6AF" src="../images/p17-1.png" class="pcalibre1 pcalibre2 pcalibre72"/>
<figcaption id="P700049702700000000000000003E5BB" data-uri="chapter01.xhtml#P700049702700000000000000003E5BB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000003E5BC" data-uri="chapter01.xhtml#P700049702700000000000000003E5BC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">1.12 </span>Process context switching.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P700049702700000000000000001E887" data-uri="chapter01.xhtml#P700049702700000000000000001E887">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P700049702700000000000000003E5BD" data-uri="chapter01.xhtml#P700049702700000000000000003E5BD" class="pcalibre1 pcalibre2 pcalibre10">A diagram shows a flow of steps over time, moving between Process A and Process B. The flow extends through user code in Process A to read, and then moves through kernel code (context switch), switching from Process A to Process B. In Process B, the flow moves through user code to disk interrupt, and then through kernel code (context switch) from Process B to Process A, to Return from read, before moving through user code in Process A.</p>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000003E5BE" data-uri="chapter01.xhtml#P700049702700000000000000003E5BE">then passing control to the new process. The new process picks up exactly where it left off. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000001AE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">1.12</span></a> shows the basic idea for our example <code id="P700049702700000000000000003E5BF" data-uri="chapter01.xhtml#P700049702700000000000000003E5BF" class="pcalibre1 calibre1 pcalibre2">hello</code> scenario.</p>
<p id="P700049702700000000000000003E5C0" data-uri="chapter01.xhtml#P700049702700000000000000003E5C0" class="pcalibre8 pcalibre1 pcalibre2">There are two concurrent processes in our example scenario: the shell process and the <code id="P700049702700000000000000003E5C1" data-uri="chapter01.xhtml#P700049702700000000000000003E5C1" class="pcalibre1 calibre1 pcalibre2">hello</code> process. Initially, the shell process is running alone, waiting for input on the command line. When we ask it to run the <code id="P700049702700000000000000003E5C2" data-uri="chapter01.xhtml#P700049702700000000000000003E5C2" class="pcalibre1 calibre1 pcalibre2">hello</code> program, the shell carries out our request by invoking a special function known as a <i class="pcalibre17 pcalibre2 pcalibre1">system call</i> that passes control to the operating system. The operating system saves the shell's context, creates a new <code id="P700049702700000000000000003E5C3" data-uri="chapter01.xhtml#P700049702700000000000000003E5C3" class="pcalibre1 calibre1 pcalibre2">hello</code> process and its context, and then passes control to the new <code id="P700049702700000000000000003E5C4" data-uri="chapter01.xhtml#P700049702700000000000000003E5C4" class="pcalibre1 calibre1 pcalibre2">hello</code> process. After <code id="P700049702700000000000000003E5C5" data-uri="chapter01.xhtml#P700049702700000000000000003E5C5" class="pcalibre1 calibre1 pcalibre2">hello</code> terminates, the operating system restores the context of the shell process and passes control back to it, where it waits for the next command-line input.</p>
<p id="P700049702700000000000000003E5C6" data-uri="chapter01.xhtml#P700049702700000000000000003E5C6" class="pcalibre8 pcalibre1 pcalibre2">As <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000001AE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">1.12</span></a> indicates, the transition from one process to another is managed by the operating system <i class="pcalibre17 pcalibre2 pcalibre1">kernel</i>. The kernel is the portion of the operating system code that is always resident in memory. When an application program requires some action by the operating system, such as to read or write a file, it executes a special <i class="pcalibre17 pcalibre2 pcalibre1">system call</i> instruction, transferring control to the kernel. The kernel then performs the requested operation and returns back to the application program. Note that the kernel is not a separate process. Instead, it is a collection of code and data structures that the system uses to manage all the processes.</p>
<p id="P700049702700000000000000003E5C7" data-uri="chapter01.xhtml#P700049702700000000000000003E5C7" class="pcalibre8 pcalibre1 pcalibre2">Implementing the process abstraction requires close cooperation between both the low-level hardware and the operating system software. We will explore how this works, and how applications can create and control their own processes, in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">8</span></a>.</p>
</section>
<section id="P70004970270000000000000000001BD" data-uri="chapter01.xhtml#P70004970270000000000000000001BD" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000003E5C8" data-uri="chapter01.xhtml#P700049702700000000000000003E5C8" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">1.7.2 </span>Threads</h1></header>
<p id="P700049702700000000000000003E5C9" data-uri="chapter01.xhtml#P700049702700000000000000003E5C9" class="pcalibre8 pcalibre1 pcalibre2">Although we normally think of a process as having a single control flow, in modern systems a process can actually consist of multiple execution units, called <i class="pcalibre17 pcalibre2 pcalibre1">threads</i>, each running in the context of the process and sharing the same code and global data. Threads are an increasingly important programming model because of the requirement for concurrency in network servers, because it is easier to share data between multiple threads than between multiple processes, and because threads are typically more efficient than processes. Multi-threading is also one way to make programs run faster when multiple processors are available, as we will discuss in</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000001C0" data-uri="chapter01.xhtml#P70004970270000000000000000001C0">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000001C1" title="18" data-uri="chapter01.xhtml#P70004970270000000000000000001C1" epub:type="pagebreak"></span>
<img alt="A diagram illustrates process virtual address space." id="P700049702700000000000000003E5CA" data-uri="P700049702700000000000000000B6B0" src="../images/p18-1.png" class="pcalibre1 pcalibre2 pcalibre73"/>
<figcaption id="P700049702700000000000000003E5CB" data-uri="chapter01.xhtml#P700049702700000000000000003E5CB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000003E5CC" data-uri="chapter01.xhtml#P700049702700000000000000003E5CC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">1.13 </span>Process virtual address space.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000003E5CD" data-uri="chapter01.xhtml#P700049702700000000000000003E5CD"><p id="P700049702700000000000000003E5CE" data-uri="chapter01.xhtml#P700049702700000000000000003E5CE" class="pcalibre1 pcalibre2 pcalibre10">(The regions are not drawn to scale.)</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P700049702700000000000000001E89A" data-uri="chapter01.xhtml#P700049702700000000000000001E89A">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P700049702700000000000000003E5CF" data-uri="chapter01.xhtml#P700049702700000000000000003E5CF" class="pcalibre1 pcalibre2 pcalibre10">A diagram shows a stack of regions. The bottom region extends from 0 to Program start. The next two regions, loaded from the hello executable file, represent read-only code and data and read/write data. The next region is Run-time heap (created by nalloc), moving through a blank region above. The next region, the printf function, contains Memory-mapped region for shared libraries. In a blank space above, arrows point from the regions above and below. The top two regions are User stack (created at run time) and Kernel virtual memory, leading to memory invisible to user code.</p>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000003E5D0" data-uri="chapter01.xhtml#P700049702700000000000000003E5D0"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000226"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">1.9.2</span></a>. You will learn the basic concepts of concurrency, including how to write threaded programs, in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">12</span></a>.</p>
</section>
<section id="P70004970270000000000000000001C8" data-uri="chapter01.xhtml#P70004970270000000000000000001C8" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000003E5D1" data-uri="chapter01.xhtml#P700049702700000000000000003E5D1" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">1.7.3 </span>Virtual Memory</h1></header>
<p id="P700049702700000000000000003E5D2" data-uri="chapter01.xhtml#P700049702700000000000000003E5D2" class="pcalibre8 pcalibre1 pcalibre2"><i class="pcalibre17 pcalibre2 pcalibre1">Virtual memory</i> is an abstraction that provides each process with the illusion that it has exclusive use of the main memory. Each process has the same uniform view of memory, which is known as its <i class="pcalibre17 pcalibre2 pcalibre1">virtual address space</i>. The virtual address space for Linux processes is shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000001C0"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">1.13</span></a>. (Other Unix systems use a similar layout.) In Linux, the topmost region of the address space is reserved for code and data in the operating system that is common to all processes. The lower region of the address space holds the code and data defined by the user's process. Note that addresses in the figure increase from the bottom to the top.</p>
<p id="P700049702700000000000000003E5D3" data-uri="chapter01.xhtml#P700049702700000000000000003E5D3" class="pcalibre8 pcalibre1 pcalibre2">The virtual address space seen by each process consists of a number of well-defined areas, each with a specific purpose. You will learn more about these areas later in the book, but it will be helpful to look briefly at each, starting with the lowest addresses and working our way up:</p>
<ul id="P700049702700000000000000003E5D4" data-uri="chapter01.xhtml#P700049702700000000000000003E5D4" class="pcalibre1 calibre9 pcalibre2">
<li id="P700049702700000000000000003E5D5" data-uri="chapter01.xhtml#P700049702700000000000000003E5D5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000003E5D6" data-uri="chapter01.xhtml#P700049702700000000000000003E5D6" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Program code and data. </span>Code begins at the same fixed address for all processes, followed by data locations that correspond to global C variables. The code and data areas are initialized directly from the contents of an executable object file—in our case, the <code id="P700049702700000000000000003E5D7" data-uri="chapter01.xhtml#P700049702700000000000000003E5D7" class="pcalibre1 calibre1 pcalibre2">hello</code> executable. You will learn more about this part of the address space when we study linking and loading in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000005FB4.xhtml#P7000497027000000000000000005FB4"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">7</span></a>.</p></li>
<li id="P700049702700000000000000003E5D8" data-uri="chapter01.xhtml#P700049702700000000000000003E5D8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000003E5D9" data-uri="chapter01.xhtml#P700049702700000000000000003E5D9" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Heap. </span>The code and data areas are followed immediately by the run-time <i class="pcalibre17 pcalibre2 pcalibre1">heap</i>. Unlike the code and data areas, which are fixed in size once the process begins <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000001D2" title="19" data-uri="chapter01.xhtml#P70004970270000000000000000001D2" epub:type="pagebreak"></span>running, the heap expands and contracts dynamically at run time as a result of calls to C standard library routines such as <code id="P700049702700000000000000003E5DA" data-uri="chapter01.xhtml#P700049702700000000000000003E5DA" class="pcalibre1 calibre1 pcalibre2">malloc</code> and <code id="P700049702700000000000000003E5DB" data-uri="chapter01.xhtml#P700049702700000000000000003E5DB" class="pcalibre1 calibre1 pcalibre2">free</code>. We will study heaps in detail when we learn about managing virtual memory in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">9</span></a>.</p></li>
<li id="P700049702700000000000000003E5DC" data-uri="chapter01.xhtml#P700049702700000000000000003E5DC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000003E5DD" data-uri="chapter01.xhtml#P700049702700000000000000003E5DD" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Shared libraries. </span>Near the middle of the address space is an area that holds the code and data for <i class="pcalibre17 pcalibre2 pcalibre1">shared libraries</i> such as the C standard library and the math library. The notion of a shared library is a powerful but somewhat difficult concept. You will learn how they work when we study dynamic linking in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000005FB4.xhtml#P7000497027000000000000000005FB4"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">7</span></a>.</p></li>
<li id="P700049702700000000000000003E5DE" data-uri="chapter01.xhtml#P700049702700000000000000003E5DE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000003E5DF" data-uri="chapter01.xhtml#P700049702700000000000000003E5DF" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Stack. </span>At the top of the user's virtual address space is the <i class="pcalibre17 pcalibre2 pcalibre1">user stack</i> that the compiler uses to implement function calls. Like the heap, the user stack expands and contracts dynamically during the execution of the program. In particular, each time we call a function, the stack grows. Each time we return from a function, it contracts. You will learn how the compiler uses the stack in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001DCE.xhtml#P7000497027000000000000000001DCE"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">3</span></a>.</p></li>
<li id="P700049702700000000000000003E5E0" data-uri="chapter01.xhtml#P700049702700000000000000003E5E0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000003E5E1" data-uri="chapter01.xhtml#P700049702700000000000000003E5E1" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Kernel virtual memory. </span>The top region of the address space is reserved for the kernel. Application programs are not allowed to read or write the contents of this area or to directly call functions defined in the kernel code. Instead, they must invoke the kernel to perform these operations.</p></li>
</ul>
<p id="P700049702700000000000000003E5E2" data-uri="chapter01.xhtml#P700049702700000000000000003E5E2" class="pcalibre8 pcalibre1 pcalibre2">For virtual memory to work, a sophisticated interaction is required between the hardware and the operating system software, including a hardware translation of every address generated by the processor. The basic idea is to store the contents of a process's virtual memory on disk and then use the main memory as a cache for the disk. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">9</span></a> explains how this works and why it is so important to the operation of modern systems.</p>
</section>
<section id="P70004970270000000000000000001DC" data-uri="chapter01.xhtml#P70004970270000000000000000001DC" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000003E5E3" data-uri="chapter01.xhtml#P700049702700000000000000003E5E3" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">1.7.4 </span>Files</h1></header>
<p id="P700049702700000000000000003E5E4" data-uri="chapter01.xhtml#P700049702700000000000000003E5E4" class="pcalibre8 pcalibre1 pcalibre2">A <i class="pcalibre17 pcalibre2 pcalibre1">file</i> is a sequence of bytes, nothing more and nothing less. Every I/O device, including disks, keyboards, displays, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files, using a small set of system calls known as <i class="pcalibre17 pcalibre2 pcalibre1">Unix I/O</i>.</p>
<p id="P700049702700000000000000003E5E5" data-uri="chapter01.xhtml#P700049702700000000000000003E5E5" class="pcalibre8 pcalibre1 pcalibre2">This simple and elegant notion of a file is nonetheless very powerful because it provides applications with a uniform view of all the varied I/O devices that might be contained in the system. For example, application programmers who manipulate the contents of a disk file are blissfully unaware of the specific disk technology. Further, the same program will run on different systems that use different disk technologies. You will learn about Unix I/O in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007867.xhtml#P7000497027000000000000000007867"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">10</span></a>.</p>
</section>
</section></body></html>
