<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>9.9 Dynamic Memory Allocation</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P700049702700000000000000000733C" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000045E03" data-uri="chapter09.xhtml#P7000497027000000000000000045E03" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9 </span>Dynamic Memory Allocation</h1></header>
<p id="P7000497027000000000000000045E04" data-uri="chapter09.xhtml#P7000497027000000000000000045E04" class="pcalibre8 pcalibre1 pcalibre2">While it is certainly possible to use the low-level <code id="P7000497027000000000000000045E05" data-uri="chapter09.xhtml#P7000497027000000000000000045E05" class="pcalibre1 calibre1 pcalibre2">mmap</code> and <code id="P7000497027000000000000000045E06" data-uri="chapter09.xhtml#P7000497027000000000000000045E06" class="pcalibre1 calibre1 pcalibre2">munmap</code> functions to create and delete areas of virtual memory, C programmers typically find it more convenient and more portable to use a <i class="pcalibre17 pcalibre2 pcalibre1">dynamic memory allocator</i> when they need to acquire additional virtual memory at run time.</p>
<p id="P7000497027000000000000000045E07" data-uri="chapter09.xhtml#P7000497027000000000000000045E07" class="pcalibre8 pcalibre1 pcalibre2">A dynamic memory allocator maintains an area of a process's virtual memory known as the <i class="pcalibre17 pcalibre2 pcalibre1">heap</i> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000734A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.33</span></a>). Details vary from system to system, but without loss of generality, we will assume that the heap is an area of demand-zero memory that begins immediately after the uninitialized data area and grows upward (toward higher addresses). For each process, the kernel maintains a variable <code id="P7000497027000000000000000045E08" data-uri="chapter09.xhtml#P7000497027000000000000000045E08" class="pcalibre1 calibre1 pcalibre2">brk</code> (pronounced "break") that points to the top of the heap.</p>
<p id="P7000497027000000000000000045E09" data-uri="chapter09.xhtml#P7000497027000000000000000045E09" class="pcalibre8 pcalibre1 pcalibre2">An allocator maintains the heap as a collection of various-size <i class="pcalibre17 pcalibre2 pcalibre1">blocks.</i> Each block is a contiguous chunk of virtual memory that is either <i class="pcalibre17 pcalibre2 pcalibre1">allocated</i> or <i class="pcalibre17 pcalibre2 pcalibre1">free.</i> An allocated block has been explicitly reserved for use by the application. A free block is available to be allocated. A free block remains free until it is explicitly allocated by the application. An allocated block remains allocated until it is freed, either explicitly by the application or implicitly by the memory allocator itself.</p>
<p id="P7000497027000000000000000045E0A" data-uri="chapter09.xhtml#P7000497027000000000000000045E0A" class="pcalibre8 pcalibre1 pcalibre2">Allocators come in two basic styles. Both styles require the application to explicitly allocate blocks. They differ about which entity is responsible for freeing allocated blocks.</p>
<ul id="P7000497027000000000000000045E0B" data-uri="chapter09.xhtml#P7000497027000000000000000045E0B" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000045E0C" data-uri="chapter09.xhtml#P7000497027000000000000000045E0C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E0D" data-uri="chapter09.xhtml#P7000497027000000000000000045E0D" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Explicit allocators </span>require the application to explicitly free any allocated blocks. For example, the C standard library provides an explicit allocator called the <code id="P7000497027000000000000000045E0E" data-uri="chapter09.xhtml#P7000497027000000000000000045E0E" class="pcalibre1 calibre1 pcalibre2">malloc</code> package. C programs allocate a block by calling the <code id="P7000497027000000000000000045E0F" data-uri="chapter09.xhtml#P7000497027000000000000000045E0F" class="pcalibre1 calibre1 pcalibre2">malloc</code></p>
<figure id="P700049702700000000000000000734A" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P700049702700000000000000000734A">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000734B" title="840" data-uri="chapter09.xhtml#P700049702700000000000000000734B" epub:type="pagebreak"></span>
<img alt="A diagram illustrates areas in the heap." id="P7000497027000000000000000045E10" data-uri="P700049702700000000000000000B79C" src="../images/p840-1.png" class="pcalibre1 pcalibre2 calibre77"/>
<figcaption id="P7000497027000000000000000045E11" data-uri="chapter09.xhtml#P7000497027000000000000000045E11" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045E12" data-uri="chapter09.xhtml#P7000497027000000000000000045E12" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.33 </span>The heap.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000026162" data-uri="chapter09.xhtml#P7000497027000000000000000026162">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045E13" data-uri="chapter09.xhtml#P7000497027000000000000000045E13" class="pcalibre1 pcalibre2 pcalibre10">A diagram of a stack has the following areas, listed from bottom to top:</p>
<ul id="P7000497027000000000000000045E14" data-uri="chapter09.xhtml#P7000497027000000000000000045E14" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000045E15" data-uri="chapter09.xhtml#P7000497027000000000000000045E15" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E16" data-uri="chapter09.xhtml#P7000497027000000000000000045E16" class="pcalibre1 pcalibre2 pcalibre10">Gap from 0</p></li>
<li id="P7000497027000000000000000045E17" data-uri="chapter09.xhtml#P7000497027000000000000000045E17" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E18" data-uri="chapter09.xhtml#P7000497027000000000000000045E18" class="pcalibre1 pcalibre2 pcalibre10">Code (.text)</p></li>
<li id="P7000497027000000000000000045E19" data-uri="chapter09.xhtml#P7000497027000000000000000045E19" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E1A" data-uri="chapter09.xhtml#P7000497027000000000000000045E1A" class="pcalibre1 pcalibre2 pcalibre10">Initialized data (.data)</p></li>
<li id="P7000497027000000000000000045E1B" data-uri="chapter09.xhtml#P7000497027000000000000000045E1B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E1C" data-uri="chapter09.xhtml#P7000497027000000000000000045E1C" class="pcalibre1 pcalibre2 pcalibre10">Uninitialized data (.bss)</p></li>
<li id="P7000497027000000000000000045E1D" data-uri="chapter09.xhtml#P7000497027000000000000000045E1D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E1E" data-uri="chapter09.xhtml#P7000497027000000000000000045E1E" class="pcalibre1 pcalibre2 pcalibre10">Heap (growing upward from top of the heap (brk ptr)</p></li>
<li id="P7000497027000000000000000045E1F" data-uri="chapter09.xhtml#P7000497027000000000000000045E1F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E20" data-uri="chapter09.xhtml#P7000497027000000000000000045E20" class="pcalibre1 pcalibre2 pcalibre10">Gap</p></li>
<li id="P7000497027000000000000000045E21" data-uri="chapter09.xhtml#P7000497027000000000000000045E21" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E22" data-uri="chapter09.xhtml#P7000497027000000000000000045E22" class="pcalibre1 pcalibre2 pcalibre10">Memory-mapped region for shared libraries</p></li>
<li id="P7000497027000000000000000045E23" data-uri="chapter09.xhtml#P7000497027000000000000000045E23" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E24" data-uri="chapter09.xhtml#P7000497027000000000000000045E24" class="pcalibre1 pcalibre2 pcalibre10">Gap</p></li>
<li id="P7000497027000000000000000045E25" data-uri="chapter09.xhtml#P7000497027000000000000000045E25" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E26" data-uri="chapter09.xhtml#P7000497027000000000000000045E26" class="pcalibre1 pcalibre2 pcalibre10">User stack</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000045E27" data-uri="chapter09.xhtml#P7000497027000000000000000045E27">function, and free a block by calling the free function. The <code id="P7000497027000000000000000045E28" data-uri="chapter09.xhtml#P7000497027000000000000000045E28" class="pcalibre1 calibre1 pcalibre2">new</code> and <code id="P7000497027000000000000000045E29" data-uri="chapter09.xhtml#P7000497027000000000000000045E29" class="pcalibre1 calibre1 pcalibre2">delete</code> calls in <code id="P7000497027000000000000000045E2A" data-uri="chapter09.xhtml#P7000497027000000000000000045E2A" class="pcalibre1 calibre1 pcalibre2">C++</code> are comparable.</p></li>
<li id="P7000497027000000000000000045E2B" data-uri="chapter09.xhtml#P7000497027000000000000000045E2B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E2C" data-uri="chapter09.xhtml#P7000497027000000000000000045E2C" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Implicit allocators, </span>on the other hand, require the allocator to detect when an allocated block is no longer being used by the program and then free the block. Implicit allocators are also known as <i class="pcalibre17 pcalibre2 pcalibre1">garbage collectors</i>, and the process of automatically freeing unused allocated blocks is known as <i class="pcalibre17 pcalibre2 pcalibre1">garbage collection.</i> For example, higher-level languages such as Lisp, ML, and Java rely on garbage collection to free allocated blocks.</p></li>
</ul>
<p id="P7000497027000000000000000045E2D" data-uri="chapter09.xhtml#P7000497027000000000000000045E2D" class="pcalibre8 pcalibre1 pcalibre2">The remainder of this section discusses the design and implementation of explicit allocators. We will discuss implicit allocators in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007565.xhtml#P7000497027000000000000000007565"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">9.10</span></a>. For concrete -ness, our discussion focuses on allocators that manage heap memory. However, you should be aware that memory allocation is a general idea that arises in a variety of contexts. For example, applications that do intensive manipulation of graphs will often use the standard allocator to acquire a large block of virtual memory and then use an application-specific allocator to manage the memory within that block as the nodes of the graph are created and destroyed.</p>
<section id="P7000497027000000000000000007356" data-uri="chapter09.xhtml#P7000497027000000000000000007356" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045E2E" data-uri="chapter09.xhtml#P7000497027000000000000000045E2E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.1 </span>The <code id="P7000497027000000000000000045E2F" data-uri="chapter09.xhtml#P7000497027000000000000000045E2F" class="pcalibre1 calibre1 pcalibre2">malloc</code> and <code id="P7000497027000000000000000045E30" data-uri="chapter09.xhtml#P7000497027000000000000000045E30" class="pcalibre1 calibre1 pcalibre2">free</code> Functions</h1></header>
<p id="P7000497027000000000000000045E31" data-uri="chapter09.xhtml#P7000497027000000000000000045E31" class="pcalibre8 pcalibre1 pcalibre2">The C standard library provides an explicit allocator known as the <code id="P7000497027000000000000000045E32" data-uri="chapter09.xhtml#P7000497027000000000000000045E32" class="pcalibre1 calibre1 pcalibre2">malloc</code> package. Programs allocate blocks from the heap by calling the <code id="P7000497027000000000000000045E33" data-uri="chapter09.xhtml#P7000497027000000000000000045E33" class="pcalibre1 calibre1 pcalibre2">malloc</code> function.</p>
<pre id="P7000497027000000000000000045E34" data-uri="chapter09.xhtml#P7000497027000000000000000045E34" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045E35" data-uri="chapter09.xhtml#P7000497027000000000000000045E35" class="calibre3 pcalibre1 pcalibre2">
#include &lt;stdlib.h&gt;

void *malloc(size_t size);
			Returns: pointer to allocated block if OK, NULL on error
</code></pre>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P700049702700000000000000000735F" data-uri="chapter09.xhtml#P700049702700000000000000000735F"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000045E36" data-uri="chapter09.xhtml#P7000497027000000000000000045E36" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007361" title="841" data-uri="chapter09.xhtml#P7000497027000000000000000007361" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>How big is a word?</h1></header>
<p id="P7000497027000000000000000045E37" data-uri="chapter09.xhtml#P7000497027000000000000000045E37" class="pcalibre1 pcalibre2 pcalibre10">Recall from our discussion of machine code in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001DCE.xhtml#P7000497027000000000000000001DCE"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">3</span></a> that Intel refers to 4-byte objects as <i class="pcalibre17 pcalibre2 pcalibre1">double words.</i> However, throughout this section, we will assume that <i class="pcalibre17 pcalibre2 pcalibre1">words</i> are 4-byte objects and that <i class="pcalibre17 pcalibre2 pcalibre1">double words</i> are 8-byte objects, which is consistent with conventional terminology.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045E38" data-uri="chapter09.xhtml#P7000497027000000000000000045E38">The <code id="P7000497027000000000000000045E39" data-uri="chapter09.xhtml#P7000497027000000000000000045E39" class="pcalibre1 calibre1 pcalibre2">malloc</code> function returns a pointer to a block of memory of at least size bytes that is suitably aligned for any kind of data object that might be contained in the block. In practice, the alignment depends on whether the code is compiled to run in 32-bit mode (<code id="P7000497027000000000000000045E3A" data-uri="chapter09.xhtml#P7000497027000000000000000045E3A" class="pcalibre1 calibre1 pcalibre2">gcc –m32</code>) or 64-bit mode (the default). In 32-bit mode, <code id="P7000497027000000000000000045E3B" data-uri="chapter09.xhtml#P7000497027000000000000000045E3B" class="pcalibre1 calibre1 pcalibre2">malloc</code> returns a block whose address is always a multiple of 8. In 64-bit mode, the address is always a multiple of 16.</p>
<p id="P7000497027000000000000000045E3C" data-uri="chapter09.xhtml#P7000497027000000000000000045E3C" class="pcalibre8 pcalibre1 pcalibre2">If <code id="P7000497027000000000000000045E3D" data-uri="chapter09.xhtml#P7000497027000000000000000045E3D" class="pcalibre1 calibre1 pcalibre2">malloc</code> encounters a problem (e.g., the program requests a block of memory that is larger than the available virtual memory), then it returns NULL and sets <code id="P7000497027000000000000000045E3E" data-uri="chapter09.xhtml#P7000497027000000000000000045E3E" class="pcalibre1 calibre1 pcalibre2">errno</code>. <code id="P7000497027000000000000000045E3F" data-uri="chapter09.xhtml#P7000497027000000000000000045E3F" class="pcalibre1 calibre1 pcalibre2">Malloc</code> does not initialize the memory it returns. Applications that want initialized dynamic memory can use <code id="P7000497027000000000000000045E40" data-uri="chapter09.xhtml#P7000497027000000000000000045E40" class="pcalibre1 calibre1 pcalibre2">calloc</code>, a thin wrapper around the <code id="P7000497027000000000000000045E41" data-uri="chapter09.xhtml#P7000497027000000000000000045E41" class="pcalibre1 calibre1 pcalibre2">malloc</code> function that initializes the allocated memory to <code id="P7000497027000000000000000045E42" data-uri="chapter09.xhtml#P7000497027000000000000000045E42" class="pcalibre1 calibre1 pcalibre2">zero</code>. Applications that want to change the size of a previously allocated block can use the <code id="P7000497027000000000000000045E43" data-uri="chapter09.xhtml#P7000497027000000000000000045E43" class="pcalibre1 calibre1 pcalibre2">realloc</code> function.</p>
<p id="P7000497027000000000000000045E44" data-uri="chapter09.xhtml#P7000497027000000000000000045E44" class="pcalibre8 pcalibre1 pcalibre2">Dynamic memory allocators such as <code id="P7000497027000000000000000045E45" data-uri="chapter09.xhtml#P7000497027000000000000000045E45" class="pcalibre1 calibre1 pcalibre2">malloc</code> can allocate or deallocate heap memory explicitly by using the <code id="P7000497027000000000000000045E46" data-uri="chapter09.xhtml#P7000497027000000000000000045E46" class="pcalibre1 calibre1 pcalibre2">mmap</code> and <code id="P7000497027000000000000000045E47" data-uri="chapter09.xhtml#P7000497027000000000000000045E47" class="pcalibre1 calibre1 pcalibre2">munmap</code> functions, or they can use the <code id="P7000497027000000000000000045E48" data-uri="chapter09.xhtml#P7000497027000000000000000045E48" class="pcalibre1 calibre1 pcalibre2">sbrk</code> function:</p>
<pre id="P7000497027000000000000000045E49" data-uri="chapter09.xhtml#P7000497027000000000000000045E49" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045E4A" data-uri="chapter09.xhtml#P7000497027000000000000000045E4A" class="calibre3 pcalibre1 pcalibre2">
#include &lt;unistd.h&gt;

void *sbrk(intptr_t incr);
				Returns: old brk pointer on success, –1 on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045E4B" data-uri="chapter09.xhtml#P7000497027000000000000000045E4B">The <code id="P7000497027000000000000000045E4C" data-uri="chapter09.xhtml#P7000497027000000000000000045E4C" class="pcalibre1 calibre1 pcalibre2">sbrk</code> function grows or shrinks the heap by adding <code id="P7000497027000000000000000045E4D" data-uri="chapter09.xhtml#P7000497027000000000000000045E4D" class="pcalibre1 calibre1 pcalibre2">incr</code> to the kernel's <code id="P7000497027000000000000000045E4E" data-uri="chapter09.xhtml#P7000497027000000000000000045E4E" class="pcalibre1 calibre1 pcalibre2">brk</code> pointer. If successful, it returns the old value of <code id="P7000497027000000000000000045E4F" data-uri="chapter09.xhtml#P7000497027000000000000000045E4F" class="pcalibre1 calibre1 pcalibre2">brk</code>, otherwise it returns –1 and sets <code id="P7000497027000000000000000045E50" data-uri="chapter09.xhtml#P7000497027000000000000000045E50" class="pcalibre1 calibre1 pcalibre2">errno</code> to ENOMEM. If <code id="P7000497027000000000000000045E51" data-uri="chapter09.xhtml#P7000497027000000000000000045E51" class="pcalibre1 calibre1 pcalibre2">incr</code> is zero, then <code id="P7000497027000000000000000045E52" data-uri="chapter09.xhtml#P7000497027000000000000000045E52" class="pcalibre1 calibre1 pcalibre2">sbrk</code> returns the current value of <code id="P7000497027000000000000000045E53" data-uri="chapter09.xhtml#P7000497027000000000000000045E53" class="pcalibre1 calibre1 pcalibre2">brk</code>. Calling <code id="P7000497027000000000000000045E54" data-uri="chapter09.xhtml#P7000497027000000000000000045E54" class="pcalibre1 calibre1 pcalibre2">sbrk</code> with a negative <code id="P7000497027000000000000000045E55" data-uri="chapter09.xhtml#P7000497027000000000000000045E55" class="pcalibre1 calibre1 pcalibre2">incr</code> is legal but tricky because the return value (the old value of <code id="P7000497027000000000000000045E56" data-uri="chapter09.xhtml#P7000497027000000000000000045E56" class="pcalibre1 calibre1 pcalibre2">brk</code>) points to <code id="P7000497027000000000000000045E57" data-uri="chapter09.xhtml#P7000497027000000000000000045E57" class="pcalibre1 calibre1 pcalibre2">abs (incr)</code> bytes past the new top of the heap.</p>
<p id="P7000497027000000000000000045E58" data-uri="chapter09.xhtml#P7000497027000000000000000045E58" class="pcalibre8 pcalibre1 pcalibre2">Programs free allocated heap blocks by calling the free function.</p>
<pre id="P7000497027000000000000000045E59" data-uri="chapter09.xhtml#P7000497027000000000000000045E59" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045E5A" data-uri="chapter09.xhtml#P7000497027000000000000000045E5A" class="calibre3 pcalibre1 pcalibre2">
#include &lt;stdlib.h&gt;

void free(void *ptr);

					Returns: nothing
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045E5B" data-uri="chapter09.xhtml#P7000497027000000000000000045E5B">The <code id="P7000497027000000000000000045E5C" data-uri="chapter09.xhtml#P7000497027000000000000000045E5C" class="pcalibre1 calibre1 pcalibre2">ptr</code> argument must point to the beginning of an allocated block that was obtained from <code id="P7000497027000000000000000045E5D" data-uri="chapter09.xhtml#P7000497027000000000000000045E5D" class="pcalibre1 calibre1 pcalibre2">malloc, calloc</code>, or <code id="P7000497027000000000000000045E5E" data-uri="chapter09.xhtml#P7000497027000000000000000045E5E" class="pcalibre1 calibre1 pcalibre2">realloc</code>. If not, then the behavior of <code id="P7000497027000000000000000045E5F" data-uri="chapter09.xhtml#P7000497027000000000000000045E5F" class="pcalibre1 calibre1 pcalibre2">free</code> is undefined. Even worse, since it returns nothing, <code id="P7000497027000000000000000045E60" data-uri="chapter09.xhtml#P7000497027000000000000000045E60" class="pcalibre1 calibre1 pcalibre2">free</code> gives no indication to the application that something is wrong. As we shall see in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000075E8.xhtml#P70004970270000000000000000075E8"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">9.11</span></a>, this can produce some baffling run-time errors.</p>
<figure id="P700049702700000000000000000738C" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P700049702700000000000000000738C">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000738D" title="842" data-uri="chapter09.xhtml#P700049702700000000000000000738D" epub:type="pagebreak"></span>
<img alt="Diagrams illustrate allocating and freeing block with malloc and free." id="P7000497027000000000000000045E61" data-uri="P700049702700000000000000000B79D" src="../images/p842-1.png" class="calibre78 pcalibre2 pcalibre1"/>
<figcaption id="P7000497027000000000000000045E62" data-uri="chapter09.xhtml#P7000497027000000000000000045E62" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045E63" data-uri="chapter09.xhtml#P7000497027000000000000000045E63" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.34 </span>Allocating and freeing blocks with <code id="P7000497027000000000000000045E64" data-uri="chapter09.xhtml#P7000497027000000000000000045E64" class="pcalibre1 calibre1 pcalibre2">malloc</code> <b class="pcalibre1 pcalibre2 pcalibre12">and</b> <code id="P7000497027000000000000000045E65" data-uri="chapter09.xhtml#P7000497027000000000000000045E65" class="pcalibre1 calibre1 pcalibre2">free</code>.</h1></header><div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000045E66" data-uri="chapter09.xhtml#P7000497027000000000000000045E66"><p id="P7000497027000000000000000045E67" data-uri="chapter09.xhtml#P7000497027000000000000000045E67" class="pcalibre1 pcalibre2 pcalibre10">Each square corresponds to a word. Each heavy rectangle corresponds to a block. Allocated blocks are shaded. Padded regions of allocated blocks are shaded with a darker blue. Free blocks are unshaded. Heap addresses increase from left to right.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000261B8" data-uri="chapter09.xhtml#P70004970270000000000000000261B8">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045E68" data-uri="chapter09.xhtml#P7000497027000000000000000045E68" class="pcalibre8 pcalibre1 pcalibre2">Five diagrams each have a row of 18 squares, shaded and labeled as summarized below.</p>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P7000497027000000000000000045E69" data-uri="chapter09.xhtml#P7000497027000000000000000045E69">
<li id="P7000497027000000000000000045E6A" data-uri="chapter09.xhtml#P7000497027000000000000000045E6A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E6B" data-uri="chapter09.xhtml#P7000497027000000000000000045E6B" class="pcalibre1 pcalibre2 pcalibre10">P1 = malloc(4*sizeof(int)): first four squareas shaded, beginning at p1</p></li>
<li id="P7000497027000000000000000045E6C" data-uri="chapter09.xhtml#P7000497027000000000000000045E6C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E6D" data-uri="chapter09.xhtml#P7000497027000000000000000045E6D" class="pcalibre1 pcalibre2 pcalibre10">P2 = malloc(5*sizeof(int)): first four shaded from p1 and p2, with next five shaded light and sixth shaded dark</p></li>
<li id="P7000497027000000000000000045E6E" data-uri="chapter09.xhtml#P7000497027000000000000000045E6E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E6F" data-uri="chapter09.xhtml#P7000497027000000000000000045E6F" class="pcalibre1 pcalibre2 pcalibre10">P3 = malloc (6*sizeof(int)): first four shaded from p1 to p2; next 6 shaded (last one dark) from p2 to p3; next 6 shaded</p></li>
<li id="P7000497027000000000000000045E70" data-uri="chapter09.xhtml#P7000497027000000000000000045E70" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E71" data-uri="chapter09.xhtml#P7000497027000000000000000045E71" class="pcalibre1 pcalibre2 pcalibre10">Free(p2): first four shaded from p1 to p2; no shading for 6 between p2 and p3; 6 shaded from p3</p></li>
<li id="P7000497027000000000000000045E72" data-uri="chapter09.xhtml#P7000497027000000000000000045E72" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E73" data-uri="chapter09.xhtml#P7000497027000000000000000045E73" class="pcalibre1 pcalibre2 pcalibre10">P4 = malloc (2*sizeof(int)): first four shaded from p1; next two shaded, with first labeled p2 and p4; next four not shaded; next six shaded from p3.</p></li>
</ol>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000045E74" data-uri="chapter09.xhtml#P7000497027000000000000000045E74" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000738C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.34</span></a> shows how an implementation of <code id="P7000497027000000000000000045E75" data-uri="chapter09.xhtml#P7000497027000000000000000045E75" class="pcalibre1 calibre1 pcalibre2">malloc</code> and <code id="P7000497027000000000000000045E76" data-uri="chapter09.xhtml#P7000497027000000000000000045E76" class="pcalibre1 calibre1 pcalibre2">free</code> might manage a (very) small heap of 16 words for a C program. Each box represents a 4-byte word. The heavy-lined rectangles correspond to allocated blocks (shaded) and free blocks (unshaded). Initially, the heap consists of a single 16-word double-word-aligned free block.<a class="pcalibre1 pcalibre2 pcalibre56 pcalibre16 pcalibre14 pcalibre15" id="r__P7000497027000000000000000007861" epub:type="noteref" href="#P7000497027000000000000000007861"><sup class="pcalibre1 pcalibre2 calibre8">1</sup></a></p><aside class="pcalibre2 pcalibre32 pcalibre57" id="P7000497027000000000000000007861" data-uri="chapter09.xhtml#P7000497027000000000000000007861" epub:type="footnote"><p class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre58 pcalibre2"><a href="#r__P7000497027000000000000000007861" class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13">1. </a></span>Throughout this section, we will assume that the allocator returns blocks aligned to 8-byte double-word boundaries.</p></aside>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P7000497027000000000000000045E77" data-uri="chapter09.xhtml#P7000497027000000000000000045E77">
<li id="P7000497027000000000000000045E78" data-uri="chapter09.xhtml#P7000497027000000000000000045E78" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E79" data-uri="chapter09.xhtml#P7000497027000000000000000045E79" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000738C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.34(a)</span></a>. </span>The program asks for a four-word block. <code id="P7000497027000000000000000045E7A" data-uri="chapter09.xhtml#P7000497027000000000000000045E7A" class="pcalibre1 calibre1 pcalibre2">Malloc</code> responds by carving out a four-word block from the front of the free block and returning a pointer to the first word of the block.</p></li>
<li id="P7000497027000000000000000045E7B" data-uri="chapter09.xhtml#P7000497027000000000000000045E7B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E7C" data-uri="chapter09.xhtml#P7000497027000000000000000045E7C" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000738C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.34(b)</span></a>. </span>The program requests a five-word block. <code id="P7000497027000000000000000045E7D" data-uri="chapter09.xhtml#P7000497027000000000000000045E7D" class="pcalibre1 calibre1 pcalibre2">Malloc</code> responds by allocating a six-word block from the front of the free block. In this example, <code id="P7000497027000000000000000045E7E" data-uri="chapter09.xhtml#P7000497027000000000000000045E7E" class="pcalibre1 calibre1 pcalibre2">malloc</code> pads the block with an extra word in order to keep the free block aligned on a double-word boundary.</p></li>
<li id="P7000497027000000000000000045E7F" data-uri="chapter09.xhtml#P7000497027000000000000000045E7F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E80" data-uri="chapter09.xhtml#P7000497027000000000000000045E80" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000738C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.34(c)</span></a>. </span>The program requests a six-word block and <code id="P7000497027000000000000000045E81" data-uri="chapter09.xhtml#P7000497027000000000000000045E81" class="pcalibre1 calibre1 pcalibre2">malloc</code> responds by carving out a six-word block from the free block.</p></li>
<li id="P7000497027000000000000000045E82" data-uri="chapter09.xhtml#P7000497027000000000000000045E82" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E83" data-uri="chapter09.xhtml#P7000497027000000000000000045E83" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000738C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.34(d)</span></a>. </span>The program frees the six-word block that was allocated in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000738C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.34(b)</span></a>. Notice that after the call to <code id="P7000497027000000000000000045E84" data-uri="chapter09.xhtml#P7000497027000000000000000045E84" class="pcalibre1 calibre1 pcalibre2">free</code> returns, the pointer <code id="P7000497027000000000000000045E85" data-uri="chapter09.xhtml#P7000497027000000000000000045E85" class="pcalibre1 calibre1 pcalibre2">p2</code> <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000073A7" title="843" data-uri="chapter09.xhtml#P70004970270000000000000000073A7" epub:type="pagebreak"></span>still points to the freed block. It is the responsibility of the application not to use <code id="P7000497027000000000000000045E86" data-uri="chapter09.xhtml#P7000497027000000000000000045E86" class="pcalibre1 calibre1 pcalibre2">p2</code> again until it is reinitialized by a new call to <code id="P7000497027000000000000000045E87" data-uri="chapter09.xhtml#P7000497027000000000000000045E87" class="pcalibre1 calibre1 pcalibre2">malloc</code>.</p></li>
<li id="P7000497027000000000000000045E88" data-uri="chapter09.xhtml#P7000497027000000000000000045E88" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E89" data-uri="chapter09.xhtml#P7000497027000000000000000045E89" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000738C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.34(e)</span></a>. </span>The program requests a two-word block. In this case, <code id="P7000497027000000000000000045E8A" data-uri="chapter09.xhtml#P7000497027000000000000000045E8A" class="pcalibre1 calibre1 pcalibre2">malloc</code> allocates a portion of the block that was freed in the previous step and returns a pointer to this new block.</p></li>
</ul>
</section>
<section id="P70004970270000000000000000073AD" data-uri="chapter09.xhtml#P70004970270000000000000000073AD" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045E8B" data-uri="chapter09.xhtml#P7000497027000000000000000045E8B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.2 </span>Why Dynamic Memory Allocation?</h1></header>
<p id="P7000497027000000000000000045E8C" data-uri="chapter09.xhtml#P7000497027000000000000000045E8C" class="pcalibre8 pcalibre1 pcalibre2">The most important reason that programs use dynamic memory allocation is that often they do not know the sizes of certain data structures until the program actually runs. For example, suppose we are asked to write a C program that reads a list of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> ASCII integers, one integer per line, from <code id="P7000497027000000000000000045E8D" data-uri="chapter09.xhtml#P7000497027000000000000000045E8D" class="pcalibre1 calibre1 pcalibre2">stdin</code> into a C array. The input consists of the integer <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, followed by the <var class="pcalibre17 pcalibre2 pcalibre1">n</var> integers to be read and stored into the array. The simplest approach is to define the array statically with some hard-coded maximum array size:</p>
<pre id="P7000497027000000000000000045E8E" data-uri="chapter09.xhtml#P7000497027000000000000000045E8E" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045E8F" data-uri="chapter09.xhtml#P7000497027000000000000000045E8F" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	#define MAXN 15213
3	
4	int array [MAXN];
5	
6	int main()
7	{
8		int i, n;
9	
10		scanf(%d", &amp;n);
11		if (n &gt; MAXN)
12			app_error("Input file too big");
13		for (i = 0; i &lt; n; i++)
14			scanf (%d", &amp;array[i]);
15		exit(0);
16	}
</code></pre>
<p id="P7000497027000000000000000045E90" data-uri="chapter09.xhtml#P7000497027000000000000000045E90" class="pcalibre8 pcalibre1 pcalibre2">Allocating arrays with hard-coded sizes like this is often a bad idea. The value of MAXN is arbitrary and has no relation to the actual amount of available virtual memory on the machine. Further, if the user of this program wanted to read a file that was larger than MAXN, the only recourse would be to recompile the program with a larger value of MAXN. While not a problem for this simple example, the presence of hard-coded array bounds can become a maintenance nightmare for large software products with millions of lines of code and numerous users.</p>
<p id="P7000497027000000000000000045E91" data-uri="chapter09.xhtml#P7000497027000000000000000045E91" class="pcalibre8 pcalibre1 pcalibre2">A better approach is to allocate the array dynamically, at run time, after the value of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> becomes known. With this approach, the maximum size of the array is limited only by the amount of available virtual memory.</p>
<pre id="P7000497027000000000000000045E92" data-uri="chapter09.xhtml#P7000497027000000000000000045E92" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045E93" data-uri="chapter09.xhtml#P7000497027000000000000000045E93" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000073B7" title="844" data-uri="chapter09.xhtml#P70004970270000000000000000073B7" epub:type="pagebreak"></span>1	#include "csapp.h"
2	
3	int main()
4	{
5		int *array, i, n;
6	
7		scanf ("%d", &amp;n);
8		array = (int *)Malloc(n * sizeof(int));
9		for (i = 0; i &lt; n; i++)
10			scanf ("%d", &amp;array[i]);
11		free(array);
12		exit(0);
13	}
</code></pre>
<p id="P7000497027000000000000000045E94" data-uri="chapter09.xhtml#P7000497027000000000000000045E94" class="pcalibre8 pcalibre1 pcalibre2">Dynamic memory allocation is a useful and important programming technique. However, in order to use allocators correctly and efficiently, programmers need to have an understanding of how they work. We will discuss some of the gruesome errors that can result from the improper use of allocators in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000075E8.xhtml#P70004970270000000000000000075E8"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">9.11</span></a>.</p>
</section>
<section id="P70004970270000000000000000073B9" data-uri="chapter09.xhtml#P70004970270000000000000000073B9" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045E95" data-uri="chapter09.xhtml#P7000497027000000000000000045E95" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.3 </span>Allocator Requirements and Goals</h1></header>
<p id="P7000497027000000000000000045E96" data-uri="chapter09.xhtml#P7000497027000000000000000045E96" class="pcalibre8 pcalibre1 pcalibre2">Explicit allocators must operate within some rather stringent constraints:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P7000497027000000000000000045E97" data-uri="chapter09.xhtml#P7000497027000000000000000045E97">
<li id="P7000497027000000000000000045E98" data-uri="chapter09.xhtml#P7000497027000000000000000045E98" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E99" data-uri="chapter09.xhtml#P7000497027000000000000000045E99" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Handling arbitrary request sequences. </span>An application can make an arbitrary sequence of allocate and free requests, subject to the constraint that each free request must correspond to a currently allocated block obtained from a previous allocate request. Thus, the allocator cannot make any assumptions about the ordering of allocate and free requests. For example, the allocator cannot assume that all allocate requests are accompanied by a matching free request, or that matching allocate and free requests are nested.</p></li>
<li id="P7000497027000000000000000045E9A" data-uri="chapter09.xhtml#P7000497027000000000000000045E9A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E9B" data-uri="chapter09.xhtml#P7000497027000000000000000045E9B" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Making immediate responses to requests. </span>The allocator must respond immediately to allocate requests. Thus, the allocator is not allowed to reorder or buffer requests in order to improve performance.</p></li>
<li id="P7000497027000000000000000045E9C" data-uri="chapter09.xhtml#P7000497027000000000000000045E9C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E9D" data-uri="chapter09.xhtml#P7000497027000000000000000045E9D" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Using only the heap. </span>In order for the allocator to be scalable, any nonscalar data structures used by the allocator must be stored in the heap itself.</p></li>
<li id="P7000497027000000000000000045E9E" data-uri="chapter09.xhtml#P7000497027000000000000000045E9E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045E9F" data-uri="chapter09.xhtml#P7000497027000000000000000045E9F" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Aligning blocks (alignment requirement). </span>The allocator must align blocks in such a way that they can hold any type of data object.</p></li>
<li id="P7000497027000000000000000045EA0" data-uri="chapter09.xhtml#P7000497027000000000000000045EA0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045EA1" data-uri="chapter09.xhtml#P7000497027000000000000000045EA1" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Not modifying allocated blocks. </span>Allocators can only manipulate or change free blocks. In particular, they are not allowed to modify or move blocks once they are allocated. Thus, techniques such as compaction of allocated blocks are not permitted.</p></li>
</ul>
<p id="P7000497027000000000000000045EA2" data-uri="chapter09.xhtml#P7000497027000000000000000045EA2" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000073C8" title="845" data-uri="chapter09.xhtml#P70004970270000000000000000073C8" epub:type="pagebreak"></span>Working within these constraints, the author of an allocator attempts to meet the often conflicting performance goals of maximizing throughput and memory utilization.</p>
<p id="P7000497027000000000000000045EA3" data-uri="chapter09.xhtml#P7000497027000000000000000045EA3" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre41">Goal 1: Maximizing throughput.</span> Given some sequence of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> allocate and free requests</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000045EA4" data-uri="chapter09.xhtml#P7000497027000000000000000045EA4"><m:math display="block" alttext="" data-uri="" altimg-width="228" altimg-height="19" altimg="../images/ch09-eq6.png"><m:mrow><m:msub><m:mi>R</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mi>k</m:mi></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:math></div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045EA5" data-uri="chapter09.xhtml#P7000497027000000000000000045EA5">we would like to maximize an allocator's <i class="pcalibre17 pcalibre2 pcalibre1">throughput</i>, which is defined as the number of requests that it completes per unit time. For example, if an allocator completes 500 allocate requests and 500 free requests in 1 second, then its throughput is 1,000 operations per second. In general, we can maximize throughput by minimizing the average time to satisfy allocate and free requests. As we'll see, it is not too difficult to develop allocators with reasonably good performance where the worst-case running time of an allocate request is linear in the number of free blocks and the running time of a free request is constant.</p>
<p id="P7000497027000000000000000045EA6" data-uri="chapter09.xhtml#P7000497027000000000000000045EA6" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre41">Goal 2: Maximizing memory utilization.</span> Naive programmers often incorrectly assume that virtual memory is an unlimited resource. In fact, the total amount of virtual memory allocated by all of the processes in a system is limited by the amount of swap space on disk. Good programmers know that virtual memory is a finite resource that must be used efficiently. This is especially true for a dynamic memory allocator that might be asked to allocate and free large blocks of memory.</p>
<p id="P7000497027000000000000000045EA7" data-uri="chapter09.xhtml#P7000497027000000000000000045EA7" class="pcalibre8 pcalibre1 pcalibre2">There are a number of ways to characterize how efficiently an allocator uses the heap. In our experience, the most useful metric is <i class="pcalibre17 pcalibre2 pcalibre1">peak utilization.</i> As before, we are given some sequence of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> allocate and free requests</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000045EA8" data-uri="chapter09.xhtml#P7000497027000000000000000045EA8"><m:math display="block" alttext="" data-uri="" altimg-width="228" altimg-height="19" altimg="../images/ch09-eq7.png"><m:mrow><m:msub><m:mi>R</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mi>k</m:mi></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:math></div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045EA9" data-uri="chapter09.xhtml#P7000497027000000000000000045EA9">If an application requests a block of <var class="pcalibre17 pcalibre2 pcalibre1">p</var> bytes, then the resulting allocated block has a <i class="pcalibre17 pcalibre2 pcalibre1">payload</i> of <var class="pcalibre17 pcalibre2 pcalibre1">p</var> bytes. After request <i class="pcalibre17 pcalibre2 pcalibre1">R<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> has completed, let the <i class="pcalibre17 pcalibre2 pcalibre1">aggregate payload</i>, denoted <i class="pcalibre17 pcalibre2 pcalibre1">P<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i>, be the sum of the pay loads of the currently allocated blocks, and let <i class="pcalibre17 pcalibre2 pcalibre1">H<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> denote the current (monotonically nondecreasing) size of the heap.</p>
<p id="P7000497027000000000000000045EAA" data-uri="chapter09.xhtml#P7000497027000000000000000045EAA" class="pcalibre8 pcalibre1 pcalibre2">Then the peak utilization over the first <var class="pcalibre17 pcalibre2 pcalibre1">k</var> + 1 requests, denoted by <i class="pcalibre17 pcalibre2 pcalibre1">U<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i>, is given by</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000045EAB" data-uri="chapter09.xhtml#P7000497027000000000000000045EAB"><m:math display="block" alttext="" data-uri="" altimg-width="139" altimg-height="51" altimg="../images/ch09-eq8.png"><m:mrow><m:msub><m:mi>U</m:mi><m:mi>k</m:mi></m:msub><m:mo>=</m:mo><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>max</m:mi></m:mrow><m:mrow><m:mi>i</m:mi><m:mo>≤</m:mo><m:mi>k</m:mi></m:mrow></m:msub><m:mtext> </m:mtext><m:msub><m:mi>P</m:mi><m:mi>i</m:mi></m:msub></m:mrow><m:mrow><m:msub><m:mi>H</m:mi><m:mi>k</m:mi></m:msub></m:mrow></m:mfrac></m:mrow></m:math></div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045EAC" data-uri="chapter09.xhtml#P7000497027000000000000000045EAC">The objective of the allocator, then, is to maximize the peak utilization <var class="pcalibre17 pcalibre2 pcalibre1">U</var><sub class="pcalibre1 pcalibre2 calibre14"><var class="pcalibre17 pcalibre2 pcalibre1">n</var>–1</sub> over the entire sequence. As we will see, there is a tension between maximizing throughput and utilization. In particular, it is easy to write an allocator that maximizes throughput at the expense of heap utilization. One of the interesting challenges in any allocator design is finding an appropriate balance between the two goals.</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P70004970270000000000000000073D3" data-uri="chapter09.xhtml#P70004970270000000000000000073D3"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000045EAD" data-uri="chapter09.xhtml#P7000497027000000000000000045EAD" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000073D5" title="846" data-uri="chapter09.xhtml#P70004970270000000000000000073D5" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Relaxing the monotonicity assumption</h1></header>
<p id="P7000497027000000000000000045EAE" data-uri="chapter09.xhtml#P7000497027000000000000000045EAE" class="pcalibre1 pcalibre2 pcalibre10">We could relax the monotonically nondecreasing assumption in our definition of <i class="pcalibre17 pcalibre2 pcalibre1">U<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> and allow the heap to grow up and down by letting <i class="pcalibre17 pcalibre2 pcalibre1">H<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i> be the high-water mark over the first <var class="pcalibre17 pcalibre2 pcalibre1">k</var> + 1 requests.</p>
</aside>
</section>
<section id="P70004970270000000000000000073D7" data-uri="chapter09.xhtml#P70004970270000000000000000073D7" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045EAF" data-uri="chapter09.xhtml#P7000497027000000000000000045EAF" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.4 </span>Fragmentation</h1></header>
<p id="P7000497027000000000000000045EB0" data-uri="chapter09.xhtml#P7000497027000000000000000045EB0" class="pcalibre8 pcalibre1 pcalibre2">The primary cause of poor heap utilization is a phenomenon known as <i class="pcalibre17 pcalibre2 pcalibre1">fragmentation</i>, which occurs when otherwise unused memory is not available to satisfy allocate requests. There are two forms of fragmentation: <i class="pcalibre17 pcalibre2 pcalibre1">internal fragmentation</i> and <i class="pcalibre17 pcalibre2 pcalibre1">external fragmentation.</i></p>
<p id="P7000497027000000000000000045EB1" data-uri="chapter09.xhtml#P7000497027000000000000000045EB1" class="pcalibre8 pcalibre1 pcalibre2"><i class="pcalibre17 pcalibre2 pcalibre1">Internal fragmentation</i> occurs when an allocated block is larger than the pay-load. This might happen for a number of reasons. For example, the implementation of an allocator might impose a minimum size on allocated blocks that is greater than some requested payload. Or, as we saw in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000738C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.34(b)</span></a>, the allocator might increase the block size in order to satisfy alignment constraints.</p>
<p id="P7000497027000000000000000045EB2" data-uri="chapter09.xhtml#P7000497027000000000000000045EB2" class="pcalibre8 pcalibre1 pcalibre2">Internal fragmentation is straightforward to quantify. It is simply the sum of the differences between the sizes of the allocated blocks and their payloads. Thus, at any point in time, the amount of internal fragmentation depends only on the pattern of previous requests and the allocator implementation.</p>
<p id="P7000497027000000000000000045EB3" data-uri="chapter09.xhtml#P7000497027000000000000000045EB3" class="pcalibre8 pcalibre1 pcalibre2"><i class="pcalibre17 pcalibre2 pcalibre1">External fragmentation</i> occurs when there <i class="pcalibre17 pcalibre2 pcalibre1">is</i> enough aggregate free memory to satisfy an allocate request, but no single free block is large enough to handle the request. For example, if the request in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000738C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.34(e)</span></a> were for eight words rather than two words, then the request could not be satisfied without requesting additional virtual memory from the kernel, even though there are eight free words remaining in the heap. The problem arises because these eight words are spread over two free blocks.</p>
<p id="P7000497027000000000000000045EB4" data-uri="chapter09.xhtml#P7000497027000000000000000045EB4" class="pcalibre8 pcalibre1 pcalibre2">External fragmentation is much more difficult to quantify than internal fragmentation because it depends not only on the pattern of previous requests and the allocator implementation but also on the pattern of <i class="pcalibre17 pcalibre2 pcalibre1">future</i> requests. For example, suppose that after <var class="pcalibre17 pcalibre2 pcalibre1">k</var> requests all of the free blocks are exactly four words in size. Does this heap suffer from external fragmentation? The answer depends on the pattern of future requests. If all of the future allocate requests are for blocks that are smaller than or equal to four words, then there is no external fragmentation. On the other hand, if one or more requests ask for blocks larger than four words, then the heap does suffer from external fragmentation.</p>
<p id="P7000497027000000000000000045EB5" data-uri="chapter09.xhtml#P7000497027000000000000000045EB5" class="pcalibre8 pcalibre1 pcalibre2">Since external fragmentation is difficult to quantify and impossible to predict, allocators typically employ heuristics that attempt to maintain small numbers of larger free blocks rather than large numbers of smaller free blocks.</p>
</section>
<section id="P70004970270000000000000000073DF" data-uri="chapter09.xhtml#P70004970270000000000000000073DF" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045EB6" data-uri="chapter09.xhtml#P7000497027000000000000000045EB6" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.5 </span>Implementation Issues</h1></header>
<p id="P7000497027000000000000000045EB7" data-uri="chapter09.xhtml#P7000497027000000000000000045EB7" class="pcalibre8 pcalibre1 pcalibre2">The simplest imaginable allocator would organize the heap as a large array of bytes and a pointer <code id="P7000497027000000000000000045EB8" data-uri="chapter09.xhtml#P7000497027000000000000000045EB8" class="pcalibre1 calibre1 pcalibre2">p</code> that initially points to the first byte of the array. To allocate <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000073E3" title="847" data-uri="chapter09.xhtml#P70004970270000000000000000073E3" epub:type="pagebreak"></span><code id="P7000497027000000000000000045EB9" data-uri="chapter09.xhtml#P7000497027000000000000000045EB9" class="pcalibre1 calibre1 pcalibre2">size</code> bytes, <code id="P7000497027000000000000000045EBA" data-uri="chapter09.xhtml#P7000497027000000000000000045EBA" class="pcalibre1 calibre1 pcalibre2">malloc</code> would save the current value of <code id="P7000497027000000000000000045EBB" data-uri="chapter09.xhtml#P7000497027000000000000000045EBB" class="pcalibre1 calibre1 pcalibre2">p</code> on the stack, increment <code id="P7000497027000000000000000045EBC" data-uri="chapter09.xhtml#P7000497027000000000000000045EBC" class="pcalibre1 calibre1 pcalibre2">p</code> by <code id="P7000497027000000000000000045EBD" data-uri="chapter09.xhtml#P7000497027000000000000000045EBD" class="pcalibre1 calibre1 pcalibre2">size</code>, and return the old value of <code id="P7000497027000000000000000045EBE" data-uri="chapter09.xhtml#P7000497027000000000000000045EBE" class="pcalibre1 calibre1 pcalibre2">p</code> to the caller. <code id="P7000497027000000000000000045EBF" data-uri="chapter09.xhtml#P7000497027000000000000000045EBF" class="pcalibre1 calibre1 pcalibre2">Free</code> would simply return to the caller without doing anything.</p>
<p id="P7000497027000000000000000045EC0" data-uri="chapter09.xhtml#P7000497027000000000000000045EC0" class="pcalibre8 pcalibre1 pcalibre2">This naive allocator is an extreme point in the design space. Since each <code id="P7000497027000000000000000045EC1" data-uri="chapter09.xhtml#P7000497027000000000000000045EC1" class="pcalibre1 calibre1 pcalibre2">malloc</code> and <code id="P7000497027000000000000000045EC2" data-uri="chapter09.xhtml#P7000497027000000000000000045EC2" class="pcalibre1 calibre1 pcalibre2">free</code> execute only a handful of instructions, throughput would be extremely good. However, since the allocator never reuses any blocks, memory utilization would be extremely bad. A practical allocator that strikes a better balance between throughput and utilization must consider the following issues:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P7000497027000000000000000045EC3" data-uri="chapter09.xhtml#P7000497027000000000000000045EC3">
<li id="P7000497027000000000000000045EC4" data-uri="chapter09.xhtml#P7000497027000000000000000045EC4" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045EC5" data-uri="chapter09.xhtml#P7000497027000000000000000045EC5" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Free block organization. </span>How do we keep track of free blocks?</p></li>
<li id="P7000497027000000000000000045EC6" data-uri="chapter09.xhtml#P7000497027000000000000000045EC6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045EC7" data-uri="chapter09.xhtml#P7000497027000000000000000045EC7" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Placement. </span>How do we choose an appropriate free block in which to place a newly allocated block?</p></li>
<li id="P7000497027000000000000000045EC8" data-uri="chapter09.xhtml#P7000497027000000000000000045EC8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045EC9" data-uri="chapter09.xhtml#P7000497027000000000000000045EC9" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Splitting. </span>After we place a newly allocated block in some free block, what do we do with the remainder of the free block?</p></li>
<li id="P7000497027000000000000000045ECA" data-uri="chapter09.xhtml#P7000497027000000000000000045ECA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045ECB" data-uri="chapter09.xhtml#P7000497027000000000000000045ECB" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Coalescing. </span>What do we do with a block that has just been freed?</p></li>
</ul>
<p id="P7000497027000000000000000045ECC" data-uri="chapter09.xhtml#P7000497027000000000000000045ECC" class="pcalibre8 pcalibre1 pcalibre2">The rest of this section looks at these issues in more detail. Since the basic techniques of placement, splitting, and coalescing cut across many different free block organizations, we will introduce them in the context of a simple free block organization known as an implicit free list.</p>
</section>
<section id="P70004970270000000000000000073F8" data-uri="chapter09.xhtml#P70004970270000000000000000073F8" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045ECD" data-uri="chapter09.xhtml#P7000497027000000000000000045ECD" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.6 </span>Implicit Free Lists</h1></header>
<p id="P7000497027000000000000000045ECE" data-uri="chapter09.xhtml#P7000497027000000000000000045ECE" class="pcalibre8 pcalibre1 pcalibre2">Any practical allocator needs some data structure that allows it to distinguish block boundaries and to distinguish between allocated and free blocks. Most allocators embed this information in the blocks themselves. One simple approach is shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000073FC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.35</span></a>.</p>
<p id="P7000497027000000000000000045ECF" data-uri="chapter09.xhtml#P7000497027000000000000000045ECF" class="pcalibre8 pcalibre1 pcalibre2">In this case, a block consists of a one-word <i class="pcalibre17 pcalibre2 pcalibre1">header</i>, the payload, and possibly some additional <i class="pcalibre17 pcalibre2 pcalibre1">padding.</i> The header encodes the block size (including the header and any padding) as well as whether the block is allocated or free. If we impose a double-word alignment constraint, then the block size is always a multiple of 8 and the 3 low-order bits of the block size are always zero. Thus, we need to store only the 29 high-order bits of the block size, freeing the remaining 3 bits to encode other information. In this case, we are using the least significant of these bits</p>
<figure id="P70004970270000000000000000073FC" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000073FC">
<img alt="A diagram illustrates the format of a simple heap block." id="P7000497027000000000000000045ED0" data-uri="P700049702700000000000000000B79E" src="../images/p847-1.png" class="pcalibre281 pcalibre2 pcalibre1"/>
<figcaption id="P7000497027000000000000000045ED1" data-uri="chapter09.xhtml#P7000497027000000000000000045ED1" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045ED2" data-uri="chapter09.xhtml#P7000497027000000000000000045ED2" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.35 </span>Format of a simple heap block.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000026224" data-uri="chapter09.xhtml#P7000497027000000000000000026224">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045ED3" data-uri="chapter09.xhtml#P7000497027000000000000000045ED3" class="pcalibre8 pcalibre1 pcalibre2">A diagram has three sections, each from 31 to 0 bits, from top to bottom as follows:</p>
<ul id="P7000497027000000000000000045ED4" data-uri="chapter09.xhtml#P7000497027000000000000000045ED4" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000045ED5" data-uri="chapter09.xhtml#P7000497027000000000000000045ED5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045ED6" data-uri="chapter09.xhtml#P7000497027000000000000000045ED6" class="pcalibre1 pcalibre2 pcalibre10">Header: block size from bit 31 to 3, with 0 under bits 2 and 1 and a under bit 0 (a = 1: Allocated; a = 0: Free)</p></li>
<li id="P7000497027000000000000000045ED7" data-uri="chapter09.xhtml#P7000497027000000000000000045ED7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045ED8" data-uri="chapter09.xhtml#P7000497027000000000000000045ED8" class="pcalibre1 pcalibre2 pcalibre10">Payload (allocated block only); malloc returns a pointer to the beginning of the payload</p></li>
<li id="P7000497027000000000000000045ED9" data-uri="chapter09.xhtml#P7000497027000000000000000045ED9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045EDA" data-uri="chapter09.xhtml#P7000497027000000000000000045EDA" class="pcalibre1 pcalibre2 pcalibre10">Padding (optional)</p></li>
</ul>
</details>
</figcaption>
</figure>
<figure id="P7000497027000000000000000007400" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P7000497027000000000000000007400">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007401" title="848" data-uri="chapter09.xhtml#P7000497027000000000000000007401" epub:type="pagebreak"></span>
<img alt="A diagram illustrates organizing the heap with an implicit free list." id="P7000497027000000000000000045EDB" data-uri="P700049702700000000000000000B79F" src="../images/p848-1.png" class="pcalibre1 pcalibre282 pcalibre2"/>
<figcaption id="P7000497027000000000000000045EDC" data-uri="chapter09.xhtml#P7000497027000000000000000045EDC" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045EDD" data-uri="chapter09.xhtml#P7000497027000000000000000045EDD" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.36 </span>Organizing the heap with an implicit free list.</h1></header><div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000045EDE" data-uri="chapter09.xhtml#P7000497027000000000000000045EDE"><p id="P7000497027000000000000000045EDF" data-uri="chapter09.xhtml#P7000497027000000000000000045EDF" class="pcalibre1 pcalibre2 pcalibre10">Allocated blocks are shaded. Free blocks are unshaded. Headers are labeled with (size (bytes)/allocated bit).</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000026232" data-uri="chapter09.xhtml#P7000497027000000000000000026232">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045EE0" data-uri="chapter09.xhtml#P7000497027000000000000000045EE0" class="pcalibre8 pcalibre1 pcalibre2">A diagram has a row of shaded and unshaded blocks, from start of heap on the left to double-word aligned on the right. Arrows jump between groups of shaded blocks. The blocks are summarized from left to right below.</p>
<ul id="P7000497027000000000000000045EE1" data-uri="chapter09.xhtml#P7000497027000000000000000045EE1" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000045EE2" data-uri="chapter09.xhtml#P7000497027000000000000000045EE2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045EE3" data-uri="chapter09.xhtml#P7000497027000000000000000045EE3" class="pcalibre1 pcalibre2 pcalibre10">Shaded, labeled unused</p></li>
<li id="P7000497027000000000000000045EE4" data-uri="chapter09.xhtml#P7000497027000000000000000045EE4" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045EE5" data-uri="chapter09.xhtml#P7000497027000000000000000045EE5" class="pcalibre1 pcalibre2 pcalibre10">Two unshaded, first labeled 8/0</p></li>
<li id="P7000497027000000000000000045EE6" data-uri="chapter09.xhtml#P7000497027000000000000000045EE6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045EE7" data-uri="chapter09.xhtml#P7000497027000000000000000045EE7" class="pcalibre1 pcalibre2 pcalibre10">Four shaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045EE8" data-uri="chapter09.xhtml#P7000497027000000000000000045EE8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045EE9" data-uri="chapter09.xhtml#P7000497027000000000000000045EE9" class="pcalibre1 pcalibre2 pcalibre10">Eight unshaded, first labeled 32/0</p></li>
<li id="P7000497027000000000000000045EEA" data-uri="chapter09.xhtml#P7000497027000000000000000045EEA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045EEB" data-uri="chapter09.xhtml#P7000497027000000000000000045EEB" class="pcalibre1 pcalibre2 pcalibre10">Five shaded, first labeled 16/1 and last labeled 0/1</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045EEC" data-uri="chapter09.xhtml#P7000497027000000000000000045EEC">(the <i class="pcalibre17 pcalibre2 pcalibre1">allocated bit)</i> to indicate whether the block is allocated or free. For example, suppose we have an allocated block with a block size of 24 (<code id="P7000497027000000000000000045EED" data-uri="chapter09.xhtml#P7000497027000000000000000045EED" class="pcalibre1 calibre1 pcalibre2">0x18</code>) bytes. Then its header would be</p>
<pre id="P7000497027000000000000000045EEE" data-uri="chapter09.xhtml#P7000497027000000000000000045EEE" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045EEF" data-uri="chapter09.xhtml#P7000497027000000000000000045EEF" class="calibre3 pcalibre1 pcalibre2">
0x00000018 | 0x1 = 0x00000019
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045EF0" data-uri="chapter09.xhtml#P7000497027000000000000000045EF0">Similarly, a free block with a block size of 40 (<code id="P7000497027000000000000000045EF1" data-uri="chapter09.xhtml#P7000497027000000000000000045EF1" class="pcalibre1 calibre1 pcalibre2">0x28</code>) bytes would have a header of</p>
<pre id="P7000497027000000000000000045EF2" data-uri="chapter09.xhtml#P7000497027000000000000000045EF2" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045EF3" data-uri="chapter09.xhtml#P7000497027000000000000000045EF3" class="calibre3 pcalibre1 pcalibre2">
0x00000028 | 0x0 = 0x00000028
</code></pre>
<p id="P7000497027000000000000000045EF4" data-uri="chapter09.xhtml#P7000497027000000000000000045EF4" class="pcalibre8 pcalibre1 pcalibre2">The header is followed by the payload that the application requested when it called <code id="P7000497027000000000000000045EF5" data-uri="chapter09.xhtml#P7000497027000000000000000045EF5" class="pcalibre1 calibre1 pcalibre2">malloc</code>. The payload is followed by a chunk of unused padding that can be any size. There are a number of reasons for the padding. For example, the padding might be part of an allocator's strategy for combating external fragmentation. Or it might be needed to satisfy the alignment requirement.</p>
<p id="P7000497027000000000000000045EF6" data-uri="chapter09.xhtml#P7000497027000000000000000045EF6" class="pcalibre8 pcalibre1 pcalibre2">Given the block format in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000073FC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.35</span></a>, we can organize the heap as a sequence of contiguous allocated and free blocks, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007400"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.36</span></a>.</p>
<p id="P7000497027000000000000000045EF7" data-uri="chapter09.xhtml#P7000497027000000000000000045EF7" class="pcalibre8 pcalibre1 pcalibre2">We call this organization an <i class="pcalibre17 pcalibre2 pcalibre1">implicit free list</i> because the free blocks are linked implicitly by the size fields in the headers. The allocator can indirectly traverse the entire set of free blocks by traversing <i class="pcalibre17 pcalibre2 pcalibre1">all</i> of the blocks in the heap. Notice that we need some kind of specially marked end block—in this example, a terminating header with the allocated bit set and a size of zero. (As we will see in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000748F"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">9.9.12</span></a>, setting the allocated bit simplifies the coalescing of free blocks.)</p>
<p id="P7000497027000000000000000045EF8" data-uri="chapter09.xhtml#P7000497027000000000000000045EF8" class="pcalibre8 pcalibre1 pcalibre2">The advantage of an implicit free list is simplicity. A significant disadvantage is that the cost of any operation that requires a search of the free list, such as placing allocated blocks, will be linear in the <i class="pcalibre17 pcalibre2 pcalibre1">total</i> number of allocated and free blocks in the heap.</p>
<p id="P7000497027000000000000000045EF9" data-uri="chapter09.xhtml#P7000497027000000000000000045EF9" class="pcalibre8 pcalibre1 pcalibre2">It is important to realize that the system's alignment requirement and the allocator's choice of block format impose a <i class="pcalibre17 pcalibre2 pcalibre1">minimum block size</i> on the allocator. No allocated or free block may be smaller than this minimum. For example, if we assume a double-word alignment requirement, then the size of each block must be a multiple of two words (8 bytes). Thus, the block format in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000073FC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.35</span></a> induces a minimum block size of two words: one word for the header and another to maintain the alignment requirement. Even if the application were to request a single byte, the allocator would still create a two-word block.</p>
<section id="P7000497027000000000000000007415" data-uri="chapter09.xhtml#P7000497027000000000000000007415" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000045EFA" data-uri="chapter09.xhtml#P7000497027000000000000000045EFA" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007417" title="849" data-uri="chapter09.xhtml#P7000497027000000000000000007417" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">9.6 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P700049702700000000000000000780C">883</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000045EFB" data-uri="chapter09.xhtml#P7000497027000000000000000045EFB">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000045EFC" data-uri="chapter09.xhtml#P7000497027000000000000000045EFC">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000045EFD" data-uri="chapter09.xhtml#P7000497027000000000000000045EFD"><p id="P7000497027000000000000000045EFE" data-uri="chapter09.xhtml#P7000497027000000000000000045EFE" class="pcalibre1 pcalibre2 pcalibre10">Determine the block sizes and header values that would result from the following sequence of <code id="P7000497027000000000000000045EFF" data-uri="chapter09.xhtml#P7000497027000000000000000045EFF" class="pcalibre1 calibre1 pcalibre2">malloc</code> requests. Assumptions: (1) The allocator maintains double-word alignment and uses an implicit free list with the block format from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000073FC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.35</span></a>. (2) Block sizes are rounded up to the nearest multiple of 8 bytes.</p>
<table id="P7000497027000000000000000045F00" data-uri="chapter09.xhtml#P7000497027000000000000000045F00" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000045F01" data-uri="chapter09.xhtml#P7000497027000000000000000045F01" class="pcalibre1 pcalibre2 calibre5">Request</th>
<th id="P7000497027000000000000000045F02" data-uri="chapter09.xhtml#P7000497027000000000000000045F02" class="pcalibre1 pcalibre2 calibre5">Block size (decimal bytes)</th>
<th id="P7000497027000000000000000045F03" data-uri="chapter09.xhtml#P7000497027000000000000000045F03" class="pcalibre1 pcalibre2 calibre5">Block header (hex)</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000045F04" data-uri="chapter09.xhtml#P7000497027000000000000000045F04" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000045F05" data-uri="chapter09.xhtml#P7000497027000000000000000045F05" class="calibre3 pcalibre1 pcalibre2">malloc(1)</code></td>
<td id="P7000497027000000000000000045F06" data-uri="chapter09.xhtml#P7000497027000000000000000045F06" class="pcalibre1 pcalibre2 calibre7">_____</td>
<td id="P7000497027000000000000000045F07" data-uri="chapter09.xhtml#P7000497027000000000000000045F07" class="pcalibre1 pcalibre2 calibre7">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000045F08" data-uri="chapter09.xhtml#P7000497027000000000000000045F08" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000045F09" data-uri="chapter09.xhtml#P7000497027000000000000000045F09" class="calibre3 pcalibre1 pcalibre2">malloc(5)</code></td>
<td id="P7000497027000000000000000045F0A" data-uri="chapter09.xhtml#P7000497027000000000000000045F0A" class="pcalibre1 pcalibre2 calibre7">_____</td>
<td id="P7000497027000000000000000045F0B" data-uri="chapter09.xhtml#P7000497027000000000000000045F0B" class="pcalibre1 pcalibre2 calibre7">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000045F0C" data-uri="chapter09.xhtml#P7000497027000000000000000045F0C" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000045F0D" data-uri="chapter09.xhtml#P7000497027000000000000000045F0D" class="calibre3 pcalibre1 pcalibre2">malloc(12)</code></td>
<td id="P7000497027000000000000000045F0E" data-uri="chapter09.xhtml#P7000497027000000000000000045F0E" class="pcalibre1 pcalibre2 calibre7">_____</td>
<td id="P7000497027000000000000000045F0F" data-uri="chapter09.xhtml#P7000497027000000000000000045F0F" class="pcalibre1 pcalibre2 calibre7">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000045F10" data-uri="chapter09.xhtml#P7000497027000000000000000045F10" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000045F11" data-uri="chapter09.xhtml#P7000497027000000000000000045F11" class="calibre3 pcalibre1 pcalibre2">malloc(13)</code></td>
<td id="P7000497027000000000000000045F12" data-uri="chapter09.xhtml#P7000497027000000000000000045F12" class="pcalibre1 pcalibre2 calibre7">_____</td>
<td id="P7000497027000000000000000045F13" data-uri="chapter09.xhtml#P7000497027000000000000000045F13" class="pcalibre1 pcalibre2 calibre7">_____</td>
</tr>
</tbody>
</table>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000007431" data-uri="chapter09.xhtml#P7000497027000000000000000007431" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045F14" data-uri="chapter09.xhtml#P7000497027000000000000000045F14" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.7 </span>Placing Allocated Blocks</h1></header>
<p id="P7000497027000000000000000045F15" data-uri="chapter09.xhtml#P7000497027000000000000000045F15" class="pcalibre8 pcalibre1 pcalibre2">When an application requests a block of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> bytes, the allocator searches the free list for a free block that is large enough to hold the requested block. The manner in which the allocator performs this search is determined by the <i class="pcalibre17 pcalibre2 pcalibre1">placement policy.</i> Some common policies are first fit, next fit, and best fit.</p>
<p id="P7000497027000000000000000045F16" data-uri="chapter09.xhtml#P7000497027000000000000000045F16" class="pcalibre8 pcalibre1 pcalibre2"><i class="pcalibre17 pcalibre2 pcalibre1">First fit</i> searches the free list from the beginning and chooses the first free block that fits. <i class="pcalibre17 pcalibre2 pcalibre1">Next fit</i> is similar to first fit, but instead of starting each search at the beginning of the list, it starts each search where the previous search left off. <i class="pcalibre17 pcalibre2 pcalibre1">Best fit</i> examines every free block and chooses the free block with the smallest size that fits.</p>
<p id="P7000497027000000000000000045F17" data-uri="chapter09.xhtml#P7000497027000000000000000045F17" class="pcalibre8 pcalibre1 pcalibre2">An advantage of first fit is that it tends to retain large free blocks at the end of the list. A disadvantage is that it tends to leave "splinters" of small free blocks toward the beginning of the list, which will increase the search time for larger blocks. Next fit was first proposed by Donald Knuth as an alternative to first fit, motivated by the idea that if we found a fit in some free block the last time, there is a good chance that we will find a fit the next time in the remainder of the block. Next fit can run significantly faster than first fit, especially if the front of the list becomes littered with many small splinters. However, some studies suggest that next fit suffers from worse memory utilization than first fit. Studies have found that best fit generally enjoys better memory utilization than either first fit or next fit. However, the disadvantage of using best fit with simple free list organizations such as the implicit free list is that it requires an exhaustive search of the heap. Later, we will look at more sophisticated segregated free list organizations that approximate a best-fit policy without an exhaustive search of the heap.</p>
</section>
<section id="P7000497027000000000000000007436" data-uri="chapter09.xhtml#P7000497027000000000000000007436" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045F18" data-uri="chapter09.xhtml#P7000497027000000000000000045F18" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.8 </span>Splitting Free Blocks</h1></header>
<p id="P7000497027000000000000000045F19" data-uri="chapter09.xhtml#P7000497027000000000000000045F19" class="pcalibre8 pcalibre1 pcalibre2">Once the allocator has located a free block that fits, it must make another policy decision about how much of the free block to allocate. One option is to use the entire free block. Although simple and fast, the main disadvantage is that it</p>
<figure id="P7000497027000000000000000007439" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P7000497027000000000000000007439">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000743A" title="850" data-uri="chapter09.xhtml#P700049702700000000000000000743A" epub:type="pagebreak"></span>
<img alt="A diagram illustrates splitting a free block to satisfy a three-word allocation request." id="P7000497027000000000000000045F1A" data-uri="P700049702700000000000000000B7A1" src="../images/p850-1.png" class="pcalibre1 pcalibre2 pcalibre283"/>
<figcaption id="P7000497027000000000000000045F1B" data-uri="chapter09.xhtml#P7000497027000000000000000045F1B" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045F1C" data-uri="chapter09.xhtml#P7000497027000000000000000045F1C" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.37 </span>Splitting a free block to satisfy a three-word allocation request.</h1></header><div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000045F1D" data-uri="chapter09.xhtml#P7000497027000000000000000045F1D"><p id="P7000497027000000000000000045F1E" data-uri="chapter09.xhtml#P7000497027000000000000000045F1E" class="pcalibre1 pcalibre2 pcalibre10">Allocated blocks are shaded. Free blocks are unshaded. Headers are labeled with (size (bytes)/allocated bit).</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000026272" data-uri="chapter09.xhtml#P7000497027000000000000000026272">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045F1F" data-uri="chapter09.xhtml#P7000497027000000000000000045F1F" class="pcalibre8 pcalibre1 pcalibre2">A diagram has a row of shaded and unshaded blocks, from start of heap on the left to double-word aligned on the right. Arrows jump between groups of shaded blocks. The blocks are summarized from left to right below.</p>
<ul id="P7000497027000000000000000045F20" data-uri="chapter09.xhtml#P7000497027000000000000000045F20" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000045F21" data-uri="chapter09.xhtml#P7000497027000000000000000045F21" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F22" data-uri="chapter09.xhtml#P7000497027000000000000000045F22" class="pcalibre1 pcalibre2 pcalibre10">Shaded, labeled unused</p></li>
<li id="P7000497027000000000000000045F23" data-uri="chapter09.xhtml#P7000497027000000000000000045F23" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F24" data-uri="chapter09.xhtml#P7000497027000000000000000045F24" class="pcalibre1 pcalibre2 pcalibre10">Two unshaded, first labeled 8/0</p></li>
<li id="P7000497027000000000000000045F25" data-uri="chapter09.xhtml#P7000497027000000000000000045F25" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F26" data-uri="chapter09.xhtml#P7000497027000000000000000045F26" class="pcalibre1 pcalibre2 pcalibre10">Four shaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045F27" data-uri="chapter09.xhtml#P7000497027000000000000000045F27" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F28" data-uri="chapter09.xhtml#P7000497027000000000000000045F28" class="pcalibre1 pcalibre2 pcalibre10">Four shaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045F29" data-uri="chapter09.xhtml#P7000497027000000000000000045F29" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F2A" data-uri="chapter09.xhtml#P7000497027000000000000000045F2A" class="pcalibre1 pcalibre2 pcalibre10">Four unshaded, first labeled 16/0</p></li>
<li id="P7000497027000000000000000045F2B" data-uri="chapter09.xhtml#P7000497027000000000000000045F2B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F2C" data-uri="chapter09.xhtml#P7000497027000000000000000045F2C" class="pcalibre1 pcalibre2 pcalibre10">Five shaded, first labeled 16/1 and last labeled 0/1</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045F2D" data-uri="chapter09.xhtml#P7000497027000000000000000045F2D">introduces internal fragmentation. If the placement policy tends to produce good fits, then some additional internal fragmentation might be acceptable.</p>
<p id="P7000497027000000000000000045F2E" data-uri="chapter09.xhtml#P7000497027000000000000000045F2E" class="pcalibre8 pcalibre1 pcalibre2">However, if the fit is not good, then the allocator will usually opt to <i class="pcalibre17 pcalibre2 pcalibre1">split</i> the free block into two parts. The first part becomes the allocated block, and the remainder becomes a new free block. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007439"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.37</span></a> shows how the allocator might split the eight-word free block in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007400"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.36</span></a> to satisfy an application's request for three words of heap memory.</p>
</section>
<section id="P7000497027000000000000000007442" data-uri="chapter09.xhtml#P7000497027000000000000000007442" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045F2F" data-uri="chapter09.xhtml#P7000497027000000000000000045F2F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.9 </span>Getting Additional Heap Memory</h1></header>
<p id="P7000497027000000000000000045F30" data-uri="chapter09.xhtml#P7000497027000000000000000045F30" class="pcalibre8 pcalibre1 pcalibre2">What happens if the allocator is unable to find a fit for the requested block? One option is to try to create some larger free blocks by merging (coalescing) free blocks that are physically adjacent in memory (next section). However, if this does not yield a sufficiently large block, or if the free blocks are already maximally coalesced, then the allocator asks the kernel for additional heap memory by calling the <code id="P7000497027000000000000000045F31" data-uri="chapter09.xhtml#P7000497027000000000000000045F31" class="pcalibre1 calibre1 pcalibre2">sbrk</code> function. The allocator transforms the additional memory into one large free block, inserts the block into the free list, and then places the requested block in this new free block.</p>
</section>
<section id="P7000497027000000000000000007446" data-uri="chapter09.xhtml#P7000497027000000000000000007446" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045F32" data-uri="chapter09.xhtml#P7000497027000000000000000045F32" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.10 </span>Coalescing Free Blocks</h1></header>
<p id="P7000497027000000000000000045F33" data-uri="chapter09.xhtml#P7000497027000000000000000045F33" class="pcalibre8 pcalibre1 pcalibre2">When the allocator frees an allocated block, there might be other free blocks that are adjacent to the newly freed block. Such adjacent free blocks can cause a phenomenon known as, <i class="pcalibre17 pcalibre2 pcalibre1">false fragmentation</i>, where there is a lot of available free memory chopped up into small, unusable free blocks. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000744A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.38</span></a> shows the result of freeing the block that was allocated in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007439"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.37</span></a>. The result is two adjacent free blocks with payloads of three words each. As a result, a subsequent request for a payload of four words would fail, even though the aggregate size of the two free blocks is large enough to satisfy the request.</p>
<p id="P7000497027000000000000000045F34" data-uri="chapter09.xhtml#P7000497027000000000000000045F34" class="pcalibre8 pcalibre1 pcalibre2">To combat false fragmentation, any practical allocator must merge adjacent free blocks in a process known as <i class="pcalibre17 pcalibre2 pcalibre1">coalescing.</i> This raises an important policy decision about when to perform coalescing. The allocator can opt for <i class="pcalibre17 pcalibre2 pcalibre1">immediate coalescing</i> by merging any adjacent blocks each time a block is freed. Or it can opt for <i class="pcalibre17 pcalibre2 pcalibre1">deferred coalescing</i> by waiting to coalesce free blocks at some later time. For example, the allocator might defer coalescing until some allocation request fails, and then scan the entire heap, coalescing all free blocks.</p>
<figure id="P700049702700000000000000000744A" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P700049702700000000000000000744A">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000744B" title="851" data-uri="chapter09.xhtml#P700049702700000000000000000744B" epub:type="pagebreak"></span>
<img alt="A diagram illustrates an example of false fragmentation." id="P7000497027000000000000000045F35" data-uri="P700049702700000000000000000B7A2" src="../images/p851-1.png" class="pcalibre1 pcalibre2 pcalibre283"/>
<figcaption id="P7000497027000000000000000045F36" data-uri="chapter09.xhtml#P7000497027000000000000000045F36" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045F37" data-uri="chapter09.xhtml#P7000497027000000000000000045F37" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.38 </span>An example of false fragmentation.</h1></header><div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000045F38" data-uri="chapter09.xhtml#P7000497027000000000000000045F38"><p id="P7000497027000000000000000045F39" data-uri="chapter09.xhtml#P7000497027000000000000000045F39" class="pcalibre1 pcalibre2 pcalibre10">Allocated blocks are shaded. Free blocks are unshaded. Headers are labeled with (size (bytes)/allocated bit).</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P700049702700000000000000002628E" data-uri="chapter09.xhtml#P700049702700000000000000002628E">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045F3A" data-uri="chapter09.xhtml#P7000497027000000000000000045F3A" class="pcalibre8 pcalibre1 pcalibre2">A diagram has a row of shaded and unshaded blocks, from start of heap on the left to double-word aligned on the right. Arrows jump between groups of blocks. The blocks are summarized from left to right below.</p>
<ul id="P7000497027000000000000000045F3B" data-uri="chapter09.xhtml#P7000497027000000000000000045F3B" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000045F3C" data-uri="chapter09.xhtml#P7000497027000000000000000045F3C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F3D" data-uri="chapter09.xhtml#P7000497027000000000000000045F3D" class="pcalibre1 pcalibre2 pcalibre10">Shaded, labeled unused</p></li>
<li id="P7000497027000000000000000045F3E" data-uri="chapter09.xhtml#P7000497027000000000000000045F3E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F3F" data-uri="chapter09.xhtml#P7000497027000000000000000045F3F" class="pcalibre1 pcalibre2 pcalibre10">Two unshaded, first labeled 8/0</p></li>
<li id="P7000497027000000000000000045F40" data-uri="chapter09.xhtml#P7000497027000000000000000045F40" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F41" data-uri="chapter09.xhtml#P7000497027000000000000000045F41" class="pcalibre1 pcalibre2 pcalibre10">Four shaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045F42" data-uri="chapter09.xhtml#P7000497027000000000000000045F42" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F43" data-uri="chapter09.xhtml#P7000497027000000000000000045F43" class="pcalibre1 pcalibre2 pcalibre10">Four unshaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045F44" data-uri="chapter09.xhtml#P7000497027000000000000000045F44" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F45" data-uri="chapter09.xhtml#P7000497027000000000000000045F45" class="pcalibre1 pcalibre2 pcalibre10">Four unshaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045F46" data-uri="chapter09.xhtml#P7000497027000000000000000045F46" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F47" data-uri="chapter09.xhtml#P7000497027000000000000000045F47" class="pcalibre1 pcalibre2 pcalibre10">Five shaded, first labeled 16/1 and last labeled 0/1</p></li>
</ul>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000045F48" data-uri="chapter09.xhtml#P7000497027000000000000000045F48" class="pcalibre8 pcalibre1 pcalibre2">Immediate coalescing is straightforward and can be performed in constant time, but with some request patterns it can introduce a form of thrashing where a block is repeatedly coalesced and then split soon thereafter. For example, in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000744A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.38</span></a>, a repeated pattern of allocating and freeing a three-word block would introduce a lot of unnecessary splitting and coalescing. In our discussion of allocators, we will assume immediate coalescing, but you should be aware that fast allocators often opt for some form of deferred coalescing.</p>
</section>
<section id="P7000497027000000000000000007452" data-uri="chapter09.xhtml#P7000497027000000000000000007452" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045F49" data-uri="chapter09.xhtml#P7000497027000000000000000045F49" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.11 </span>Coalescing with Boundary Tags</h1></header>
<p id="P7000497027000000000000000045F4A" data-uri="chapter09.xhtml#P7000497027000000000000000045F4A" class="pcalibre8 pcalibre1 pcalibre2">How does an allocator implement coalescing? Let us refer to the block we want to free as the <i class="pcalibre17 pcalibre2 pcalibre1">current block.</i> Then coalescing the next free block (in memory) is straightforward and efficient. The header of the current block points to the header of the next block, which can be checked to determine if the next block is free. If so, its size is simply added to the size of the current header and the blocks are coalesced in constant time.</p>
<p id="P7000497027000000000000000045F4B" data-uri="chapter09.xhtml#P7000497027000000000000000045F4B" class="pcalibre8 pcalibre1 pcalibre2">But how would we coalesce the previous block? Given an implicit free list of blocks with headers, the only option would be to search the entire list, remembering the location of the previous block, until we reached the current block. With an implicit free list, this means that each call to free would require time linear in the size of the heap. Even with more sophisticated free list organizations, the search time would not be constant.</p>
<p id="P7000497027000000000000000045F4C" data-uri="chapter09.xhtml#P7000497027000000000000000045F4C" class="pcalibre8 pcalibre1 pcalibre2">Knuth developed a clever and general technique, known as <i class="pcalibre17 pcalibre2 pcalibre1">boundary tags</i>, that allows for constant-time coalescing of the previous block. The idea, which is shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007461"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.39</span></a>, is to add <i class="pcalibre17 pcalibre2 pcalibre1">&amp; footer</i> (the boundary tag) at the end of each block, where the footer is a replica of the header. If each block includes such a footer, then the allocator can determine the starting location and status of the previous block by inspecting its footer, which is always one word away from the start of the current block.</p>
<p id="P7000497027000000000000000045F4D" data-uri="chapter09.xhtml#P7000497027000000000000000045F4D" class="pcalibre8 pcalibre1 pcalibre2">Consider all the cases that can exist when the allocator frees the current block:</p>
<ol id="P7000497027000000000000000045F4E" data-uri="chapter09.xhtml#P7000497027000000000000000045F4E" class="pcalibre1 calibre19 pcalibre2">
<li id="P7000497027000000000000000045F4F" data-uri="chapter09.xhtml#P7000497027000000000000000045F4F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F50" data-uri="chapter09.xhtml#P7000497027000000000000000045F50" class="pcalibre1 pcalibre2 pcalibre10">The previous and next blocks are both allocated.</p></li>
<li id="P7000497027000000000000000045F51" data-uri="chapter09.xhtml#P7000497027000000000000000045F51" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F52" data-uri="chapter09.xhtml#P7000497027000000000000000045F52" class="pcalibre1 pcalibre2 pcalibre10">The previous block is allocated and the next block is free.</p></li>
<li id="P7000497027000000000000000045F53" data-uri="chapter09.xhtml#P7000497027000000000000000045F53" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F54" data-uri="chapter09.xhtml#P7000497027000000000000000045F54" class="pcalibre1 pcalibre2 pcalibre10">The previous block is free and the next block is allocated.</p></li>
<li id="P7000497027000000000000000045F55" data-uri="chapter09.xhtml#P7000497027000000000000000045F55" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F56" data-uri="chapter09.xhtml#P7000497027000000000000000045F56" class="pcalibre1 pcalibre2 pcalibre10">The previous and next blocks are both free.</p></li>
</ol>
<figure id="P7000497027000000000000000007461" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P7000497027000000000000000007461">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007462" title="852" data-uri="chapter09.xhtml#P7000497027000000000000000007462" epub:type="pagebreak"></span>
<img alt="A diagram illustrates the format of a heap block that uses a boundary tab." id="P7000497027000000000000000045F57" data-uri="P700049702700000000000000000B7A3" src="../images/p852-1.png" class="pcalibre1 pcalibre2 pcalibre284"/>
<figcaption id="P7000497027000000000000000045F58" data-uri="chapter09.xhtml#P7000497027000000000000000045F58" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045F59" data-uri="chapter09.xhtml#P7000497027000000000000000045F59" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.39 </span>Format of heap block that uses a boundary tag.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000262AF" data-uri="chapter09.xhtml#P70004970270000000000000000262AF">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045F5A" data-uri="chapter09.xhtml#P7000497027000000000000000045F5A" class="pcalibre8 pcalibre1 pcalibre2">A diagram has three sections, each from 31 to 0 bits, from top to bottom as follows:</p>
<ul id="P7000497027000000000000000045F5B" data-uri="chapter09.xhtml#P7000497027000000000000000045F5B" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000045F5C" data-uri="chapter09.xhtml#P7000497027000000000000000045F5C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F5D" data-uri="chapter09.xhtml#P7000497027000000000000000045F5D" class="pcalibre1 pcalibre2 pcalibre10">Header: Block size from bit 31 to 3, with a/f under bits 2 to 0 (a = 001: Allocated; a = 000: Free)</p></li>
<li id="P7000497027000000000000000045F5E" data-uri="chapter09.xhtml#P7000497027000000000000000045F5E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F5F" data-uri="chapter09.xhtml#P7000497027000000000000000045F5F" class="pcalibre1 pcalibre2 pcalibre10">Payload (allocated block only)</p></li>
<li id="P7000497027000000000000000045F60" data-uri="chapter09.xhtml#P7000497027000000000000000045F60" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F61" data-uri="chapter09.xhtml#P7000497027000000000000000045F61" class="pcalibre1 pcalibre2 pcalibre10">Padding (optional)</p></li>
<li id="P7000497027000000000000000045F62" data-uri="chapter09.xhtml#P7000497027000000000000000045F62" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F63" data-uri="chapter09.xhtml#P7000497027000000000000000045F63" class="pcalibre1 pcalibre2 pcalibre10">Foot: block size from bit 31 to 3, with a/f under bits 2 to 0</p></li>
</ul>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000045F64" data-uri="chapter09.xhtml#P7000497027000000000000000045F64" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007472"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.40</span></a> shows how we would coalesce each of the four cases.</p>
<p id="P7000497027000000000000000045F65" data-uri="chapter09.xhtml#P7000497027000000000000000045F65" class="pcalibre8 pcalibre1 pcalibre2">In case 1, both adjacent blocks are allocated and thus no coalescing is possible. So the status of the current block is simply changed from allocated to free. In case 2, the current block is merged with the next block. The header of the current block and the footer of the next block are updated with the combined sizes of the current and next blocks. In case 3, the previous block is merged with the current block. The header of the previous block and the footer of the current block are updated with the combined sizes of the two blocks. In case 4, all three blocks are merged to form a single free block, with the header of the previous block and the footer of the next block updated with the combined sizes of the three blocks. In each case, the coalescing is performed in constant time.</p>
<p id="P7000497027000000000000000045F66" data-uri="chapter09.xhtml#P7000497027000000000000000045F66" class="pcalibre8 pcalibre1 pcalibre2">The idea of boundary tags is a simple and elegant one that generalizes to many different types of allocators and free list organizations. However, there is a potential disadvantage. Requiring each block to contain both a header and a footer can introduce significant memory overhead if an application manipulates many small blocks. For example, if a graph application dynamically creates and destroys graph nodes by making repeated calls to <code id="P7000497027000000000000000045F67" data-uri="chapter09.xhtml#P7000497027000000000000000045F67" class="pcalibre1 calibre1 pcalibre2">malloc</code> and <code id="P7000497027000000000000000045F68" data-uri="chapter09.xhtml#P7000497027000000000000000045F68" class="pcalibre1 calibre1 pcalibre2">free</code>, and each graph node requires only a couple of words of memory, then the header and the footer will consume half of each allocated block.</p>
<p id="P7000497027000000000000000045F69" data-uri="chapter09.xhtml#P7000497027000000000000000045F69" class="pcalibre8 pcalibre1 pcalibre2">Fortunately, there is a clever optimization of boundary tags that eliminates the need for a footer in allocated blocks. Recall that when we attempt to coalesce the current block with the previous and next blocks in memory, the size field in the footer of the previous block is only needed if the previous block is <i class="pcalibre17 pcalibre2 pcalibre1">free.</i> If we were to store the allocated/free bit of the previous block in one of the excess low-order bits of the current block, then allocated blocks would not need footers, and we could use that extra space for payload. Note, however, that free blocks would still need footers.</p>
<section id="P700049702700000000000000000746C" data-uri="chapter09.xhtml#P700049702700000000000000000746C" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000045F6A" data-uri="chapter09.xhtml#P7000497027000000000000000045F6A" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">9.7 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P700049702700000000000000000780C">883</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000045F6B" data-uri="chapter09.xhtml#P7000497027000000000000000045F6B">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000045F6C" data-uri="chapter09.xhtml#P7000497027000000000000000045F6C">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000045F6D" data-uri="chapter09.xhtml#P7000497027000000000000000045F6D"><p id="P7000497027000000000000000045F6E" data-uri="chapter09.xhtml#P7000497027000000000000000045F6E" class="pcalibre1 pcalibre2 pcalibre10">Determine the minimum block size for each of the following combinations of alignment requirements and block formats. Assumptions: Implicit free list, zero-size payloads are not allowed, and headers and footers are stored in 4-byte words.</p>
<figure id="P7000497027000000000000000007472" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P7000497027000000000000000007472">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007473" title="853" data-uri="chapter09.xhtml#P7000497027000000000000000007473" epub:type="pagebreak"></span>
<img alt="A diagram illustrates four cases of coalescing with boundary tags." id="P7000497027000000000000000045F6F" data-uri="P700049702700000000000000000B7A4" src="../images/p853-1.png" class="pcalibre1 pcalibre2 pcalibre285"/>
<figcaption id="P7000497027000000000000000045F70" data-uri="chapter09.xhtml#P7000497027000000000000000045F70" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045F71" data-uri="chapter09.xhtml#P7000497027000000000000000045F71" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.40 </span>Coalescing with boundary tags.</h1></header><div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000045F72" data-uri="chapter09.xhtml#P7000497027000000000000000045F72"><p id="P7000497027000000000000000045F73" data-uri="chapter09.xhtml#P7000497027000000000000000045F73" class="pcalibre1 pcalibre2 pcalibre10">Case 1 : prev and next allocated. Case 2: prev allocated, next free. Case 3: prev free, next allocated. Case 4: next and prev free.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000262CA" data-uri="chapter09.xhtml#P70004970270000000000000000262CA">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045F74" data-uri="chapter09.xhtml#P7000497027000000000000000045F74" class="pcalibre1 pcalibre2 pcalibre10">A diagram illustrates four cases as heap blocks, beginning with a block with sections summarized below, from top to bottom:</p>
<ul id="P7000497027000000000000000045F75" data-uri="chapter09.xhtml#P7000497027000000000000000045F75" class="pcalibre1 pcalibre2 pcalibre117">
<li id="P7000497027000000000000000045F76" data-uri="chapter09.xhtml#P7000497027000000000000000045F76" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F77" data-uri="chapter09.xhtml#P7000497027000000000000000045F77" class="pcalibre1 pcalibre2 pcalibre10">M1 and a</p></li>
<li id="P7000497027000000000000000045F78" data-uri="chapter09.xhtml#P7000497027000000000000000045F78" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F79" data-uri="chapter09.xhtml#P7000497027000000000000000045F79" class="pcalibre1 pcalibre2 pcalibre10">Blank</p></li>
<li id="P7000497027000000000000000045F7A" data-uri="chapter09.xhtml#P7000497027000000000000000045F7A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F7B" data-uri="chapter09.xhtml#P7000497027000000000000000045F7B" class="pcalibre1 pcalibre2 pcalibre10">M1 and a</p></li>
<li id="P7000497027000000000000000045F7C" data-uri="chapter09.xhtml#P7000497027000000000000000045F7C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F7D" data-uri="chapter09.xhtml#P7000497027000000000000000045F7D" class="pcalibre1 pcalibre2 pcalibre10">N and a</p></li>
<li id="P7000497027000000000000000045F7E" data-uri="chapter09.xhtml#P7000497027000000000000000045F7E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F7F" data-uri="chapter09.xhtml#P7000497027000000000000000045F7F" class="pcalibre1 pcalibre2 pcalibre10">Blank shaded</p></li>
<li id="P7000497027000000000000000045F80" data-uri="chapter09.xhtml#P7000497027000000000000000045F80" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F81" data-uri="chapter09.xhtml#P7000497027000000000000000045F81" class="pcalibre1 pcalibre2 pcalibre10">N and a</p></li>
<li id="P7000497027000000000000000045F82" data-uri="chapter09.xhtml#P7000497027000000000000000045F82" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F83" data-uri="chapter09.xhtml#P7000497027000000000000000045F83" class="pcalibre1 pcalibre2 pcalibre10">M2 and a</p></li>
<li id="P7000497027000000000000000045F84" data-uri="chapter09.xhtml#P7000497027000000000000000045F84" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F85" data-uri="chapter09.xhtml#P7000497027000000000000000045F85" class="pcalibre1 pcalibre2 pcalibre10">Blank</p></li>
<li id="P7000497027000000000000000045F86" data-uri="chapter09.xhtml#P7000497027000000000000000045F86" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F87" data-uri="chapter09.xhtml#P7000497027000000000000000045F87" class="pcalibre1 pcalibre2 pcalibre10">M2 and a</p></li>
</ul>
<p id="P7000497027000000000000000045F88" data-uri="chapter09.xhtml#P7000497027000000000000000045F88" class="pcalibre1 pcalibre2 pcalibre10">The changed blocks for each case are summarized below.</p>
<ul id="P7000497027000000000000000045F89" data-uri="chapter09.xhtml#P7000497027000000000000000045F89" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000045F8A" data-uri="chapter09.xhtml#P7000497027000000000000000045F8A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F8B" data-uri="chapter09.xhtml#P7000497027000000000000000045F8B" class="pcalibre1 pcalibre2 pcalibre10">Case 1: above and below shaded blank, a is changed to f</p></li>
<li id="P7000497027000000000000000045F8C" data-uri="chapter09.xhtml#P7000497027000000000000000045F8C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F8D" data-uri="chapter09.xhtml#P7000497027000000000000000045F8D" class="pcalibre1 pcalibre2 pcalibre10">Case 2: shaded blank now extends down to bottom blank; above and below this blank is n+m2 and f</p></li>
<li id="P7000497027000000000000000045F8E" data-uri="chapter09.xhtml#P7000497027000000000000000045F8E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F8F" data-uri="chapter09.xhtml#P7000497027000000000000000045F8F" class="pcalibre1 pcalibre2 pcalibre10">Case 3: shaded blank now extends up to top blank; above and below this blank is n+m1 and f</p></li>
<li id="P7000497027000000000000000045F90" data-uri="chapter09.xhtml#P7000497027000000000000000045F90" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045F91" data-uri="chapter09.xhtml#P7000497027000000000000000045F91" class="pcalibre1 pcalibre2 pcalibre10">Case 4: shaded blank now extends between the top and bottom blanks; above and below this blank is n+m1+m2 and f</p></li>
</ul>
</details>
</figcaption>
</figure>
<table id="P7000497027000000000000000045F92" data-uri="chapter09.xhtml#P7000497027000000000000000045F92" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000045F93" data-uri="chapter09.xhtml#P7000497027000000000000000045F93" class="pcalibre1 pcalibre2 calibre5"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000747B" title="854" data-uri="chapter09.xhtml#P700049702700000000000000000747B" epub:type="pagebreak"></span>Alignment</th>
<th id="P7000497027000000000000000045F94" data-uri="chapter09.xhtml#P7000497027000000000000000045F94" class="pcalibre1 pcalibre2 calibre5">Allocated block</th>
<th id="P7000497027000000000000000045F95" data-uri="chapter09.xhtml#P7000497027000000000000000045F95" class="pcalibre1 pcalibre2 calibre5">Free block</th>
<th id="P7000497027000000000000000045F96" data-uri="chapter09.xhtml#P7000497027000000000000000045F96" class="pcalibre1 pcalibre2 calibre5">Minimum block size (bytes)</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000045F97" data-uri="chapter09.xhtml#P7000497027000000000000000045F97" class="pcalibre1 pcalibre2 calibre7">Single word</td>
<td id="P7000497027000000000000000045F98" data-uri="chapter09.xhtml#P7000497027000000000000000045F98" class="pcalibre1 pcalibre2 calibre7">Header and footer</td>
<td id="P7000497027000000000000000045F99" data-uri="chapter09.xhtml#P7000497027000000000000000045F99" class="pcalibre1 pcalibre2 calibre7">Header and footer</td>
<td id="P7000497027000000000000000045F9A" data-uri="chapter09.xhtml#P7000497027000000000000000045F9A" class="pcalibre1 pcalibre2 calibre7">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000045F9B" data-uri="chapter09.xhtml#P7000497027000000000000000045F9B" class="pcalibre1 pcalibre2 calibre7">Single word</td>
<td id="P7000497027000000000000000045F9C" data-uri="chapter09.xhtml#P7000497027000000000000000045F9C" class="pcalibre1 pcalibre2 calibre7">Header, but no footer</td>
<td id="P7000497027000000000000000045F9D" data-uri="chapter09.xhtml#P7000497027000000000000000045F9D" class="pcalibre1 pcalibre2 calibre7">Header and footer</td>
<td id="P7000497027000000000000000045F9E" data-uri="chapter09.xhtml#P7000497027000000000000000045F9E" class="pcalibre1 pcalibre2 calibre7">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000045F9F" data-uri="chapter09.xhtml#P7000497027000000000000000045F9F" class="pcalibre1 pcalibre2 calibre7">Double word</td>
<td id="P7000497027000000000000000045FA0" data-uri="chapter09.xhtml#P7000497027000000000000000045FA0" class="pcalibre1 pcalibre2 calibre7">Header and footer</td>
<td id="P7000497027000000000000000045FA1" data-uri="chapter09.xhtml#P7000497027000000000000000045FA1" class="pcalibre1 pcalibre2 calibre7">Header and footer</td>
<td id="P7000497027000000000000000045FA2" data-uri="chapter09.xhtml#P7000497027000000000000000045FA2" class="pcalibre1 pcalibre2 calibre7">_____</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000045FA3" data-uri="chapter09.xhtml#P7000497027000000000000000045FA3" class="pcalibre1 pcalibre2 calibre7">Double word</td>
<td id="P7000497027000000000000000045FA4" data-uri="chapter09.xhtml#P7000497027000000000000000045FA4" class="pcalibre1 pcalibre2 calibre7">Header, but no footer</td>
<td id="P7000497027000000000000000045FA5" data-uri="chapter09.xhtml#P7000497027000000000000000045FA5" class="pcalibre1 pcalibre2 calibre7">Header and footer</td>
<td id="P7000497027000000000000000045FA6" data-uri="chapter09.xhtml#P7000497027000000000000000045FA6" class="pcalibre1 pcalibre2 calibre7">_____</td>
</tr>
</tbody>
</table>
</div></li></ol>
</section>
</section>
<section id="P700049702700000000000000000748F" data-uri="chapter09.xhtml#P700049702700000000000000000748F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045FA7" data-uri="chapter09.xhtml#P7000497027000000000000000045FA7" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.12 </span>Putting It Together: Implementing a Simple Allocator</h1></header>
<p id="P7000497027000000000000000045FA8" data-uri="chapter09.xhtml#P7000497027000000000000000045FA8" class="pcalibre8 pcalibre1 pcalibre2">Building an allocator is a challenging task. The design space is large, with numerous alternatives for block format and free list format, as well as placement, splitting, and coalescing policies. Another challenge is that you are often forced to program outside the safe, familiar confines of the type system, relying on the error-prone pointer casting and pointer arithmetic that is typical of low-level systems programming.</p>
<p id="P7000497027000000000000000045FA9" data-uri="chapter09.xhtml#P7000497027000000000000000045FA9" class="pcalibre8 pcalibre1 pcalibre2">While allocators do not require enormous amounts of code, they are subtle and unforgiving. Students familiar with higher-level languages such as C++ or Java often hit a conceptual wall when they first encounter this style of programming. To help you clear this hurdle, we will work through the implementation of a simple allocator based on an implicit free list with immediate boundary-tag coalescing. The maximum block size is 2<sup class="pcalibre1 pcalibre2 pcalibre85">32</sup> = 4 GB. The code is 64-bit clean, running without modification in 32-bit (<code id="P7000497027000000000000000045FAA" data-uri="chapter09.xhtml#P7000497027000000000000000045FAA" class="pcalibre1 calibre1 pcalibre2">gcc -m32</code>) or 64-bit (<code id="P7000497027000000000000000045FAB" data-uri="chapter09.xhtml#P7000497027000000000000000045FAB" class="pcalibre1 calibre1 pcalibre2">gcc -m64</code>) processes.</p>
<section id="P7000497027000000000000000007495" data-uri="chapter09.xhtml#P7000497027000000000000000007495" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000045FAC" data-uri="chapter09.xhtml#P7000497027000000000000000045FAC" epub:type="title">General Allocator Design</h1></header>
<p id="P7000497027000000000000000045FAD" data-uri="chapter09.xhtml#P7000497027000000000000000045FAD" class="pcalibre8 pcalibre1 pcalibre2">Our allocator uses a model of the memory system provided by the <code id="P7000497027000000000000000045FAE" data-uri="chapter09.xhtml#P7000497027000000000000000045FAE" class="pcalibre1 calibre1 pcalibre2">memlib.c</code> package shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000074A9"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.41</span></a>. The purpose of the model is to allow us to run our allocator without interfering with the existing system-level <code id="P7000497027000000000000000045FAF" data-uri="chapter09.xhtml#P7000497027000000000000000045FAF" class="pcalibre1 calibre1 pcalibre2">malloc</code> package.</p>
<p id="P7000497027000000000000000045FB0" data-uri="chapter09.xhtml#P7000497027000000000000000045FB0" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000045FB1" data-uri="chapter09.xhtml#P7000497027000000000000000045FB1" class="pcalibre1 calibre1 pcalibre2">mem_init</code> function models the virtual memory available to the heap as a large double-word aligned array of bytes. The bytes between <code id="P7000497027000000000000000045FB2" data-uri="chapter09.xhtml#P7000497027000000000000000045FB2" class="pcalibre1 calibre1 pcalibre2">mem_heap</code> and <code id="P7000497027000000000000000045FB3" data-uri="chapter09.xhtml#P7000497027000000000000000045FB3" class="pcalibre1 calibre1 pcalibre2">mem_brk</code> represent allocated virtual memory. The bytes following <code id="P7000497027000000000000000045FB4" data-uri="chapter09.xhtml#P7000497027000000000000000045FB4" class="pcalibre1 calibre1 pcalibre2">mem_brk</code> represent unallocated virtual memory. The allocator requests additional heap memory by calling the <code id="P7000497027000000000000000045FB5" data-uri="chapter09.xhtml#P7000497027000000000000000045FB5" class="pcalibre1 calibre1 pcalibre2">mem_sbrk</code> function, which has the same interface as the system's <code id="P7000497027000000000000000045FB6" data-uri="chapter09.xhtml#P7000497027000000000000000045FB6" class="pcalibre1 calibre1 pcalibre2">sbrk</code> function, as well as the same semantics, except that it rejects requests to shrink the heap.</p>
<p id="P7000497027000000000000000045FB7" data-uri="chapter09.xhtml#P7000497027000000000000000045FB7" class="pcalibre8 pcalibre1 pcalibre2">The allocator itself is contained in a source file (<code id="P7000497027000000000000000045FB8" data-uri="chapter09.xhtml#P7000497027000000000000000045FB8" class="pcalibre1 calibre1 pcalibre2">mm. c</code>) that users can compile and link into their applications. The allocator exports three functions to application programs:</p>
<pre id="P7000497027000000000000000045FB9" data-uri="chapter09.xhtml#P7000497027000000000000000045FB9" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045FBA" data-uri="chapter09.xhtml#P7000497027000000000000000045FBA" class="calibre3 pcalibre1 pcalibre2">
1	extern int mm_init(void);
2	extern void *mm_malloc (size_t size);
3	extern void mm_free (void *ptr);
</code></pre>
<p id="P7000497027000000000000000045FBB" data-uri="chapter09.xhtml#P7000497027000000000000000045FBB" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000045FBC" data-uri="chapter09.xhtml#P7000497027000000000000000045FBC" class="pcalibre1 calibre1 pcalibre2">mm_init</code> function initializes the allocator, returning 0 if successful and –1 otherwise. The <code id="P7000497027000000000000000045FBD" data-uri="chapter09.xhtml#P7000497027000000000000000045FBD" class="pcalibre1 calibre1 pcalibre2">mm_malloc</code> and <code id="P7000497027000000000000000045FBE" data-uri="chapter09.xhtml#P7000497027000000000000000045FBE" class="pcalibre1 calibre1 pcalibre2">mm_free</code> functions have the same interfaces and semantics as their system counterparts. The allocator uses the block format</p>
<figure id="P70004970270000000000000000074A9" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000074A9">
<p id="P7000497027000000000000000045FBF" data-uri="chapter09.xhtml#P7000497027000000000000000045FBF" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000074AB" title="855" data-uri="chapter09.xhtml#P70004970270000000000000000074AB" epub:type="pagebreak"></span>_______________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/memlib.c</i></p>
<pre id="P7000497027000000000000000045FC0" data-uri="chapter09.xhtml#P7000497027000000000000000045FC0" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045FC1" data-uri="chapter09.xhtml#P7000497027000000000000000045FC1" class="calibre3 pcalibre1 pcalibre2">

1	/* Private global variables */
2	static char *mem_heap;		/* Points to first byte of heap */
3	static char *mem_brk;		/* Points to last byte of heap plus 1 */
4	static char *mem_max_addr;	/* Max legal heap addr plus 1*/
5	
6	/*
7	* mem_init - Initialize the memory system model
8	*/
9	void mem_init(void)
10	{
11		mem_heap = (char *)Malloc(MAX_HEAP);
12		mem_brk = (char *)mem_heap;
13		mem_max_addr = (char *)(mem_heap + MAX_HEAP);
14	}
15	
16	/*
17	* mem_sbrk - Simple model of the sbrk function. Extends the heap
18	*	by incr bytes and returns the start address of the new area. In
19	*	this model, the heap cannot be shrunk.
20	*/
21	void *mem_sbrk(int incr)
22	{
23		char *old_brk = mem_brk;
24	
25		if ( (incr &lt; 0)|| ((mem_brk + incr) &gt; mem_max_addr)) {
26			errno = ENOMEM;
27			fprintf(stderr, "ERROR: mem_sbrk failed. Ran out of memory...\n");
28			return (void *)–1l;
29		}
30		mem_brk += incr;
31		return (void *)old_brk;
32	}
</code></pre>
<p id="P7000497027000000000000000045FC2" data-uri="chapter09.xhtml#P7000497027000000000000000045FC2" class="pcalibre8 pcalibre1 pcalibre2">___________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/memlib.c</i></p>
<figcaption id="P7000497027000000000000000045FC3" data-uri="chapter09.xhtml#P7000497027000000000000000045FC3" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045FC4" data-uri="chapter09.xhtml#P7000497027000000000000000045FC4" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.41 </span><code id="P7000497027000000000000000045FC5" data-uri="chapter09.xhtml#P7000497027000000000000000045FC5" class="pcalibre1 calibre1 pcalibre2">memlib. c</code>: Memory system model.</h1></header></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045FC6" data-uri="chapter09.xhtml#P7000497027000000000000000045FC6">shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007461"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.39</span></a>. The minimum block size is 16 bytes. The free list is organized as an implicit free list, with the invariant form shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000074B6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.42</span></a>.</p>
<p id="P7000497027000000000000000045FC7" data-uri="chapter09.xhtml#P7000497027000000000000000045FC7" class="pcalibre8 pcalibre1 pcalibre2">The first word is an unused padding word aligned to a double-word boundary. The padding is followed by a special <i class="pcalibre17 pcalibre2 pcalibre1">prologue block</i>, which is an 8-byte allocated block consisting of only a header and a footer. The prologue block is created during initialization and is never freed. Following the prologue block are zero or more regular blocks that are created by calls to <code id="P7000497027000000000000000045FC8" data-uri="chapter09.xhtml#P7000497027000000000000000045FC8" class="pcalibre1 calibre1 pcalibre2">malloc</code> or <code id="P7000497027000000000000000045FC9" data-uri="chapter09.xhtml#P7000497027000000000000000045FC9" class="pcalibre1 calibre1 pcalibre2">free</code>. The heap always ends with a special <i class="pcalibre17 pcalibre2 pcalibre1">epilogue block</i>, which is a zero-size allocated block</p>
<figure id="P70004970270000000000000000074B6" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000074B6">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000074B7" title="856" data-uri="chapter09.xhtml#P70004970270000000000000000074B7" epub:type="pagebreak"></span>
<img alt="A diagram illustrates an invarian t form of the implicit free list." id="P7000497027000000000000000045FCA" data-uri="P700049702700000000000000000B7A5" src="../images/p856-1.png" class="pcalibre1 pcalibre2 pcalibre286"/>
<figcaption id="P7000497027000000000000000045FCB" data-uri="chapter09.xhtml#P7000497027000000000000000045FCB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045FCC" data-uri="chapter09.xhtml#P7000497027000000000000000045FCC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.42 </span>Invariant form of the implicit free list.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000026324" data-uri="chapter09.xhtml#P7000497027000000000000000026324">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045FCD" data-uri="chapter09.xhtml#P7000497027000000000000000045FCD" class="pcalibre8 pcalibre1 pcalibre2">A diagram has a row of shaded and unshaded blocks, from start of heap on the left to double-word aligned on the right, as summarized below.</p>
<ul id="P7000497027000000000000000045FCE" data-uri="chapter09.xhtml#P7000497027000000000000000045FCE" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000045FCF" data-uri="chapter09.xhtml#P7000497027000000000000000045FCF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045FD0" data-uri="chapter09.xhtml#P7000497027000000000000000045FD0" class="pcalibre1 pcalibre2 pcalibre10">Three shaded blocks, beginning at static, the second two each labeled 8/1, together representing prologue block with char *heap_listp between.</p></li>
<li id="P7000497027000000000000000045FD1" data-uri="chapter09.xhtml#P7000497027000000000000000045FD1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045FD2" data-uri="chapter09.xhtml#P7000497027000000000000000045FD2" class="pcalibre1 pcalibre2 pcalibre10">Three unshaded, together as regular block 1, the first containing hdr and the third ftr</p></li>
<li id="P7000497027000000000000000045FD3" data-uri="chapter09.xhtml#P7000497027000000000000000045FD3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045FD4" data-uri="chapter09.xhtml#P7000497027000000000000000045FD4" class="pcalibre1 pcalibre2 pcalibre10">Three unshaded, together as regular block 2, the first containing hdr and the third ftr</p></li>
<li id="P7000497027000000000000000045FD5" data-uri="chapter09.xhtml#P7000497027000000000000000045FD5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045FD6" data-uri="chapter09.xhtml#P7000497027000000000000000045FD6" class="pcalibre1 pcalibre2 pcalibre10">…</p></li>
<li id="P7000497027000000000000000045FD7" data-uri="chapter09.xhtml#P7000497027000000000000000045FD7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045FD8" data-uri="chapter09.xhtml#P7000497027000000000000000045FD8" class="pcalibre1 pcalibre2 pcalibre10">Three unshaded, together as regular block n, the first containing hdr and the third ftr</p></li>
<li id="P7000497027000000000000000045FD9" data-uri="chapter09.xhtml#P7000497027000000000000000045FD9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045FDA" data-uri="chapter09.xhtml#P7000497027000000000000000045FDA" class="pcalibre1 pcalibre2 pcalibre10">One shaded as epilogue block hdr, containing 0/1</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045FDB" data-uri="chapter09.xhtml#P7000497027000000000000000045FDB">that consists of only a header. The prologue and epilogue blocks are tricks that eliminate the edge conditions during coalescing. The allocator uses a single private (<code id="P7000497027000000000000000045FDC" data-uri="chapter09.xhtml#P7000497027000000000000000045FDC" class="pcalibre1 calibre1 pcalibre2">static</code>) global variable (<code id="P7000497027000000000000000045FDD" data-uri="chapter09.xhtml#P7000497027000000000000000045FDD" class="pcalibre1 calibre1 pcalibre2">heap_listp</code>) that always points to the prologue block. (As a minor optimization, we could make it point to the next block instead of the prologue block.)</p>
</section>
<section id="P70004970270000000000000000074BE" data-uri="chapter09.xhtml#P70004970270000000000000000074BE" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000045FDE" data-uri="chapter09.xhtml#P7000497027000000000000000045FDE" epub:type="title">Basic Constants and Macros for Manipulating the Free List</h1></header>
<p id="P7000497027000000000000000045FDF" data-uri="chapter09.xhtml#P7000497027000000000000000045FDF" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000074D0"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.43</span></a> shows some basic constants and macros that we will use throughout the allocator code. Lines 2–4 define some basic size constants: the sizes of words (WSIZE) and double words (DSIZE), and the size of the initial free block and the default size for expanding the heap (CHUNKSIZE).</p>
<p id="P7000497027000000000000000045FE0" data-uri="chapter09.xhtml#P7000497027000000000000000045FE0" class="pcalibre8 pcalibre1 pcalibre2">Manipulating the headers and footers in the free list can be troublesome because it demands extensive use of casting and pointer arithmetic. Thus, we find it helpful to define a small set of macros for accessing and traversing the free list (lines 9–25). The PACK macro (line 9) combines a size and an allocate bit and returns a value that can be stored in a header or footer.</p>
<p id="P7000497027000000000000000045FE1" data-uri="chapter09.xhtml#P7000497027000000000000000045FE1" class="pcalibre8 pcalibre1 pcalibre2">The GET macro (line 12) reads and returns the word referenced by argument <code id="P7000497027000000000000000045FE2" data-uri="chapter09.xhtml#P7000497027000000000000000045FE2" class="pcalibre1 calibre1 pcalibre2">p</code>. The casting here is crucial. The argument <code id="P7000497027000000000000000045FE3" data-uri="chapter09.xhtml#P7000497027000000000000000045FE3" class="pcalibre1 calibre1 pcalibre2">p</code> is typically a (<code id="P7000497027000000000000000045FE4" data-uri="chapter09.xhtml#P7000497027000000000000000045FE4" class="pcalibre1 calibre1 pcalibre2">void *</code>) pointer, which cannot be dereferenced directly. Similarly, the PUT macro (line 13) stores <code id="P7000497027000000000000000045FE5" data-uri="chapter09.xhtml#P7000497027000000000000000045FE5" class="pcalibre1 calibre1 pcalibre2">val</code> in the word pointed at by argument <code id="P7000497027000000000000000045FE6" data-uri="chapter09.xhtml#P7000497027000000000000000045FE6" class="pcalibre1 calibre1 pcalibre2">p</code>.</p>
<p id="P7000497027000000000000000045FE7" data-uri="chapter09.xhtml#P7000497027000000000000000045FE7" class="pcalibre8 pcalibre1 pcalibre2">The GET_SIZE and GET_ALLOC macros (lines 16–17) return the size and allocated bit, respectively, from a header or footer at address <code id="P7000497027000000000000000045FE8" data-uri="chapter09.xhtml#P7000497027000000000000000045FE8" class="pcalibre1 calibre1 pcalibre2">p</code>. The remaining macros operate on <i class="pcalibre17 pcalibre2 pcalibre1">block pointers</i> (denoted <code id="P7000497027000000000000000045FE9" data-uri="chapter09.xhtml#P7000497027000000000000000045FE9" class="pcalibre1 calibre1 pcalibre2">bp</code>) that point to the first payload byte. Given a block pointer <code id="P7000497027000000000000000045FEA" data-uri="chapter09.xhtml#P7000497027000000000000000045FEA" class="pcalibre1 calibre1 pcalibre2">bp</code>, the HDRP and FTRP macros (lines 20–21) return pointers to the block header and footer, respectively. The NEXT_BLKP and PREV_BLKP macros (lines 24–25) return the block pointers of the next and previous blocks, respectively.</p>
<p id="P7000497027000000000000000045FEB" data-uri="chapter09.xhtml#P7000497027000000000000000045FEB" class="pcalibre8 pcalibre1 pcalibre2">The macros can be composed in various ways to manipulate the free list. For example, given a pointer <code id="P7000497027000000000000000045FEC" data-uri="chapter09.xhtml#P7000497027000000000000000045FEC" class="pcalibre1 calibre1 pcalibre2">bp</code> to the current block, we could use the following line of code to determine the size of the next block in memory:</p>
<pre id="P7000497027000000000000000045FED" data-uri="chapter09.xhtml#P7000497027000000000000000045FED" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045FEE" data-uri="chapter09.xhtml#P7000497027000000000000000045FEE" class="calibre3 pcalibre1 pcalibre2">
size_t size = GET_SIZE(HDRP(NEXT_BLKP(bp)));
</code></pre>
<figure id="P70004970270000000000000000074D0" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000074D0">
<p id="P7000497027000000000000000045FEF" data-uri="chapter09.xhtml#P7000497027000000000000000045FEF" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000074D2" title="857" data-uri="chapter09.xhtml#P70004970270000000000000000074D2" epub:type="pagebreak"></span>_________________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/mm.c</i></p>
<pre id="P7000497027000000000000000045FF0" data-uri="chapter09.xhtml#P7000497027000000000000000045FF0" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000045FF1" data-uri="chapter09.xhtml#P7000497027000000000000000045FF1" class="calibre3 pcalibre1 pcalibre2">
1	/* Basic constants and macros */
2	#define WSIZE	4	 /* Word and header/footer size (bytes) */
3	#define DSIZE	8	/* Double word size (bytes) */
4	#define CHUNKSIZE (1&lt;&lt;12) /* Extend heap by this amount (bytes) */
5	
6	#define MAX(x, y) ((x) &gt; (y)? (x) : (y))
7	
8	/* Pack a size and allocated bit into a word */
9	#define PACK(size, alloc) ((size)	|	(alloc))
10	
11	/* Read and write a word at address p */
12	#define GET(p)	(* (unsigned int *)(p))
13	#define PUT(p, val)		(*(unsigned int *)(p) = (val))
14	
15	/* Read the size and allocated fields from address p */
16	#define GET_SIZE(p)	(GET(p) &amp; ~0x7)
17	#define GET_ALL0C(p)	(GET(p) &amp; 0x1)
18	
19	/* Given block ptr bp, compute address of its header and footer */
20	#define HDRP(bp)	((char *) (bp) - WSIZE)
21	#define FTRP(bp)	((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)
22	
23	/* Given block ptr bp, compute address of next and previous blocks */
24	#define NEXT_BLKP(bp)	((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))
25	#define PREV_BLKP(bp)	((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))
</code></pre>
<p id="P7000497027000000000000000045FF2" data-uri="chapter09.xhtml#P7000497027000000000000000045FF2" class="pcalibre8 pcalibre1 pcalibre2">________________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/mm.c</i></p>
<figcaption id="P7000497027000000000000000045FF3" data-uri="chapter09.xhtml#P7000497027000000000000000045FF3" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045FF4" data-uri="chapter09.xhtml#P7000497027000000000000000045FF4" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.43 </span>Basic constants and macros for manipulating the free list.</h1></header></figcaption>
</figure>
</section>
<section id="P70004970270000000000000000074D8" data-uri="chapter09.xhtml#P70004970270000000000000000074D8" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000045FF5" data-uri="chapter09.xhtml#P7000497027000000000000000045FF5" epub:type="title">Creating the Initial Free List</h1></header>
<p id="P7000497027000000000000000045FF6" data-uri="chapter09.xhtml#P7000497027000000000000000045FF6" class="pcalibre8 pcalibre1 pcalibre2">Before calling <code id="P7000497027000000000000000045FF7" data-uri="chapter09.xhtml#P7000497027000000000000000045FF7" class="pcalibre1 calibre1 pcalibre2">mm_malloc</code> or <code id="P7000497027000000000000000045FF8" data-uri="chapter09.xhtml#P7000497027000000000000000045FF8" class="pcalibre1 calibre1 pcalibre2">mm_free</code>, the application must initialize the heap by calling the <code id="P7000497027000000000000000045FF9" data-uri="chapter09.xhtml#P7000497027000000000000000045FF9" class="pcalibre1 calibre1 pcalibre2">mm_init</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000074E5"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.44</span></a>).</p>
<p id="P7000497027000000000000000045FFA" data-uri="chapter09.xhtml#P7000497027000000000000000045FFA" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000045FFB" data-uri="chapter09.xhtml#P7000497027000000000000000045FFB" class="pcalibre1 calibre1 pcalibre2">mm_init</code> function gets four words from the memory system and initializes them to create the empty free list (lines 4–10). It then calls the <code id="P7000497027000000000000000045FFC" data-uri="chapter09.xhtml#P7000497027000000000000000045FFC" class="pcalibre1 calibre1 pcalibre2">extend_heap</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000074EE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.45</span></a>), which extends the heap by CHUNKSIZE bytes and creates the initial free block. At this point, the allocator is initialized and ready to accept allocate and free requests from the application.</p>
<p id="P7000497027000000000000000045FFD" data-uri="chapter09.xhtml#P7000497027000000000000000045FFD" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000045FFE" data-uri="chapter09.xhtml#P7000497027000000000000000045FFE" class="pcalibre1 calibre1 pcalibre2">extend_heap</code> function is invoked in two different circumstances: (1) when the heap is initialized and (2) when <code id="P7000497027000000000000000045FFF" data-uri="chapter09.xhtml#P7000497027000000000000000045FFF" class="pcalibre1 calibre1 pcalibre2">mm_malloc</code> is unable to find a suitable fit. To maintain alignment, <code id="P7000497027000000000000000046000" data-uri="chapter09.xhtml#P7000497027000000000000000046000" class="pcalibre1 calibre1 pcalibre2">extend_heap</code> rounds up the requested size to the nearest</p>
<figure id="P70004970270000000000000000074E5" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000074E5">
<p id="P7000497027000000000000000046001" data-uri="chapter09.xhtml#P7000497027000000000000000046001" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000074E7" title="858" data-uri="chapter09.xhtml#P70004970270000000000000000074E7" epub:type="pagebreak"></span>_________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/mm.c</i></p>
<pre id="P7000497027000000000000000046002" data-uri="chapter09.xhtml#P7000497027000000000000000046002" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046003" data-uri="chapter09.xhtml#P7000497027000000000000000046003" class="calibre3 pcalibre1 pcalibre2">
1	int mm_init(void)
2	{
3		/* Create the initial empty heap */
4		if ((heap_listp = mem_sbrk(4*WSIZE)) == (void *)–1)
5			return –1;
6		PUT(heap_listp, 0);				/* Alignment padding */
7		PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1));	/* Prologue header */
8		PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1));	/* Prologue footer */
9		PUT(heap_listp + (3*WSIZE), PACK(0, 1));	/* Epilogue header */
10		heap_listp += (2*WSIZE);
11	
12		/* Extend the empty heap with a free block of CHUMSIZE bytes */
13		if (extend_heap(CHUMSIZE/WSIZE) == NULL)
14			return –1;
15		return 0;
16	}
</code></pre>
<p id="P7000497027000000000000000046004" data-uri="chapter09.xhtml#P7000497027000000000000000046004" class="pcalibre8 pcalibre1 pcalibre2">_______________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/mm.c</i></p>
<figcaption id="P7000497027000000000000000046005" data-uri="chapter09.xhtml#P7000497027000000000000000046005" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046006" data-uri="chapter09.xhtml#P7000497027000000000000000046006" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.44 </span><code id="P7000497027000000000000000046007" data-uri="chapter09.xhtml#P7000497027000000000000000046007" class="pcalibre1 calibre1 pcalibre2">mm_init</code> creates a heap with an initial free block.</h1></header></figcaption>
</figure>
<figure id="P70004970270000000000000000074EE" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000074EE">
<p id="P7000497027000000000000000046008" data-uri="chapter09.xhtml#P7000497027000000000000000046008" class="pcalibre8 pcalibre1 pcalibre2">____________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/mm.c</i></p>
<pre id="P7000497027000000000000000046009" data-uri="chapter09.xhtml#P7000497027000000000000000046009" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004600A" data-uri="chapter09.xhtml#P700049702700000000000000004600A" class="calibre3 pcalibre1 pcalibre2">
1	static void *extend_heap(size_t words)
2	{
3		char *bp;
4		size_t size;
5	
6		/* Allocate an even number of words to maintain alignment */
7		size = (words % 2) ? (words+1) * WSIZE : words * WSIZE;
8		if ((long)(bp = mem_sbrk(size)) == –1)
9			return NULL;
10	
11		/* Initialize free block header/footer and the epilogue header */
12		PUT(HDRP(bp), PACK(size, 0));		/* Free block header */
13		PUT(FTRP(bp), PACK(size, 0));		/* Free block footer */
14		PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));	/* New epilogue header */
15	
16		/* Coalesce if the previous block was free */
17		return coalesce(bp);
18	}
</code></pre>
<p id="P700049702700000000000000004600B" data-uri="chapter09.xhtml#P700049702700000000000000004600B" class="pcalibre8 pcalibre1 pcalibre2">_______________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/mm.c</i></p>
<figcaption id="P700049702700000000000000004600C" data-uri="chapter09.xhtml#P700049702700000000000000004600C" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004600D" data-uri="chapter09.xhtml#P700049702700000000000000004600D" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.45 </span><code id="P700049702700000000000000004600E" data-uri="chapter09.xhtml#P700049702700000000000000004600E" class="pcalibre1 calibre1 pcalibre2">extend_heap</code> extends the heap with a new free block.</h1></header></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004600F" data-uri="chapter09.xhtml#P700049702700000000000000004600F"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000074F7" title="859" data-uri="chapter09.xhtml#P70004970270000000000000000074F7" epub:type="pagebreak"></span>multiple of 2 words (8 bytes) and then requests the additional heap space from the memory system (lines 7–9).</p>
<p id="P7000497027000000000000000046010" data-uri="chapter09.xhtml#P7000497027000000000000000046010" class="pcalibre8 pcalibre1 pcalibre2">The remainder of the <code id="P7000497027000000000000000046011" data-uri="chapter09.xhtml#P7000497027000000000000000046011" class="pcalibre1 calibre1 pcalibre2">extend_heap</code> function (lines 12–17) is somewhat subtle. The heap begins on a double-word aligned boundary, and every call to <code id="P7000497027000000000000000046012" data-uri="chapter09.xhtml#P7000497027000000000000000046012" class="pcalibre1 calibre1 pcalibre2">extend_heap</code> returns a block whose size is an integral number of double words. Thus, every call to <code id="P7000497027000000000000000046013" data-uri="chapter09.xhtml#P7000497027000000000000000046013" class="pcalibre1 calibre1 pcalibre2">mem_sbrk</code> returns a double-word aligned chunk of memory immediately following the header of the epilogue block. This header becomes the header of the new free block (line 12), and the last word of the chunk becomes the new epilogue block header (line 14). Finally, in the likely case that the previous heap was terminated by a free block, we call the coalesce function to merge the two free blocks and return the block pointer of the merged blocks (line 17).</p>
</section>
<section id="P70004970270000000000000000074FC" data-uri="chapter09.xhtml#P70004970270000000000000000074FC" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046014" data-uri="chapter09.xhtml#P7000497027000000000000000046014" epub:type="title">Freeing and Coalescing Blocks</h1></header>
<p id="P7000497027000000000000000046015" data-uri="chapter09.xhtml#P7000497027000000000000000046015" class="pcalibre8 pcalibre1 pcalibre2">An application frees a previously allocated block by calling the <code id="P7000497027000000000000000046016" data-uri="chapter09.xhtml#P7000497027000000000000000046016" class="pcalibre1 calibre1 pcalibre2">mm_free</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007509"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.46</span></a>), which frees the requested block (<code id="P7000497027000000000000000046017" data-uri="chapter09.xhtml#P7000497027000000000000000046017" class="pcalibre1 calibre1 pcalibre2">bp</code>) and then merges adjacent free blocks using the boundary-tags coalescing technique described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007452"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">9.9.11</span></a>.</p>
<p id="P7000497027000000000000000046018" data-uri="chapter09.xhtml#P7000497027000000000000000046018" class="pcalibre8 pcalibre1 pcalibre2">The code in the coalesce helper function is a straightforward implementation of the four cases outlined in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007472"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.40</span></a>. There is one somewhat subtle aspect. The free list format we have chosen—with its prologue and epilogue blocks that are always marked as allocated—allows us to ignore the potentially troublesome edge conditions where the requested block <code id="P7000497027000000000000000046019" data-uri="chapter09.xhtml#P7000497027000000000000000046019" class="pcalibre1 calibre1 pcalibre2">bp</code> is at the beginning or end of the heap. Without these special blocks, the code would be messier, more error prone, and slower because we would have to check for these rare edge conditions on each and every free request.</p>
</section>
<section id="P7000497027000000000000000007503" data-uri="chapter09.xhtml#P7000497027000000000000000007503" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004601A" data-uri="chapter09.xhtml#P700049702700000000000000004601A" epub:type="title">Allocating Blocks</h1></header>
<p id="P700049702700000000000000004601B" data-uri="chapter09.xhtml#P700049702700000000000000004601B" class="pcalibre8 pcalibre1 pcalibre2">An application requests a block of size bytes of memory by calling the <code id="P700049702700000000000000004601C" data-uri="chapter09.xhtml#P700049702700000000000000004601C" class="pcalibre1 calibre1 pcalibre2">mm_malloc</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007512"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.47</span></a>). After checking for spurious requests, the allocator must adjust the requested block size to allow room for the header and the footer, and to satisfy the double-word alignment requirement. Lines 12–13 enforce the minimum block size of 16 bytes: 8 bytes to satisfy the alignment requirement and 8 more bytes for the overhead of the header and footer. For requests over 8 bytes (line 15), the general rule is to add in the overhead bytes and then round up to the nearest multiple of 8.</p>
<p id="P700049702700000000000000004601D" data-uri="chapter09.xhtml#P700049702700000000000000004601D" class="pcalibre8 pcalibre1 pcalibre2">Once the allocator has adjusted the requested size, it searches the free list for a suitable free block (line 18). If there is a fit, then the allocator places the requested block and optionally splits the excess (line 19) and then returns the address of the newly allocated block.</p>
<p id="P700049702700000000000000004601E" data-uri="chapter09.xhtml#P700049702700000000000000004601E" class="pcalibre8 pcalibre1 pcalibre2">If the allocator cannot find a fit, it extends the heap with a new free block (lines 24–26), places the requested block in the new free block, optionally splitting the block (line 27), and then returns a pointer to the newly allocated block.</p>
<figure id="P7000497027000000000000000007509" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P7000497027000000000000000007509">
<p id="P700049702700000000000000004601F" data-uri="chapter09.xhtml#P700049702700000000000000004601F" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000750B" title="860" data-uri="chapter09.xhtml#P700049702700000000000000000750B" epub:type="pagebreak"></span>______________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/mm.c</i></p>
<pre id="P7000497027000000000000000046020" data-uri="chapter09.xhtml#P7000497027000000000000000046020" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046021" data-uri="chapter09.xhtml#P7000497027000000000000000046021" class="calibre3 pcalibre1 pcalibre2">
1	void mm_free(void *bp)
2	{
3		size_t size = GET_SIZE(HDRP(bp));
4	
5		PUT(HDRP(bp), PACKCsize, 0));
6		PUT(FTRPCbp), PACKCsize, 0));
7		coalesce(bp);
8	}
9	
10	static void *coalesce(void *bp)
11	{
12		size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));
13		size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
14		size_t size = GET_SIZE(HDRP(bp));
15	
16		if (prev_alloc &amp;&amp; next_alloc) {			/* Case 1 */
17			return bp;
18		}
19	
20		else if (prev_alloc &amp;&amp; !next_alloc) {		/* Case 2 */
21			size += GET_SIZE(HDRP(NEXT_BLKP(bp)));
22			PUT(HDRP(bp), PACK(size, 0));
23			PUT (FTRP(bp), PACK(size,0));
24		}
25	
26		else if (!prev_alloc &amp;&amp; next_alloc) {		/* Case 3 */
27			size += GET_SIZE(HDRP(PREV_BLKP(bp)));
28			PUT(FTRPCbp), PACKCsize, 0));
29			PUT(HDRP(PREV_BLKP(bp)), PACKCsize, 0));
30			bp = PREV_BLKP(bp);
31		}
32	
33		else {						/* Case 4 */
34			size += GET_SIZE(HDRP(PREV_BLKP(bp))) +
35				GET_SIZE(FTRP(NEXT_BLKP(bp)));
36			PUT(HDRP(PREV_BLKP(bp)), PACKCsize, 0));
37			PUT(FTRP(NEXT_BLKP(bp)), PACKCsize, 0));
38			bp = PREV_BLKP(bp);
39		}
40		return bp;
41	}
</code></pre>
<p id="P7000497027000000000000000046022" data-uri="chapter09.xhtml#P7000497027000000000000000046022" class="pcalibre8 pcalibre1 pcalibre2">__________________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/mm.c</i></p>
<figcaption id="P7000497027000000000000000046023" data-uri="chapter09.xhtml#P7000497027000000000000000046023" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046024" data-uri="chapter09.xhtml#P7000497027000000000000000046024" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.46 </span><code id="P7000497027000000000000000046025" data-uri="chapter09.xhtml#P7000497027000000000000000046025" class="pcalibre1 calibre1 pcalibre2">mm_free</code> frees a block and uses boundary-tag coalescing to merge it with any adjacent free blocks in constant time.</h1></header></figcaption>
</figure>
<figure id="P7000497027000000000000000007512" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P7000497027000000000000000007512">
<p id="P7000497027000000000000000046026" data-uri="chapter09.xhtml#P7000497027000000000000000046026" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007514" title="861" data-uri="chapter09.xhtml#P7000497027000000000000000007514" epub:type="pagebreak"></span>____________________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/mm.c</i></p>
<pre id="P7000497027000000000000000046027" data-uri="chapter09.xhtml#P7000497027000000000000000046027" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046028" data-uri="chapter09.xhtml#P7000497027000000000000000046028" class="calibre3 pcalibre1 pcalibre2">
1	void *mm_malloc(size_t size)
2	{
3		size_t asize;	/* Adjusted block size */
4		size_t extendsize;	/* Amount to extend heap if no fit */
5		char *bp;
6	
7		/* Ignore spurious requests */
8		if (size == 0)
9			return NULL;
10	
11		/* Adjust block size to include overhead and alignment reqs. */
12		if (size &lt;= DSIZE)
13			asize = 2*DSIZE;
14		else
15			asize = DSIZE * ((size + (DSIZE) + (DSIZE-1)) / DSIZE);
16	
17		/* Search the free list for a fit */
18		if ((bp = find_fit(asize)) != NULL) {
19			place(bp, asize);
20			return bp;
21		}
22	
23		/* No fit found. Get more memory and place the block */
24		extendsize = MAX(asize,CHUNKSIZE);
25		if ((bp = extend_heap(extendsize/WSIZE)) == NULL)
26		return NULL;
27		place(bp, asize);
28		return bp;
29	}
</code></pre>
<p id="P7000497027000000000000000046029" data-uri="chapter09.xhtml#P7000497027000000000000000046029" class="pcalibre8 pcalibre1 pcalibre2">____________________________________________________________________<i class="pcalibre17 pcalibre2 pcalibre1">code/vm/malloc/mm.c</i></p>
<figcaption id="P700049702700000000000000004602A" data-uri="chapter09.xhtml#P700049702700000000000000004602A" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004602B" data-uri="chapter09.xhtml#P700049702700000000000000004602B" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.47 </span><code id="P700049702700000000000000004602C" data-uri="chapter09.xhtml#P700049702700000000000000004602C" class="pcalibre1 calibre1 pcalibre2">mm_malloc</code> allocates a block from the free list.</h1></header></figcaption>
</figure>
<section id="P700049702700000000000000000751B" data-uri="chapter09.xhtml#P700049702700000000000000000751B" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P700049702700000000000000004602D" data-uri="chapter09.xhtml#P700049702700000000000000004602D" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">9.8 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P7000497027000000000000000007849">884</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004602E" data-uri="chapter09.xhtml#P700049702700000000000000004602E">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004602F" data-uri="chapter09.xhtml#P700049702700000000000000004602F">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000046030" data-uri="chapter09.xhtml#P7000497027000000000000000046030"><p id="P7000497027000000000000000046031" data-uri="chapter09.xhtml#P7000497027000000000000000046031" class="pcalibre1 pcalibre2 pcalibre10">Implement a <code id="P7000497027000000000000000046032" data-uri="chapter09.xhtml#P7000497027000000000000000046032" class="pcalibre1 calibre1 pcalibre2">find_fit</code> function for the simple allocator described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000748F"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">9.9.12</span></a>.</p>
<pre id="P7000497027000000000000000046033" data-uri="chapter09.xhtml#P7000497027000000000000000046033" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046034" data-uri="chapter09.xhtml#P7000497027000000000000000046034" class="calibre3 pcalibre1 pcalibre2">
static void *find_fit(size_t asize)
</code></pre>
<p id="P7000497027000000000000000046035" data-uri="chapter09.xhtml#P7000497027000000000000000046035" class="pcalibre1 pcalibre2 pcalibre10">Your solution should perform a first-fit search of the implicit free list.</p>
</div></li></ol>
</section>
<section id="P7000497027000000000000000007525" data-uri="chapter09.xhtml#P7000497027000000000000000007525" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P7000497027000000000000000046036" data-uri="chapter09.xhtml#P7000497027000000000000000046036" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">9.9 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P7000497027000000000000000007849">884</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000046037" data-uri="chapter09.xhtml#P7000497027000000000000000046037">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000046038" data-uri="chapter09.xhtml#P7000497027000000000000000046038">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000046039" data-uri="chapter09.xhtml#P7000497027000000000000000046039"><p id="P700049702700000000000000004603A" data-uri="chapter09.xhtml#P700049702700000000000000004603A" class="pcalibre1 pcalibre2 pcalibre10">Implement a place function for the example allocator.</p>
<pre id="P700049702700000000000000004603B" data-uri="chapter09.xhtml#P700049702700000000000000004603B" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004603C" data-uri="chapter09.xhtml#P700049702700000000000000004603C" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000752D" title="862" data-uri="chapter09.xhtml#P700049702700000000000000000752D" epub:type="pagebreak"></span>static void place(void *bp, size_t asize)
</code></pre>
<p id="P700049702700000000000000004603D" data-uri="chapter09.xhtml#P700049702700000000000000004603D" class="pcalibre1 pcalibre2 pcalibre10">Your solution should place the requested block at the beginning of the free block, splitting only if the size of the remainder would equal or exceed the minimum block size.</p>
</div></li></ol>
</section>
</section>
</section>
<section id="P700049702700000000000000000752F" data-uri="chapter09.xhtml#P700049702700000000000000000752F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004603E" data-uri="chapter09.xhtml#P700049702700000000000000004603E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.13 </span>Explicit Free Lists</h1></header>
<p id="P700049702700000000000000004603F" data-uri="chapter09.xhtml#P700049702700000000000000004603F" class="pcalibre8 pcalibre1 pcalibre2">The implicit free list provides us with a simple way to introduce some basic allocator concepts. However, because block allocation time is linear in the total number of heap blocks, the implicit free list is not appropriate for a general-purpose allocator (although it might be fine for a special-purpose allocator where the number of heap blocks is known beforehand to be small).</p>
<p id="P7000497027000000000000000046040" data-uri="chapter09.xhtml#P7000497027000000000000000046040" class="pcalibre8 pcalibre1 pcalibre2">A better approach is to organize the free blocks into some form of explicit data structure. Since by definition the body of a free block is not needed by the program, the pointers that implement the data structure can be stored within the bodies of the free blocks. For example, the heap can be organized as a doubly linked free list by including a <code id="P7000497027000000000000000046041" data-uri="chapter09.xhtml#P7000497027000000000000000046041" class="pcalibre1 calibre1 pcalibre2">pred</code> (predecessor) and <code id="P7000497027000000000000000046042" data-uri="chapter09.xhtml#P7000497027000000000000000046042" class="pcalibre1 calibre1 pcalibre2">succ</code> (successor) pointer in each free block, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007536"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.48</span></a>.</p>
<p id="P7000497027000000000000000046043" data-uri="chapter09.xhtml#P7000497027000000000000000046043" class="pcalibre8 pcalibre1 pcalibre2">Using a doubly linked list instead of an implicit free list reduces the first-fit allocation time from linear in the total number of blocks to linear in the number of <i class="pcalibre17 pcalibre2 pcalibre1">free</i> blocks. However, the time to free a block can be either linear or constant, depending on the policy we choose for ordering the blocks in the free list.</p>
<figure id="P7000497027000000000000000007536" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P7000497027000000000000000007536">
<img alt="Diagrams illustrate allocated block and free block." id="P7000497027000000000000000046044" data-uri="P700049702700000000000000000B7A6" src="../images/p862-1.png" class="calibre79 pcalibre1 pcalibre2"/>
<figcaption id="P7000497027000000000000000046045" data-uri="chapter09.xhtml#P7000497027000000000000000046045" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046046" data-uri="chapter09.xhtml#P7000497027000000000000000046046" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.48 </span>Format of heap blocks that use doubly linked free lists.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P700049702700000000000000002639F" data-uri="chapter09.xhtml#P700049702700000000000000002639F">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000046047" data-uri="chapter09.xhtml#P7000497027000000000000000046047" class="pcalibre8 pcalibre1 pcalibre2">Two diagrams each show a block, from 31 to 0 bits. Diagram (a), of the allocated block, has the following from top to bottom:</p>
<ul id="P7000497027000000000000000046048" data-uri="chapter09.xhtml#P7000497027000000000000000046048" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000046049" data-uri="chapter09.xhtml#P7000497027000000000000000046049" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004604A" data-uri="chapter09.xhtml#P700049702700000000000000004604A" class="pcalibre1 pcalibre2 pcalibre10">Header, with block size from 31 to 3 bits and a/f from 2 to 0 bits</p></li>
<li id="P700049702700000000000000004604B" data-uri="chapter09.xhtml#P700049702700000000000000004604B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004604C" data-uri="chapter09.xhtml#P700049702700000000000000004604C" class="pcalibre1 pcalibre2 pcalibre10">Payload</p></li>
<li id="P700049702700000000000000004604D" data-uri="chapter09.xhtml#P700049702700000000000000004604D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004604E" data-uri="chapter09.xhtml#P700049702700000000000000004604E" class="pcalibre1 pcalibre2 pcalibre10">Padding (optional)</p></li>
<li id="P700049702700000000000000004604F" data-uri="chapter09.xhtml#P700049702700000000000000004604F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046050" data-uri="chapter09.xhtml#P7000497027000000000000000046050" class="pcalibre1 pcalibre2 pcalibre10">Footer, with block size and a/f as in the header</p></li>
</ul>
<p id="P7000497027000000000000000046051" data-uri="chapter09.xhtml#P7000497027000000000000000046051" class="pcalibre1 pcalibre2 pcalibre10">Diagram (b), of the free block, has the old payload section divided into pred (predecessor) and succ (successor) at the top, with a blank section below.</p>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000046052" data-uri="chapter09.xhtml#P7000497027000000000000000046052" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000753B" title="863" data-uri="chapter09.xhtml#P700049702700000000000000000753B" epub:type="pagebreak"></span>One approach is to maintain the list in <i class="pcalibre17 pcalibre2 pcalibre1">last-in first-out</i> (LIFO) order by inserting newly freed blocks at the beginning of the list. With a LIFO ordering and a first-fit placement policy, the allocator inspects the most recently used blocks first. In this case, freeing a block can be performed in constant time. If boundary tags are used, then coalescing can also be performed in constant time.</p>
<p id="P7000497027000000000000000046053" data-uri="chapter09.xhtml#P7000497027000000000000000046053" class="pcalibre8 pcalibre1 pcalibre2">Another approach is to maintain the list in <i class="pcalibre17 pcalibre2 pcalibre1">address order</i>, where the address of each block in the list is less than the address of its successor. In this case, freeing a block requires a linear-time search to locate the appropriate predecessor. The trade-off is that address-ordered first fit enjoys better memory utilization than LIFO-ordered first fit, approaching the utilization of best fit.</p>
<p id="P7000497027000000000000000046054" data-uri="chapter09.xhtml#P7000497027000000000000000046054" class="pcalibre8 pcalibre1 pcalibre2">A disadvantage of explicit lists in general is that free blocks must be large enough to contain all of the necessary pointers, as well as the header and possibly a footer. This results in a larger minimum block size and increases the potential for internal fragmentation.</p>
</section>
<section id="P700049702700000000000000000753E" data-uri="chapter09.xhtml#P700049702700000000000000000753E" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046055" data-uri="chapter09.xhtml#P7000497027000000000000000046055" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.9.14 </span>Segregated Free Lists</h1></header>
<p id="P7000497027000000000000000046056" data-uri="chapter09.xhtml#P7000497027000000000000000046056" class="pcalibre8 pcalibre1 pcalibre2">As we have seen, an allocator that uses a single linked list of free blocks requires time linear in the number of free blocks to allocate a block. A popular approach for reducing the allocation time, known generally as <i class="pcalibre17 pcalibre2 pcalibre1">segregated storage</i>, is to maintain multiple free lists, where each list holds blocks that are roughly the same size. The general idea is to partition the set of all possible block sizes into equivalence classes called <i class="pcalibre17 pcalibre2 pcalibre1">size classes.</i> There are many ways to define the size classes. For example, we might partition the block sizes by powers of 2:</p>

<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000046057" data-uri="chapter09.xhtml#P7000497027000000000000000046057"><m:math display="block" alttext="" data-uri="" altimg-width="592" altimg-height="19" altimg="../images/ch09-eq9.png"><m:mrow><m:mrow><m:mo>{</m:mo> <m:mn>1</m:mn> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mn>2</m:mn> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>3</m:mn><m:mo>,</m:mo><m:mn>4</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>5</m:mn><m:mo>−</m:mo><m:mn>8</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mo>⋯</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>025</m:mn><m:mo>−</m:mo><m:mn>2</m:mn><m:mo>,</m:mo><m:mn>048</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>2</m:mn><m:mo>,</m:mo><m:mn>049</m:mn><m:mo>−</m:mo><m:mn>4</m:mn><m:mo>,</m:mo><m:mn>096</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>4</m:mn><m:mo>,</m:mo><m:mn>097</m:mn><m:mo>−</m:mo><m:mi>∞</m:mi></m:mrow> <m:mo>}</m:mo></m:mrow></m:mrow></m:math></div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046058" data-uri="chapter09.xhtml#P7000497027000000000000000046058">Or we might assign small blocks to their own size classes and partition large blocks by powers of 2:</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000046059" data-uri="chapter09.xhtml#P7000497027000000000000000046059"><m:math display="block" alttext="" data-uri="" altimg-width="661" altimg-height="19" altimg="../images/ch09-eq10.png"><m:mrow><m:mrow><m:mo>{</m:mo> <m:mn>1</m:mn> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mn>2</m:mn> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mn>3</m:mn> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mo>⋯</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>023</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>024</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>025</m:mn><m:mo>−</m:mo><m:mn>2</m:mn><m:mo>,</m:mo><m:mn>048</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>2</m:mn><m:mo>,</m:mo><m:mn>049</m:mn><m:mo>−</m:mo><m:mn>4</m:mn><m:mo>,</m:mo><m:mn>096</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>4</m:mn><m:mo>,</m:mo><m:mn>097</m:mn><m:mo>−</m:mo><m:mi>∞</m:mi></m:mrow> <m:mo>}</m:mo></m:mrow></m:mrow></m:math></div>
<p id="P700049702700000000000000004605A" data-uri="chapter09.xhtml#P700049702700000000000000004605A" class="pcalibre8 pcalibre1 pcalibre2">The allocator maintains an array of free lists, with one free list per size class, ordered by increasing size. When the allocator needs a block of size <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, it searches the appropriate free list. If it cannot find a block that fits, it searches the next list, and so on.</p>
<p id="P700049702700000000000000004605B" data-uri="chapter09.xhtml#P700049702700000000000000004605B" class="pcalibre8 pcalibre1 pcalibre2">The dynamic storage allocation literature describes dozens of variants of segregated storage that differ in how they define size classes, when they perform coalescing, when they request additional heap memory from the operating system, whether they allow splitting, and so forth. To give you a sense of what is possible, we will describe two of the basic approaches: <i class="pcalibre17 pcalibre2 pcalibre1">simple segregated storage</i> and <i class="pcalibre17 pcalibre2 pcalibre1">segregated fits.</i></p>
<section id="P7000497027000000000000000007546" data-uri="chapter09.xhtml#P7000497027000000000000000007546" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004605C" data-uri="chapter09.xhtml#P700049702700000000000000004605C" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007548" title="864" data-uri="chapter09.xhtml#P7000497027000000000000000007548" epub:type="pagebreak"></span>Simple Segregated Storage</h1></header>
<p id="P700049702700000000000000004605D" data-uri="chapter09.xhtml#P700049702700000000000000004605D" class="pcalibre8 pcalibre1 pcalibre2">With simple segregated storage, the free list for each size class contains same-size blocks, each the size of the largest element of the size class. For example, if some size class is defined as {17–32}, then the free list for that class consists entirely of blocks of size 32.</p>
<p id="P700049702700000000000000004605E" data-uri="chapter09.xhtml#P700049702700000000000000004605E" class="pcalibre8 pcalibre1 pcalibre2">To allocate a block of some given size, we check the appropriate free list. If the list is not empty, we simply allocate the first block in its entirety. Free blocks are never split to satisfy allocation requests. If the list is empty, the allocator requests a fixed-size chunk of additional memory from the operating system (typically a multiple of the page size), divides the chunk into equal-size blocks, and links the blocks together to form the new free list. To free a block, the allocator simply inserts the block at the front of the appropriate free list.</p>
<p id="P700049702700000000000000004605F" data-uri="chapter09.xhtml#P700049702700000000000000004605F" class="pcalibre8 pcalibre1 pcalibre2">There are a number of advantages to this simple scheme. Allocating and freeing blocks are both fast constant-time operations. Further, the combination of the same-size blocks in each chunk, no splitting, and no coalescing means that there is very little per-block memory overhead. Since each chunk has only same-size blocks, the size of an allocated block can be inferred from its address. Since there is no coalescing, allocated blocks do not need an allocated/free flag in the header. Thus, allocated blocks require no headers, and since there is no coalescing, they do not require any footers either. Since allocate and free operations insert and delete blocks at the beginning of the free list, the list need only be singly linked instead of doubly linked. The bottom line is that the only required field in any block is a one-word <code id="P7000497027000000000000000046060" data-uri="chapter09.xhtml#P7000497027000000000000000046060" class="pcalibre1 calibre1 pcalibre2">succ</code> pointer in each free block, and thus the minimum block size is only one word.</p>
<p id="P7000497027000000000000000046061" data-uri="chapter09.xhtml#P7000497027000000000000000046061" class="pcalibre8 pcalibre1 pcalibre2">A significant disadvantage is that simple segregated storage is susceptible to internal and external fragmentation. Internal fragmentation is possible because free blocks are never split. Worse, certain reference patterns can cause extreme external fragmentation because free blocks are never coalesced (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000754E"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">9.10</span></a>).</p>
<section id="P700049702700000000000000000754E" data-uri="chapter09.xhtml#P700049702700000000000000000754E" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P7000497027000000000000000046062" data-uri="chapter09.xhtml#P7000497027000000000000000046062" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">9.10 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P700049702700000000000000000785C">885</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000046063" data-uri="chapter09.xhtml#P7000497027000000000000000046063">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000046064" data-uri="chapter09.xhtml#P7000497027000000000000000046064">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000046065" data-uri="chapter09.xhtml#P7000497027000000000000000046065"><p id="P7000497027000000000000000046066" data-uri="chapter09.xhtml#P7000497027000000000000000046066" class="pcalibre1 pcalibre2 pcalibre10">Describe a reference pattern that results in severe external fragmentation in an allocator based on simple segregated storage.</p>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000007554" data-uri="chapter09.xhtml#P7000497027000000000000000007554" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046067" data-uri="chapter09.xhtml#P7000497027000000000000000046067" epub:type="title">Segregated Fits</h1></header>
<p id="P7000497027000000000000000046068" data-uri="chapter09.xhtml#P7000497027000000000000000046068" class="pcalibre8 pcalibre1 pcalibre2">With this approach, the allocator maintains an array of free lists. Each free list is associated with a size class and is organized as some kind of explicit or implicit list. Each list contains potentially different-size blocks whose sizes are members of the size class. There are many variants of segregated fits allocators. Here we describe a simple version.</p>
<p id="P7000497027000000000000000046069" data-uri="chapter09.xhtml#P7000497027000000000000000046069" class="pcalibre8 pcalibre1 pcalibre2">To allocate a block, we determine the size class of the request and do a first-fit search of the appropriate free list for a block that fits. If we find one, then we (optionally) split it and insert the fragment in the appropriate free list. If we cannot find a block that fits, then we search the free list for the next larger size class. We <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007558" title="865" data-uri="chapter09.xhtml#P7000497027000000000000000007558" epub:type="pagebreak"></span>repeat until we find a block that fits. If none of the free lists yields a block that fits, then we request additional heap memory from the operating system, allocate the block out of this new heap memory, and place the remainder in the appropriate size class. To free a block, we coalesce and place the result on the appropriate free list.</p>
<p id="P700049702700000000000000004606A" data-uri="chapter09.xhtml#P700049702700000000000000004606A" class="pcalibre8 pcalibre1 pcalibre2">The segregated fits approach is a popular choice with production-quality allocators such as the GNU <code id="P700049702700000000000000004606B" data-uri="chapter09.xhtml#P700049702700000000000000004606B" class="pcalibre1 calibre1 pcalibre2">malloc</code> package provided in the C standard library because it is both fast and memory efficient. Search times are reduced because searches are limited to particular parts of the heap instead of the entire heap. Memory utilization can improve because of the interesting fact that a simple first-fit search of a segregated free list approximates a best-fit search of the entire heap.</p>
</section>
<section id="P700049702700000000000000000755B" data-uri="chapter09.xhtml#P700049702700000000000000000755B" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004606C" data-uri="chapter09.xhtml#P700049702700000000000000004606C" epub:type="title">Buddy Systems</h1></header>
<p id="P700049702700000000000000004606D" data-uri="chapter09.xhtml#P700049702700000000000000004606D" class="pcalibre8 pcalibre1 pcalibre2">A <i class="pcalibre17 pcalibre2 pcalibre1">buddy system</i> is a special case of segregated fits where each size class is a power of 2. The basic idea is that, given a heap of 2<i class="pcalibre17 pcalibre2 pcalibre1"><sup class="pcalibre1 pcalibre2 pcalibre85">m</sup></i> words, we maintain a separate free list for each block size <i class="pcalibre17 pcalibre2 pcalibre1">2<sup class="pcalibre1 pcalibre2 pcalibre85">k</sup></i>, where 0 ≤ <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≤ <var class="pcalibre17 pcalibre2 pcalibre1">m</var>. Requested block sizes are rounded up to the nearest power of 2. Originally, there is one free block of size 2<i class="pcalibre17 pcalibre2 pcalibre1"><sup class="pcalibre1 pcalibre2 pcalibre85">m</sup></i> words.</p>
<p id="P700049702700000000000000004606E" data-uri="chapter09.xhtml#P700049702700000000000000004606E" class="pcalibre8 pcalibre1 pcalibre2">To allocate a block of size 2<i class="pcalibre17 pcalibre2 pcalibre1"><sup class="pcalibre1 pcalibre2 pcalibre85">k</sup></i>, we find the first available block of size 2<sup class="pcalibre1 pcalibre2 pcalibre85"><var class="pcalibre17 pcalibre2 pcalibre1">j</var></sup>, such that <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≤ <var class="pcalibre17 pcalibre2 pcalibre1">j</var> ≤ <var class="pcalibre17 pcalibre2 pcalibre1">m</var>. If <var class="pcalibre17 pcalibre2 pcalibre1">j</var> = <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, then we are done. Otherwise, we recursively split the block in half until <var class="pcalibre17 pcalibre2 pcalibre1">j</var> = <i class="pcalibre17 pcalibre2 pcalibre1">k.</i> As we perform this splitting, each remaining half (known as a <i class="pcalibre17 pcalibre2 pcalibre1">buddy</i>) is placed on the appropriate free list. To free a block of size 2<i class="pcalibre17 pcalibre2 pcalibre1"><sup class="pcalibre1 pcalibre2 pcalibre85">k</sup></i>, we continue coalescing with the free buddies. When we encounter an allocated buddy, we stop the coalescing.</p>
<p id="P700049702700000000000000004606F" data-uri="chapter09.xhtml#P700049702700000000000000004606F" class="pcalibre8 pcalibre1 pcalibre2">A key fact about buddy systems is that, given the address and size of a block, it is easy to compute the address of its buddy. For example, a block of size 32 bytes with address</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000046070" data-uri="chapter09.xhtml#P7000497027000000000000000046070"><m:math display="block" alttext="" data-uri="" altimg-width="134" altimg-height="15" altimg="../images/ch09-eq11.png"><m:mrow><m:mi>x</m:mi><m:mi>x</m:mi><m:mi>x</m:mi><m:mtext> </m:mtext><m:mo>…</m:mo><m:mi>x</m:mi><m:mn>00000</m:mn></m:mrow></m:math></div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046071" data-uri="chapter09.xhtml#P7000497027000000000000000046071">has its buddy at address</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000046072" data-uri="chapter09.xhtml#P7000497027000000000000000046072"><m:math display="block" alttext="" data-uri="" altimg-width="134" altimg-height="16" altimg="../images/ch09-eq12.png"><m:mrow><m:mi>x</m:mi><m:mi>x</m:mi><m:mi>x</m:mi><m:mtext> </m:mtext><m:mo>…</m:mo><m:mi>x</m:mi><m:mn>10000</m:mn></m:mrow></m:math></div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046073" data-uri="chapter09.xhtml#P7000497027000000000000000046073">In other words, the addresses of a block and its buddy differ in exactly one bit position.</p>
<p id="P7000497027000000000000000046074" data-uri="chapter09.xhtml#P7000497027000000000000000046074" class="pcalibre8 pcalibre1 pcalibre2">The major advantage of a buddy system allocator is its fast searching and coalescing. The major disadvantage is that the power-of-2 requirement on the block size can cause significant internal fragmentation. For this reason, buddy system allocators are not appropriate for general-purpose workloads. However, for certain application-specific workloads, where the block sizes are known in advance to be powers of 2, buddy system allocators have a certain appeal.</p>
</section>
</section>
</section></body></html>
