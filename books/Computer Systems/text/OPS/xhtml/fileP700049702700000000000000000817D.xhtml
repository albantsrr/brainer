<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>12.3 Concurrent Programming with Threads</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P700049702700000000000000000817D" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000046C62" data-uri="chapter12.xhtml#P7000497027000000000000000046C62" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3 </span>Concurrent Programming with Threads</h1></header>
<p id="P7000497027000000000000000046C63" data-uri="chapter12.xhtml#P7000497027000000000000000046C63" class="pcalibre8 pcalibre1 pcalibre2">To this point, we have looked at two approaches for creating concurrent logical flows. With the first approach, we use a separate process for each flow. The kernel schedules each process automatically, and each process has its own private address space, which makes it difficult for flows to share data. With the second approach, we create our own logical flows and use I/O multiplexing to explicitly schedule the flows. Because there is only one process, flows share the entire address space. <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000008180" title="986" data-uri="chapter12.xhtml#P7000497027000000000000000008180" epub:type="pagebreak"></span>This section introduces a third approach—based on threads—that is a hybrid of these two.</p>
<p id="P7000497027000000000000000046C64" data-uri="chapter12.xhtml#P7000497027000000000000000046C64" class="pcalibre8 pcalibre1 pcalibre2">A <i class="pcalibre17 pcalibre2 pcalibre1">thread</i> is a logical flow that runs in the context of a process. Thus far in this book, our programs have consisted of a single thread per process. But modern systems also allow us to write programs that have multiple threads running concurrently in a single process. The threads are scheduled automatically by the kernel. Each thread has its own <i class="pcalibre17 pcalibre2 pcalibre1">thread context</i>, including a unique integer <i class="pcalibre17 pcalibre2 pcalibre1">thread ID (TID)</i>, stack, stack pointer, program counter, general-purpose registers, and condition codes. All threads running in a process share the entire virtual address space of that process.</p>
<p id="P7000497027000000000000000046C65" data-uri="chapter12.xhtml#P7000497027000000000000000046C65" class="pcalibre8 pcalibre1 pcalibre2">Logical flows based on threads combine qualities of flows based on processes and I/O multiplexing. Like processes, threads are scheduled automatically by the kernel and are known to the kernel by an integer ID. Like flows based on I/O multiplexing, multiple threads run in the context of a single process, and thus they share the entire contents of the process virtual address space, including its code, data, heap, shared libraries, and open files.</p>
<section id="P7000497027000000000000000008183" data-uri="chapter12.xhtml#P7000497027000000000000000008183" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046C66" data-uri="chapter12.xhtml#P7000497027000000000000000046C66" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.1 </span>Thread Execution Model</h1></header>
<p id="P7000497027000000000000000046C67" data-uri="chapter12.xhtml#P7000497027000000000000000046C67" class="pcalibre8 pcalibre1 pcalibre2">The execution model for multiple threads is similar in some ways to the execution model for multiple processes. Consider the example in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008189"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.12</span></a>. Each process begins life as a single thread called the <i class="pcalibre17 pcalibre2 pcalibre1">main thread</i>. At some point, the main thread creates a <i class="pcalibre17 pcalibre2 pcalibre1">peer thread</i>, and from this point in time the two threads run concurrently. Eventually, control passes to the peer thread via a context switch, either because the main thread executes a slow system call such as <code id="P7000497027000000000000000046C68" data-uri="chapter12.xhtml#P7000497027000000000000000046C68" class="pcalibre1 calibre1 pcalibre2">read</code> or <code id="P7000497027000000000000000046C69" data-uri="chapter12.xhtml#P7000497027000000000000000046C69" class="pcalibre1 calibre1 pcalibre2">sleep</code> or because it is interrupted by the system's interval timer. The peer thread executes for a while before control passes back to the main thread, and so on.</p>
<p id="P7000497027000000000000000046C6A" data-uri="chapter12.xhtml#P7000497027000000000000000046C6A" class="pcalibre8 pcalibre1 pcalibre2">Thread execution differs from processes in some important ways. Because a thread context is much smaller than a process context, a thread context switch is faster than a process context switch. Another difference is that threads, unlike processes, are not organized in a rigid parent-child hierarchy. The threads associated</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008189" data-uri="chapter12.xhtml#P7000497027000000000000000008189">
<img alt="A diagram of concurrent thread execution shows a progression over time from thread 1 (main thread) to thread 2 (peer thread) within the thread context switch, and proceeding in this pattern." id="P7000497027000000000000000046C6B" data-uri="P700049702700000000000000000B7D0" src="../images/p986-1.png" class="calibre88 pcalibre1 pcalibre2"/>
<figcaption id="P7000497027000000000000000046C6C" data-uri="chapter12.xhtml#P7000497027000000000000000046C6C" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046C6D" data-uri="chapter12.xhtml#P7000497027000000000000000046C6D" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.12 </span>Concurrent thread execution.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046C6E" data-uri="chapter12.xhtml#P7000497027000000000000000046C6E"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000818E" title="987" data-uri="chapter12.xhtml#P700049702700000000000000000818E" epub:type="pagebreak"></span>with a process form a <i class="pcalibre17 pcalibre2 pcalibre1">pool</i> of peers, independent of which threads were created by which other threads. The main thread is distinguished from other threads only in the sense that it is always the first thread to run in the process. The main impact of this notion of a pool of peers is that a thread can kill any of its peers or wait for any of its peers to terminate. Further, each peer can read and write the same shared data.</p>
</section>
<section id="P700049702700000000000000000818F" data-uri="chapter12.xhtml#P700049702700000000000000000818F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046C6F" data-uri="chapter12.xhtml#P7000497027000000000000000046C6F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.2 </span>Posix Threads</h1></header>
<p id="P7000497027000000000000000046C70" data-uri="chapter12.xhtml#P7000497027000000000000000046C70" class="pcalibre8 pcalibre1 pcalibre2">Posix threads (Pthreads) is a standard interface for manipulating threads from C programs. It was adopted in 1995 and is available on all Linux systems. Pthreads defines about 60 functions that allow programs to create, kill, and reap threads, to share data safely with peer threads, and to notify peers about changes in the system state.</p>
<p id="P7000497027000000000000000046C71" data-uri="chapter12.xhtml#P7000497027000000000000000046C71" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008195"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.13</span></a> shows a simple Pthreads program. The main thread creates a peer thread and then waits for it to terminate. The peer thread prints <code id="P7000497027000000000000000046C72" data-uri="chapter12.xhtml#P7000497027000000000000000046C72" class="pcalibre1 calibre1 pcalibre2">Hello, world!\n</code> and terminates. When the main thread detects that the peer thread has terminated, it terminates the process by calling <code id="P7000497027000000000000000046C73" data-uri="chapter12.xhtml#P7000497027000000000000000046C73" class="pcalibre1 calibre1 pcalibre2">exit</code>. This is the first threaded program we have seen, so let us dissect it carefully. The code and local data for a thread are encapsulated in a <i class="pcalibre17 pcalibre2 pcalibre1">thread routine</i>. As shown by the prototype in line 2, each thread routine takes as input a single generic pointer and returns a generic pointer. If you want to pass multiple arguments to a thread routine, then you should put the arguments into a structure and pass a pointer to the structure. Similarly, if you</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008195" data-uri="chapter12.xhtml#P7000497027000000000000000008195">
<p id="P7000497027000000000000000046C74" data-uri="chapter12.xhtml#P7000497027000000000000000046C74" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/hello.c</i></p>
<pre id="P7000497027000000000000000046C75" data-uri="chapter12.xhtml#P7000497027000000000000000046C75" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046C76" data-uri="chapter12.xhtml#P7000497027000000000000000046C76" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	void *thread(void *vargp);
3	
4	int main()
5	{
6		pthread_t tid;
7		Pthread_create(&amp;tid, NULL, thread, NULL);
8		Pthread_join(tid, NULL);
9		exit(0);
10	}
11	
12	void *thread(void *vargp) /* Thread routine */
13	{
14		printf("Hello, world!\n");
15		return NULL;
16	}
</code></pre>
<p id="P7000497027000000000000000046C77" data-uri="chapter12.xhtml#P7000497027000000000000000046C77" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/hello.c</i></p>
<figcaption id="P7000497027000000000000000046C78" data-uri="chapter12.xhtml#P7000497027000000000000000046C78" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046C79" data-uri="chapter12.xhtml#P7000497027000000000000000046C79" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.13 </span><code id="P7000497027000000000000000046C7A" data-uri="chapter12.xhtml#P7000497027000000000000000046C7A" class="pcalibre1 calibre1 pcalibre2">hello.c</code>: The Pthreads "Hello, world!" program.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046C7B" data-uri="chapter12.xhtml#P7000497027000000000000000046C7B"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000819E" title="988" data-uri="chapter12.xhtml#P700049702700000000000000000819E" epub:type="pagebreak"></span>want the thread routine to return multiple arguments, you can return a pointer to a structure.</p>
<p id="P7000497027000000000000000046C7C" data-uri="chapter12.xhtml#P7000497027000000000000000046C7C" class="pcalibre8 pcalibre1 pcalibre2">Line 4 marks the beginning of the code for the main thread. The main thread declares a single local variable <code id="P7000497027000000000000000046C7D" data-uri="chapter12.xhtml#P7000497027000000000000000046C7D" class="pcalibre1 calibre1 pcalibre2">tid</code>, which will be used to store the thread ID of the peer thread (line 6). The main thread creates a new peer thread by calling the <code id="P7000497027000000000000000046C7E" data-uri="chapter12.xhtml#P7000497027000000000000000046C7E" class="pcalibre1 calibre1 pcalibre2">pthread_create</code> function (line 7). When the call to <code id="P7000497027000000000000000046C7F" data-uri="chapter12.xhtml#P7000497027000000000000000046C7F" class="pcalibre1 calibre1 pcalibre2">pthread_create</code> returns, the main thread and the newly created peer thread are running concurrently, and <code id="P7000497027000000000000000046C80" data-uri="chapter12.xhtml#P7000497027000000000000000046C80" class="pcalibre1 calibre1 pcalibre2">tid</code> contains the ID of the new thread. The main thread waits for the peer thread to terminate with the call to <code id="P7000497027000000000000000046C81" data-uri="chapter12.xhtml#P7000497027000000000000000046C81" class="pcalibre1 calibre1 pcalibre2">pthread_join</code> in line 8. Finally, the main thread calls <code id="P7000497027000000000000000046C82" data-uri="chapter12.xhtml#P7000497027000000000000000046C82" class="pcalibre1 calibre1 pcalibre2">exit</code> (line 9), which terminates all threads (in this case, just the main thread) currently running in the process.</p>
<p id="P7000497027000000000000000046C83" data-uri="chapter12.xhtml#P7000497027000000000000000046C83" class="pcalibre8 pcalibre1 pcalibre2">Lines 12−16 define the thread routine for the peer thread. It simply prints a string and then terminates the peer thread by executing the <code id="P7000497027000000000000000046C84" data-uri="chapter12.xhtml#P7000497027000000000000000046C84" class="pcalibre1 calibre1 pcalibre2">return</code> statement in line 15.</p>
</section>
<section id="P70004970270000000000000000081A8" data-uri="chapter12.xhtml#P70004970270000000000000000081A8" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046C85" data-uri="chapter12.xhtml#P7000497027000000000000000046C85" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.3 </span>Creating Threads</h1></header>
<p id="P7000497027000000000000000046C86" data-uri="chapter12.xhtml#P7000497027000000000000000046C86" class="pcalibre8 pcalibre1 pcalibre2">Threads create other threads by calling the <code id="P7000497027000000000000000046C87" data-uri="chapter12.xhtml#P7000497027000000000000000046C87" class="pcalibre1 calibre1 pcalibre2">pthread_create</code> function.</p>
<pre id="P7000497027000000000000000046C88" data-uri="chapter12.xhtml#P7000497027000000000000000046C88" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046C89" data-uri="chapter12.xhtml#P7000497027000000000000000046C89" class="calibre3 pcalibre1 pcalibre2">
#include &lt;pthread.h&gt;
typedef void *(func)(void *);
int pthread_create(pthread_t *tid, pthread_attr_t *attr,
		   func *f, void *arg);
					Returns: 0 if OK, nonzero on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046C8A" data-uri="chapter12.xhtml#P7000497027000000000000000046C8A">The <code id="P7000497027000000000000000046C8B" data-uri="chapter12.xhtml#P7000497027000000000000000046C8B" class="pcalibre1 calibre1 pcalibre2">pthread_create</code> function creates a new thread and runs the <i class="pcalibre17 pcalibre2 pcalibre1">thread routine</i> <code id="P7000497027000000000000000046C8C" data-uri="chapter12.xhtml#P7000497027000000000000000046C8C" class="pcalibre1 calibre1 pcalibre2">f</code> in the context of the new thread and with an input argument of <code id="P7000497027000000000000000046C8D" data-uri="chapter12.xhtml#P7000497027000000000000000046C8D" class="pcalibre1 calibre1 pcalibre2">arg</code>. The <code id="P7000497027000000000000000046C8E" data-uri="chapter12.xhtml#P7000497027000000000000000046C8E" class="pcalibre1 calibre1 pcalibre2">attr</code> argument can be used to change the default attributes of the newly created thread. Changing these attributes is beyond our scope, and in our examples, we will always call <code id="P7000497027000000000000000046C8F" data-uri="chapter12.xhtml#P7000497027000000000000000046C8F" class="pcalibre1 calibre1 pcalibre2">pthread_create</code> with a NULL <code id="P7000497027000000000000000046C90" data-uri="chapter12.xhtml#P7000497027000000000000000046C90" class="pcalibre1 calibre1 pcalibre2">attr</code> argument.</p>
<p id="P7000497027000000000000000046C91" data-uri="chapter12.xhtml#P7000497027000000000000000046C91" class="pcalibre8 pcalibre1 pcalibre2">When <code id="P7000497027000000000000000046C92" data-uri="chapter12.xhtml#P7000497027000000000000000046C92" class="pcalibre1 calibre1 pcalibre2">pthread_create</code> returns, argument <code id="P7000497027000000000000000046C93" data-uri="chapter12.xhtml#P7000497027000000000000000046C93" class="pcalibre1 calibre1 pcalibre2">tid</code> contains the ID of the newly created thread. The new thread can determine its own thread ID by calling the <code id="P7000497027000000000000000046C94" data-uri="chapter12.xhtml#P7000497027000000000000000046C94" class="pcalibre1 calibre1 pcalibre2">pthread_self</code> function.</p>
<pre id="P7000497027000000000000000046C95" data-uri="chapter12.xhtml#P7000497027000000000000000046C95" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046C96" data-uri="chapter12.xhtml#P7000497027000000000000000046C96" class="calibre3 pcalibre1 pcalibre2">
#include &lt;pthread.h&gt;
pthread_t pthread_self(void);
						Returns: thread ID of caller
</code></pre>
</section>
<section id="P70004970270000000000000000081BB" data-uri="chapter12.xhtml#P70004970270000000000000000081BB" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046C97" data-uri="chapter12.xhtml#P7000497027000000000000000046C97" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.4 </span>Terminating Threads</h1></header>
<p id="P7000497027000000000000000046C98" data-uri="chapter12.xhtml#P7000497027000000000000000046C98" class="pcalibre8 pcalibre1 pcalibre2">A thread terminates in one of the following ways:</p>
<ul id="P7000497027000000000000000046C99" data-uri="chapter12.xhtml#P7000497027000000000000000046C99" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000046C9A" data-uri="chapter12.xhtml#P7000497027000000000000000046C9A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046C9B" data-uri="chapter12.xhtml#P7000497027000000000000000046C9B" class="pcalibre1 pcalibre2 pcalibre10">The thread terminates <i class="pcalibre17 pcalibre2 pcalibre1">implicitly</i> when its top-level thread routine returns.</p></li>
<li id="P7000497027000000000000000046C9C" data-uri="chapter12.xhtml#P7000497027000000000000000046C9C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046C9D" data-uri="chapter12.xhtml#P7000497027000000000000000046C9D" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000081C3" title="989" data-uri="chapter12.xhtml#P70004970270000000000000000081C3" epub:type="pagebreak"></span>The thread terminates <i class="pcalibre17 pcalibre2 pcalibre1">explicitly</i> by calling the <code id="P7000497027000000000000000046C9E" data-uri="chapter12.xhtml#P7000497027000000000000000046C9E" class="pcalibre1 calibre1 pcalibre2">pthread_exit</code> function. If the main thread calls <code id="P7000497027000000000000000046C9F" data-uri="chapter12.xhtml#P7000497027000000000000000046C9F" class="pcalibre1 calibre1 pcalibre2">pthread_exit</code>, it waits for all other peer threads to terminate and then terminates the main thread and the entire process with a return value of <code id="P7000497027000000000000000046CA0" data-uri="chapter12.xhtml#P7000497027000000000000000046CA0" class="pcalibre1 calibre1 pcalibre2">thread_return</code>.</p>
<pre id="P7000497027000000000000000046CA1" data-uri="chapter12.xhtml#P7000497027000000000000000046CA1" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046CA2" data-uri="chapter12.xhtml#P7000497027000000000000000046CA2" class="calibre3 pcalibre1 pcalibre2">
#include &lt;pthread.h&gt;
void pthread_exit(void *thread_return);
						Never returns
</code></pre></li>
<li id="P7000497027000000000000000046CA3" data-uri="chapter12.xhtml#P7000497027000000000000000046CA3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046CA4" data-uri="chapter12.xhtml#P7000497027000000000000000046CA4" class="pcalibre1 pcalibre2 pcalibre10">Some peer thread calls the Linux <code id="P7000497027000000000000000046CA5" data-uri="chapter12.xhtml#P7000497027000000000000000046CA5" class="pcalibre1 calibre1 pcalibre2">exit</code> function, which terminates the process and all threads associated with the process.</p></li>
<li id="P7000497027000000000000000046CA6" data-uri="chapter12.xhtml#P7000497027000000000000000046CA6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000046CA7" data-uri="chapter12.xhtml#P7000497027000000000000000046CA7" class="pcalibre1 pcalibre2 pcalibre10">Another peer thread terminates the current thread by calling the <code id="P7000497027000000000000000046CA8" data-uri="chapter12.xhtml#P7000497027000000000000000046CA8" class="pcalibre1 calibre1 pcalibre2">pthread_cancel</code> function with the ID of the current thread.</p>
<pre id="P7000497027000000000000000046CA9" data-uri="chapter12.xhtml#P7000497027000000000000000046CA9" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046CAA" data-uri="chapter12.xhtml#P7000497027000000000000000046CAA" class="calibre3 pcalibre1 pcalibre2">
#include &lt;pthread.h&gt;
int pthread_cancel(pthread_t tid);
					Returns: 0 if OK, nonzero on error
</code></pre></li>
</ul>
</section>
<section id="P70004970270000000000000000081D1" data-uri="chapter12.xhtml#P70004970270000000000000000081D1" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046CAB" data-uri="chapter12.xhtml#P7000497027000000000000000046CAB" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.5 </span>Reaping Terminated Threads</h1></header>
<p id="P7000497027000000000000000046CAC" data-uri="chapter12.xhtml#P7000497027000000000000000046CAC" class="pcalibre8 pcalibre1 pcalibre2">Threads wait for other threads to terminate by calling the <code id="P7000497027000000000000000046CAD" data-uri="chapter12.xhtml#P7000497027000000000000000046CAD" class="pcalibre1 calibre1 pcalibre2">pthread_join</code> function.</p>
<pre id="P7000497027000000000000000046CAE" data-uri="chapter12.xhtml#P7000497027000000000000000046CAE" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046CAF" data-uri="chapter12.xhtml#P7000497027000000000000000046CAF" class="calibre3 pcalibre1 pcalibre2">
#include &lt;pthread.h&gt;
int pthread_join(pthread_t tid, void **thread_return);
					Returns: 0 if OK, nonzero on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046CB0" data-uri="chapter12.xhtml#P7000497027000000000000000046CB0">The <code id="P7000497027000000000000000046CB1" data-uri="chapter12.xhtml#P7000497027000000000000000046CB1" class="pcalibre1 calibre1 pcalibre2">pthread_join</code> function blocks until thread <code id="P7000497027000000000000000046CB2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB2" class="pcalibre1 calibre1 pcalibre2">tid</code> terminates, assigns the generic (<code id="P7000497027000000000000000046CB3" data-uri="chapter12.xhtml#P7000497027000000000000000046CB3" class="pcalibre1 calibre1 pcalibre2">void *</code>) pointer returned by the thread routine to the location pointed to by <code id="P7000497027000000000000000046CB4" data-uri="chapter12.xhtml#P7000497027000000000000000046CB4" class="pcalibre1 calibre1 pcalibre2">thread_return</code>, and then <i class="pcalibre17 pcalibre2 pcalibre1">reaps</i> any memory resources held by the terminated thread.</p>
<p id="P7000497027000000000000000046CB5" data-uri="chapter12.xhtml#P7000497027000000000000000046CB5" class="pcalibre8 pcalibre1 pcalibre2">Notice that, unlike the Linux <code id="P7000497027000000000000000046CB6" data-uri="chapter12.xhtml#P7000497027000000000000000046CB6" class="pcalibre1 calibre1 pcalibre2">wait</code> function, the <code id="P7000497027000000000000000046CB7" data-uri="chapter12.xhtml#P7000497027000000000000000046CB7" class="pcalibre1 calibre1 pcalibre2">pthread_join</code> function can only wait for a specific thread to terminate. There is no way to instruct <code id="P7000497027000000000000000046CB8" data-uri="chapter12.xhtml#P7000497027000000000000000046CB8" class="pcalibre1 calibre1 pcalibre2">pthread_join</code> to wait for an <i class="pcalibre17 pcalibre2 pcalibre1">arbitrary</i> thread to terminate. This can complicate our code by forcing us to use other, less intuitive mechanisms to detect process termination. Indeed, Stevens argues convincingly that this is a bug in the specification [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>].</p>
</section>
<section id="P70004970270000000000000000081E0" data-uri="chapter12.xhtml#P70004970270000000000000000081E0" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046CB9" data-uri="chapter12.xhtml#P7000497027000000000000000046CB9" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.6 </span>Detaching Threads</h1></header>
<p id="P7000497027000000000000000046CBA" data-uri="chapter12.xhtml#P7000497027000000000000000046CBA" class="pcalibre8 pcalibre1 pcalibre2">At any point in time, a thread is <i class="pcalibre17 pcalibre2 pcalibre1">joinable</i> or <i class="pcalibre17 pcalibre2 pcalibre1">detached</i>. A joinable thread can be reaped and killed by other threads. Its memory resources (such as the stack) are not freed until it is reaped by another thread. In contrast, a detached thread cannot <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000081E3" title="990" data-uri="chapter12.xhtml#P70004970270000000000000000081E3" epub:type="pagebreak"></span>be reaped or killed by other threads. Its memory resources are freed automatically by the system when it terminates.</p>
<p id="P7000497027000000000000000046CBB" data-uri="chapter12.xhtml#P7000497027000000000000000046CBB" class="pcalibre8 pcalibre1 pcalibre2">By default, threads are created joinable. In order to avoid memory leaks, each joinable thread should be either explicitly reaped by another thread or detached by a call to the <code id="P7000497027000000000000000046CBC" data-uri="chapter12.xhtml#P7000497027000000000000000046CBC" class="pcalibre1 calibre1 pcalibre2">pthread_detach</code> function.</p>
<pre id="P7000497027000000000000000046CBD" data-uri="chapter12.xhtml#P7000497027000000000000000046CBD" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046CBE" data-uri="chapter12.xhtml#P7000497027000000000000000046CBE" class="calibre3 pcalibre1 pcalibre2">
#include &lt;pthread.h&gt;
int pthread_detach(pthread_t tid);
					Returns: 0 if OK, nonzero on error
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046CBF" data-uri="chapter12.xhtml#P7000497027000000000000000046CBF">The <code id="P7000497027000000000000000046CC0" data-uri="chapter12.xhtml#P7000497027000000000000000046CC0" class="pcalibre1 calibre1 pcalibre2">pthread_detach</code> function detaches the joinable thread <code id="P7000497027000000000000000046CC1" data-uri="chapter12.xhtml#P7000497027000000000000000046CC1" class="pcalibre1 calibre1 pcalibre2">tid</code>. Threads can detach themselves by calling <code id="P7000497027000000000000000046CC2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC2" class="pcalibre1 calibre1 pcalibre2">pthread_detach</code> with an argument of <code id="P7000497027000000000000000046CC3" data-uri="chapter12.xhtml#P7000497027000000000000000046CC3" class="pcalibre1 calibre1 pcalibre2">pthread_self()</code>.</p>
<p id="P7000497027000000000000000046CC4" data-uri="chapter12.xhtml#P7000497027000000000000000046CC4" class="pcalibre8 pcalibre1 pcalibre2">Although some of our examples will use joinable threads, there are good reasons to use detached threads in real programs. For example, a high-performance Web server might create a new peer thread each time it receives a connection request from a Web browser. Since each connection is handled independently by a separate thread, it is unnecessary—and indeed undesirable—for the server to explicitly wait for each peer thread to terminate. In this case, each peer thread should detach itself before it begins processing the request so that its memory resources can be reclaimed after it terminates.</p>
</section>
<section id="P70004970270000000000000000081EE" data-uri="chapter12.xhtml#P70004970270000000000000000081EE" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046CC5" data-uri="chapter12.xhtml#P7000497027000000000000000046CC5" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.3.7 </span>Initializing Threads</h1></header>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046CC6" data-uri="chapter12.xhtml#P7000497027000000000000000046CC6">The <code id="P7000497027000000000000000046CC7" data-uri="chapter12.xhtml#P7000497027000000000000000046CC7" class="pcalibre1 calibre1 pcalibre2">pthread_once</code> function allows you to initialize the state associated with a thread routine.</p>
<pre id="P7000497027000000000000000046CC8" data-uri="chapter12.xhtml#P7000497027000000000000000046CC8" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046CC9" data-uri="chapter12.xhtml#P7000497027000000000000000046CC9" class="calibre3 pcalibre1 pcalibre2">
#include &lt;pthread.h&gt;
pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *once_control,
		void (*init_routine)(void));
						Always returns 0
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046CCA" data-uri="chapter12.xhtml#P7000497027000000000000000046CCA">The <code id="P7000497027000000000000000046CCB" data-uri="chapter12.xhtml#P7000497027000000000000000046CCB" class="pcalibre1 calibre1 pcalibre2">once_control</code> variable is a global or static variable that is always initialized to PTHREAD_ONCE_INIT. The first time you call <code id="P7000497027000000000000000046CCC" data-uri="chapter12.xhtml#P7000497027000000000000000046CCC" class="pcalibre1 calibre1 pcalibre2">pthread_once</code> with an argument of <code id="P7000497027000000000000000046CCD" data-uri="chapter12.xhtml#P7000497027000000000000000046CCD" class="pcalibre1 calibre1 pcalibre2">once_control</code>, it invokes <code id="P7000497027000000000000000046CCE" data-uri="chapter12.xhtml#P7000497027000000000000000046CCE" class="pcalibre1 calibre1 pcalibre2">init_routine</code>, which is a function with no input arguments that returns nothing. Subsequent calls to <code id="P7000497027000000000000000046CCF" data-uri="chapter12.xhtml#P7000497027000000000000000046CCF" class="pcalibre1 calibre1 pcalibre2">pthread_once</code> with the same <code id="P7000497027000000000000000046CD0" data-uri="chapter12.xhtml#P7000497027000000000000000046CD0" class="pcalibre1 calibre1 pcalibre2">once_control</code> variable do nothing. The <code id="P7000497027000000000000000046CD1" data-uri="chapter12.xhtml#P7000497027000000000000000046CD1" class="pcalibre1 calibre1 pcalibre2">pthread_once</code> function is useful whenever you need to dynamically initialize global variables that are shared by multiple threads. We will look at an example in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008456"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5.5</span></a>.</p>
</section>
<section id="P70004970270000000000000000081FC" data-uri="chapter12.xhtml#P70004970270000000000000000081FC" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046CD2" data-uri="chapter12.xhtml#P7000497027000000000000000046CD2" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000081FE" title="991" data-uri="chapter12.xhtml#P70004970270000000000000000081FE" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">12.3.8 </span>A Concurrent Server Based on Threads</h1></header>
<p id="P7000497027000000000000000046CD3" data-uri="chapter12.xhtml#P7000497027000000000000000046CD3" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008200"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.14</span></a> shows the code for a concurrent echo server based on threads. The overall structure is similar to the process-based design. The main thread repeatedly waits for a connection request and then creates a peer thread to handle the request. While the code looks simple, there are a couple of general and somewhat subtle issues we need to look at more closely. The first issue is how to pass</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008200" data-uri="chapter12.xhtml#P7000497027000000000000000008200">
<p id="P7000497027000000000000000046CD4" data-uri="chapter12.xhtml#P7000497027000000000000000046CD4" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservert.c</i></p>
<pre id="P7000497027000000000000000046CD5" data-uri="chapter12.xhtml#P7000497027000000000000000046CD5" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046CD6" data-uri="chapter12.xhtml#P7000497027000000000000000046CD6" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	
3	void echo(int connfd);
4	void *thread(void *vargp);
5	
6	int main(int argc, char **argv)
7	{
8		int listenfd, *connfdp;
9		socklen_t clientlen;
10		struct sockaddr_storage clientaddr;
11		pthread_t tid;
12	
13		if (argc != 2) {
14			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
15			exit(0);
16		}
17		listenfd = Open_listenfd(argv[1]); 18
19		while (1) {
20			clientlen=sizeof(struct sockaddr_storage);
21			connfdp = Malloc(sizeof(int));
22			*connfdp = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);
23			Pthread_create(&amp;tid, NULL, thread, connfdp);
24		}
25	}
26	
27	/* Thread routine */
28	void *thread(void *vargp)
29	{
30		int connfd = *((int *)vargp);
31		Pthread_detach(pthread_self());
32		Free(vargp);
33		echo(connfd);
34		Close(connfd);
35		return NULL;
36	}
</code></pre>
<p id="P7000497027000000000000000046CD7" data-uri="chapter12.xhtml#P7000497027000000000000000046CD7" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/echoservert.c</i></p>
<figcaption id="P7000497027000000000000000046CD8" data-uri="chapter12.xhtml#P7000497027000000000000000046CD8" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046CD9" data-uri="chapter12.xhtml#P7000497027000000000000000046CD9" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.14 </span>Concurrent echo server based on threads.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046CDA" data-uri="chapter12.xhtml#P7000497027000000000000000046CDA"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000008208" title="992" data-uri="chapter12.xhtml#P7000497027000000000000000008208" epub:type="pagebreak"></span>the connected descriptor to the peer thread when we call <code id="P7000497027000000000000000046CDB" data-uri="chapter12.xhtml#P7000497027000000000000000046CDB" class="pcalibre1 calibre1 pcalibre2">pthread_create</code>. The obvious approach is to pass a pointer to the descriptor, as in the following:</p>
<pre id="P7000497027000000000000000046CDC" data-uri="chapter12.xhtml#P7000497027000000000000000046CDC" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046CDD" data-uri="chapter12.xhtml#P7000497027000000000000000046CDD" class="calibre3 pcalibre1 pcalibre2">
connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);
Pthread_create(&amp;tid, NULL, thread, &amp;connfd);
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046CDE" data-uri="chapter12.xhtml#P7000497027000000000000000046CDE">Then we have the peer thread dereference the pointer and assign it to a local variable, as follows:</p>
<pre id="P7000497027000000000000000046CDF" data-uri="chapter12.xhtml#P7000497027000000000000000046CDF" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046CE0" data-uri="chapter12.xhtml#P7000497027000000000000000046CE0" class="calibre3 pcalibre1 pcalibre2">
void *thread(void *vargp) {
	int connfd = *((int *)vargp);
	⋮
}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046CE1" data-uri="chapter12.xhtml#P7000497027000000000000000046CE1">This would be wrong, however, because it introduces a <i class="pcalibre17 pcalibre2 pcalibre1">race</i> between the assignment statement in the peer thread and the <code id="P7000497027000000000000000046CE2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE2" class="pcalibre1 calibre1 pcalibre2">accept</code> statement in the main thread. If the assignment statement completes before the next <code id="P7000497027000000000000000046CE3" data-uri="chapter12.xhtml#P7000497027000000000000000046CE3" class="pcalibre1 calibre1 pcalibre2">accept</code>, then the local <code id="P7000497027000000000000000046CE4" data-uri="chapter12.xhtml#P7000497027000000000000000046CE4" class="pcalibre1 calibre1 pcalibre2">connfd</code> variable in the peer thread gets the correct descriptor value. However, if the assignment completes <i class="pcalibre17 pcalibre2 pcalibre1">after</i> the <code id="P7000497027000000000000000046CE5" data-uri="chapter12.xhtml#P7000497027000000000000000046CE5" class="pcalibre1 calibre1 pcalibre2">accept</code>, then the local <code id="P7000497027000000000000000046CE6" data-uri="chapter12.xhtml#P7000497027000000000000000046CE6" class="pcalibre1 calibre1 pcalibre2">connfd</code> variable in the peer thread gets the descriptor number of the <i class="pcalibre17 pcalibre2 pcalibre1">next</i> connection. The unhappy result is that two threads are now performing input and output on the same descriptor. In order to avoid the potentially deadly race, we must assign each connected descriptor returned by <code id="P7000497027000000000000000046CE7" data-uri="chapter12.xhtml#P7000497027000000000000000046CE7" class="pcalibre1 calibre1 pcalibre2">accept</code> to its own dynamically allocated memory block, as shown in lines 21−22. We will return to the issue of races in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008577.xhtml#P7000497027000000000000000008610"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">12.7.4</span></a>.</p>
<p id="P7000497027000000000000000046CE8" data-uri="chapter12.xhtml#P7000497027000000000000000046CE8" class="pcalibre8 pcalibre1 pcalibre2">Another issue is avoiding memory leaks in the thread routine. Since we are not explicitly reaping threads, we must detach each thread so that its memory resources will be reclaimed when it terminates (line 31). Further, we must be careful to free the memory block that was allocated by the main thread (line 32).</p>
<section id="P7000497027000000000000000008217" data-uri="chapter12.xhtml#P7000497027000000000000000008217" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046CE9" data-uri="chapter12.xhtml#P7000497027000000000000000046CE9" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000046CEA" data-uri="chapter12.xhtml#P7000497027000000000000000046CEA">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000046CEB" data-uri="chapter12.xhtml#P7000497027000000000000000046CEB">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000046CEC" data-uri="chapter12.xhtml#P7000497027000000000000000046CEC"><p id="P7000497027000000000000000046CED" data-uri="chapter12.xhtml#P7000497027000000000000000046CED" class="pcalibre1 pcalibre2 pcalibre10">In the process-based server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000008097.xhtml#P70004970270000000000000000080CF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.5</span></a>, we were careful to close the connected descriptor in two places: the parent process and the child process. However, in the threads-based server in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008200"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.14</span></a>, we only closed the connected descriptor in one place: the peer thread. Why?</p></div></li>
</ol>
</section>
</section>
</section></body></html>
