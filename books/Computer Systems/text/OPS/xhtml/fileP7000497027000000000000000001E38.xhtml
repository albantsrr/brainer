<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>3.2 Program Encodings</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000001E38" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P70004970270000000000000000400A8" data-uri="chapter03.xhtml#P70004970270000000000000000400A8" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.2 </span>Program Encodings</h1></header>
<p id="P70004970270000000000000000400A9" data-uri="chapter03.xhtml#P70004970270000000000000000400A9" class="pcalibre8 pcalibre1 pcalibre2">Suppose we write a C program as two files <code id="P70004970270000000000000000400AA" data-uri="chapter03.xhtml#P70004970270000000000000000400AA" class="pcalibre1 calibre1 pcalibre2">p1.c</code> and <code id="P70004970270000000000000000400AB" data-uri="chapter03.xhtml#P70004970270000000000000000400AB" class="pcalibre1 calibre1 pcalibre2">p2.c.</code> We can then compile this code using a Unix command line:</p>
<pre id="P70004970270000000000000000400AC" data-uri="chapter03.xhtml#P70004970270000000000000000400AC" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000400AD" data-uri="chapter03.xhtml#P70004970270000000000000000400AD" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000001E3F" title="170" data-uri="chapter03.xhtml#P7000497027000000000000000001E3F" epub:type="pagebreak"></span>linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -Og -o p p1.c p2.c</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000400AE" data-uri="chapter03.xhtml#P70004970270000000000000000400AE">The command <code id="P70004970270000000000000000400AF" data-uri="chapter03.xhtml#P70004970270000000000000000400AF" class="pcalibre1 calibre1 pcalibre2">gcc</code> indicates the <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>C compiler. Since this is the default compiler on Linux, we could also invoke it as simply <code id="P70004970270000000000000000400B0" data-uri="chapter03.xhtml#P70004970270000000000000000400B0" class="pcalibre1 calibre1 pcalibre2">cc</code>. The command-line option –<code id="P70004970270000000000000000400B1" data-uri="chapter03.xhtml#P70004970270000000000000000400B1" class="pcalibre1 calibre1 pcalibre2">0g</code><a class="pcalibre1 pcalibre2 pcalibre56 pcalibre16 pcalibre14 pcalibre15" id="r__P7000497027000000000000000003A68" epub:type="noteref" href="#P7000497027000000000000000003A68"><sup class="pcalibre1 pcalibre2 calibre8">1</sup></a> instructs the compiler to apply a level of optimization that yields machine code that follows the overall structure of the original C code. Invoking higher levels of optimization can generate code that is so heavily transformed that the relationship between the generated machine code and the original source code is difficult to understand. We will therefore use –<code id="P70004970270000000000000000400B2" data-uri="chapter03.xhtml#P70004970270000000000000000400B2" class="pcalibre1 calibre1 pcalibre2">0g</code> optimization as a learning tool and then see what happens as we increase the level of optimization. In practice, higher levels of optimization (e.g., specified with the option –<code id="P70004970270000000000000000400B3" data-uri="chapter03.xhtml#P70004970270000000000000000400B3" class="pcalibre1 calibre1 pcalibre2">01</code> or –<code id="P70004970270000000000000000400B4" data-uri="chapter03.xhtml#P70004970270000000000000000400B4" class="pcalibre1 calibre1 pcalibre2">02</code>) are considered a better choice in terms of the resulting program performance.</p><aside class="pcalibre2 pcalibre32 pcalibre57" id="P7000497027000000000000000003A68" data-uri="chapter03.xhtml#P7000497027000000000000000003A68" epub:type="footnote"><p class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre58 pcalibre2"><a href="#r__P7000497027000000000000000003A68" class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13">1. </a></span>This optimization level was introduced in <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>version 4.8. Earlier versions of <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>, as well as non-GNU compilers, will not recognize this option. For these, using optimization level one (specified with the command-line flag <code id="P7000497027000000000000000041C30" data-uri="chapter03.xhtml#P7000497027000000000000000041C30" class="calibre3 pcalibre1 pcalibre2">-O1</code>) is probably the best choice for generating code that follows the original program structure.</p></aside>
<p id="P70004970270000000000000000400B5" data-uri="chapter03.xhtml#P70004970270000000000000000400B5" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P70004970270000000000000000400B6" data-uri="chapter03.xhtml#P70004970270000000000000000400B6" class="pcalibre1 calibre1 pcalibre2">gcc</code> command invokes an entire sequence of programs to turn the source code into executable code. First, the C <i class="pcalibre17 pcalibre2 pcalibre1">preprocessor</i> expands the source code to include any files specified with <code id="P70004970270000000000000000400B7" data-uri="chapter03.xhtml#P70004970270000000000000000400B7" class="pcalibre1 calibre1 pcalibre2">#include</code> commands and to expand any macros, specified with <code id="P70004970270000000000000000400B8" data-uri="chapter03.xhtml#P70004970270000000000000000400B8" class="pcalibre1 calibre1 pcalibre2">#define</code> declarations. Second, the <i class="pcalibre17 pcalibre2 pcalibre1">compiler</i> generates assembly-code versions of the two source files having names <code id="P70004970270000000000000000400B9" data-uri="chapter03.xhtml#P70004970270000000000000000400B9" class="pcalibre1 calibre1 pcalibre2">p1.s</code> and <code id="P70004970270000000000000000400BA" data-uri="chapter03.xhtml#P70004970270000000000000000400BA" class="pcalibre1 calibre1 pcalibre2">p2.s.</code> Next, the <i class="pcalibre17 pcalibre2 pcalibre1">assembler</i> converts the assembly code into binary <i class="pcalibre17 pcalibre2 pcalibre1">object-code</i> files <code id="P70004970270000000000000000400BB" data-uri="chapter03.xhtml#P70004970270000000000000000400BB" class="pcalibre1 calibre1 pcalibre2">p1.o</code> and <code id="P70004970270000000000000000400BC" data-uri="chapter03.xhtml#P70004970270000000000000000400BC" class="pcalibre1 calibre1 pcalibre2">p2.o.</code> Object code is one form of machine code—it contains binary representations of all of the instructions, but the addresses of global values are not yet filled in. Finally, the <i class="pcalibre17 pcalibre2 pcalibre1">linker</i> merges these two object-code files along with code implementing library functions (e.g., <code id="P70004970270000000000000000400BD" data-uri="chapter03.xhtml#P70004970270000000000000000400BD" class="pcalibre1 calibre1 pcalibre2">printf</code>) and generates the final executable code file <code id="P70004970270000000000000000400BE" data-uri="chapter03.xhtml#P70004970270000000000000000400BE" class="pcalibre1 calibre1 pcalibre2">p</code> (as specified by the command-line directive <code id="P70004970270000000000000000400BF" data-uri="chapter03.xhtml#P70004970270000000000000000400BF" class="pcalibre1 calibre1 pcalibre2">-o p</code>). Executable code is the second form of machine code we will consider—it is the exact form of code that is executed by the processor. The relation between these different forms of machine code and the linking process is described in more detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000005FB4.xhtml#P7000497027000000000000000005FB4"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">7</span></a>.</p>
<section id="P7000497027000000000000000001E52" data-uri="chapter03.xhtml#P7000497027000000000000000001E52" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000400C0" data-uri="chapter03.xhtml#P70004970270000000000000000400C0" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.2.1 </span>Machine-Level Code</h1></header>
<p id="P70004970270000000000000000400C1" data-uri="chapter03.xhtml#P70004970270000000000000000400C1" class="pcalibre8 pcalibre1 pcalibre2">As described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000248"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">1.9.3</span></a>, computer systems employ several different forms of abstraction, hiding details of an implementation through the use of a simpler abstract model. Two of these are especially important for machine-level programming. First, the format and behavior of a machine-level program is defined by the <i class="pcalibre17 pcalibre2 pcalibre1">instruction set architecture</i>, or ISA, defining the processor state, the format of the instructions, and the effect each of these instructions will have on the state. Most ISAs, including x86-64, describe the behavior of a program as if each instruction is executed in sequence, with one instruction completing before the next one begins. The processor hardware is far more elaborate, executing many instructions concurrently, but it employs safeguards to ensure that the overall behavior matches the sequential operation dictated by the ISA. Second, the memory addresses used by a machine-level program are <i class="pcalibre17 pcalibre2 pcalibre1">virtual addresses</i>, providing a memory model that <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000001E55" title="171" data-uri="chapter03.xhtml#P7000497027000000000000000001E55" epub:type="pagebreak"></span>appears to be a very large byte array. The actual implementation of the memory system involves a combination of multiple hardware memories and operating system software, as described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">9</span></a>.</p>
<p id="P70004970270000000000000000400C2" data-uri="chapter03.xhtml#P70004970270000000000000000400C2" class="pcalibre8 pcalibre1 pcalibre2">The compiler does most of the work in the overall compilation sequence, transforming programs expressed in the relatively abstract execution model provided by C into the very elementary instructions that the processor executes. The assembly-code representation is very close to machine code. Its main feature is that it is in a more readable textual format, as compared to the binary format of machine code. Being able to understand assembly code and how it relates to the original C code is a key step in understanding how computers execute programs.</p>
<p id="P70004970270000000000000000400C3" data-uri="chapter03.xhtml#P70004970270000000000000000400C3" class="pcalibre8 pcalibre1 pcalibre2">The machine code for x86-64 differs greatly from the original C code. Parts of the processor state are visible that normally are hidden from the C programmer:</p>
<ul id="P70004970270000000000000000400C4" data-uri="chapter03.xhtml#P70004970270000000000000000400C4" class="pcalibre1 calibre9 pcalibre2">
<li id="P70004970270000000000000000400C5" data-uri="chapter03.xhtml#P70004970270000000000000000400C5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000400C6" data-uri="chapter03.xhtml#P70004970270000000000000000400C6" class="pcalibre1 pcalibre2 pcalibre10">The <i class="pcalibre17 pcalibre2 pcalibre1">program counter</i> (commonly referred to as the PC, and called <code id="P70004970270000000000000000400C7" data-uri="chapter03.xhtml#P70004970270000000000000000400C7" class="pcalibre1 calibre1 pcalibre2">%rip</code> in x86-64) indicates the address in memory of the next instruction to be executed.</p></li>
<li id="P70004970270000000000000000400C8" data-uri="chapter03.xhtml#P70004970270000000000000000400C8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000400C9" data-uri="chapter03.xhtml#P70004970270000000000000000400C9" class="pcalibre1 pcalibre2 pcalibre10">The integer <i class="pcalibre17 pcalibre2 pcalibre1">register file</i> contains 16 named locations storing 64-bit values. These registers can hold addresses (corresponding to C pointers) or integer data. Some registers are used to keep track of critical parts of the program state, while others are used to hold temporary data, such as the arguments and local variables of a procedure, as well as the value to be returned by a function.</p></li>
<li id="P70004970270000000000000000400CA" data-uri="chapter03.xhtml#P70004970270000000000000000400CA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000400CB" data-uri="chapter03.xhtml#P70004970270000000000000000400CB" class="pcalibre1 pcalibre2 pcalibre10">The condition code registers hold status information about the most recently executed arithmetic or logical instruction. These are used to implement conditional changes in the control or data flow, such as is required to implement if and while statements.</p></li>
<li id="P70004970270000000000000000400CC" data-uri="chapter03.xhtml#P70004970270000000000000000400CC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000400CD" data-uri="chapter03.xhtml#P70004970270000000000000000400CD" class="pcalibre1 pcalibre2 pcalibre10">A set of vector registers can each hold one or more integer or floating-point values.</p></li>
</ul>
<p id="P70004970270000000000000000400CE" data-uri="chapter03.xhtml#P70004970270000000000000000400CE" class="pcalibre8 pcalibre1 pcalibre2">Whereas C provides a model in which objects of different data types can be declared and allocated in memory, machine code views the memory as simply a large byte-addressable array. Aggregate data types in C such as arrays and structures are represented in machine code as contiguous collections of bytes. Even for scalar data types, assembly code makes no distinctions between signed or unsigned integers, between different types of pointers, or even between pointers and integers.</p>
<p id="P70004970270000000000000000400CF" data-uri="chapter03.xhtml#P70004970270000000000000000400CF" class="pcalibre8 pcalibre1 pcalibre2">The program memory contains the executable machine code for the program, some information required by the operating system, a run-time stack for managing procedure calls and returns, and blocks of memory allocated by the user (e.g., by using the <code id="P70004970270000000000000000400D0" data-uri="chapter03.xhtml#P70004970270000000000000000400D0" class="pcalibre1 calibre1 pcalibre2">malloc</code> library function). As mentioned earlier, the program memory is addressed using virtual addresses. At any given time, only limited subranges of virtual addresses are considered valid. For example, x86-64 virtual addresses are represented by 64-bit words. In current implementations of these machines, the upper 16 bits must be set to zero, and so an address can potentially specify a byte over a range of 2<sup class="pcalibre1 pcalibre2 pcalibre85">48</sup>, or 64 terabytes. More typical programs will only have access to a few megabytes, or perhaps several gigabytes. The operating system manages</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000001E65" data-uri="chapter03.xhtml#P7000497027000000000000000001E65"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P70004970270000000000000000400D1" data-uri="chapter03.xhtml#P70004970270000000000000000400D1" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000001E67" title="172" data-uri="chapter03.xhtml#P7000497027000000000000000001E67" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>The ever-changing forms of generated code</h1></header>
<p id="P70004970270000000000000000400D2" data-uri="chapter03.xhtml#P70004970270000000000000000400D2" class="pcalibre1 pcalibre2 pcalibre40">In our presentation, we will show the code generated by a particular version of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>with particular settings of the command-line options. If you compile code on your own machine, chances are you will be using a different compiler or a different version of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>and hence will generate different code. The open-source community supporting <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>keeps changing the code generator, attempting to generate more efficient code according to changing code guidelines provided by the microprocessor manufacturers.</p>
<p id="P70004970270000000000000000400D3" data-uri="chapter03.xhtml#P70004970270000000000000000400D3" class="pcalibre1 pcalibre2 pcalibre10">Our goal in studying the examples shown in our presentation is to demonstrate how to examine assembly code and map it back to the constructs found in high-level programming languages. You will need to adapt these techniques to the style of code generated by your particular compiler.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000400D4" data-uri="chapter03.xhtml#P70004970270000000000000000400D4">this virtual address space, translating virtual addresses into the physical addresses of values in the actual processor memory.</p>
<p id="P70004970270000000000000000400D5" data-uri="chapter03.xhtml#P70004970270000000000000000400D5" class="pcalibre8 pcalibre1 pcalibre2">A single machine instruction performs only a very elementary operation. For example, it might add two numbers stored in registers, transfer data between memory and a register, or conditionally branch to a new instruction address. The compiler must generate sequences of such instructions to implement program constructs such as arithmetic expression evaluation, loops, or procedure calls and returns.</p>
</section>
<section id="P7000497027000000000000000001E6C" data-uri="chapter03.xhtml#P7000497027000000000000000001E6C" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000400D6" data-uri="chapter03.xhtml#P70004970270000000000000000400D6" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.2.2 </span>Code Examples</h1></header>
<p id="P70004970270000000000000000400D7" data-uri="chapter03.xhtml#P70004970270000000000000000400D7" class="pcalibre8 pcalibre1 pcalibre2">Suppose we write a C code file <code id="P70004970270000000000000000400D8" data-uri="chapter03.xhtml#P70004970270000000000000000400D8" class="pcalibre1 calibre1 pcalibre2">mstore.c</code> containing the following function definition:</p>

<pre id="P70004970270000000000000000400D9" data-uri="chapter03.xhtml#P70004970270000000000000000400D9" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000400DA" data-uri="chapter03.xhtml#P70004970270000000000000000400DA" class="calibre3 pcalibre1 pcalibre2">
long mult2(long, long);

void multstore(long x, long y, long *dest) {
	long t = mult2(x, y);
	*dest = t;
}
</code></pre>
<p id="P70004970270000000000000000400DB" data-uri="chapter03.xhtml#P70004970270000000000000000400DB" class="pcalibre8 pcalibre1 pcalibre2">To see the assembly code generated by the C compiler, we can use the -S option on the command line:</p>

<pre id="P70004970270000000000000000400DC" data-uri="chapter03.xhtml#P70004970270000000000000000400DC" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000400DD" data-uri="chapter03.xhtml#P70004970270000000000000000400DD" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -Og -S mstore.c</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000400DE" data-uri="chapter03.xhtml#P70004970270000000000000000400DE">This will cause <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>to run the compiler, generating an assembly file <code id="P70004970270000000000000000400DF" data-uri="chapter03.xhtml#P70004970270000000000000000400DF" class="pcalibre1 calibre1 pcalibre2">mstore.s</code>, and go no further. (Normally it would then invoke the assembler to generate an object-code file.)</p>

<p id="P70004970270000000000000000400E0" data-uri="chapter03.xhtml#P70004970270000000000000000400E0" class="pcalibre8 pcalibre1 pcalibre2">The assembly-code file contains various declarations, including the following set of lines:</p>
<pre id="P70004970270000000000000000400E1" data-uri="chapter03.xhtml#P70004970270000000000000000400E1" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000400E2" data-uri="chapter03.xhtml#P70004970270000000000000000400E2" class="calibre3 pcalibre1 pcalibre2">
multstore:
	pushq	%rbx
</code></pre>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000001E7A" data-uri="chapter03.xhtml#P7000497027000000000000000001E7A"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P70004970270000000000000000400E3" data-uri="chapter03.xhtml#P70004970270000000000000000400E3" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000001E7C" title="173" data-uri="chapter03.xhtml#P7000497027000000000000000001E7C" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>How do I display the byte representation of a program?</h1></header>
<p id="P70004970270000000000000000400E4" data-uri="chapter03.xhtml#P70004970270000000000000000400E4" class="pcalibre1 pcalibre2 pcalibre40">To display the binary object code for a program (say, <code id="P70004970270000000000000000400E5" data-uri="chapter03.xhtml#P70004970270000000000000000400E5" class="pcalibre1 calibre1 pcalibre2">mstore</code>), we use a <i class="pcalibre17 pcalibre2 pcalibre1">disassembler</i> (described below) to determine that the code for the procedure is 14 bytes long. Then we run the GNU debugging tool <span class="pcalibre1 pcalibre29 pcalibre2">gdb </span>on file <code id="P70004970270000000000000000400E6" data-uri="chapter03.xhtml#P70004970270000000000000000400E6" class="pcalibre1 calibre1 pcalibre2">mstore.o</code> and give it the command</p>

<pre id="P70004970270000000000000000400E7" data-uri="chapter03.xhtml#P70004970270000000000000000400E7" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000400E8" data-uri="chapter03.xhtml#P70004970270000000000000000400E8" class="calibre3 pcalibre1 pcalibre2">
(gdb) <i class="pcalibre17 pcalibre2 pcalibre1">x/14xb multstore</i>
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000400E9" data-uri="chapter03.xhtml#P70004970270000000000000000400E9">telling it to display (abbreviated `x') 14 hex-formatted (also `x') bytes (`b') starting at the address where function multstore is located. You will find that <span class="pcalibre1 pcalibre29 pcalibre2">gdb</span> has many useful features for analyzing machine-level programs, as will be discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002E6D.xhtml#P7000497027000000000000000002EC0"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.10.2</span></a>.</p>
</aside>
<pre id="P70004970270000000000000000400EA" data-uri="chapter03.xhtml#P70004970270000000000000000400EA" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000400EB" data-uri="chapter03.xhtml#P70004970270000000000000000400EB" class="calibre3 pcalibre1 pcalibre2">
movq	%rdx, %rbx
call	mult2
movq	%rax, (%rbx)
popq	%rbx
ret	
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000400EC" data-uri="chapter03.xhtml#P70004970270000000000000000400EC">Each indented line in the code corresponds to a single machine instruction. For example, the <code id="P70004970270000000000000000400ED" data-uri="chapter03.xhtml#P70004970270000000000000000400ED" class="pcalibre1 calibre1 pcalibre2">pushq</code> instruction indicates that the contents of register <code id="P70004970270000000000000000400EE" data-uri="chapter03.xhtml#P70004970270000000000000000400EE" class="pcalibre1 calibre1 pcalibre2">%rbx</code> should be pushed onto the program stack. All information about local variable names or data types has been stripped away.</p>

<p id="P70004970270000000000000000400EF" data-uri="chapter03.xhtml#P70004970270000000000000000400EF" class="pcalibre8 pcalibre1 pcalibre2">If we use the -c command-line option, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>will both compile and assemble the code</p>

<pre id="P70004970270000000000000000400F0" data-uri="chapter03.xhtml#P70004970270000000000000000400F0" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000400F1" data-uri="chapter03.xhtml#P70004970270000000000000000400F1" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -Og -c mstore.c</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000400F2" data-uri="chapter03.xhtml#P70004970270000000000000000400F2">This will generate an object-code file <code id="P70004970270000000000000000400F3" data-uri="chapter03.xhtml#P70004970270000000000000000400F3" class="pcalibre1 calibre1 pcalibre2">mstore.o</code> that is in binary format and hence cannot be viewed directly. Embedded within the 1,368 bytes of the file <code id="P70004970270000000000000000400F4" data-uri="chapter03.xhtml#P70004970270000000000000000400F4" class="pcalibre1 calibre1 pcalibre2">mstore.o</code> is a 14-byte sequence with the hexadecimal representation</p>
<pre id="P70004970270000000000000000400F5" data-uri="chapter03.xhtml#P70004970270000000000000000400F5" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000400F6" data-uri="chapter03.xhtml#P70004970270000000000000000400F6" class="calibre3 pcalibre1 pcalibre2">
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000400F7" data-uri="chapter03.xhtml#P70004970270000000000000000400F7">This is the object code corresponding to the assembly instructions listed previously. A key lesson to learn from this is that the program executed by the machine is simply a sequence of bytes encoding a series of instructions. The machine has very little information about the source code from which these instructions were generated.</p>
<p id="P70004970270000000000000000400F8" data-uri="chapter03.xhtml#P70004970270000000000000000400F8" class="pcalibre8 pcalibre1 pcalibre2">To inspect the contents of machine-code files, a class of programs known as <i class="pcalibre17 pcalibre2 pcalibre1">disassemblers</i> can be invaluable. These programs generate a format similar to assembly code from the machine code. With Linux systems, the program <span class="pcalibre1 pcalibre29 pcalibre2">objdump </span>(for "object dump") can serve this role given the <code id="P70004970270000000000000000400F9" data-uri="chapter03.xhtml#P70004970270000000000000000400F9" class="pcalibre1 calibre1 pcalibre2">-d</code> command-line flag:</p>
<pre id="P70004970270000000000000000400FA" data-uri="chapter03.xhtml#P70004970270000000000000000400FA" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000400FB" data-uri="chapter03.xhtml#P70004970270000000000000000400FB" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">objdump -d mstore.o</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000400FC" data-uri="chapter03.xhtml#P70004970270000000000000000400FC">The result (where we have added line numbers on the left and annotations in italicized text) is as follows:</p>
<pre id="P70004970270000000000000000400FD" data-uri="chapter03.xhtml#P70004970270000000000000000400FD" class="calibre2 pcalibre2 pcalibre1">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000001E97" title="174" data-uri="chapter03.xhtml#P7000497027000000000000000001E97" epub:type="pagebreak"></span><b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Disassembly of function</i></b> <code id="P70004970270000000000000000400FE" data-uri="chapter03.xhtml#P70004970270000000000000000400FE" class="calibre3 pcalibre1 pcalibre2">sum</code> <b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">in binary file</i></b> <code id="P70004970270000000000000000400FF" data-uri="chapter03.xhtml#P70004970270000000000000000400FF" class="calibre3 pcalibre1 pcalibre2">mstore.o</code>
<code id="P7000497027000000000000000040100" data-uri="chapter03.xhtml#P7000497027000000000000000040100" class="calibre3 pcalibre1 pcalibre2">
1	0000000000000000 &lt;multstore&gt;:
</code></pre>
<pre id="P7000497027000000000000000040101" data-uri="chapter03.xhtml#P7000497027000000000000000040101" class="calibre2 pcalibre2 pcalibre1">    <i class="pcalibre17 pcalibre2 pcalibre1">Offset</i>   <i class="pcalibre17 pcalibre2 pcalibre1">Bytes</i>		<i class="pcalibre17 pcalibre2 pcalibre1">Equivalent assembly language</i>
<code id="P7000497027000000000000000040102" data-uri="chapter03.xhtml#P7000497027000000000000000040102" class="calibre3 pcalibre1 pcalibre2">
2	0:	53			push	%rbx
3	1:	48 89 d3		mov	%rdx,%rbx
4	4:	e8 00 00 00 00		callq	9 &lt;multstore+0x9&gt;
5	9:	48 89 03		mov	%rax,(%rbx)
6	c:	5b			pop	%rbx
7	d:	c3			retq	
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040103" data-uri="chapter03.xhtml#P7000497027000000000000000040103">On the left we see the 14 hexadecimal byte values, listed in the byte sequence shown earlier, partitioned into groups of 1 to 5 bytes each. Each of these groups is a single instruction, with the assembly-language equivalent shown on the right.</p>
<p id="P7000497027000000000000000040104" data-uri="chapter03.xhtml#P7000497027000000000000000040104" class="pcalibre8 pcalibre1 pcalibre2">Several features about machine code and its disassembled representation are worth noting:</p>
<ul id="P7000497027000000000000000040105" data-uri="chapter03.xhtml#P7000497027000000000000000040105" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000040106" data-uri="chapter03.xhtml#P7000497027000000000000000040106" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040107" data-uri="chapter03.xhtml#P7000497027000000000000000040107" class="pcalibre1 pcalibre2 pcalibre10">x86-64 instructions can range in length from 1 to 15 bytes. The instruction encoding is designed so that commonly used instructions and those with fewer operands require a smaller number of bytes than do less common ones or ones with more operands.</p></li>
<li id="P7000497027000000000000000040108" data-uri="chapter03.xhtml#P7000497027000000000000000040108" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040109" data-uri="chapter03.xhtml#P7000497027000000000000000040109" class="pcalibre1 pcalibre2 pcalibre10">The instruction format is designed in such a way that from a given starting position, there is a unique decoding of the bytes into machine instructions. For example, only the instruction <code id="P700049702700000000000000004010A" data-uri="chapter03.xhtml#P700049702700000000000000004010A" class="pcalibre1 calibre1 pcalibre2">pushq %rbx</code> can start with byte value <code id="P700049702700000000000000004010B" data-uri="chapter03.xhtml#P700049702700000000000000004010B" class="pcalibre1 calibre1 pcalibre2">53</code>.</p></li>
<li id="P700049702700000000000000004010C" data-uri="chapter03.xhtml#P700049702700000000000000004010C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004010D" data-uri="chapter03.xhtml#P700049702700000000000000004010D" class="pcalibre1 pcalibre2 pcalibre10">The disassembler determines the assembly code based purely on the byte sequences in the machine-code file. It does not require access to the source or assembly-code versions of the program.</p></li>
<li id="P700049702700000000000000004010E" data-uri="chapter03.xhtml#P700049702700000000000000004010E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004010F" data-uri="chapter03.xhtml#P700049702700000000000000004010F" class="pcalibre1 pcalibre2 pcalibre10">The disassembler uses a slightly different naming convention for the instructions than does the assembly code generated by <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>. In our example, it has omitted the suffix `<code id="P7000497027000000000000000040110" data-uri="chapter03.xhtml#P7000497027000000000000000040110" class="pcalibre1 calibre1 pcalibre2">q</code>' from many of the instructions. These suffixes are size designators and can be omitted in most cases. Conversely, the disassembler adds the suffix `<code id="P7000497027000000000000000040111" data-uri="chapter03.xhtml#P7000497027000000000000000040111" class="pcalibre1 calibre1 pcalibre2">q</code>' to the <code id="P7000497027000000000000000040112" data-uri="chapter03.xhtml#P7000497027000000000000000040112" class="pcalibre1 calibre1 pcalibre2">call</code> and <code id="P7000497027000000000000000040113" data-uri="chapter03.xhtml#P7000497027000000000000000040113" class="pcalibre1 calibre1 pcalibre2">ret</code> instructions. Again, these suffixes can safely be omitted.</p></li>
</ul>
<p id="P7000497027000000000000000040114" data-uri="chapter03.xhtml#P7000497027000000000000000040114" class="pcalibre8 pcalibre1 pcalibre2">Generating the actual executable code requires running a linker on the set of object-code files, one of which must contain a function <code id="P7000497027000000000000000040115" data-uri="chapter03.xhtml#P7000497027000000000000000040115" class="pcalibre1 calibre1 pcalibre2">main</code>. Suppose in file <code id="P7000497027000000000000000040116" data-uri="chapter03.xhtml#P7000497027000000000000000040116" class="pcalibre1 calibre1 pcalibre2">main.c</code> we had the following function:</p>

<pre id="P7000497027000000000000000040117" data-uri="chapter03.xhtml#P7000497027000000000000000040117" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040118" data-uri="chapter03.xhtml#P7000497027000000000000000040118" class="calibre3 pcalibre1 pcalibre2">
#include &lt;stdio.h&gt;

void multstore(long, long, long *);

int main() {
	long d;
	multstore(2, 3, &amp;d);
	printf("2 * 3 –&gt; %ld\n", d);
	return 0;
}

<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000001EB3" title="175" data-uri="chapter03.xhtml#P7000497027000000000000000001EB3" epub:type="pagebreak"></span>long mult2(long a, long b) {
	long s = a * b;
	return s;
}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040119" data-uri="chapter03.xhtml#P7000497027000000000000000040119">Then we could generate an executable program prog as follows:</p>
<pre id="P700049702700000000000000004011A" data-uri="chapter03.xhtml#P700049702700000000000000004011A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004011B" data-uri="chapter03.xhtml#P700049702700000000000000004011B" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -Og -o prog main.c mstore.c</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004011C" data-uri="chapter03.xhtml#P700049702700000000000000004011C">The file <code id="P700049702700000000000000004011D" data-uri="chapter03.xhtml#P700049702700000000000000004011D" class="pcalibre1 calibre1 pcalibre2">prog</code> has grown to 8,655 bytes, since it contains not just the machine code for the procedures we provided but also code used to start and terminate the program as well as to interact with the operating system.</p>
<p id="P700049702700000000000000004011E" data-uri="chapter03.xhtml#P700049702700000000000000004011E" class="pcalibre8 pcalibre1 pcalibre2">We can disassemble the file <code id="P700049702700000000000000004011F" data-uri="chapter03.xhtml#P700049702700000000000000004011F" class="pcalibre1 calibre1 pcalibre2">prog:</code></p>
<pre id="P7000497027000000000000000040120" data-uri="chapter03.xhtml#P7000497027000000000000000040120" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040121" data-uri="chapter03.xhtml#P7000497027000000000000000040121" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">objdump -d prog</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040122" data-uri="chapter03.xhtml#P7000497027000000000000000040122">The disassembler will extract various code sequences, including the following:</p>
<pre id="P7000497027000000000000000040123" data-uri="chapter03.xhtml#P7000497027000000000000000040123" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040124" data-uri="chapter03.xhtml#P7000497027000000000000000040124" class="calibre3 pcalibre1 pcalibre2"><i class="pcalibre17 pcalibre2 pcalibre1">Disassembly of function</i> <code id="P7000497027000000000000000040125" data-uri="chapter03.xhtml#P7000497027000000000000000040125" class="pcalibre1 calibre1 pcalibre2">sum</code> <i class="pcalibre17 pcalibre2 pcalibre1">in binary file</i> <code id="P7000497027000000000000000040126" data-uri="chapter03.xhtml#P7000497027000000000000000040126" class="pcalibre1 calibre1 pcalibre2">prog</code>
1 0000000000400540 &lt;multstore&gt;:
2	400540:	53			push	%rbx
3	400541:	48 89 d3		mov	%rdx,%rbx
4	400544:	e8 42 00 00 00		callq	40058b &lt;mult2&gt;
5	400549:	48 89 03		mov	%rax,(%rbx)
6	40054c:	5b			pop	%rbx
7	40054d:	c3			retq	
8	40054e:	90			nop	
9	40054f:	90			nop	
</code></pre>
<p id="P7000497027000000000000000040127" data-uri="chapter03.xhtml#P7000497027000000000000000040127" class="pcalibre8 pcalibre1 pcalibre2">This code is almost identical to that generated by the disassembly of <code id="P7000497027000000000000000040128" data-uri="chapter03.xhtml#P7000497027000000000000000040128" class="pcalibre1 calibre1 pcalibre2">mstore.c.</code> One important difference is that the addresses listed along the left are different—the linker has shifted the location of this code to a different range of addresses. A second difference is that the linker has filled in the address that the <code id="P7000497027000000000000000040129" data-uri="chapter03.xhtml#P7000497027000000000000000040129" class="pcalibre1 calibre1 pcalibre2">callq</code> instruction should use in calling the function <code id="P700049702700000000000000004012A" data-uri="chapter03.xhtml#P700049702700000000000000004012A" class="pcalibre1 calibre1 pcalibre2">mult2</code> (line 4 of the disassembly). One task for the linker is to match function calls with the locations of the executable code for those functions. A final difference is that we see two additional lines of code (lines 8-9). These instructions will have no effect on the program, since they occur after the return instruction (line 7). They have been inserted to grow the code for the function to 16 bytes, enabling a better placement of the next block of code in terms of memory system performance.</p>
</section>
<section id="P7000497027000000000000000001EC6" data-uri="chapter03.xhtml#P7000497027000000000000000001EC6" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004012B" data-uri="chapter03.xhtml#P700049702700000000000000004012B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.2.3 </span>Notes on Formatting</h1></header>
<p id="P700049702700000000000000004012C" data-uri="chapter03.xhtml#P700049702700000000000000004012C" class="pcalibre8 pcalibre1 pcalibre2">The assembly code generated by <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>is difficult for a human to read. On one hand, it contains information with which we need not be concerned, while on the other hand, it does not provide any description of the program or how it works. For example, suppose we give the command</p>
<pre id="P700049702700000000000000004012D" data-uri="chapter03.xhtml#P700049702700000000000000004012D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004012E" data-uri="chapter03.xhtml#P700049702700000000000000004012E" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -Og -S mstore.c</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004012F" data-uri="chapter03.xhtml#P700049702700000000000000004012F"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000001ECC" title="176" data-uri="chapter03.xhtml#P7000497027000000000000000001ECC" epub:type="pagebreak"></span>to generate the file <code id="P7000497027000000000000000040130" data-uri="chapter03.xhtml#P7000497027000000000000000040130" class="pcalibre1 calibre1 pcalibre2">mstore.s.</code> The full content of the file is as follows:</p>
<pre id="P7000497027000000000000000040131" data-uri="chapter03.xhtml#P7000497027000000000000000040131" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040132" data-uri="chapter03.xhtml#P7000497027000000000000000040132" class="calibre3 pcalibre1 pcalibre2">
	.file	"010–mstore.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
	pushq	%rbx
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	ret
	.size	multstore, .–multstore
	.ident	"GCC: (Ubuntu 4.8.1–2ubuntu1~12.04) 4.8.1"
	.section		.note.GNU-stack,"",@progbits
</code></pre>
<p id="P7000497027000000000000000040133" data-uri="chapter03.xhtml#P7000497027000000000000000040133" class="pcalibre8 pcalibre1 pcalibre2">All of the lines beginning with `.' are directives to guide the assembler and linker. We can generally ignore these. On the other hand, there are no explanatory remarks about what the instructions do or how they relate to the source code.</p>
<p id="P7000497027000000000000000040134" data-uri="chapter03.xhtml#P7000497027000000000000000040134" class="pcalibre8 pcalibre1 pcalibre2">To provide a clearer presentation of assembly code, we will show it in a form that omits most of the directives, while including line numbers and explanatory annotations. For our example, an annotated version would appear as follows:</p>
<pre id="P7000497027000000000000000040135" data-uri="chapter03.xhtml#P7000497027000000000000000040135" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040136" data-uri="chapter03.xhtml#P7000497027000000000000000040136" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">void multstore(long x, long y, long *dest)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi, y in %rsi, dest in %rdx</i>
1	multstore:
2	pushq	%rbx		<i class="pcalibre17 pcalibre2 pcalibre1">Save %rbx</i>
3	movq	%rdx, %rbx	<i class="pcalibre17 pcalibre2 pcalibre1">Copy dest to %rbx</i>
4	call	mult2		<i class="pcalibre17 pcalibre2 pcalibre1">Call mult2(x, y)</i>
5	movq	%rax, (%rbx)	<i class="pcalibre17 pcalibre2 pcalibre1">Store result at *dest</i>
6	popq	%rbx		<i class="pcalibre17 pcalibre2 pcalibre1">Restore %rbx</i>
7	ret			<i class="pcalibre17 pcalibre2 pcalibre1">Return</i>
</code></pre>
<p id="P7000497027000000000000000040137" data-uri="chapter03.xhtml#P7000497027000000000000000040137" class="pcalibre8 pcalibre1 pcalibre2">We typically show only the lines of code relevant to the point being discussed. Each line is numbered on the left for reference and annotated on the right by a brief description of the effect of the instruction and how it relates to the computations of the original C code. This is a stylized version of the way assembly-language programmers format their code.</p>
<p id="P7000497027000000000000000040138" data-uri="chapter03.xhtml#P7000497027000000000000000040138" class="pcalibre8 pcalibre1 pcalibre2">We also provide Web asides to cover material intended for dedicated machine-language enthusiasts. One Web aside describes IA32 machine code. Having a background in x86-64 makes learning IA32 fairly simple. Another Web aside gives a brief presentation of ways to incorporate assembly code into C programs. For some applications, the programmer must drop down to assembly code to access low-level features of the machine. One approach is to write entire functions in assembly code and combine them with C functions during the linking stage. A</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000001ED6" data-uri="chapter03.xhtml#P7000497027000000000000000001ED6"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000040139" data-uri="chapter03.xhtml#P7000497027000000000000000040139" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000001ED8" title="177" data-uri="chapter03.xhtml#P7000497027000000000000000001ED8" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>ATT versus Intel assembly-code formats</h1></header>
<p id="P700049702700000000000000004013A" data-uri="chapter03.xhtml#P700049702700000000000000004013A" class="pcalibre1 pcalibre2 pcalibre40">In our presentation, we show assembly code in ATT format (named after AT&amp;T, the company that operated Bell Laboratories for many years), the default format for <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>, <span class="pcalibre1 pcalibre29 pcalibre2">objdump</span>, and the other tools we will consider. Other programming tools, including those from Microsoft as well as the documentation from Intel, show assembly code in <i class="pcalibre17 pcalibre2 pcalibre1">Intel</i> format. The two formats differ in a number of ways. As an example, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>can generate code in Intel format for the sum function using the following command line:</p>
<pre id="P700049702700000000000000004013B" data-uri="chapter03.xhtml#P700049702700000000000000004013B" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004013C" data-uri="chapter03.xhtml#P700049702700000000000000004013C" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gcc -Og -S -masm=intel mstore.c</i>
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P700049702700000000000000004013D" data-uri="chapter03.xhtml#P700049702700000000000000004013D">This gives the following assembly code:</p>
<pre id="P700049702700000000000000004013E" data-uri="chapter03.xhtml#P700049702700000000000000004013E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004013F" data-uri="chapter03.xhtml#P700049702700000000000000004013F" class="calibre3 pcalibre1 pcalibre2">
multstore:
	push	rbx
	mov	rbx, rdx
	call	mult2
	mov	QWORD PTR [rbx], rax
	pop	rbx
	ret
</code></pre>
<p id="P7000497027000000000000000040140" data-uri="chapter03.xhtml#P7000497027000000000000000040140" class="pcalibre1 pcalibre2 pcalibre40">We see that the Intel and ATT formats differ in the following ways:</p>
<ul id="P7000497027000000000000000040141" data-uri="chapter03.xhtml#P7000497027000000000000000040141" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000040142" data-uri="chapter03.xhtml#P7000497027000000000000000040142" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040143" data-uri="chapter03.xhtml#P7000497027000000000000000040143" class="pcalibre1 pcalibre2 pcalibre10">The Intel code omits the size designation suffixes. We see instruction push and <code id="P7000497027000000000000000040144" data-uri="chapter03.xhtml#P7000497027000000000000000040144" class="pcalibre1 calibre1 pcalibre2">mov</code> instead of <code id="P7000497027000000000000000040145" data-uri="chapter03.xhtml#P7000497027000000000000000040145" class="pcalibre1 calibre1 pcalibre2">pushq</code> and <code id="P7000497027000000000000000040146" data-uri="chapter03.xhtml#P7000497027000000000000000040146" class="pcalibre1 calibre1 pcalibre2">movq</code>.</p></li>
<li id="P7000497027000000000000000040147" data-uri="chapter03.xhtml#P7000497027000000000000000040147" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040148" data-uri="chapter03.xhtml#P7000497027000000000000000040148" class="pcalibre1 pcalibre2 pcalibre10">The Intel code omits the `%' character in front of register names, using <code id="P7000497027000000000000000040149" data-uri="chapter03.xhtml#P7000497027000000000000000040149" class="pcalibre1 calibre1 pcalibre2">rbx</code> instead of <code id="P700049702700000000000000004014A" data-uri="chapter03.xhtml#P700049702700000000000000004014A" class="pcalibre1 calibre1 pcalibre2">%rbx</code>.</p></li>
<li id="P700049702700000000000000004014B" data-uri="chapter03.xhtml#P700049702700000000000000004014B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004014C" data-uri="chapter03.xhtml#P700049702700000000000000004014C" class="pcalibre1 pcalibre2 pcalibre10">The Intel code has a different way of describing locations in memory—for example, <code id="P700049702700000000000000004014D" data-uri="chapter03.xhtml#P700049702700000000000000004014D" class="pcalibre1 calibre1 pcalibre2">QWORD PTR [rbx]</code> rather than <code id="P700049702700000000000000004014E" data-uri="chapter03.xhtml#P700049702700000000000000004014E" class="pcalibre1 calibre1 pcalibre2">(%rbx)</code>.</p></li>
<li id="P700049702700000000000000004014F" data-uri="chapter03.xhtml#P700049702700000000000000004014F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040150" data-uri="chapter03.xhtml#P7000497027000000000000000040150" class="pcalibre1 pcalibre2 pcalibre10">Instructions with multiple operands list them in the reverse order. This can be very confusing when switching between the two formats.</p></li>
</ul>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000040151" data-uri="chapter03.xhtml#P7000497027000000000000000040151">Although we will not be using Intel format in our presentation, you will encounter it in documentation from Intel and Microsoft.</p>

</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040152" data-uri="chapter03.xhtml#P7000497027000000000000000040152">second is to use <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>'s support for embedding assembly code directly within C programs.</p>
</section>
</section></body></html>
