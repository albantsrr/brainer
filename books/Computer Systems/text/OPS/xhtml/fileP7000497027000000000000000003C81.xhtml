<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>4.2 Logic Design and the Hardware Control Language HCL</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000003C81" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000041E65" data-uri="chapter04.xhtml#P7000497027000000000000000041E65" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.2 </span>Logic Design and the Hardware Control Language HCL</h1></header>
<p id="P7000497027000000000000000041E66" data-uri="chapter04.xhtml#P7000497027000000000000000041E66" class="pcalibre8 pcalibre1 pcalibre2">In hardware design, electronic circuits are used to compute functions on bits and to store bits in different kinds of memory elements. Most contemporary circuit technology represents different bit values as high or low voltages on signal wires. In current technology, logic value 1 is represented by a high voltage of around 1.0 volt, while logic value 0 is represented by a low voltage of around 0.0 volts. Three major components are required to implement a digital system: <i class="pcalibre17 pcalibre2 pcalibre1">combinational logic</i> to compute functions on the bits, <i class="pcalibre17 pcalibre2 pcalibre1">memory elements</i> to store bits, and <i class="pcalibre17 pcalibre2 pcalibre1">clock signals</i> to regulate the updating of the memory elements.</p>
<p id="P7000497027000000000000000041E67" data-uri="chapter04.xhtml#P7000497027000000000000000041E67" class="pcalibre8 pcalibre1 pcalibre2">In this section, we provide a brief description of these different components. We also introduce HCL (for "hardware control language"), the language that we use to describe the control logic of the different processor designs. We only describe HCL informally here. A complete reference for HCL can be found in Web Aside <span class="pcalibre1 pcalibre29 pcalibre2">arch:hcl </span>on page 472.</p>

<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000003C85" data-uri="chapter04.xhtml#P7000497027000000000000000003C85"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000041E68" data-uri="chapter04.xhtml#P7000497027000000000000000041E68" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003C87" title="373" data-uri="chapter04.xhtml#P7000497027000000000000000003C87" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Modern logic design</h1></header>
<p id="P7000497027000000000000000041E69" data-uri="chapter04.xhtml#P7000497027000000000000000041E69" class="pcalibre1 pcalibre2 pcalibre40">At one time, hardware designers created circuit designs by drawing schematic diagrams of logic circuits (first with paper and pencil, and later with computer graphics terminals). Nowadays, most designs are expressed in a <i class="pcalibre17 pcalibre2 pcalibre1">hardware description language</i> (HDL), a textual notation that looks similar to a programming language but that is used to describe hardware structures rather than program behaviors. The most commonly used languages are Verilog, having a syntax similar to C, and VHDL, having a syntax similar to the Ada programming language. These languages were originally designed for creating simulation models of digital circuits. In the mid-1980s, researchers developed <i class="pcalibre17 pcalibre2 pcalibre1">logic synthesis</i> programs that could generate efficient circuit designs from HDL descriptions. There are now a number of commercial synthesis programs, and this has become the dominant technique for generating digital circuits. This shift from hand-designed circuits to synthesized ones can be likened to the shift from writing programs in assembly code to writing them in a high-level language and having a compiler generate the machine code.</p>
<p id="P7000497027000000000000000041E6A" data-uri="chapter04.xhtml#P7000497027000000000000000041E6A" class="pcalibre1 pcalibre2 pcalibre10">Our HCL language expresses only the control portions of a hardware design, with only a limited set of operations and with no modularity. As we will see, however, the control logic is the most difficult part of designing a microprocessor. We have developed tools that can directly translate HCL into Verilog, and by combining this code with Verilog code for the basic hardware units, we can generate HDL descriptions from which actual working microprocessors can be synthesized. By carefully separating out, designing, and testing the control logic, we can create a working microprocessor with reasonable effort. Web Aside <span class="pcalibre1 pcalibre29 pcalibre2">arch:vlog </span>on page 467 describes how we can generate Verilog versions of a Y86-64 processor.</p>
</aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003C8A" data-uri="chapter04.xhtml#P7000497027000000000000000003C8A">
<img alt="A diagram illustrates three logic gate types." id="P7000497027000000000000000041E6B" data-uri="P700049702700000000000000000B6CD" src="../images/p373-1.png" class="pcalibre1 pcalibre2 pcalibre143"/>
<figcaption id="P7000497027000000000000000041E6C" data-uri="chapter04.xhtml#P7000497027000000000000000041E6C" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041E6D" data-uri="chapter04.xhtml#P7000497027000000000000000041E6D" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.9 </span>Logic gate types.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041E6E" data-uri="chapter04.xhtml#P7000497027000000000000000041E6E"><p id="P7000497027000000000000000041E6F" data-uri="chapter04.xhtml#P7000497027000000000000000041E6F" class="pcalibre8 pcalibre1 pcalibre2">Each gate generates output equal to some Boolean function of its inputs.</p><p id="P7000497027000000000000000041E70" data-uri="chapter04.xhtml#P7000497027000000000000000041E70" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000022150" data-uri="chapter04.xhtml#P7000497027000000000000000022150">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000041E71" data-uri="chapter04.xhtml#P7000497027000000000000000041E71" class="pcalibre8 pcalibre1 pcalibre2">The three logic gate types are summarized below.</p>
<ul id="P7000497027000000000000000041E72" data-uri="chapter04.xhtml#P7000497027000000000000000041E72" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000041E73" data-uri="chapter04.xhtml#P7000497027000000000000000041E73" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041E74" data-uri="chapter04.xhtml#P7000497027000000000000000041E74" class="pcalibre1 pcalibre2 pcalibre10">AND: round bullet shape with a and b on the left and out on the right, depicting out = a &amp;&amp; b</p></li>
<li id="P7000497027000000000000000041E75" data-uri="chapter04.xhtml#P7000497027000000000000000041E75" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041E76" data-uri="chapter04.xhtml#P7000497027000000000000000041E76" class="pcalibre1 pcalibre2 pcalibre10">OR: pointing bullet shape with and b on the left and out on the right, depicting out = a | | b</p></li>
<li id="P7000497027000000000000000041E77" data-uri="chapter04.xhtml#P7000497027000000000000000041E77" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041E78" data-uri="chapter04.xhtml#P7000497027000000000000000041E78" class="pcalibre1 pcalibre2 pcalibre10">NOT: triangle with a on the left and out on the right, depicting out = !a</p></li>
</ul>
</details>
</figcaption>
</figure>

<section id="P7000497027000000000000000003C90" data-uri="chapter04.xhtml#P7000497027000000000000000003C90" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041E79" data-uri="chapter04.xhtml#P7000497027000000000000000041E79" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.2.1 </span>Logic Gates</h1></header>
<p id="P7000497027000000000000000041E7A" data-uri="chapter04.xhtml#P7000497027000000000000000041E7A" class="pcalibre8 pcalibre1 pcalibre2">Logic gates are the basic computing elements for digital circuits. They generate an output equal to some Boolean function of the bit values at their inputs. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003C8A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.9</span></a> shows the standard symbols used for Boolean functions <span class="pcalibre1 pcalibre29 pcalibre2">and, or</span>, and <span class="pcalibre1 pcalibre29 pcalibre2">not. </span>HCL expressions are shown below the gates for the operators in C (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000002AD_split_001.xhtml#P70004970270000000000000000006AF"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">2.1.8</span></a>): <code id="P7000497027000000000000000041E7B" data-uri="chapter04.xhtml#P7000497027000000000000000041E7B" class="pcalibre1 calibre1 pcalibre2">&amp;&amp;</code> for <span class="pcalibre1 pcalibre29 pcalibre2">and</span>, || for <span class="pcalibre1 pcalibre29 pcalibre2">or</span>, and ! for <span class="pcalibre1 pcalibre29 pcalibre2">not. </span>We use these instead of the bit-level C operators <code id="P7000497027000000000000000041E7C" data-uri="chapter04.xhtml#P7000497027000000000000000041E7C" class="pcalibre1 calibre1 pcalibre2">&amp;</code>, |, and ~, because logic gates operate on single-bit quantities, not entire words. Although the figure illustrates only two-input versions of the <span class="pcalibre1 pcalibre29 pcalibre2">and </span>and <span class="pcalibre1 pcalibre29 pcalibre2">or </span>gates, it is common to see these being used as <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-way operations for <var class="pcalibre17 pcalibre2 pcalibre1">n</var> &gt; 2. We still write these in HCL using binary operators, though, so the operation of a three-input <span class="pcalibre1 pcalibre29 pcalibre2">and </span>gate with inputs a, b, and c is described with the HCL expression a <code id="P7000497027000000000000000041E7D" data-uri="chapter04.xhtml#P7000497027000000000000000041E7D" class="pcalibre1 calibre1 pcalibre2">&amp;&amp;</code> b <code id="P7000497027000000000000000041E7E" data-uri="chapter04.xhtml#P7000497027000000000000000041E7E" class="pcalibre1 calibre1 pcalibre2">&amp;&amp;</code> c.</p>
<p id="P7000497027000000000000000041E7F" data-uri="chapter04.xhtml#P7000497027000000000000000041E7F" class="pcalibre8 pcalibre1 pcalibre2">Logic gates are always active. If some input to a gate changes, then within some small amount of time, the output will change accordingly.</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003C98" data-uri="chapter04.xhtml#P7000497027000000000000000003C98">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003C99" title="374" data-uri="chapter04.xhtml#P7000497027000000000000000003C99" epub:type="pagebreak"></span><img alt="A diagram illustrates a combination circuit." id="P7000497027000000000000000041E80" data-uri="P700049702700000000000000000B6CE" src="../images/p374-1.png" class="pcalibre1 pcalibre2 pcalibre144"/>
<figcaption id="P7000497027000000000000000041E81" data-uri="chapter04.xhtml#P7000497027000000000000000041E81" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041E82" data-uri="chapter04.xhtml#P7000497027000000000000000041E82" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.10 </span>Combinational circuit to test for bit equality.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041E83" data-uri="chapter04.xhtml#P7000497027000000000000000041E83"><p id="P7000497027000000000000000041E84" data-uri="chapter04.xhtml#P7000497027000000000000000041E84" class="pcalibre8 pcalibre1 pcalibre2">The output will equal 1 when both inputs are 0 or both are 1.</p><p id="P7000497027000000000000000041E85" data-uri="chapter04.xhtml#P7000497027000000000000000041E85" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000022165" data-uri="chapter04.xhtml#P7000497027000000000000000022165">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000041E86" data-uri="chapter04.xhtml#P7000497027000000000000000041E86" class="pcalibre1 pcalibre2 pcalibre10">A circuit has a and b on the left and eq on the right, with bit equal in between containing a circuit of logic gates. The bit equal has two AND gates leading to an OR gate, which leads to eq. A and B are each connected to the top AND gate and separate NOT gates, which are each connected to the bottom AND gate.</p>
</details>
</figcaption>
</figure>
</section>
<section id="P7000497027000000000000000003C9F" data-uri="chapter04.xhtml#P7000497027000000000000000003C9F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041E87" data-uri="chapter04.xhtml#P7000497027000000000000000041E87" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.2.2 </span>Combinational Circuits and HCL Boolean Expressions</h1></header>
<p id="P7000497027000000000000000041E88" data-uri="chapter04.xhtml#P7000497027000000000000000041E88" class="pcalibre8 pcalibre1 pcalibre2">By assembling a number of logic gates into a network, we can construct computational blocks known as <i class="pcalibre17 pcalibre2 pcalibre1">combinational circuits.</i> Several restrictions are placed on how the networks are constructed:</p>
<ul id="P7000497027000000000000000041E89" data-uri="chapter04.xhtml#P7000497027000000000000000041E89" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000041E8A" data-uri="chapter04.xhtml#P7000497027000000000000000041E8A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041E8B" data-uri="chapter04.xhtml#P7000497027000000000000000041E8B" class="pcalibre1 pcalibre2 pcalibre10">Every logic gate input must be connected to exactly one of the following: (1) one of the system inputs (known as a <i class="pcalibre17 pcalibre2 pcalibre1">primary input</i>), (2) the output connection of some memory element, or (3) the output of some logic gate.</p></li>
<li id="P7000497027000000000000000041E8C" data-uri="chapter04.xhtml#P7000497027000000000000000041E8C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041E8D" data-uri="chapter04.xhtml#P7000497027000000000000000041E8D" class="pcalibre1 pcalibre2 pcalibre10">The outputs of two or more logic gates cannot be connected together. Otherwise, the two could try to drive the wire toward different voltages, possibly causing an invalid voltage or a circuit malfunction.</p></li>
<li id="P7000497027000000000000000041E8E" data-uri="chapter04.xhtml#P7000497027000000000000000041E8E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041E8F" data-uri="chapter04.xhtml#P7000497027000000000000000041E8F" class="pcalibre1 pcalibre2 pcalibre10">The network must be <i class="pcalibre17 pcalibre2 pcalibre1">acyclic.</i> That is, there cannot be a path through a series of gates that forms a loop in the network. Such loops can cause ambiguity in the function computed by the network.</p></li>
</ul>
<p id="P7000497027000000000000000041E90" data-uri="chapter04.xhtml#P7000497027000000000000000041E90" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003C98"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.10</span></a> shows an example of a simple combinational circuit that we will find useful. It has two inputs, a and b. It generates a single output eq, such that the output will equal 1 if either a and b are both 1 (detected by the upper <span class="pcalibre1 pcalibre29 pcalibre2">and </span>gate) or are both 0 (detected by the lower <span class="pcalibre1 pcalibre29 pcalibre2">and </span>gate). We write the function of this network in HCL as</p>
<pre id="P7000497027000000000000000041E91" data-uri="chapter04.xhtml#P7000497027000000000000000041E91" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041E92" data-uri="chapter04.xhtml#P7000497027000000000000000041E92" class="calibre3 pcalibre1 pcalibre2">bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b);</code></pre>
<p id="P7000497027000000000000000041E93" data-uri="chapter04.xhtml#P7000497027000000000000000041E93" class="pcalibre8 pcalibre1 pcalibre2">This code simply defines the bit-level (denoted by data type <code id="P7000497027000000000000000041E94" data-uri="chapter04.xhtml#P7000497027000000000000000041E94" class="pcalibre1 calibre1 pcalibre2">bool</code>) signal eq as a function of inputs a and b. As this example shows, HCL uses C-style syntax, with `=' associating a signal name with an expression. Unlike C, however, we do not view this as performing a computation and assigning the result to some memory location. Instead, it is simply a way to give a name to an expression.</p>
<section id="P7000497027000000000000000003CAE" data-uri="chapter04.xhtml#P7000497027000000000000000003CAE" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041E95" data-uri="chapter04.xhtml#P7000497027000000000000000041E95" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.9 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046F2">484</a>)</h1></header>
<p id="P7000497027000000000000000041E96" data-uri="chapter04.xhtml#P7000497027000000000000000041E96" class="pcalibre8 pcalibre1 pcalibre2">Write an HCL expression for a signal <code id="P7000497027000000000000000041E97" data-uri="chapter04.xhtml#P7000497027000000000000000041E97" class="pcalibre1 calibre1 pcalibre2">xor</code>, equal to the <span class="pcalibre1 pcalibre29 pcalibre2">exclusive-or </span>of inputs a and b. What is the relation between the signals <code id="P7000497027000000000000000041E98" data-uri="chapter04.xhtml#P7000497027000000000000000041E98" class="pcalibre1 calibre1 pcalibre2">xor</code> and eq defined above?</p>
</section>
<p id="P7000497027000000000000000041E99" data-uri="chapter04.xhtml#P7000497027000000000000000041E99" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CB4"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.11</span></a> shows another example of a simple but useful combinational circuit known as a <i class="pcalibre17 pcalibre2 pcalibre1">multiplexor</i> (commonly referred to as a "MUX"). A multiplexor</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003CB4" data-uri="chapter04.xhtml#P7000497027000000000000000003CB4">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003CB5" title="375" data-uri="chapter04.xhtml#P7000497027000000000000000003CB5" epub:type="pagebreak"></span><img alt="A diagram illustrates a multiplexor circuit." id="P7000497027000000000000000041E9A" data-uri="P700049702700000000000000000B6CF" src="../images/p375-1.png" class="pcalibre1 pcalibre145 pcalibre2"/>
<figcaption id="P7000497027000000000000000041E9B" data-uri="chapter04.xhtml#P7000497027000000000000000041E9B" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041E9C" data-uri="chapter04.xhtml#P7000497027000000000000000041E9C" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.11 </span>Single-bit multiplexor circuit.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041E9D" data-uri="chapter04.xhtml#P7000497027000000000000000041E9D"><p id="P7000497027000000000000000041E9E" data-uri="chapter04.xhtml#P7000497027000000000000000041E9E" class="pcalibre1 pcalibre2 pcalibre10">The output will equal input a if the control signal s is 1 and will equal input b when s is 0.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P700049702700000000000000002217F" data-uri="chapter04.xhtml#P700049702700000000000000002217F">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000041E9F" data-uri="chapter04.xhtml#P7000497027000000000000000041E9F" class="pcalibre1 pcalibre2 pcalibre10">A circuit has a, b, and s on the left and out on the right, with bit MUX in between containing a circuit of logic gates. The bit MUX has two AND gates leading to an OR gate, which leads to out. S is connected to the bottom AND gate and a NOT gate connected to the top AND gate. A is connected to the bottom AND gate and B connected to the top AND gate.</p>
</details>
</figcaption>
</figure>

<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041EA0" data-uri="chapter04.xhtml#P7000497027000000000000000041EA0">selects a value from among a set of different data signals, depending on the value of a control input signal. In this single-bit multiplexor, the two data signals are the input bits a and b, while the control signal is the input bit s. The output will equal a when s is 1, and it will equal b when s is 0. In this circuit, we can see that the two <span class="pcalibre1 pcalibre29 pcalibre2">and </span>gates determine whether to pass their respective data inputs to the <span class="pcalibre1 pcalibre29 pcalibre2">or </span>gate. The upper <span class="pcalibre1 pcalibre29 pcalibre2">and </span>gate passes signal b when s is 0 (since the other input to the gate is !s), while the lower <span class="pcalibre1 pcalibre29 pcalibre2">and </span>gate passes signal a when s is 1. Again, we can write an HCL expression for the output signal, using the same operations as are present in the combinational circuit:</p>
<pre id="P7000497027000000000000000041EA1" data-uri="chapter04.xhtml#P7000497027000000000000000041EA1" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041EA2" data-uri="chapter04.xhtml#P7000497027000000000000000041EA2" class="calibre3 pcalibre1 pcalibre2">bool out = (s &amp;&amp; a) || (!s &amp;&amp; b);</code></pre>
<p id="P7000497027000000000000000041EA3" data-uri="chapter04.xhtml#P7000497027000000000000000041EA3" class="pcalibre8 pcalibre1 pcalibre2">Our HCL expressions demonstrate a clear parallel between combinational logic circuits and logical expressions in C. They both use Boolean operations to compute functions over their inputs. Several differences between these two ways of expressing computation are worth noting:</p>
<ul id="P7000497027000000000000000041EA4" data-uri="chapter04.xhtml#P7000497027000000000000000041EA4" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000041EA5" data-uri="chapter04.xhtml#P7000497027000000000000000041EA5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EA6" data-uri="chapter04.xhtml#P7000497027000000000000000041EA6" class="pcalibre1 pcalibre2 pcalibre10">Since a combinational circuit consists of a series of logic gates, it has the property that the outputs continually respond to changes in the inputs. If some input to the circuit changes, then after some delay, the outputs will change accordingly. By contrast, a C expression is only evaluated when it is encountered during the execution of a program.</p></li>
<li id="P7000497027000000000000000041EA7" data-uri="chapter04.xhtml#P7000497027000000000000000041EA7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EA8" data-uri="chapter04.xhtml#P7000497027000000000000000041EA8" class="pcalibre1 pcalibre2 pcalibre10">Logical expressions in C allow arguments to be arbitrary integers, interpreting 0 as <span class="pcalibre1 pcalibre29 pcalibre2">false </span>and anything else as <span class="pcalibre1 pcalibre29 pcalibre2">true. </span>In contrast, our logic gates only operate over the bit values 0 and 1.</p></li>
<li id="P7000497027000000000000000041EA9" data-uri="chapter04.xhtml#P7000497027000000000000000041EA9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EAA" data-uri="chapter04.xhtml#P7000497027000000000000000041EAA" class="pcalibre1 pcalibre2 pcalibre10">Logical expressions in C have the property that they might only be partially evaluated. If the outcome of an <span class="pcalibre1 pcalibre29 pcalibre2">and </span>or <span class="pcalibre1 pcalibre29 pcalibre2">or </span>operation can be determined by just evaluating the first argument, then the second argument will not be evaluated. For example, with the C expression</p></li>
</ul>
<pre id="P7000497027000000000000000041EAB" data-uri="chapter04.xhtml#P7000497027000000000000000041EAB" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041EAC" data-uri="chapter04.xhtml#P7000497027000000000000000041EAC" class="calibre3 pcalibre1 pcalibre2">(a &amp;&amp; !a) &amp;&amp; func(b, c)</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041EAD" data-uri="chapter04.xhtml#P7000497027000000000000000041EAD">the function <code id="P7000497027000000000000000041EAE" data-uri="chapter04.xhtml#P7000497027000000000000000041EAE" class="pcalibre1 calibre1 pcalibre2">func</code> will not be called, because the expression (<code id="P7000497027000000000000000041EAF" data-uri="chapter04.xhtml#P7000497027000000000000000041EAF" class="pcalibre1 calibre1 pcalibre2">a &amp;&amp; !a</code>) evaluates to 0. In contrast, combinational logic does not have any partial evaluation rules. The gates simply respond to changing inputs.</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003CCB" data-uri="chapter04.xhtml#P7000497027000000000000000003CCB">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003CCC" title="376" data-uri="chapter04.xhtml#P7000497027000000000000000003CCC" epub:type="pagebreak"></span><img alt="Diagrams illustrate bit-level implementation and word-level abstraction for equality test circuit." id="P7000497027000000000000000041EB0" data-uri="P700049702700000000000000000B6D1" src="../images/p376-1.png" class="pcalibre1 pcalibre2 calibre29"/>
<figcaption id="P7000497027000000000000000041EB1" data-uri="chapter04.xhtml#P7000497027000000000000000041EB1" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041EB2" data-uri="chapter04.xhtml#P7000497027000000000000000041EB2" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.12 </span>Word-level equality test circuit.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041EB3" data-uri="chapter04.xhtml#P7000497027000000000000000041EB3"><p id="P7000497027000000000000000041EB4" data-uri="chapter04.xhtml#P7000497027000000000000000041EB4" class="pcalibre8 pcalibre1 pcalibre2">The output will equal 1 when each bit from word A equals its counterpart from word B. Word-level equality is one of the operations in HCL.</p><p id="P7000497027000000000000000041EB5" data-uri="chapter04.xhtml#P7000497027000000000000000041EB5" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000022196" data-uri="chapter04.xhtml#P7000497027000000000000000022196">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000041EB6" data-uri="chapter04.xhtml#P7000497027000000000000000041EB6" class="pcalibre8 pcalibre1 pcalibre2">Two diagrams are summarized below.</p>
<ul id="P7000497027000000000000000041EB7" data-uri="chapter04.xhtml#P7000497027000000000000000041EB7" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000041EB8" data-uri="chapter04.xhtml#P7000497027000000000000000041EB8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EB9" data-uri="chapter04.xhtml#P7000497027000000000000000041EB9" class="pcalibre1 pcalibre2 pcalibre10">Bit-level implementation: four bit equal diagrams led to an AND gate and Eq:</p>
<ul id="P7000497027000000000000000041EBA" data-uri="chapter04.xhtml#P7000497027000000000000000041EBA" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000041EBB" data-uri="chapter04.xhtml#P7000497027000000000000000041EBB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EBC" data-uri="chapter04.xhtml#P7000497027000000000000000041EBC" class="pcalibre1 pcalibre2 pcalibre10">a<sub class="pcalibre1 pcalibre2 calibre14">63</sub> and b<sub class="pcalibre1 pcalibre2 calibre14">63</sub> lead to eq<sub class="pcalibre1 pcalibre2 calibre14">63</sub></p></li>
<li id="P7000497027000000000000000041EBD" data-uri="chapter04.xhtml#P7000497027000000000000000041EBD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EBE" data-uri="chapter04.xhtml#P7000497027000000000000000041EBE" class="pcalibre1 pcalibre2 pcalibre10">a<sub class="pcalibre1 pcalibre2 calibre14">62</sub> and b<sub class="pcalibre1 pcalibre2 calibre14">62</sub> lead to eq<sub class="pcalibre1 pcalibre2 calibre14">62</sub></p></li>
<li id="P7000497027000000000000000041EBF" data-uri="chapter04.xhtml#P7000497027000000000000000041EBF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EC0" data-uri="chapter04.xhtml#P7000497027000000000000000041EC0" class="pcalibre1 pcalibre2 pcalibre10">a<sub class="pcalibre1 pcalibre2 calibre14">1</sub> and b<sub class="pcalibre1 pcalibre2 calibre14">1</sub> lead to eq<sub class="pcalibre1 pcalibre2 calibre14">1</sub></p></li>
<li id="P7000497027000000000000000041EC1" data-uri="chapter04.xhtml#P7000497027000000000000000041EC1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EC2" data-uri="chapter04.xhtml#P7000497027000000000000000041EC2" class="pcalibre1 pcalibre2 pcalibre10">a<sub class="pcalibre1 pcalibre2 calibre14">0</sub> and b<sub class="pcalibre1 pcalibre2 calibre14">0</sub> lead to eq<sub class="pcalibre1 pcalibre2 calibre14">0</sub></p></li>
</ul></li>
<li id="P7000497027000000000000000041EC3" data-uri="chapter04.xhtml#P7000497027000000000000000041EC3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EC4" data-uri="chapter04.xhtml#P7000497027000000000000000041EC4" class="pcalibre1 pcalibre2 pcalibre10">Word-level implemention: B and A lead to = which leads to A == B.</p></li>
</ul>
</details>
</figcaption>
</figure>
</section>

<section id="P7000497027000000000000000003CD2" data-uri="chapter04.xhtml#P7000497027000000000000000003CD2" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041EC5" data-uri="chapter04.xhtml#P7000497027000000000000000041EC5" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.2.3 </span>Word-Level Combinational Circuits and HCL Integer Expressions</h1></header>
<p id="P7000497027000000000000000041EC6" data-uri="chapter04.xhtml#P7000497027000000000000000041EC6" class="pcalibre8 pcalibre1 pcalibre2">By assembling large networks of logic gates, we can construct combinational circuits that compute much more complex functions. Typically, we design circuits that operate on data <i class="pcalibre17 pcalibre2 pcalibre1">words.</i> These are groups of bit-level signals that represent an integer or some control pattern. For example, our processor designs will contain numerous words, with word sizes ranging between 4 and 64 bits, representing integers, addresses, instruction codes, and register identifiers.</p>
<p id="P7000497027000000000000000041EC7" data-uri="chapter04.xhtml#P7000497027000000000000000041EC7" class="pcalibre8 pcalibre1 pcalibre2">Combinational circuits that perform word-level computations are constructed using logic gates to compute the individual bits of the output word, based on the individual bits of the input words. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CCB"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.12</span></a> shows a combinational circuit that tests whether two 64-bit words A and B are equal. That is, the output will equal 1 if and only if each bit of A equals the corresponding bit of B. This circuit is implemented using 64 of the single-bit equality circuits shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003C98"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.10</span></a>. The outputs of these single-bit circuits are combined with an <span class="pcalibre1 pcalibre29 pcalibre2">and </span>gate to form the circuit output.</p>
<p id="P7000497027000000000000000041EC8" data-uri="chapter04.xhtml#P7000497027000000000000000041EC8" class="pcalibre8 pcalibre1 pcalibre2">In HCL, we will declare any word-level signal as an <code id="P7000497027000000000000000041EC9" data-uri="chapter04.xhtml#P7000497027000000000000000041EC9" class="pcalibre1 calibre1 pcalibre2">int</code>, without specifying the word size. This is done for simplicity. In a full-featured hardware description language, every word can be declared to have a specific number of bits. HCL allows words to be compared for equality, and so the functionality of the circuit shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CCB"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.12</span></a> can be expressed at the word level as</p>
<p id="P7000497027000000000000000041ECA" data-uri="chapter04.xhtml#P7000497027000000000000000041ECA" class="pcalibre8 pcalibre1 pcalibre2"><code id="P7000497027000000000000000041ECB" data-uri="chapter04.xhtml#P7000497027000000000000000041ECB" class="pcalibre1 calibre1 pcalibre2">bool Eq = (A == B);</code></p>
<p id="P7000497027000000000000000041ECC" data-uri="chapter04.xhtml#P7000497027000000000000000041ECC" class="pcalibre8 pcalibre1 pcalibre2">where arguments A and B are of type int. Note that we use the same syntax conventions as in C, where `=' denotes assignment and `==' denotes the equality operator.</p>

<p id="P7000497027000000000000000041ECD" data-uri="chapter04.xhtml#P7000497027000000000000000041ECD" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003CDC" title="377" data-uri="chapter04.xhtml#P7000497027000000000000000003CDC" epub:type="pagebreak"></span>As is shown on the right side of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CCB"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.12</span></a>, we will draw word-level circuits using medium-thickness lines to represent the set of wires carrying the individual bits of the word, and we will show a single-bit signal as a dashed line.</p>
<section id="P7000497027000000000000000003CDD" data-uri="chapter04.xhtml#P7000497027000000000000000003CDD" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041ECE" data-uri="chapter04.xhtml#P7000497027000000000000000041ECE" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.10 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046F2">484</a>)</h1></header>
<p id="P7000497027000000000000000041ECF" data-uri="chapter04.xhtml#P7000497027000000000000000041ECF" class="pcalibre8 pcalibre1 pcalibre2">Suppose you want to implement a word-level equality circuit using the <span class="pcalibre1 pcalibre29 pcalibre2">exclusive-or </span>circuits from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CAE"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.9</span></a> rather than from bit-level equality circuits. Design such a circuit for a 64-bit word consisting of 64 bit-level <span class="pcalibre1 pcalibre29 pcalibre2">exclusive-or </span>circuits and two additional logic gates.</p>
</section>
<p id="P7000497027000000000000000041ED0" data-uri="chapter04.xhtml#P7000497027000000000000000041ED0" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CE1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.13</span></a> shows the circuit for a word-level multiplexor. This circuit generates a 64-bit word Out equal to one of the two input words, A or B, depending on the control input bit s. The circuit consists of 64 identical subcircuits, each having a structure similar to the bit-level multiplexor from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CB4"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.11</span></a>. Rather than replicating the bit-level multiplexor 64 times, the word-level version reduces the number of inverters by generating !s once and reusing it at each bit position.</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003CE1" data-uri="chapter04.xhtml#P7000497027000000000000000003CE1">
<img alt="Diagrams illustrate bit-level implementation and word-level abstraction for multiplexor circuit." id="P7000497027000000000000000041ED1" data-uri="P700049702700000000000000000B6D2" src="../images/p377-1.png" class="pcalibre1 pcalibre2 calibre30"/>
<figcaption id="P7000497027000000000000000041ED2" data-uri="chapter04.xhtml#P7000497027000000000000000041ED2" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041ED3" data-uri="chapter04.xhtml#P7000497027000000000000000041ED3" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.13 </span>Word-level multiplexor circuit.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041ED4" data-uri="chapter04.xhtml#P7000497027000000000000000041ED4"><p id="P7000497027000000000000000041ED5" data-uri="chapter04.xhtml#P7000497027000000000000000041ED5" class="pcalibre8 pcalibre1 pcalibre2"> The output will equal input word A when the control signal s is 1, and it will equal B otherwise. Multiplexors are described in HCL using case expressions.</p><p id="P7000497027000000000000000041ED6" data-uri="chapter04.xhtml#P7000497027000000000000000041ED6" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000221B7" data-uri="chapter04.xhtml#P70004970270000000000000000221B7">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000041ED7" data-uri="chapter04.xhtml#P7000497027000000000000000041ED7" class="pcalibre8 pcalibre1 pcalibre2">Two diagrams are summarized below.</p>
<ul id="P7000497027000000000000000041ED8" data-uri="chapter04.xhtml#P7000497027000000000000000041ED8" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000041ED9" data-uri="chapter04.xhtml#P7000497027000000000000000041ED9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EDA" data-uri="chapter04.xhtml#P7000497027000000000000000041EDA" class="pcalibre1 pcalibre2 pcalibre10">Bit-level implementation: s leads to a series of AND gates as well as a NOT gate leading to the AND gates. Pairs of AND gates leads to OR gates leading to an OUT:</p>
<ul id="P7000497027000000000000000041EDB" data-uri="chapter04.xhtml#P7000497027000000000000000041EDB" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000041EDC" data-uri="chapter04.xhtml#P7000497027000000000000000041EDC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EDD" data-uri="chapter04.xhtml#P7000497027000000000000000041EDD" class="pcalibre1 pcalibre2 pcalibre10">Leading to out<sub class="pcalibre1 pcalibre2 calibre14">63</sub>, b<sub class="pcalibre1 pcalibre2 calibre14">63</sub> and a<sub class="pcalibre1 pcalibre2 calibre14">63</sub> lead to separate AND gates</p></li>
<li id="P7000497027000000000000000041EDE" data-uri="chapter04.xhtml#P7000497027000000000000000041EDE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EDF" data-uri="chapter04.xhtml#P7000497027000000000000000041EDF" class="pcalibre1 pcalibre2 pcalibre10">Leading to out<sub class="pcalibre1 pcalibre2 calibre14">62</sub>, b<sub class="pcalibre1 pcalibre2 calibre14">62</sub> and a<sub class="pcalibre1 pcalibre2 calibre14">62</sub> lead to separate AND gates</p></li>
<li id="P7000497027000000000000000041EE0" data-uri="chapter04.xhtml#P7000497027000000000000000041EE0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EE1" data-uri="chapter04.xhtml#P7000497027000000000000000041EE1" class="pcalibre1 pcalibre2 pcalibre10">Leading to out<sub class="pcalibre1 pcalibre2 calibre14">0</sub>, b<sub class="pcalibre1 pcalibre2 calibre14">0</sub> and a<sub class="pcalibre1 pcalibre2 calibre14">0</sub> lead to separate AND gates</p></li>
</ul></li>
<li id="P7000497027000000000000000041EE2" data-uri="chapter04.xhtml#P7000497027000000000000000041EE2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EE3" data-uri="chapter04.xhtml#P7000497027000000000000000041EE3" class="pcalibre1 pcalibre2 pcalibre10">Word-level abstraction: S, B, and A lead to MUX, which leads to Out, showing:</p>
<ul id="P7000497027000000000000000041EE4" data-uri="chapter04.xhtml#P7000497027000000000000000041EE4" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000041EE5" data-uri="chapter04.xhtml#P7000497027000000000000000041EE5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EE6" data-uri="chapter04.xhtml#P7000497027000000000000000041EE6" class="pcalibre1 pcalibre2 pcalibre10">Int Out = [</p>
<ul id="P7000497027000000000000000041EE7" data-uri="chapter04.xhtml#P7000497027000000000000000041EE7" class="pcalibre146 pcalibre2 pcalibre1">
<li id="P7000497027000000000000000041EE8" data-uri="chapter04.xhtml#P7000497027000000000000000041EE8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EE9" data-uri="chapter04.xhtml#P7000497027000000000000000041EE9" class="pcalibre1 pcalibre2 pcalibre10">S : A;</p></li>
<li id="P7000497027000000000000000041EEA" data-uri="chapter04.xhtml#P7000497027000000000000000041EEA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EEB" data-uri="chapter04.xhtml#P7000497027000000000000000041EEB" class="pcalibre1 pcalibre2 pcalibre10">L: B;</p></li>
</ul></li>
<li id="P7000497027000000000000000041EEC" data-uri="chapter04.xhtml#P7000497027000000000000000041EEC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041EED" data-uri="chapter04.xhtml#P7000497027000000000000000041EED" class="pcalibre1 pcalibre2 pcalibre10">] ;</p></li>
</ul></li>
</ul>
</details>
</figcaption>
</figure>

<p id="P7000497027000000000000000041EEE" data-uri="chapter04.xhtml#P7000497027000000000000000041EEE" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003CE8" title="378" data-uri="chapter04.xhtml#P7000497027000000000000000003CE8" epub:type="pagebreak"></span>We will use many forms of multiplexors in our processor designs. They allow us to select a word from a number of sources depending on some control condition. Multiplexing functions are described in HCL using <i class="pcalibre17 pcalibre2 pcalibre1">case expressions.</i> A case expression has the following general form:</p>
<pre id="P7000497027000000000000000041EEF" data-uri="chapter04.xhtml#P7000497027000000000000000041EEF" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041EF0" data-uri="chapter04.xhtml#P7000497027000000000000000041EF0" class="calibre3 pcalibre1 pcalibre2">[
<i class="pcalibre17 pcalibre2 pcalibre1">select<sub class="pcalibre1 pcalibre2 pcalibre122">1</sub> : expr<sub class="pcalibre1 pcalibre2 pcalibre122">1</sub>;</i>
<i class="pcalibre17 pcalibre2 pcalibre1">select<sub class="pcalibre1 pcalibre2 pcalibre122">2</sub></i> : <i class="pcalibre17 pcalibre2 pcalibre1">sxpr<sub class="pcalibre1 pcalibre2 pcalibre122">2</sub>;</i>
â‹®
<i class="pcalibre17 pcalibre2 pcalibre1">select<sub class="pcalibre1 pcalibre2 pcalibre122">k</sub> : expr<sub class="pcalibre1 pcalibre2 pcalibre122">k</sub>;</i>
]
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041EF1" data-uri="chapter04.xhtml#P7000497027000000000000000041EF1">The expression contains a series of cases, where each case <var class="pcalibre17 pcalibre2 pcalibre1">i</var> consists of a Boolean expression <i class="pcalibre17 pcalibre2 pcalibre1">select<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>, indicating when this case should be selected, and an integer expression <i class="pcalibre17 pcalibre2 pcalibre1">expr<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>, indicating the resulting value.</p>
<p id="P7000497027000000000000000041EF2" data-uri="chapter04.xhtml#P7000497027000000000000000041EF2" class="pcalibre8 pcalibre1 pcalibre2">Unlike the switch statement of C, we do not require the different selection expressions to be mutually exclusive. Logically, the selection expressions are evaluated in sequence, and the case for the first one yielding 1 is selected. For example, the word-level multiplexor of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CE1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.13</span></a> can be described in HCL as</p>
<pre id="P7000497027000000000000000041EF3" data-uri="chapter04.xhtml#P7000497027000000000000000041EF3" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041EF4" data-uri="chapter04.xhtml#P7000497027000000000000000041EF4" class="calibre3 pcalibre1 pcalibre2">word Out = [
	s: A;
	1: B;
];
</code></pre>
<p id="P7000497027000000000000000041EF5" data-uri="chapter04.xhtml#P7000497027000000000000000041EF5" class="pcalibre8 pcalibre1 pcalibre2">In this code, the second selection expression is simply 1, indicating that this case should be selected if no prior one has been. This is the way to specify a default case in HCL. Nearly all case expressions end in this manner.</p>
<p id="P7000497027000000000000000041EF6" data-uri="chapter04.xhtml#P7000497027000000000000000041EF6" class="pcalibre8 pcalibre1 pcalibre2">Allowing nonexclusive selection expressions makes the HCL code more readable. An actual hardware multiplexor must have mutually exclusive signals controlling which input word should be passed to the output, such as the signals s and !s in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CE1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.13</span></a>. To translate an HCL case expression into hardware, a logic synthesis program would need to analyze the set of selection expressions and resolve any possible conflicts by making sure that only the first matching case would be selected.</p>
<p id="P7000497027000000000000000041EF7" data-uri="chapter04.xhtml#P7000497027000000000000000041EF7" class="pcalibre8 pcalibre1 pcalibre2">The selection expressions can be arbitrary Boolean expressions, and there can be an arbitrary number of cases. This allows case expressions to describe blocks where there are many choices of input signals with complex selection criteria. For example, consider the diagram of a 4-way multiplexor shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CF4"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.14</span></a>. This circuit selects from among the four input words A, B, C, and D based on the control signals s1 and s0, treating the controls as a 2-bit binary number. We can express this in HCL using Boolean expressions to describe the different combinations of control bit patterns:</p>
<pre id="P7000497027000000000000000041EF8" data-uri="chapter04.xhtml#P7000497027000000000000000041EF8" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041EF9" data-uri="chapter04.xhtml#P7000497027000000000000000041EF9" class="calibre3 pcalibre1 pcalibre2">word Out4 = [
	!s1 &amp;&amp; !s0 : A; # 00
</code></pre>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003CF4" data-uri="chapter04.xhtml#P7000497027000000000000000003CF4">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003CF5" title="379" data-uri="chapter04.xhtml#P7000497027000000000000000003CF5" epub:type="pagebreak"></span><img alt="A diagram of a four-way multiplexor shows s1, s0, D, C, B, and A leading to MUX4, which leads to Out4." id="P7000497027000000000000000041EFA" data-uri="P700049702700000000000000000B6D3" src="../images/p379-1.png" class="pcalibre147 pcalibre1 pcalibre2"/>
<figcaption id="P7000497027000000000000000041EFB" data-uri="chapter04.xhtml#P7000497027000000000000000041EFB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041EFC" data-uri="chapter04.xhtml#P7000497027000000000000000041EFC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.14 </span>Four-way multiplexor.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000041EFD" data-uri="chapter04.xhtml#P7000497027000000000000000041EFD"><p id="P7000497027000000000000000041EFE" data-uri="chapter04.xhtml#P7000497027000000000000000041EFE" class="pcalibre8 pcalibre1 pcalibre2"> The different combinations of control signals s1 and s0 determine which data input is transmitted to the output.</p><p id="P7000497027000000000000000041EFF" data-uri="chapter04.xhtml#P7000497027000000000000000041EFF" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
</figcaption>
</figure>
<pre id="P7000497027000000000000000041F00" data-uri="chapter04.xhtml#P7000497027000000000000000041F00" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041F01" data-uri="chapter04.xhtml#P7000497027000000000000000041F01" class="calibre3 pcalibre1 pcalibre2">	!s1 : B; # 01
	!s0 : C; # 10
	1 : D; # 11
];
</code></pre>
<p id="P7000497027000000000000000041F02" data-uri="chapter04.xhtml#P7000497027000000000000000041F02" class="pcalibre8 pcalibre1 pcalibre2">The comments on the right (any text starting with # and running for the rest of the line is a comment) show which combination of s1 and s0 will cause the case to be selected. Observe that the selection expressions can sometimes be simplified, since only the first matching case is selected. For example, the second expression can be written <code id="P7000497027000000000000000041F03" data-uri="chapter04.xhtml#P7000497027000000000000000041F03" class="pcalibre1 calibre1 pcalibre2">!s1</code>, rather than the more complete <code id="P7000497027000000000000000041F04" data-uri="chapter04.xhtml#P7000497027000000000000000041F04" class="pcalibre1 calibre1 pcalibre2">!s1 &amp;&amp; s0</code>, since the only other possibility having <code id="P7000497027000000000000000041F05" data-uri="chapter04.xhtml#P7000497027000000000000000041F05" class="pcalibre1 calibre1 pcalibre2">s1</code> equal to 0 was given as the first selection expression. Similarly, the third expression can be written as <code id="P7000497027000000000000000041F06" data-uri="chapter04.xhtml#P7000497027000000000000000041F06" class="pcalibre1 calibre1 pcalibre2">!s0</code>, while the fourth can simply be written as 1.</p>
<p id="P7000497027000000000000000041F07" data-uri="chapter04.xhtml#P7000497027000000000000000041F07" class="pcalibre8 pcalibre1 pcalibre2">As a final example, suppose we want to design a logic circuit that finds the minimum value among a set of words A, B, and C, diagrammed as follows:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003D03" data-uri="chapter04.xhtml#P7000497027000000000000000003D03">
<img alt="A diagram shows C, B, and A leading to MIN3, leading to Min3." id="P7000497027000000000000000041F08" data-uri="P700049702700000000000000000B6D4" src="../images/p379-2.png" class="pcalibre1 pcalibre2 pcalibre148"/>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041F09" data-uri="chapter04.xhtml#P7000497027000000000000000041F09">We can express this using an HCL case expression as</p>
<pre id="P7000497027000000000000000041F0A" data-uri="chapter04.xhtml#P7000497027000000000000000041F0A" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041F0B" data-uri="chapter04.xhtml#P7000497027000000000000000041F0B" class="calibre3 pcalibre1 pcalibre2">word Min3 = [
	A &lt;= B &amp;&amp; A &lt;= C : A;
	B &lt;= A &amp;&amp; B &lt;= C : B;
	1 : C;
];
</code></pre>

<section id="P7000497027000000000000000003D08" data-uri="chapter04.xhtml#P7000497027000000000000000003D08" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041F0C" data-uri="chapter04.xhtml#P7000497027000000000000000041F0C" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.11 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046F2">484</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041F0D" data-uri="chapter04.xhtml#P7000497027000000000000000041F0D">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041F0E" data-uri="chapter04.xhtml#P7000497027000000000000000041F0E">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041F0F" data-uri="chapter04.xhtml#P7000497027000000000000000041F0F"><p id="P7000497027000000000000000041F10" data-uri="chapter04.xhtml#P7000497027000000000000000041F10" class="pcalibre1 pcalibre2 pcalibre10">The HCL code given for computing the minimum of three words contains four comparison expressions of the form <var class="pcalibre17 pcalibre2 pcalibre1">X</var> &lt;= <i class="pcalibre17 pcalibre2 pcalibre1">Y.</i> Rewrite the code to compute the same result, but using only three comparisons.</p></div>
</li>
</ol>
</section>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003D0E" data-uri="chapter04.xhtml#P7000497027000000000000000003D0E">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003D0F" title="380" data-uri="chapter04.xhtml#P7000497027000000000000000003D0F" epub:type="pagebreak"></span><img alt="A diagram shows four ALU circuits." id="P7000497027000000000000000041F11" data-uri="P700049702700000000000000000B6D5" src="../images/p380-1.png" class="pcalibre1 pcalibre2 pcalibre149"/>
<figcaption id="P7000497027000000000000000041F12" data-uri="chapter04.xhtml#P7000497027000000000000000041F12" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041F13" data-uri="chapter04.xhtml#P7000497027000000000000000041F13" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.15 </span>Arithmetic/logic unit (ALU).</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041F14" data-uri="chapter04.xhtml#P7000497027000000000000000041F14"><p id="P7000497027000000000000000041F15" data-uri="chapter04.xhtml#P7000497027000000000000000041F15" class="pcalibre8 pcalibre1 pcalibre2"> Depending on the setting of the function input, the circuit will perform one of four different arithmetic and logical operations.</p><p id="P7000497027000000000000000041F16" data-uri="chapter04.xhtml#P7000497027000000000000000041F16" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000221F6" data-uri="chapter04.xhtml#P70004970270000000000000000221F6">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000041F17" data-uri="chapter04.xhtml#P7000497027000000000000000041F17" class="pcalibre8 pcalibre1 pcalibre2">The four ALU circuits are summarized below.</p>
<ul id="P7000497027000000000000000041F18" data-uri="chapter04.xhtml#P7000497027000000000000000041F18" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000041F19" data-uri="chapter04.xhtml#P7000497027000000000000000041F19" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041F1A" data-uri="chapter04.xhtml#P7000497027000000000000000041F1A" class="pcalibre1 pcalibre2 pcalibre10">Input 0: Y and X lead to A and B, respectively, in ALU, with output X + Y</p></li>
<li id="P7000497027000000000000000041F1B" data-uri="chapter04.xhtml#P7000497027000000000000000041F1B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041F1C" data-uri="chapter04.xhtml#P7000497027000000000000000041F1C" class="pcalibre1 pcalibre2 pcalibre10">Input 1: Y and X lead to A and B, respectively, in ALU, with output X minus Y</p></li>
<li id="P7000497027000000000000000041F1D" data-uri="chapter04.xhtml#P7000497027000000000000000041F1D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041F1E" data-uri="chapter04.xhtml#P7000497027000000000000000041F1E" class="pcalibre1 pcalibre2 pcalibre10">Input 2: Y and X lead to A and B, respectively, in ALU, with output X &amp; Y</p></li>
<li id="P7000497027000000000000000041F1F" data-uri="chapter04.xhtml#P7000497027000000000000000041F1F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041F20" data-uri="chapter04.xhtml#P7000497027000000000000000041F20" class="pcalibre1 pcalibre2 pcalibre10">Input 3: Y and X lead to A and B, respectively, in ALU, with output X ^ Y</p></li>
</ul>
</details>
</figcaption>
</figure>
<section id="P7000497027000000000000000003D15" data-uri="chapter04.xhtml#P7000497027000000000000000003D15" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041F21" data-uri="chapter04.xhtml#P7000497027000000000000000041F21" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.12 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046F2">484</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041F22" data-uri="chapter04.xhtml#P7000497027000000000000000041F22">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041F23" data-uri="chapter04.xhtml#P7000497027000000000000000041F23">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041F24" data-uri="chapter04.xhtml#P7000497027000000000000000041F24"><p id="P7000497027000000000000000041F25" data-uri="chapter04.xhtml#P7000497027000000000000000041F25" class="pcalibre1 pcalibre2 pcalibre10">Write HCL code describing a circuit that for word inputs A, B, and C selects the <i class="pcalibre17 pcalibre2 pcalibre1">median</i> of the three values. That is, the output equals the word lying between the minimum and maximum of the three inputs.</p></div>
</li>
</ol>
</section>
<p id="P7000497027000000000000000041F26" data-uri="chapter04.xhtml#P7000497027000000000000000041F26" class="pcalibre8 pcalibre1 pcalibre2">Combinational logic circuits can be designed to perform many different types of operations on word-level data. The detailed design of these is beyond the scope of our presentation. One important combinational circuit, known as an <i class="pcalibre17 pcalibre2 pcalibre1">arithmetic/logic unit</i> (ALU), is diagrammed at an abstract level in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003D0E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.15</span></a>. In our version, the circuit has three inputs: two data inputs labeled A and B and a control input. Depending on the setting of the control input, the circuit will perform different arithmetic or logical operations on the data inputs. Observe that the four operations diagrammed for this ALU correspond to the four different integer operations supported by the Y86-64 instruction set, and the control values match the function codes for these instructions (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000003AB0.xhtml#P7000497027000000000000000003B10"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.3</span></a>). Note also the ordering of operands for subtraction, where the A input is subtracted from the B input. This ordering is chosen in anticipation of the ordering of arguments in the <code id="P7000497027000000000000000041F27" data-uri="chapter04.xhtml#P7000497027000000000000000041F27" class="pcalibre1 calibre1 pcalibre2">subq</code> instruction.</p>
</section>

<section id="P7000497027000000000000000003D1D" data-uri="chapter04.xhtml#P7000497027000000000000000003D1D" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041F28" data-uri="chapter04.xhtml#P7000497027000000000000000041F28" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.2.4 </span>Set Membership</h1></header>
<p id="P7000497027000000000000000041F29" data-uri="chapter04.xhtml#P7000497027000000000000000041F29" class="pcalibre8 pcalibre1 pcalibre2">In our processor designs, we will find many examples where we want to compare one signal against a number of possible matching signals, such as to test whether the code for some instruction being processed matches some category of instruction codes. As a simple example, suppose we want to generate the signals s1 and s0 for the 4-way multiplexor of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003CF4"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.14</span></a> by selecting the high- and low-order bits from a 2-bit signal code, as follows:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003D20" data-uri="chapter04.xhtml#P7000497027000000000000000003D20">
<img alt="A diagram shows code leading to Control, leading to s1 and s0, which lead to MUX4. D, C, B, and A also lead to MUX4, which leads to Out4." id="P7000497027000000000000000041F2A" data-uri="P700049702700000000000000000B6D6" src="../images/p380-2.png" class="pcalibre150 pcalibre1 pcalibre2"/>
</figure>

<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041F2B" data-uri="chapter04.xhtml#P7000497027000000000000000041F2B"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003D23" title="381" data-uri="chapter04.xhtml#P7000497027000000000000000003D23" epub:type="pagebreak"></span>In this circuit, the 2-bit signal code would then control the selection among the four data words A, B, C, and D. We can express the generation of signals s1 and s0 using equality tests based on the possible values of code:</p>
<pre id="P7000497027000000000000000041F2C" data-uri="chapter04.xhtml#P7000497027000000000000000041F2C" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041F2D" data-uri="chapter04.xhtml#P7000497027000000000000000041F2D" class="calibre3 pcalibre1 pcalibre2">bool s1 = code == 2 || code == 3;</code>
<code id="P7000497027000000000000000041F2E" data-uri="chapter04.xhtml#P7000497027000000000000000041F2E" class="calibre3 pcalibre1 pcalibre2">bool s0 = code == 1 || code == 3;</code></pre>
<p id="P7000497027000000000000000041F2F" data-uri="chapter04.xhtml#P7000497027000000000000000041F2F" class="pcalibre8 pcalibre1 pcalibre2">A more concise expression can be written that expresses the property that s1 is 1 when code is in the set {2, 3}, and s0 is 1 when code is in the set {1, 3}:</p>
<pre id="P7000497027000000000000000041F30" data-uri="chapter04.xhtml#P7000497027000000000000000041F30" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041F31" data-uri="chapter04.xhtml#P7000497027000000000000000041F31" class="calibre3 pcalibre1 pcalibre2">bool s1 = code in { 2, 3 };</code>
<code id="P7000497027000000000000000041F32" data-uri="chapter04.xhtml#P7000497027000000000000000041F32" class="calibre3 pcalibre1 pcalibre2">bool s0 = code in { 1, 3 };</code></pre>
<p id="P7000497027000000000000000041F33" data-uri="chapter04.xhtml#P7000497027000000000000000041F33" class="pcalibre8 pcalibre1 pcalibre2">The general form of a set membership test is</p>
<pre id="P7000497027000000000000000041F34" data-uri="chapter04.xhtml#P7000497027000000000000000041F34" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041F35" data-uri="chapter04.xhtml#P7000497027000000000000000041F35" class="calibre3 pcalibre1 pcalibre2"><i class="pcalibre17 pcalibre2 pcalibre1">iexpr</i> in <i class="pcalibre17 pcalibre2 pcalibre1">{.iexpr<sub class="pcalibre1 pcalibre2 pcalibre122">1</sub>, iexpr<sub class="pcalibre1 pcalibre2 pcalibre122">2</sub>, Â·Â·Â·, iexpr<sub class="pcalibre1 pcalibre2 pcalibre122">k</sub>}</i></code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041F36" data-uri="chapter04.xhtml#P7000497027000000000000000041F36">where the value being tested <i class="pcalibre17 pcalibre2 pcalibre1">(iexpr)</i> and the candidate matches (<i class="pcalibre17 pcalibre2 pcalibre1">iexpr</i><sub class="pcalibre1 pcalibre2 calibre14">1</sub> through <i class="pcalibre17 pcalibre2 pcalibre1">iexpr<sub class="pcalibre1 pcalibre2 calibre14">k</sub></i>) are all integer expressions.</p>
</section>
<section id="P7000497027000000000000000003D2F" data-uri="chapter04.xhtml#P7000497027000000000000000003D2F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041F37" data-uri="chapter04.xhtml#P7000497027000000000000000041F37" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.2.5 </span>Memory and Clocking</h1></header>
<p id="P7000497027000000000000000041F38" data-uri="chapter04.xhtml#P7000497027000000000000000041F38" class="pcalibre8 pcalibre1 pcalibre2">Combinational circuits, by their very nature, do not store any information. Instead, they simply react to the signals at their inputs, generating outputs equal to some function of the inputs. To create <i class="pcalibre17 pcalibre2 pcalibre1">sequential circuits</i>â€”that is, systems that have state and perform computations on that stateâ€”we must introduce devices that store information represented as bits. Our storage devices are all controlled by a single <i class="pcalibre17 pcalibre2 pcalibre1">clock</i>, a periodic signal that determines when new values are to be loaded into the devices. We consider two classes of memory devices:</p>

<blockquote id="P7000497027000000000000000041F39" data-uri="chapter04.xhtml#P7000497027000000000000000041F39" class="pcalibre88 pcalibre87 pcalibre86"><p id="P7000497027000000000000000041F3A" data-uri="chapter04.xhtml#P7000497027000000000000000041F3A" class="pcalibre8 pcalibre1 pcalibre2"><i class="pcalibre17 pcalibre2 pcalibre1">Clocked registers</i> (or simply <i class="pcalibre17 pcalibre2 pcalibre1">registers)</i> store individual bits or words. The clock signal controls the loading of the register with the value at its input.</p>
<p id="P7000497027000000000000000041F3B" data-uri="chapter04.xhtml#P7000497027000000000000000041F3B" class="pcalibre1 pcalibre2 pcalibre10"><i class="pcalibre17 pcalibre2 pcalibre1">Random access memories</i> (or simply <i class="pcalibre17 pcalibre2 pcalibre1">memories</i>) store multiple words, using an address to select which word should be read or written. Examples of random access memories include (1) the virtual memory system of a processor, where a combination of hardware and operating system software make it appear to a processor that it can access any word within a large address space; and (2) the register file, where register identifiers serve as the addresses. In a Y86-64 processor, the register file holds the 15 program registers (<code id="P7000497027000000000000000041F3C" data-uri="chapter04.xhtml#P7000497027000000000000000041F3C" class="calibre3 pcalibre1 pcalibre2">%rax</code> through <code id="P7000497027000000000000000041F3D" data-uri="chapter04.xhtml#P7000497027000000000000000041F3D" class="calibre3 pcalibre1 pcalibre2">%r14</code>).</p>
</blockquote>
<p id="P7000497027000000000000000041F3E" data-uri="chapter04.xhtml#P7000497027000000000000000041F3E" class="pcalibre8 pcalibre1 pcalibre2">As we can see, the word "register" means two slightly different things when speaking of hardware versus machine-language programming. In hardware, a register is directly connected to the rest of the circuit by its input and output wires. In machine-level programming, the registers represent a small collection of addressable words in the CPU, where the addresses consist of register IDs. These words are generally stored in the register file, although we will see that the hardware can sometimes pass a word directly from one instruction to another to</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003D38" data-uri="chapter04.xhtml#P7000497027000000000000000003D38">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003D39" title="382" data-uri="chapter04.xhtml#P7000497027000000000000000003D39" epub:type="pagebreak"></span><img alt="A diagram of the register operation shows a flow from state = x, with input y and output x, leading to rising clock leading to state = y, with output y." id="P7000497027000000000000000041F3F" data-uri="P700049702700000000000000000B6D7" src="../images/p382-1.png" class="pcalibre151 pcalibre2 pcalibre1"/>
<figcaption id="P7000497027000000000000000041F40" data-uri="chapter04.xhtml#P7000497027000000000000000041F40" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041F41" data-uri="chapter04.xhtml#P7000497027000000000000000041F41" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.16 </span>Register operation.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000041F42" data-uri="chapter04.xhtml#P7000497027000000000000000041F42"><p id="P7000497027000000000000000041F43" data-uri="chapter04.xhtml#P7000497027000000000000000041F43" class="pcalibre8 pcalibre1 pcalibre2"> The register outputs remain held at the current register state until the clock signal rises. When the clock rises, the values at the register inputs are captured to become the new register state.</p><p id="P7000497027000000000000000041F44" data-uri="chapter04.xhtml#P7000497027000000000000000041F44" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041F45" data-uri="chapter04.xhtml#P7000497027000000000000000041F45">avoid the delay of first writing and then reading the register file. When necessary to avoid ambiguity, we will call the two classes of registers "hardware registers" and "program registers," respectively.</p>
<p id="P7000497027000000000000000041F46" data-uri="chapter04.xhtml#P7000497027000000000000000041F46" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003D38"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.16</span></a> gives a more detailed view of a hardware register and how it operates. For most of the time, the register remains in a fixed state (shown as x), generating an output equal to its current state. Signals propagate through the combinational logic preceding the register, creating a new value for the register input (shown as y), but the register output remains fixed as long as the clock is low. As the clock rises, the input signals are loaded into the register as its next state (y), and this becomes the new register output until the next rising clock edge. A key point is that the registers serve as barriers between the combinational logic in different parts of the circuit. Values only propagate from a register input to its output once every clock cycle at the rising clock edge. Our Y86-64 processors will use clocked registers to hold the program counter (PC), the condition codes (CC), and the program status (Stat).</p>
<p id="P7000497027000000000000000041F47" data-uri="chapter04.xhtml#P7000497027000000000000000041F47" class="pcalibre8 pcalibre1 pcalibre2">The following diagram shows a typical register file:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003D42" data-uri="chapter04.xhtml#P7000497027000000000000000003D42">
<img alt="A diagram of a register file, with clock input, has two read ports: A with input srcA and output valA and B with input srcB and output valB, and a write port with inputs dstW and valW." id="P7000497027000000000000000041F48" data-uri="P700049702700000000000000000B6D8" src="../images/p382-2.png" class="pcalibre1 pcalibre2 calibre31"/>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041F49" data-uri="chapter04.xhtml#P7000497027000000000000000041F49">This register file has two <i class="pcalibre17 pcalibre2 pcalibre1">read ports</i>, named A and B, and one <i class="pcalibre17 pcalibre2 pcalibre1">write port</i>, named W. Such a <i class="pcalibre17 pcalibre2 pcalibre1">multiported</i> random access memory allows multiple read and write operations to take place simultaneously. In the register file diagrammed, the circuit can read the values of two program registers and update the state of a third. Each port has an address input, indicating which program register should be selected, and a data output or input giving a value for that program register. The addresses are register identifiers, using the encoding shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000003AB0.xhtml#P7000497027000000000000000003B18"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.4</span></a>. The two read ports have address inputs srcA and srcB (short for "source A" and "source B") and data <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003D45" title="383" data-uri="chapter04.xhtml#P7000497027000000000000000003D45" epub:type="pagebreak"></span>outputs valA and valB (short for "value A" and "value B"). The write port has address input dstW (short for "destination W") and data input valW (short for "value W").</p>
<p id="P7000497027000000000000000041F4A" data-uri="chapter04.xhtml#P7000497027000000000000000041F4A" class="pcalibre8 pcalibre1 pcalibre2">The register file is not a combinational circuit, since it has internal storage. In our implementation, however, data can be read from the register file as if it were a block of combinational logic having addresses as inputs and the data as outputs. When either srcA or srcB is set to some register ID, then, after some delay, the value stored in the corresponding program register will appear on either valA or valB. For example, setting srcA to 3 will cause the value of program register <code id="P7000497027000000000000000041F4B" data-uri="chapter04.xhtml#P7000497027000000000000000041F4B" class="pcalibre1 calibre1 pcalibre2">%rbx</code> to be read, and this value will appear on output valA.</p>
<p id="P7000497027000000000000000041F4C" data-uri="chapter04.xhtml#P7000497027000000000000000041F4C" class="pcalibre8 pcalibre1 pcalibre2">The writing of words to the register file is controlled by the clock signal in a manner similar to the loading of values into a clocked register. Every time the clock rises, the value on input valW is written to the program register indicated by the register ID on input dstW. When dstW is set to the special ID value <code id="P7000497027000000000000000041F4D" data-uri="chapter04.xhtml#P7000497027000000000000000041F4D" class="pcalibre1 calibre1 pcalibre2">0xF</code>, no program register is written. Since the register file can be both read and written, a natural question to ask is, "What happens if the circuit attempts to read and write the same register simultaneously?" The answer is straightforward: if the same register ID is used for both a read port and the write port, then, as the clock rises, there will be a transition on the read port's data output from the old value to the new. When we incorporate the register file into our processor design, we will make sure that we take this property into consideration.</p>
<p id="P7000497027000000000000000041F4E" data-uri="chapter04.xhtml#P7000497027000000000000000041F4E" class="pcalibre8 pcalibre1 pcalibre2">Our processor has a random access memory for storing program data, as illustrated below:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003D4B" data-uri="chapter04.xhtml#P7000497027000000000000000003D4B">
<img alt="A diagram of data memory shows inputs from clock, read, write, address, and data in and outputs as error and data out." id="P7000497027000000000000000041F4F" data-uri="P700049702700000000000000000B6D9" src="../images/p383-1.png" class="pcalibre1 pcalibre2 calibre32"/>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041F50" data-uri="chapter04.xhtml#P7000497027000000000000000041F50">This memory has a single address input, a data input for writing, and a data output for reading. Like the register file, reading from our memory operates in a manner similar to combinational logic: If we provide an address on the address input and set the write control signal to 0, then after some delay, the value stored at that address will appear on data out. The error signal will be set to 1 if the address is out of range, and to 0 otherwise. Writing to the memory is controlled by the clock: We set address to the desired address, data in to the desired value, and write to 1. When we then operate the clock, the specified location in the memory will be updated, as long as the address is valid. As with the read operation, the error signal will be set to 1 if the address is invalid. This signal is generated by combinational logic, since the required bounds checking is purely a function of the address input and does not involve saving any state.</p>

<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000003D4E" data-uri="chapter04.xhtml#P7000497027000000000000000003D4E"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000041F51" data-uri="chapter04.xhtml#P7000497027000000000000000041F51" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003D50" title="384" data-uri="chapter04.xhtml#P7000497027000000000000000003D50" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Real-life memory design</h1></header>
<p id="P7000497027000000000000000041F52" data-uri="chapter04.xhtml#P7000497027000000000000000041F52" class="pcalibre1 pcalibre2 pcalibre40">The memory system in a full-scale microprocessor is far more complex than the simple one we assume in our design. It consists of several forms of hardware memories, including several random access memories, plus nonvolatile memory or magnetic disk, as well as a variety of hardware and software mechanisms for managing these devices. The design and characteristics of the memory system are described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000005190.xhtml#P7000497027000000000000000005190"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">6</span></a>.</p>
<p id="P7000497027000000000000000041F53" data-uri="chapter04.xhtml#P7000497027000000000000000041F53" class="pcalibre1 pcalibre2 pcalibre10">Nonetheless, our simple memory design can be used for smaller systems, and it provides us with an abstraction of the interface between the processor and memory for more complex systems.</p>
</aside>
<p id="P7000497027000000000000000041F54" data-uri="chapter04.xhtml#P7000497027000000000000000041F54" class="pcalibre8 pcalibre1 pcalibre2">Our processor includes an additional read-only memory for reading instructions. In most actual systems, these memories are merged into a single memory with two ports: one for reading instructions, and the other for reading or writing data.</p>
</section>
</section></body></html>
