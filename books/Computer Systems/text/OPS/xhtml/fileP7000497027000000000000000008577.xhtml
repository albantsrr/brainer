<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>12.7 Other Concurrency Issues</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000008577" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000047026" data-uri="chapter12.xhtml#P7000497027000000000000000047026" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.7 </span>Other Concurrency Issues</h1></header>
<p id="P7000497027000000000000000047027" data-uri="chapter12.xhtml#P7000497027000000000000000047027" class="pcalibre8 pcalibre1 pcalibre2">You probably noticed that life got much more complicated once we were asked to synchronize accesses to shared data. So far, we have looked at techniques for mutual exclusion and producer-consumer synchronization, but this is only the tip of the iceberg. Synchronization is a fundamentally difficult problem that raises issues that simply do not arise in ordinary sequential programs. This section is a survey (by no means complete) of some of the issues you need to be aware of when you write concurrent programs. To keep things concrete, we will couch our discussion in terms of threads. Keep in mind, however, that these are typical of the issues that arise when concurrent flows of any kind manipulate shared resources.</p>
<section id="P700049702700000000000000000857A" data-uri="chapter12.xhtml#P700049702700000000000000000857A" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000047028" data-uri="chapter12.xhtml#P7000497027000000000000000047028" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.7.1 </span>Thread Safety</h1></header>
<p id="P7000497027000000000000000047029" data-uri="chapter12.xhtml#P7000497027000000000000000047029" class="pcalibre8 pcalibre1 pcalibre2">When we program with threads, we must be careful to write functions that have a property called thread safety. A function is said to be <i class="pcalibre17 pcalibre2 pcalibre1">thread-safe</i> if and only if it will always produce correct results when called repeatedly from multiple concurrent threads. If a function is not thread-safe, then we say it is <i class="pcalibre17 pcalibre2 pcalibre1">thread-unsafe</i>.</p>
<p id="P700049702700000000000000004702A" data-uri="chapter12.xhtml#P700049702700000000000000004702A" class="pcalibre8 pcalibre1 pcalibre2">We can identify four (nondisjoint) classes of thread-unsafe functions:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P700049702700000000000000004702B" data-uri="chapter12.xhtml#P700049702700000000000000004702B">
<li id="P700049702700000000000000004702C" data-uri="chapter12.xhtml#P700049702700000000000000004702C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004702D" data-uri="chapter12.xhtml#P700049702700000000000000004702D" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Class 1: </span><i class="pcalibre17 pcalibre2 pcalibre1">Functions that do not protect shared variables.</i> We have already encountered this problem with the thread function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008286"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.16</span></a>, which</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008581" data-uri="chapter12.xhtml#P7000497027000000000000000008581">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000008582" title="1021" data-uri="chapter12.xhtml#P7000497027000000000000000008582" epub:type="pagebreak"></span>
<p id="P700049702700000000000000004702E" data-uri="chapter12.xhtml#P700049702700000000000000004702E" class="pcalibre1 pcalibre2 pcalibre40">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/rand.c</i></p>
<pre id="P700049702700000000000000004702F" data-uri="chapter12.xhtml#P700049702700000000000000004702F" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000047030" data-uri="chapter12.xhtml#P7000497027000000000000000047030" class="calibre3 pcalibre1 pcalibre2">
1	unsigned next_seed = 1;
2
3	/* rand - return pseudorandom integer in the range 0..32767 */
4	unsigned rand(void)
5	{
6		next_seed = next_seed*1103515245 + 12543;
7		return (unsigned)(next_seed&gt;&gt;16) % 32768;
8	}
9
10	/* srand - set the initial seed for rand() */
11	void srand(unsigned new_seed)
12	{
13		next_seed = new_seed;
14	}
</code></pre>
<p id="P7000497027000000000000000047031" data-uri="chapter12.xhtml#P7000497027000000000000000047031" class="pcalibre1 pcalibre2 pcalibre40">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/rand.c</i></p>
<figcaption id="P7000497027000000000000000047032" data-uri="chapter12.xhtml#P7000497027000000000000000047032" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000047033" data-uri="chapter12.xhtml#P7000497027000000000000000047033" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.37 </span>A thread-unsafe pseudorandom number generator.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000047034" data-uri="chapter12.xhtml#P7000497027000000000000000047034"><p id="P7000497027000000000000000047035" data-uri="chapter12.xhtml#P7000497027000000000000000047035" class="pcalibre1 pcalibre2 pcalibre10">(Based on [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41C">61</a>])</p></div></figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P7000497027000000000000000047036" data-uri="chapter12.xhtml#P7000497027000000000000000047036">increments an unprotected global counter variable. This class of thread-unsafe functions is relatively easy to make thread-safe: protect the shared variables with synchronization operations such as <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var>. An advantage is that it does not require any changes in the calling program. A disadvantage is that the synchronization operations slow down the function.</p></li>
<li id="P7000497027000000000000000047037" data-uri="chapter12.xhtml#P7000497027000000000000000047037" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000047038" data-uri="chapter12.xhtml#P7000497027000000000000000047038" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Class 2: </span><i class="pcalibre17 pcalibre2 pcalibre1">Functions that keep state across multiple invocations.</i> A pseudorandom number generator is a simple example of this class of thread-unsafe functions. Consider the pseudorandom number generator package in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008581"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.37</span></a>.</p>
<p id="P7000497027000000000000000047039" data-uri="chapter12.xhtml#P7000497027000000000000000047039" class="pcalibre1 pcalibre2 pcalibre42">The <code id="P700049702700000000000000004703A" data-uri="chapter12.xhtml#P700049702700000000000000004703A" class="pcalibre1 calibre1 pcalibre2">rand</code> function is thread-unsafe because the result of the current invocation depends on an intermediate result from the previous iteration. When we call <code id="P700049702700000000000000004703B" data-uri="chapter12.xhtml#P700049702700000000000000004703B" class="pcalibre1 calibre1 pcalibre2">rand</code> repeatedly from a single thread after seeding it with a call to <code id="P700049702700000000000000004703C" data-uri="chapter12.xhtml#P700049702700000000000000004703C" class="pcalibre1 calibre1 pcalibre2">srand</code>, we can expect a repeatable sequence of numbers. However, this assumption no longer holds if multiple threads are calling <code id="P700049702700000000000000004703D" data-uri="chapter12.xhtml#P700049702700000000000000004703D" class="pcalibre1 calibre1 pcalibre2">rand</code>.</p>
<p id="P700049702700000000000000004703E" data-uri="chapter12.xhtml#P700049702700000000000000004703E" class="pcalibre1 pcalibre2 pcalibre42">The only way to make a function such as <code id="P700049702700000000000000004703F" data-uri="chapter12.xhtml#P700049702700000000000000004703F" class="pcalibre1 calibre1 pcalibre2">rand</code> thread-safe is to rewrite it so that it does not use any <code id="P7000497027000000000000000047040" data-uri="chapter12.xhtml#P7000497027000000000000000047040" class="pcalibre1 calibre1 pcalibre2">static</code> data, relying instead on the caller to pass the state information in arguments. The disadvantage is that the programmer is now forced to change the code in the calling routine as well. In a large program where there are potentially hundreds of different call sites, making such modifications could be nontrivial and prone to error.</p></li>
<li id="P7000497027000000000000000047041" data-uri="chapter12.xhtml#P7000497027000000000000000047041" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000047042" data-uri="chapter12.xhtml#P7000497027000000000000000047042" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Class 3: </span><i class="pcalibre17 pcalibre2 pcalibre1">Functions that return a pointer to a static variable.</i> Some functions, such as <code id="P7000497027000000000000000047043" data-uri="chapter12.xhtml#P7000497027000000000000000047043" class="pcalibre1 calibre1 pcalibre2">ctime</code> and <code id="P7000497027000000000000000047044" data-uri="chapter12.xhtml#P7000497027000000000000000047044" class="pcalibre1 calibre1 pcalibre2">gethostbyname</code>, compute a result in a <code id="P7000497027000000000000000047045" data-uri="chapter12.xhtml#P7000497027000000000000000047045" class="pcalibre1 calibre1 pcalibre2">static</code> variable and then return a pointer to that variable. If we call such functions from</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000859B" data-uri="chapter12.xhtml#P700049702700000000000000000859B">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000859C" title="1022" data-uri="chapter12.xhtml#P700049702700000000000000000859C" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000047046" data-uri="chapter12.xhtml#P7000497027000000000000000047046" class="pcalibre1 pcalibre2 pcalibre40">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/ctime-ts.c</i></p>
<pre id="P7000497027000000000000000047047" data-uri="chapter12.xhtml#P7000497027000000000000000047047" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000047048" data-uri="chapter12.xhtml#P7000497027000000000000000047048" class="calibre3 pcalibre1 pcalibre2">
1	char *ctime_ts(const time_t *timep, char *privatep)
2	{
3		char *sharedp;
4
5		P(&amp;mutex);
6		sharedp = ctime(timep);
7		strcpy(privatep, sharedp); /* Copy string from shared to private */
8		V(&amp;mutex);
9		return privatep;
10	}
</code></pre>
<p id="P7000497027000000000000000047049" data-uri="chapter12.xhtml#P7000497027000000000000000047049" class="pcalibre1 pcalibre2 pcalibre40">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/ctime-ts.c</i></p>
<figcaption id="P700049702700000000000000004704A" data-uri="chapter12.xhtml#P700049702700000000000000004704A" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004704B" data-uri="chapter12.xhtml#P700049702700000000000000004704B" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.38 </span>Thread-safe wrapper function for the C standard library <code id="P700049702700000000000000004704C" data-uri="chapter12.xhtml#P700049702700000000000000004704C" class="pcalibre1 calibre1 pcalibre2">ctime</code> function.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P700049702700000000000000004704D" data-uri="chapter12.xhtml#P700049702700000000000000004704D"><p id="P700049702700000000000000004704E" data-uri="chapter12.xhtml#P700049702700000000000000004704E" class="pcalibre1 pcalibre2 pcalibre10">This example uses the lock-and-copy technique to call a class 3 thread-unsafe function.</p></div></figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P700049702700000000000000004704F" data-uri="chapter12.xhtml#P700049702700000000000000004704F">concurrent threads, then disaster is likely, as results being used by one thread are silently overwritten by another thread.</p>
<p id="P7000497027000000000000000047050" data-uri="chapter12.xhtml#P7000497027000000000000000047050" class="pcalibre1 pcalibre2 pcalibre42">There are two ways to deal with this class of thread-unsafe functions. One option is to rewrite the function so that the caller passes the address of the variable in which to store the results. This eliminates all shared data, but it requires the programmer to have access to the function source code.</p>
<p id="P7000497027000000000000000047051" data-uri="chapter12.xhtml#P7000497027000000000000000047051" class="pcalibre1 pcalibre2 pcalibre42">If the thread-unsafe function is difficult or impossible to modify (e.g., the code is very complex or there is no source code available), then another option is to use the <i class="pcalibre17 pcalibre2 pcalibre1">lock-and-copy</i> technique. The basic idea is to associate a mutex with the thread-unsafe function. At each call site, lock the mutex, call the thread-unsafe function, copy the result returned by the function to a private memory location, and then unlock the mutex. To minimize changes to the caller, you should define a thread-safe wrapper function that performs the lock-and-copy and then replace all calls to the thread-unsafe function with calls to the wrapper. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000859B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.38</span></a> shows a thread-safe wrapper for <code id="P7000497027000000000000000047052" data-uri="chapter12.xhtml#P7000497027000000000000000047052" class="pcalibre1 calibre1 pcalibre2">ctime</code> that uses the lock-and-copy technique.</p></li>
<li id="P7000497027000000000000000047053" data-uri="chapter12.xhtml#P7000497027000000000000000047053" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000047054" data-uri="chapter12.xhtml#P7000497027000000000000000047054" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Class 4: </span><i class="pcalibre17 pcalibre2 pcalibre1">Functions that call thread-unsafe functions.</i> If a function <var class="pcalibre17 pcalibre2 pcalibre1">f</var> calls a thread-unsafe function <var class="pcalibre17 pcalibre2 pcalibre1">g</var>, is <var class="pcalibre17 pcalibre2 pcalibre1">f</var> thread-unsafe? It depends. If <var class="pcalibre17 pcalibre2 pcalibre1">g</var> is a class 2 function that relies on state across multiple invocations, then <var class="pcalibre17 pcalibre2 pcalibre1">f</var> is also thread-unsafe and there is no recourse short of rewriting <var class="pcalibre17 pcalibre2 pcalibre1">g</var>. However, if <var class="pcalibre17 pcalibre2 pcalibre1">g</var> is a class 1 or class 3 function, then <var class="pcalibre17 pcalibre2 pcalibre1">f</var> can still be thread-safe if you protect the call site and any resulting shared data with a mutex. We see a good example of this in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000859B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.38</span></a>, where we use lock-and-copy to write a thread-safe function that calls a thread-unsafe function.</p></li>
</ul>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000085AC" data-uri="chapter12.xhtml#P70004970270000000000000000085AC">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000085AD" title="1023" data-uri="chapter12.xhtml#P70004970270000000000000000085AD" epub:type="pagebreak"></span>
<img alt="A diagram shows all functions divided among thread-safe functions and thread-unsafe functions. Reentrant functions are within thread-safe functions." id="P7000497027000000000000000047055" data-uri="P700049702700000000000000000B69B" src="../images/p1023-1.png" class="pcalibre1 pcalibre2 calibre90"/>
<figcaption id="P7000497027000000000000000047056" data-uri="chapter12.xhtml#P7000497027000000000000000047056" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000047057" data-uri="chapter12.xhtml#P7000497027000000000000000047057" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.39 </span>Relationships between the sets of reentrant, thread-safe, and thread-unsafe functions.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000085B1" data-uri="chapter12.xhtml#P70004970270000000000000000085B1">
<p id="P7000497027000000000000000047058" data-uri="chapter12.xhtml#P7000497027000000000000000047058" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/rand-r.c</i></p>
<pre id="P7000497027000000000000000047059" data-uri="chapter12.xhtml#P7000497027000000000000000047059" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004705A" data-uri="chapter12.xhtml#P700049702700000000000000004705A" class="calibre3 pcalibre1 pcalibre2">
1	/* rand_r - return a pseudorandom integer on 0..32767 */
2	int rand_r(unsigned int *nextp)
3	{
4		*nextp = *nextp * 1103515245 + 12345;
5		return (unsigned int)(*nextp / 65536) % 32768;
6	}
</code></pre>
<p id="P700049702700000000000000004705B" data-uri="chapter12.xhtml#P700049702700000000000000004705B" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/rand-r.c</i></p>
<figcaption id="P700049702700000000000000004705C" data-uri="chapter12.xhtml#P700049702700000000000000004705C" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004705D" data-uri="chapter12.xhtml#P700049702700000000000000004705D" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.40 </span><code id="P700049702700000000000000004705E" data-uri="chapter12.xhtml#P700049702700000000000000004705E" class="pcalibre1 calibre1 pcalibre2">rand_r</code>: A reentrant version of the <code id="P700049702700000000000000004705F" data-uri="chapter12.xhtml#P700049702700000000000000004705F" class="pcalibre1 calibre1 pcalibre2">rand</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008581"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.37</span></a>.</h1></header>
</figcaption>
</figure>
</section>
<section id="P70004970270000000000000000085BA" data-uri="chapter12.xhtml#P70004970270000000000000000085BA" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000047060" data-uri="chapter12.xhtml#P7000497027000000000000000047060" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.7.2 </span>Reentrancy</h1></header>
<p id="P7000497027000000000000000047061" data-uri="chapter12.xhtml#P7000497027000000000000000047061" class="pcalibre8 pcalibre1 pcalibre2">There is an important class of thread-safe functions, known as <i class="pcalibre17 pcalibre2 pcalibre1">reentrant functions</i>, that are characterized by the property that they do not reference <i class="pcalibre17 pcalibre2 pcalibre1">any</i> shared data when they are called by multiple threads. Although the terms <i class="pcalibre17 pcalibre2 pcalibre1">thread-safe</i> and <i class="pcalibre17 pcalibre2 pcalibre1">reentrant</i> are sometimes used (incorrectly) as synonyms, there is a clear technical distinction that is worth preserving. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000085AC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.39</span></a> shows the set relationships between reentrant, thread-safe, and thread-unsafe functions. The set of all functions is partitioned into the disjoint sets of thread-safe and thread-unsafe functions. The set of reentrant functions is a proper subset of the thread-safe functions.</p>
<p id="P7000497027000000000000000047062" data-uri="chapter12.xhtml#P7000497027000000000000000047062" class="pcalibre8 pcalibre1 pcalibre2">Reentrant functions are typically more efficient than non-reentrant thread-safe functions because they require no synchronization operations. Furthermore, the only way to convert a class 2 thread-unsafe function into a thread-safe one is to rewrite it so that it is reentrant. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000085B1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.40</span></a> shows a reentrant version of the <code id="P7000497027000000000000000047063" data-uri="chapter12.xhtml#P7000497027000000000000000047063" class="pcalibre1 calibre1 pcalibre2">rand</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008581"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.37</span></a>. The key idea is that we have replaced the static <code id="P7000497027000000000000000047064" data-uri="chapter12.xhtml#P7000497027000000000000000047064" class="pcalibre1 calibre1 pcalibre2">next</code> variable with a pointer that is passed in by the caller.</p>
<p id="P7000497027000000000000000047065" data-uri="chapter12.xhtml#P7000497027000000000000000047065" class="pcalibre8 pcalibre1 pcalibre2">Is it possible to inspect the code of some function and declare a priori that it is reentrant? Unfortunately, it depends. If all function arguments are passed by value (i.e., no pointers) and all data references are to local automatic stack variables (i.e., no references to static or global variables), then the function is <i class="pcalibre17 pcalibre2 pcalibre1">explicitly reentrant</i>, in the sense that we can assert its reentrancy regardless of how it is called.</p>
<p id="P7000497027000000000000000047066" data-uri="chapter12.xhtml#P7000497027000000000000000047066" class="pcalibre8 pcalibre1 pcalibre2">However, if we loosen our assumptions a bit and allow some parameters in our otherwise explicitly reentrant function to be passed by reference (i.e., we allow them to pass pointers), then we have an <i class="pcalibre17 pcalibre2 pcalibre1">implicitly reentrant</i> function, in the sense that it is only reentrant if the calling threads are careful to pass pointers <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000085C2" title="1024" data-uri="chapter12.xhtml#P70004970270000000000000000085C2" epub:type="pagebreak"></span>to nonshared data. For example, the <code id="P7000497027000000000000000047067" data-uri="chapter12.xhtml#P7000497027000000000000000047067" class="pcalibre1 calibre1 pcalibre2">rand_r</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000085B1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.40</span></a> is implicitly reentrant.</p>
<p id="P7000497027000000000000000047068" data-uri="chapter12.xhtml#P7000497027000000000000000047068" class="pcalibre8 pcalibre1 pcalibre2">We always use the term <i class="pcalibre17 pcalibre2 pcalibre1">reentrant</i> to include both explicit and implicit reentrant functions. However, it is important to realize that reentrancy is sometimes a property of both the caller and the callee, and not just the callee alone.</p>
<section id="P70004970270000000000000000085C5" data-uri="chapter12.xhtml#P70004970270000000000000000085C5" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000047069" data-uri="chapter12.xhtml#P7000497027000000000000000047069" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.12 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008803">1038</a>)</h1></header> 
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004706A" data-uri="chapter12.xhtml#P700049702700000000000000004706A">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004706B" data-uri="chapter12.xhtml#P700049702700000000000000004706B">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004706C" data-uri="chapter12.xhtml#P700049702700000000000000004706C"><p id="P700049702700000000000000004706D" data-uri="chapter12.xhtml#P700049702700000000000000004706D" class="pcalibre1 pcalibre2 pcalibre10">The <code id="P700049702700000000000000004706E" data-uri="chapter12.xhtml#P700049702700000000000000004706E" class="pcalibre1 calibre1 pcalibre2">ctime_ts</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000859B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.38</span></a> is thread-safe but not reentrant. Explain.</p></div></li>
</ol>
</section>
</section>
<section id="P70004970270000000000000000085CC" data-uri="chapter12.xhtml#P70004970270000000000000000085CC" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004706F" data-uri="chapter12.xhtml#P700049702700000000000000004706F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.7.3 </span>Using Existing Library Functions in Threaded Programs</h1></header>
<p id="P7000497027000000000000000047070" data-uri="chapter12.xhtml#P7000497027000000000000000047070" class="pcalibre8 pcalibre1 pcalibre2">Most Linux functions, including the functions defined in the standard C library (such as <code id="P7000497027000000000000000047071" data-uri="chapter12.xhtml#P7000497027000000000000000047071" class="pcalibre1 calibre1 pcalibre2">malloc, free, realloc, printf</code>, and <code id="P7000497027000000000000000047072" data-uri="chapter12.xhtml#P7000497027000000000000000047072" class="pcalibre1 calibre1 pcalibre2">scanf</code>), are thread-safe, with only a few exceptions. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000085DB"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.41</span></a> lists some common exceptions. (See [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>] for a complete list.) The <code id="P7000497027000000000000000047073" data-uri="chapter12.xhtml#P7000497027000000000000000047073" class="pcalibre1 calibre1 pcalibre2">strtok</code> function is a deprecated function (one whose use is discouraged) for parsing strings. The <code id="P7000497027000000000000000047074" data-uri="chapter12.xhtml#P7000497027000000000000000047074" class="pcalibre1 calibre1 pcalibre2">asctime, ctime</code>, and <code id="P7000497027000000000000000047075" data-uri="chapter12.xhtml#P7000497027000000000000000047075" class="pcalibre1 calibre1 pcalibre2">localtime</code> functions are popular functions for converting back and forth between different time and date formats. The <code id="P7000497027000000000000000047076" data-uri="chapter12.xhtml#P7000497027000000000000000047076" class="pcalibre1 calibre1 pcalibre2">gethostbyaddr, gethostbyname</code>, and <code id="P7000497027000000000000000047077" data-uri="chapter12.xhtml#P7000497027000000000000000047077" class="pcalibre1 calibre1 pcalibre2">inet_ntoa</code> functions are obsolete network programming functions that have been replaced by the reentrant getaddrinfo, <code id="P7000497027000000000000000047078" data-uri="chapter12.xhtml#P7000497027000000000000000047078" class="pcalibre1 calibre1 pcalibre2">getnameinfo</code>, and <code id="P7000497027000000000000000047079" data-uri="chapter12.xhtml#P7000497027000000000000000047079" class="pcalibre1 calibre1 pcalibre2">inet_ntop</code> functions, respectively (see <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007B7A.xhtml#P7000497027000000000000000007B7A"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">11</span></a>). With the exceptions of <code id="P700049702700000000000000004707A" data-uri="chapter12.xhtml#P700049702700000000000000004707A" class="pcalibre1 calibre1 pcalibre2">rand</code> and <code id="P700049702700000000000000004707B" data-uri="chapter12.xhtml#P700049702700000000000000004707B" class="pcalibre1 calibre1 pcalibre2">strtok</code>, they are of the class 3 variety that return a pointer to a static variable. If we need to call one of these functions in a threaded program, the least disruptive approach to the caller is to lock and copy. However, the lock-and-copy approach has a number of disadvantages. First, the additional synchronization slows down the program. Second, functions that return pointers to complex structures of structures require a <i class="pcalibre17 pcalibre2 pcalibre1">deep copy</i> of the structures in order to copy the entire structure hierarchy. Third, the lock-and-copy approach will not work for a class 2 thread-unsafe function such as <code id="P700049702700000000000000004707C" data-uri="chapter12.xhtml#P700049702700000000000000004707C" class="pcalibre1 calibre1 pcalibre2">rand</code> that relies on static state across calls.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000085DB" data-uri="chapter12.xhtml#P70004970270000000000000000085DB">
<table id="P700049702700000000000000004707D" data-uri="chapter12.xhtml#P700049702700000000000000004707D" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P700049702700000000000000004707E" data-uri="chapter12.xhtml#P700049702700000000000000004707E" class="pcalibre1 pcalibre2 calibre5">Thread-unsafe function</th>
<th id="P700049702700000000000000004707F" data-uri="chapter12.xhtml#P700049702700000000000000004707F" class="pcalibre1 pcalibre2 calibre5">Thread-unsafe class</th>
<th id="P7000497027000000000000000047080" data-uri="chapter12.xhtml#P7000497027000000000000000047080" class="pcalibre1 pcalibre2 calibre5">Linux thread-safe version</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000047081" data-uri="chapter12.xhtml#P7000497027000000000000000047081" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000047082" data-uri="chapter12.xhtml#P7000497027000000000000000047082" class="calibre3 pcalibre1 pcalibre2">rand</code></td>
<td id="P7000497027000000000000000047083" data-uri="chapter12.xhtml#P7000497027000000000000000047083" class="pcalibre1 pcalibre2 calibre7">2</td>
<td id="P7000497027000000000000000047084" data-uri="chapter12.xhtml#P7000497027000000000000000047084" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000047085" data-uri="chapter12.xhtml#P7000497027000000000000000047085" class="calibre3 pcalibre1 pcalibre2">rand_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000047086" data-uri="chapter12.xhtml#P7000497027000000000000000047086" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000047087" data-uri="chapter12.xhtml#P7000497027000000000000000047087" class="calibre3 pcalibre1 pcalibre2">strtok</code></td>
<td id="P7000497027000000000000000047088" data-uri="chapter12.xhtml#P7000497027000000000000000047088" class="pcalibre1 pcalibre2 calibre7">2</td>
<td id="P7000497027000000000000000047089" data-uri="chapter12.xhtml#P7000497027000000000000000047089" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004708A" data-uri="chapter12.xhtml#P700049702700000000000000004708A" class="calibre3 pcalibre1 pcalibre2">strtok_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004708B" data-uri="chapter12.xhtml#P700049702700000000000000004708B" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004708C" data-uri="chapter12.xhtml#P700049702700000000000000004708C" class="calibre3 pcalibre1 pcalibre2">asctime</code></td>
<td id="P700049702700000000000000004708D" data-uri="chapter12.xhtml#P700049702700000000000000004708D" class="pcalibre1 pcalibre2 calibre7">3</td>
<td id="P700049702700000000000000004708E" data-uri="chapter12.xhtml#P700049702700000000000000004708E" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004708F" data-uri="chapter12.xhtml#P700049702700000000000000004708F" class="calibre3 pcalibre1 pcalibre2">asctime_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000047090" data-uri="chapter12.xhtml#P7000497027000000000000000047090" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000047091" data-uri="chapter12.xhtml#P7000497027000000000000000047091" class="calibre3 pcalibre1 pcalibre2">ctime</code></td>
<td id="P7000497027000000000000000047092" data-uri="chapter12.xhtml#P7000497027000000000000000047092" class="pcalibre1 pcalibre2 calibre7">3</td>
<td id="P7000497027000000000000000047093" data-uri="chapter12.xhtml#P7000497027000000000000000047093" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000047094" data-uri="chapter12.xhtml#P7000497027000000000000000047094" class="calibre3 pcalibre1 pcalibre2">ctime_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000047095" data-uri="chapter12.xhtml#P7000497027000000000000000047095" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000047096" data-uri="chapter12.xhtml#P7000497027000000000000000047096" class="calibre3 pcalibre1 pcalibre2">gethostbyaddr</code></td>
<td id="P7000497027000000000000000047097" data-uri="chapter12.xhtml#P7000497027000000000000000047097" class="pcalibre1 pcalibre2 calibre7">3</td>
<td id="P7000497027000000000000000047098" data-uri="chapter12.xhtml#P7000497027000000000000000047098" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000047099" data-uri="chapter12.xhtml#P7000497027000000000000000047099" class="calibre3 pcalibre1 pcalibre2">gethostbyaddr_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004709A" data-uri="chapter12.xhtml#P700049702700000000000000004709A" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004709B" data-uri="chapter12.xhtml#P700049702700000000000000004709B" class="calibre3 pcalibre1 pcalibre2">gethostbyname</code></td>
<td id="P700049702700000000000000004709C" data-uri="chapter12.xhtml#P700049702700000000000000004709C" class="pcalibre1 pcalibre2 calibre7">3</td>
<td id="P700049702700000000000000004709D" data-uri="chapter12.xhtml#P700049702700000000000000004709D" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004709E" data-uri="chapter12.xhtml#P700049702700000000000000004709E" class="calibre3 pcalibre1 pcalibre2">gethostbyname_r</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004709F" data-uri="chapter12.xhtml#P700049702700000000000000004709F" class="pcalibre1 pcalibre2 calibre7"><code id="P70004970270000000000000000470A0" data-uri="chapter12.xhtml#P70004970270000000000000000470A0" class="calibre3 pcalibre1 pcalibre2">inet_ntoa</code></td>
<td id="P70004970270000000000000000470A1" data-uri="chapter12.xhtml#P70004970270000000000000000470A1" class="pcalibre1 pcalibre2 calibre7">3</td>
<td id="P70004970270000000000000000470A2" data-uri="chapter12.xhtml#P70004970270000000000000000470A2" class="pcalibre1 pcalibre2 calibre7">(none)</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000470A3" data-uri="chapter12.xhtml#P70004970270000000000000000470A3" class="pcalibre1 pcalibre2 calibre7"><code id="P70004970270000000000000000470A4" data-uri="chapter12.xhtml#P70004970270000000000000000470A4" class="calibre3 pcalibre1 pcalibre2">localtime</code></td>
<td id="P70004970270000000000000000470A5" data-uri="chapter12.xhtml#P70004970270000000000000000470A5" class="pcalibre1 pcalibre2 calibre7">3</td>
<td id="P70004970270000000000000000470A6" data-uri="chapter12.xhtml#P70004970270000000000000000470A6" class="pcalibre1 pcalibre2 calibre7"><code id="P70004970270000000000000000470A7" data-uri="chapter12.xhtml#P70004970270000000000000000470A7" class="calibre3 pcalibre1 pcalibre2">localtime_r</code></td>
</tr>
</tbody>
</table>
<figcaption id="P70004970270000000000000000470A8" data-uri="chapter12.xhtml#P70004970270000000000000000470A8" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000470A9" data-uri="chapter12.xhtml#P70004970270000000000000000470A9" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.41 </span>Common thread-unsafe library functions.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000470AA" data-uri="chapter12.xhtml#P70004970270000000000000000470AA"><p id="P70004970270000000000000000470AB" data-uri="chapter12.xhtml#P70004970270000000000000000470AB" class="pcalibre1 pcalibre2 pcalibre10"></p></div></figcaption>
</figure>
<p id="P70004970270000000000000000470AC" data-uri="chapter12.xhtml#P70004970270000000000000000470AC" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000860C" title="1025" data-uri="chapter12.xhtml#P700049702700000000000000000860C" epub:type="pagebreak"></span>Therefore, Linux systems provide reentrant versions of most thread-unsafe functions. The names of the reentrant versions always end with the <code id="P70004970270000000000000000470AD" data-uri="chapter12.xhtml#P70004970270000000000000000470AD" class="pcalibre1 calibre1 pcalibre2">_r</code> suffix. For example, the reentrant version of <code id="P70004970270000000000000000470AE" data-uri="chapter12.xhtml#P70004970270000000000000000470AE" class="pcalibre1 calibre1 pcalibre2">asctime</code> is called <code id="P70004970270000000000000000470AF" data-uri="chapter12.xhtml#P70004970270000000000000000470AF" class="pcalibre1 calibre1 pcalibre2">asctime_r</code>. We recommend using these functions whenever possible.</p>
</section>
<section id="P7000497027000000000000000008610" data-uri="chapter12.xhtml#P7000497027000000000000000008610" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000470B0" data-uri="chapter12.xhtml#P70004970270000000000000000470B0" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.7.4 </span>Races</h1></header>
<p id="P70004970270000000000000000470B1" data-uri="chapter12.xhtml#P70004970270000000000000000470B1" class="pcalibre8 pcalibre1 pcalibre2">A <i class="pcalibre17 pcalibre2 pcalibre1">race</i> occurs when the correctness of a program depends on one thread reaching point <var class="pcalibre17 pcalibre2 pcalibre1">x</var> in its control flow before another thread reaches point <var class="pcalibre17 pcalibre2 pcalibre1">y</var>. Races usually occur because programmers assume that threads will take some particular trajectory through the execution state space, forgetting the golden rule that threaded programs must work correctly for any feasible trajectory.</p>
<p id="P70004970270000000000000000470B2" data-uri="chapter12.xhtml#P70004970270000000000000000470B2" class="pcalibre8 pcalibre1 pcalibre2">An example is the easiest way to understand the nature of races. Consider the simple program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008614"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.42</span></a>. The main thread creates four peer threads and passes a pointer to a unique integer ID to each one. Each peer thread copies the</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008614" data-uri="chapter12.xhtml#P7000497027000000000000000008614">
<p id="P70004970270000000000000000470B3" data-uri="chapter12.xhtml#P70004970270000000000000000470B3" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/race.c</i></p>
<pre id="P70004970270000000000000000470B4" data-uri="chapter12.xhtml#P70004970270000000000000000470B4" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000470B5" data-uri="chapter12.xhtml#P70004970270000000000000000470B5" class="calibre3 pcalibre1 pcalibre2">
1	/* WARNING: This code is buggy! */
2	#include "csapp.h"
3	#define N 4
4
5	void *thread(void *vargp);
6
7	int main()
8	{
9		pthread_t tid[N];
10		int i;
11
12		for (i = 0; i &lt; N; i++)
13			Pthread_create(&amp;tid[i], NULL, thread, &amp;i);
14		for (i = 0; i &lt; N; i++)
15			Pthread_join(tid[i], NULL);
16		exit(0);
17	}
18
19	/* Thread routine */
20	void *thread(void *vargp)
21	{
22		int myid = *((int *)vargp);
23		printf("Hello from thread %d\n", myid);
24		return NULL;
25	}
</code></pre>
<p id="P70004970270000000000000000470B6" data-uri="chapter12.xhtml#P70004970270000000000000000470B6" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/race.c</i></p>
<figcaption id="P70004970270000000000000000470B7" data-uri="chapter12.xhtml#P70004970270000000000000000470B7" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000470B8" data-uri="chapter12.xhtml#P70004970270000000000000000470B8" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.42 </span>program with a race.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000470B9" data-uri="chapter12.xhtml#P70004970270000000000000000470B9"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000861C" title="1026" data-uri="chapter12.xhtml#P700049702700000000000000000861C" epub:type="pagebreak"></span>ID passed in its argument to a local variable (line 22) and then prints a message containing the ID. It looks simple enough, but when we run this program on our system, we get the following incorrect result:</p>
<pre id="P70004970270000000000000000470BA" data-uri="chapter12.xhtml#P70004970270000000000000000470BA" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000470BB" data-uri="chapter12.xhtml#P70004970270000000000000000470BB" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./race</i>
Hello from thread 1
Hello from thread 3
Hello from thread 2
Hello from thread 3</code></pre>
<p id="P70004970270000000000000000470BC" data-uri="chapter12.xhtml#P70004970270000000000000000470BC" class="pcalibre8 pcalibre1 pcalibre2">The problem is caused by a race between each peer thread and the main thread. Can you spot the race? Here is what happens. When the main thread creates a peer thread in line 13, it passes a pointer to the local stack variable <var class="pcalibre17 pcalibre2 pcalibre1">i</var>. At this point, the race is on between the next increment of <code id="P70004970270000000000000000470BD" data-uri="chapter12.xhtml#P70004970270000000000000000470BD" class="pcalibre1 calibre1 pcalibre2">i</code> in line 12 and the dereferencing and assignment of the argument in line 22. If the peer thread executes line 22 before the main thread increments <code id="P70004970270000000000000000470BE" data-uri="chapter12.xhtml#P70004970270000000000000000470BE" class="pcalibre1 calibre1 pcalibre2">i</code> in line 12, then the <code id="P70004970270000000000000000470BF" data-uri="chapter12.xhtml#P70004970270000000000000000470BF" class="pcalibre1 calibre1 pcalibre2">myid</code> variable gets the correct ID. Otherwise, it will contain the ID of some other thread. The scary thing is that whether we get the correct answer depends on how the kernel schedules the execution of the threads. On our system it fails, but on other systems it might work correctly, leaving the programmer blissfully unaware of a serious bug.</p>
<p id="P70004970270000000000000000470C0" data-uri="chapter12.xhtml#P70004970270000000000000000470C0" class="pcalibre8 pcalibre1 pcalibre2">To eliminate the race, we can dynamically allocate a separate block for each integer ID and pass the thread routine a pointer to this block, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008638"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.43</span></a> (lines 12âˆ’14). Notice that the thread routine must free the block in order to avoid a memory leak.</p>
<p id="P70004970270000000000000000470C1" data-uri="chapter12.xhtml#P70004970270000000000000000470C1" class="pcalibre8 pcalibre1 pcalibre2">When we run this program on our system, we now get the correct result:</p>
<pre id="P70004970270000000000000000470C2" data-uri="chapter12.xhtml#P70004970270000000000000000470C2" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000470C3" data-uri="chapter12.xhtml#P70004970270000000000000000470C3" class="calibre3 pcalibre1 pcalibre2">linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">./norace</i>
Hello from thread 0
Hello from thread 1
Hello from thread 2
Hello from thread 3</code></pre>
<section id="P7000497027000000000000000008627" data-uri="chapter12.xhtml#P7000497027000000000000000008627" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000470C4" data-uri="chapter12.xhtml#P70004970270000000000000000470C4" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.13 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008837">1039</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000470C5" data-uri="chapter12.xhtml#P70004970270000000000000000470C5">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000470C6" data-uri="chapter12.xhtml#P70004970270000000000000000470C6">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000470C7" data-uri="chapter12.xhtml#P70004970270000000000000000470C7"><p id="P70004970270000000000000000470C8" data-uri="chapter12.xhtml#P70004970270000000000000000470C8" class="pcalibre1 pcalibre2 pcalibre10">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008638"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.43</span></a>, we might be tempted to free the allocated memory block immediately after line 14 in the main thread, instead of freeing it in the peer thread. But this would be a bad idea. Why?</p></div></li>
</ol>
</section>
<section id="P700049702700000000000000000862D" data-uri="chapter12.xhtml#P700049702700000000000000000862D" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000470C9" data-uri="chapter12.xhtml#P70004970270000000000000000470C9" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.14 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008837">1039</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre323" id="P70004970270000000000000000470CA" data-uri="chapter12.xhtml#P70004970270000000000000000470CA">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000470CB" data-uri="chapter12.xhtml#P70004970270000000000000000470CB">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000470CC" data-uri="chapter12.xhtml#P70004970270000000000000000470CC"><p id="P70004970270000000000000000470CD" data-uri="chapter12.xhtml#P70004970270000000000000000470CD" class="pcalibre1 pcalibre2 pcalibre10">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008638"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.43</span></a>, we eliminated the race by allocating a separate block for each integer ID. Outline a different approach that does not call the <code id="P70004970270000000000000000470CE" data-uri="chapter12.xhtml#P70004970270000000000000000470CE" class="pcalibre1 calibre1 pcalibre2">malloc</code> or <code id="P70004970270000000000000000470CF" data-uri="chapter12.xhtml#P70004970270000000000000000470CF" class="pcalibre1 calibre1 pcalibre2">free</code> functions.</p></div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000470D0" data-uri="chapter12.xhtml#P70004970270000000000000000470D0">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000470D1" data-uri="chapter12.xhtml#P70004970270000000000000000470D1"><p id="P70004970270000000000000000470D2" data-uri="chapter12.xhtml#P70004970270000000000000000470D2" class="pcalibre1 pcalibre2 pcalibre10">What are the advantages and disadvantages of this approach?</p></div></li>
</ol>
</section>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008638" data-uri="chapter12.xhtml#P7000497027000000000000000008638">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000008639" title="1027" data-uri="chapter12.xhtml#P7000497027000000000000000008639" epub:type="pagebreak"></span>
<p id="P70004970270000000000000000470D3" data-uri="chapter12.xhtml#P70004970270000000000000000470D3" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/norace.c</i></p>
<pre id="P70004970270000000000000000470D4" data-uri="chapter12.xhtml#P70004970270000000000000000470D4" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000470D5" data-uri="chapter12.xhtml#P70004970270000000000000000470D5" class="calibre3 pcalibre1 pcalibre2">
1	#include "csapp.h"
2	#define N 4
3
4	void *thread(void *vargp);
5
6	int main()
7	{
8		pthread_t tid[N];
9		int i, *ptr;
10
11		for (i = 0; i &lt; N; i++) {
12			ptr = Malloc(sizeof(int));
13			*ptr = i;
14			Pthread_create(&amp;tid[i], NULL, thread, ptr);
15		}
16		for (i = 0; i &lt; N; i++)
17			Pthread_join(tid[i], NULL);
18		exit(0);
19	}
20
21	/* Thread routine */
22	void *thread(void *vargp)
23	{
24		int myid = *((int *)vargp);
25		Free(vargp);
26		printf("Hello from thread %d\n", myid);
27		return NULL;
28	}
</code></pre>
<p id="P70004970270000000000000000470D6" data-uri="chapter12.xhtml#P70004970270000000000000000470D6" class="pcalibre8 pcalibre1 pcalibre2">-------------------------------------------<i class="pcalibre17 pcalibre2 pcalibre1">code/conc/norace.c</i></p>
<figcaption id="P70004970270000000000000000470D7" data-uri="chapter12.xhtml#P70004970270000000000000000470D7" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000470D8" data-uri="chapter12.xhtml#P70004970270000000000000000470D8" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.43 </span></h1></header>
<div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000470D9" data-uri="chapter12.xhtml#P70004970270000000000000000470D9"><p id="P70004970270000000000000000470DA" data-uri="chapter12.xhtml#P70004970270000000000000000470DA" class="pcalibre1 pcalibre2 pcalibre10">A correct version of the program in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008614"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.42</span></a> without a race.</p></div></figcaption>
</figure>
</section>
<section id="P7000497027000000000000000008642" data-uri="chapter12.xhtml#P7000497027000000000000000008642" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000470DB" data-uri="chapter12.xhtml#P70004970270000000000000000470DB" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">12.7.5 </span>Deadlocks</h1></header>
<p id="P70004970270000000000000000470DC" data-uri="chapter12.xhtml#P70004970270000000000000000470DC" class="pcalibre8 pcalibre1 pcalibre2">Semaphores introduce the potential for a nasty kind of run-time error, called <i class="pcalibre17 pcalibre2 pcalibre1">deadlock</i>, where a collection of threads is blocked, waiting for a condition that will never be true. The progress graph is an invaluable tool for understanding deadlock. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008648"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.44</span></a> shows the progress graph for a pair of threads that use two semaphores for mutual exclusion. From this graph, we can glean some important insights about deadlock:</p>
<ul id="P70004970270000000000000000470DD" data-uri="chapter12.xhtml#P70004970270000000000000000470DD" class="pcalibre1 calibre9 pcalibre2">
<li id="P70004970270000000000000000470DE" data-uri="chapter12.xhtml#P70004970270000000000000000470DE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000470DF" data-uri="chapter12.xhtml#P70004970270000000000000000470DF" class="pcalibre1 pcalibre2 pcalibre10">The programmer has incorrectly ordered the <var class="pcalibre17 pcalibre2 pcalibre1">P</var> and <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operations such that the forbidden regions for the two semaphores overlap. If some execution trajectory happens to reach the <i class="pcalibre17 pcalibre2 pcalibre1">deadlock state d</i>, then no further progress is</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008648" data-uri="chapter12.xhtml#P7000497027000000000000000008648">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000008649" title="1028" data-uri="chapter12.xhtml#P7000497027000000000000000008649" epub:type="pagebreak"></span>
<img alt="A graph shows trajectories and regions for a program that can deadlock." id="P70004970270000000000000000470E0" data-uri="P700049702700000000000000000B69C" src="../images/p1028-1.png" class="pcalibre1 pcalibre2 pcalibre324"/>
<figcaption id="P70004970270000000000000000470E1" data-uri="chapter12.xhtml#P70004970270000000000000000470E1" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000470E2" data-uri="chapter12.xhtml#P70004970270000000000000000470E2" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.44 </span>Progress graph for a program that can deadlock.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000027455" data-uri="chapter12.xhtml#P7000497027000000000000000027455">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000470E3" data-uri="chapter12.xhtml#P70004970270000000000000000470E3" class="pcalibre1 pcalibre2 pcalibre10">A graph of thread 2 versus thread 1 shows P(s), P(t), V(s), and V(t) on the thread 1 axis and P(t), P(s), V(t), and V(s) on the thread 2 axis (initially s = 1 and t = 1). Regions include a forbidden region for s (from P(s) to V(s) on each axis) and a forbidden region for t (from P(t) to V(t) on each axis). The deadlock state d extends from P(s) to P(t). A trajectory that does not deadlock extends vertical to P(s), right to P(s), up to V(s) and then right, outside the regions. A trajectory that deadlocks extends right to P(s), up to P(t), right to the end of P(s), up to the end of P(t), right to P(t), and up into the deadlock state.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000470E4" data-uri="chapter12.xhtml#P70004970270000000000000000470E4">possible because the overlapping forbidden regions block progress in every legal direction. In other words, the program is deadlocked because each thread is waiting for the other to do a <var class="pcalibre17 pcalibre2 pcalibre1">V</var> operation that will never occur.</p></li>
<li id="P70004970270000000000000000470E5" data-uri="chapter12.xhtml#P70004970270000000000000000470E5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000470E6" data-uri="chapter12.xhtml#P70004970270000000000000000470E6" class="pcalibre1 pcalibre2 pcalibre10">The overlapping forbidden regions induce a set of states called the <i class="pcalibre17 pcalibre2 pcalibre1">deadlock region</i>. If a trajectory happens to touch a state in the deadlock region, then deadlock is inevitable. Trajectories can enter deadlock regions, but they can never leave.</p></li>
<li id="P70004970270000000000000000470E7" data-uri="chapter12.xhtml#P70004970270000000000000000470E7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000470E8" data-uri="chapter12.xhtml#P70004970270000000000000000470E8" class="pcalibre1 pcalibre2 pcalibre10">Deadlock is an especially difficult issue because it is not always predictable. Some lucky execution trajectories will skirt the deadlock region, while others will be trapped by it. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008648"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.44</span></a> shows an example of each. The implications for a programmer are scary. You might run the same program a thousand times without any problem, but then the next time it deadlocks. Or the program might work fine on one machine but deadlock on another. Worst of all, the error is often not repeatable because different executions have different trajectories.</p></li>
</ul>
<p id="P70004970270000000000000000470E9" data-uri="chapter12.xhtml#P70004970270000000000000000470E9" class="pcalibre8 pcalibre1 pcalibre2">Programs deadlock for many reasons, and preventing them is a difficult problem in general. However, when binary semaphores are used for mutual exclusion, as in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008648"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.44</span></a>, then you can apply the following simple and effective rule to prevent deadlocks:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000008653" data-uri="chapter12.xhtml#P7000497027000000000000000008653">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000008654" title="1029" data-uri="chapter12.xhtml#P7000497027000000000000000008654" epub:type="pagebreak"></span>
<img alt="A graph shows regions for a dead-lock free program." id="P70004970270000000000000000470EA" data-uri="P700049702700000000000000000B69D" src="../images/p1029-1.png" class="pcalibre1 pcalibre325 pcalibre2"/>
<figcaption id="P70004970270000000000000000470EB" data-uri="chapter12.xhtml#P70004970270000000000000000470EB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000470EC" data-uri="chapter12.xhtml#P70004970270000000000000000470EC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">12.45 </span>Progress graph for a deadlock-free program.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000027460" data-uri="chapter12.xhtml#P7000497027000000000000000027460">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000470ED" data-uri="chapter12.xhtml#P70004970270000000000000000470ED" class="pcalibre1 pcalibre2 pcalibre10">A graph of thread 2 versus thread 1 shows P(s), P(t), V(s), and V(t) on the thread 1 axis and P(s), P(t), V(t), and V(s) on the thread 2 axis (initially s = 1 and t = 1). Regions include a forbidden region for s from P(s) to V(s) on each axis and a forbidden region for t from P(t) to V(t) on each axis.</p>
</details>
</figcaption>
</figure>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P70004970270000000000000000470EE" data-uri="chapter12.xhtml#P70004970270000000000000000470EE">
<li id="P70004970270000000000000000470EF" data-uri="chapter12.xhtml#P70004970270000000000000000470EF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000470F0" data-uri="chapter12.xhtml#P70004970270000000000000000470F0" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Mutex lock ordering rule: </span>Given a total ordering of all mutexes, a program is deadlock-free if each thread acquires its mutexes in order and releases them in reverse order.</p></li>
</ul>
<p id="P70004970270000000000000000470F1" data-uri="chapter12.xhtml#P70004970270000000000000000470F1" class="pcalibre8 pcalibre1 pcalibre2">For example, we can fix the deadlock in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008648"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.44</span></a> by locking <var class="pcalibre17 pcalibre2 pcalibre1">s</var> first, then <var class="pcalibre17 pcalibre2 pcalibre1">t</var>, in each thread. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000008653"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">12.45</span></a> shows the resulting progress graph.</p>
<section id="P700049702700000000000000000865C" data-uri="chapter12.xhtml#P700049702700000000000000000865C" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000470F2" data-uri="chapter12.xhtml#P70004970270000000000000000470F2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">12.15 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008837">1039</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000470F3" data-uri="chapter12.xhtml#P70004970270000000000000000470F3">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000470F4" data-uri="chapter12.xhtml#P70004970270000000000000000470F4">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000470F5" data-uri="chapter12.xhtml#P70004970270000000000000000470F5"><p id="P70004970270000000000000000470F6" data-uri="chapter12.xhtml#P70004970270000000000000000470F6" class="pcalibre1 pcalibre2 pcalibre10">Consider the following program, which attempts to use a pair of semaphores for mutual exclusion.</p>
<pre id="P70004970270000000000000000470F7" data-uri="chapter12.xhtml#P70004970270000000000000000470F7" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000470F8" data-uri="chapter12.xhtml#P70004970270000000000000000470F8" class="calibre3 pcalibre1 pcalibre2">Initially: s = 1, t = 0.</code></pre>
<pre id="P70004970270000000000000000470F9" data-uri="chapter12.xhtml#P70004970270000000000000000470F9" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000470FA" data-uri="chapter12.xhtml#P70004970270000000000000000470FA" class="calibre3 pcalibre1 pcalibre2">
      Thread 1:	      Thread 2:
	P(s);		P(s);
	V(s);		V(s);
	P(t);		P(t);
	V(t);		V(t);
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000470FB" data-uri="chapter12.xhtml#P70004970270000000000000000470FB">
<li id="P70004970270000000000000000470FC" data-uri="chapter12.xhtml#P70004970270000000000000000470FC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000470FD" data-uri="chapter12.xhtml#P70004970270000000000000000470FD" class="pcalibre1 pcalibre2 pcalibre10">Draw the progress graph for this program.</p></li>
<li id="P70004970270000000000000000470FE" data-uri="chapter12.xhtml#P70004970270000000000000000470FE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000470FF" data-uri="chapter12.xhtml#P70004970270000000000000000470FF" class="pcalibre1 pcalibre2 pcalibre10">Does it always deadlock?</p></li>
<li id="P7000497027000000000000000047100" data-uri="chapter12.xhtml#P7000497027000000000000000047100" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000047101" data-uri="chapter12.xhtml#P7000497027000000000000000047101" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000866D" title="1030" data-uri="chapter12.xhtml#P700049702700000000000000000866D" epub:type="pagebreak"></span>If so, what simple change to the initial semaphore values will eliminate the potential for deadlock?</p></li>
<li id="P7000497027000000000000000047102" data-uri="chapter12.xhtml#P7000497027000000000000000047102" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000047103" data-uri="chapter12.xhtml#P7000497027000000000000000047103" class="pcalibre1 pcalibre2 pcalibre10">Draw the progress graph for the resulting deadlock-free program.</p></li>
</ol></div></li>
</ol>
</section>
</section>
</section></body></html>
