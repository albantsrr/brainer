<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>1.3 It Pays to Understand How Compilation Systems Work</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P700049702700000000000000000010D" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000003E513" data-uri="chapter01.xhtml#P700049702700000000000000003E513" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">1.3 </span>It Pays to Understand How Compilation Systems Work</h1></header>
<p id="P700049702700000000000000003E514" data-uri="chapter01.xhtml#P700049702700000000000000003E514" class="pcalibre8 pcalibre1 pcalibre2">For simple programs such as <code id="P700049702700000000000000003E515" data-uri="chapter01.xhtml#P700049702700000000000000003E515" class="pcalibre1 calibre1 pcalibre2">hello.c</code>, we can rely on the compilation system to produce correct and efficient machine code. However, there are some important reasons why programmers need to understand how compilation systems work:</p>
<ul id="P700049702700000000000000003E516" data-uri="chapter01.xhtml#P700049702700000000000000003E516" class="pcalibre1 calibre9 pcalibre2">
<li id="P700049702700000000000000003E517" data-uri="chapter01.xhtml#P700049702700000000000000003E517" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000003E518" data-uri="chapter01.xhtml#P700049702700000000000000003E518" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Optimizing program performance. </span>Modern compilers are sophisticated tools that usually produce good code. As programmers, we do not need to know the inner workings of the compiler in order to write efficient code. However, in order to make good coding decisions in our C programs, we do need a basic understanding of machine-level code and how the compiler translates different C statements into machine code. For example, is a <code id="P700049702700000000000000003E519" data-uri="chapter01.xhtml#P700049702700000000000000003E519" class="pcalibre1 calibre1 pcalibre2">switch</code> statement always more efficient than a sequence of <code id="P700049702700000000000000003E51A" data-uri="chapter01.xhtml#P700049702700000000000000003E51A" class="pcalibre1 calibre1 pcalibre2">if-else</code> statements? How much overhead is incurred by a function call? Is a <code id="P700049702700000000000000003E51B" data-uri="chapter01.xhtml#P700049702700000000000000003E51B" class="pcalibre1 calibre1 pcalibre2">while</code> loop more efficient than a <code id="P700049702700000000000000003E51C" data-uri="chapter01.xhtml#P700049702700000000000000003E51C" class="pcalibre1 calibre1 pcalibre2">for</code> loop? Are pointer references more efficient than array indexes? Why does our loop run so much faster if we sum into a local variable instead of an argument that is passed by reference? How can a function run faster when we simply rearrange the parentheses in an arithmetic expression?</p>
<p id="P700049702700000000000000003E51D" data-uri="chapter01.xhtml#P700049702700000000000000003E51D" class="pcalibre1 pcalibre2 pcalibre63"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000000119" title="7" data-uri="chapter01.xhtml#P7000497027000000000000000000119" epub:type="pagebreak"></span>In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001DCE.xhtml#P7000497027000000000000000001DCE"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">3</span></a>, we introduce x86-64, the machine language of recent generations of Linux, Macintosh, and Windows computers. We describe how compilers translate different C constructs into this language. In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004893.xhtml#P7000497027000000000000000004893"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">5</span></a>, you will learn how to tune the performance of your C programs by making simple transformations to the C code that help the compiler do its job better. In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000005190.xhtml#P7000497027000000000000000005190"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">6</span></a>, you will learn about the hierarchical nature of the memory system, how C compilers store data arrays in memory, and how your C programs can exploit this knowledge to run more efficiently.</p></li>
<li id="P700049702700000000000000003E51E" data-uri="chapter01.xhtml#P700049702700000000000000003E51E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000003E51F" data-uri="chapter01.xhtml#P700049702700000000000000003E51F" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Understanding link-time errors. </span>In our experience, some of the most perplexing programming errors are related to the operation of the linker, especially when you are trying to build large software systems. For example, what does it mean when the linker reports that it cannot resolve a reference? What is the difference between a static variable and a global variable? What happens if you define two global variables in different C files with the same name? What is the difference between a static library and a dynamic library? Why does it matter what order we list libraries on the command line? And scariest of all, why do some linker-related errors not appear until run time? You will learn the answers to these kinds of questions in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000005FB4.xhtml#P7000497027000000000000000005FB4"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">7</span></a>.</p></li>
<li id="P700049702700000000000000003E520" data-uri="chapter01.xhtml#P700049702700000000000000003E520" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000003E521" data-uri="chapter01.xhtml#P700049702700000000000000003E521" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Avoiding security holes. </span>For many years, <i class="pcalibre17 pcalibre2 pcalibre1">buffer overflow vulnerabilities</i> have accounted for many of the security holes in network and Internet servers. These vulnerabilities exist because too few programmers understand the need to carefully restrict the quantity and forms of data they accept from untrusted sources. A first step in learning secure programming is to understand the consequences of the way data and control information are stored on the program stack. We cover the stack discipline and buffer overflow vulnerabilities in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001DCE.xhtml#P7000497027000000000000000001DCE"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">3</span></a> as part of our study of assembly language. We will also learn about methods that can be used by the programmer, compiler, and operating system to reduce the threat of attack.</p></li>
</ul>
</section></body></html>
