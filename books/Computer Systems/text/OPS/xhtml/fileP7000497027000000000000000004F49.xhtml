<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.12 Understanding Memory Performance</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000004F49" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P70004970270000000000000000436AF" data-uri="chapter05.xhtml#P70004970270000000000000000436AF" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.12 </span>Understanding Memory Performance</h1></header>
<p id="P70004970270000000000000000436B0" data-uri="chapter05.xhtml#P70004970270000000000000000436B0" class="pcalibre8 pcalibre1 pcalibre2">All of the code we have written thus far, and all the tests we have run, access relatively small amounts of memory. For example, the combining routines were measured over vectors of length less than 1,000 elements, requiring no more than 8,000 bytes of data. All modern processors contain one or more <i class="pcalibre17 pcalibre2 pcalibre1">cache</i> memories to provide fast access to such small amounts of memory. In this section, we will further investigate the performance of programs that involve load (reading from memory into registers) and store (writing from registers to memory) operations, considering only the cases where all data are held in cache. In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000005190.xhtml#P7000497027000000000000000005190"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">6</span></a>, we go into much more detail about how caches work, their performance characteristics, and how to write code that makes best use of caches.</p>
<p id="P70004970270000000000000000436B1" data-uri="chapter05.xhtml#P70004970270000000000000000436B1" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004F4D" title="554" data-uri="chapter05.xhtml#P7000497027000000000000000004F4D" epub:type="pagebreak"></span>As <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004B76"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.11</span></a> shows, modern processors have dedicated functional units to perform load and store operations, and these units have internal buffers to hold sets of outstanding requests for memory operations. For example, our reference machine has two load units, each of which can holdup to 72 pending read requests. It has a single store unit with a store buffer containing up to 42 write requests. Each of these units can initiate 1 operation every clock cycle.</p>
<section id="P7000497027000000000000000004F4E" data-uri="chapter05.xhtml#P7000497027000000000000000004F4E" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000436B2" data-uri="chapter05.xhtml#P70004970270000000000000000436B2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.12.1 </span>Load Performance</h1></header>
<p id="P70004970270000000000000000436B3" data-uri="chapter05.xhtml#P70004970270000000000000000436B3" class="pcalibre8 pcalibre1 pcalibre2">The performance of a program containing load operations depends on both the pipelining capability and the latency of the load unit. In our experiments with combining operations using our reference machine, we saw that the CPE never got below 0.50 for any combination of data type and combining operation, except when using SIMD operations. One factor limiting the CPE for our examples is that they all require reading one value from memory for each element computed. With two load units, each able to initiate at most 1 load operation every clock cycle, the CPE cannot be less than 0.50. For applications where we must load <var class="pcalibre17 pcalibre2 pcalibre1">k</var> values for every element computed, we can never achieve a CPE lower than <var class="pcalibre17 pcalibre2 pcalibre1">k</var>/2 (see, for example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000005090.xhtml#P70004970270000000000000000050AF"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15</span></a>).</p>
<p id="P70004970270000000000000000436B4" data-uri="chapter05.xhtml#P70004970270000000000000000436B4" class="pcalibre8 pcalibre1 pcalibre2">In our examples so far, we have not seen any performance effects due to the latency of load operations. The addresses for our load operations depended only on the loop index <var class="pcalibre17 pcalibre2 pcalibre1">i</var>, and so the load operations did not form part of a performance-limiting critical path.</p>
<p id="P70004970270000000000000000436B5" data-uri="chapter05.xhtml#P70004970270000000000000000436B5" class="pcalibre8 pcalibre1 pcalibre2">To determine the latency of the load operation on a machine, we can set up a computation with a sequence of load operations, where the outcome of one determines the address for the next. As an example, consider the function <code id="P70004970270000000000000000436B6" data-uri="chapter05.xhtml#P70004970270000000000000000436B6" class="pcalibre1 calibre1 pcalibre2">list_len</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F57"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.31</span></a>, which computes the length of a linked list. In the loop of this function, each successive value of variable <code id="P70004970270000000000000000436B7" data-uri="chapter05.xhtml#P70004970270000000000000000436B7" class="pcalibre1 calibre1 pcalibre2">ls</code> depends on the value read by the pointer reference <code id="P70004970270000000000000000436B8" data-uri="chapter05.xhtml#P70004970270000000000000000436B8" class="pcalibre1 calibre1 pcalibre2">ls-&gt;next</code>. Our measurements show that function <code id="P70004970270000000000000000436B9" data-uri="chapter05.xhtml#P70004970270000000000000000436B9" class="pcalibre1 calibre1 pcalibre2">list_len</code> has</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004F57" data-uri="chapter05.xhtml#P7000497027000000000000000004F57">

<pre id="P70004970270000000000000000436BA" data-uri="chapter05.xhtml#P70004970270000000000000000436BA" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000436BB" data-uri="chapter05.xhtml#P70004970270000000000000000436BB" class="calibre3 pcalibre1 pcalibre2">
1	typedef struct ELE {
2		struct ELE *next;
3		long data;
4	} list_ele, *list_ptr; 5
6	long list_len(list_ptr ls) {
7		long len = 0;
8		while (ls) {
9			len++;
10			ls = ls-&gt;next;
11		}
12		return len;
13	}
</code></pre>
<figcaption id="P70004970270000000000000000436BC" data-uri="chapter05.xhtml#P70004970270000000000000000436BC" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000436BD" data-uri="chapter05.xhtml#P70004970270000000000000000436BD" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.31 </span>Linked list function.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000436BE" data-uri="chapter05.xhtml#P70004970270000000000000000436BE"><p id="P70004970270000000000000000436BF" data-uri="chapter05.xhtml#P70004970270000000000000000436BF" class="pcalibre1 pcalibre2 pcalibre10">Its performance is limited by the latency of the load operation.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000436C0" data-uri="chapter05.xhtml#P70004970270000000000000000436C0"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004F5F" title="555" data-uri="chapter05.xhtml#P7000497027000000000000000004F5F" epub:type="pagebreak"></span>a CPE of 4.00, which we claim is a direct indication of the latency of the load operation. To see this, consider the assembly code for the loop:</p>
<pre id="P70004970270000000000000000436C1" data-uri="chapter05.xhtml#P70004970270000000000000000436C1" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000436C2" data-uri="chapter05.xhtml#P70004970270000000000000000436C2" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of list_len</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">ls in %rdi, len in %rax</i>
1	.L3:			<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	 addq $1, %rax		  <i class="pcalibre17 pcalibre2 pcalibre1">Increment len</i>
3	 movq (%rdi), %rdi	  <i class="pcalibre17 pcalibre2 pcalibre1">ls = ls-&gt;next</i>
4	 testq %rdi, %rdi	  <i class="pcalibre17 pcalibre2 pcalibre1">Test ls</i>
5	 jne .L3		  <i class="pcalibre17 pcalibre2 pcalibre1">If nonnull, goto</i> loop
</code></pre>
<p id="P70004970270000000000000000436C3" data-uri="chapter05.xhtml#P70004970270000000000000000436C3" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P70004970270000000000000000436C4" data-uri="chapter05.xhtml#P70004970270000000000000000436C4" class="pcalibre1 calibre1 pcalibre2">movq</code> instruction on line 3 forms the critical bottleneck in this loop. Each successive value of register <code id="P70004970270000000000000000436C5" data-uri="chapter05.xhtml#P70004970270000000000000000436C5" class="pcalibre1 calibre1 pcalibre2">%rdi</code> depends on the result of a load operation having the value in <code id="P70004970270000000000000000436C6" data-uri="chapter05.xhtml#P70004970270000000000000000436C6" class="pcalibre1 calibre1 pcalibre2">%rdi</code> as its address. Thus, the load operation for one iteration cannot begin until the one for the previous iteration has completed. The CPE of 4.00 for this function is determined by the latency of the load operation. Indeed, this measurement matches the documented access time of 4 cycles for the reference machine's L1 cache, as is discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000556F.xhtml#P700049702700000000000000000556F"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">6.4</span></a>.</p>
</section>
<section id="P7000497027000000000000000004F66" data-uri="chapter05.xhtml#P7000497027000000000000000004F66" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000436C7" data-uri="chapter05.xhtml#P70004970270000000000000000436C7" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.12.2 </span>Store Performance</h1></header>
<p id="P70004970270000000000000000436C8" data-uri="chapter05.xhtml#P70004970270000000000000000436C8" class="pcalibre8 pcalibre1 pcalibre2">In all of our examples thus far, we analyzed only functions that reference memory mostly with load operations, reading from a memory location into a register. Its counterpart, the <i class="pcalibre17 pcalibre2 pcalibre1">store</i> operation, writes a register value to memory. The performance of this operation, particularly in relation to its interactions with load operations, involves several subtle issues.</p>
<p id="P70004970270000000000000000436C9" data-uri="chapter05.xhtml#P70004970270000000000000000436C9" class="pcalibre8 pcalibre1 pcalibre2">As with the load operation, in most cases, the store operation can operate in a fully pipelined mode, beginning a new store on every cycle. For example, consider the function shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F6E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.32</span></a> that sets the elements of an array <code id="P70004970270000000000000000436CA" data-uri="chapter05.xhtml#P70004970270000000000000000436CA" class="pcalibre1 calibre1 pcalibre2">dest</code> of length <code id="P70004970270000000000000000436CB" data-uri="chapter05.xhtml#P70004970270000000000000000436CB" class="pcalibre1 calibre1 pcalibre2">n</code> to zero. Our measurements show a CPE of 1.0. This is the best we can achieve on a machine with a single store functional unit.</p>
<p id="P70004970270000000000000000436CC" data-uri="chapter05.xhtml#P70004970270000000000000000436CC" class="pcalibre8 pcalibre1 pcalibre2">Unlike the other operations we have considered so far, the store operation does not affect any register values. Thus, by their very nature, a series of store operations cannot create a data dependency. Only a load operation is affected by the result of a store operation, since only a load can read back the memory value that has been written by the store. The function <code id="P70004970270000000000000000436CD" data-uri="chapter05.xhtml#P70004970270000000000000000436CD" class="pcalibre1 calibre1 pcalibre2">write_read</code> shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.33</span></a></p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004F6E" data-uri="chapter05.xhtml#P7000497027000000000000000004F6E">

<pre id="P70004970270000000000000000436CE" data-uri="chapter05.xhtml#P70004970270000000000000000436CE" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000436CF" data-uri="chapter05.xhtml#P70004970270000000000000000436CF" class="calibre3 pcalibre1 pcalibre2">
1	/* Set elements of array to 0 */
2	void clear_array(long *dest, long n) {
3		long i;
4		for (i = 0; i &lt; n; i++)
5			dest[i] = 0;
6	}
</code></pre>
<figcaption id="P70004970270000000000000000436D0" data-uri="chapter05.xhtml#P70004970270000000000000000436D0" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000436D1" data-uri="chapter05.xhtml#P70004970270000000000000000436D1" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.32 </span>Function to set array elements to 0.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000436D2" data-uri="chapter05.xhtml#P70004970270000000000000000436D2"><p id="P70004970270000000000000000436D3" data-uri="chapter05.xhtml#P70004970270000000000000000436D3" class="pcalibre1 pcalibre2 pcalibre10">This code achieves a CPE of 1.0.</p></div></figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004F75" data-uri="chapter05.xhtml#P7000497027000000000000000004F75">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004F76" title="556" data-uri="chapter05.xhtml#P7000497027000000000000000004F76" epub:type="pagebreak"></span>
<pre id="P70004970270000000000000000436D4" data-uri="chapter05.xhtml#P70004970270000000000000000436D4" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000436D5" data-uri="chapter05.xhtml#P70004970270000000000000000436D5" class="calibre3 pcalibre1 pcalibre2">
1	/* Write to dest, read from src */
2	void write_read(long *src, long *dst, long n)
3	{
4		long cnt = n;
5		long val = 0; 6
7		while (cnt) {
8			*dst = val;
9			val = (*src)+1;
10			cnt−;
11		}
12	}
</code></pre>
<img alt="A diagram includes a code and illustrations of two executions." id="P70004970270000000000000000436D6" data-uri="P700049702700000000000000000B722" src="../images/p556-1.png" class="pcalibre1 pcalibre202 pcalibre2"/>
<figcaption id="P70004970270000000000000000436D7" data-uri="chapter05.xhtml#P70004970270000000000000000436D7" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000436D8" data-uri="chapter05.xhtml#P70004970270000000000000000436D8" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.33 </span>Code to write and read memory locations, along with illustrative executions.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000436D9" data-uri="chapter05.xhtml#P70004970270000000000000000436D9"><p id="P70004970270000000000000000436DA" data-uri="chapter05.xhtml#P70004970270000000000000000436DA" class="pcalibre1 pcalibre2 pcalibre10">This function highlights the interactions between stores and loads when arguments <code id="P70004970270000000000000000436DB" data-uri="chapter05.xhtml#P70004970270000000000000000436DB" class="pcalibre1 calibre1 pcalibre2">src</code> and <code id="P70004970270000000000000000436DC" data-uri="chapter05.xhtml#P70004970270000000000000000436DC" class="pcalibre1 calibre1 pcalibre2">dest</code> are equal.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000239C8" data-uri="chapter05.xhtml#P70004970270000000000000000239C8">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000436DD" data-uri="chapter05.xhtml#P70004970270000000000000000436DD" class="pcalibre8 pcalibre1 pcalibre2">The lines of the code are reproduced below.</p>
<ol id="P70004970270000000000000000436DE" data-uri="chapter05.xhtml#P70004970270000000000000000436DE" class="pcalibre1 calibre19 pcalibre2">
<li id="P70004970270000000000000000436DF" data-uri="chapter05.xhtml#P70004970270000000000000000436DF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436E0" data-uri="chapter05.xhtml#P70004970270000000000000000436E0" class="pcalibre1 pcalibre2 pcalibre10">/* Write to dest, read from src */</p></li>
<li id="P70004970270000000000000000436E1" data-uri="chapter05.xhtml#P70004970270000000000000000436E1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436E2" data-uri="chapter05.xhtml#P70004970270000000000000000436E2" class="pcalibre1 pcalibre2 pcalibre10">void write_read(long *src, long *dst, long n)</p></li>
<li id="P70004970270000000000000000436E3" data-uri="chapter05.xhtml#P70004970270000000000000000436E3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436E4" data-uri="chapter05.xhtml#P70004970270000000000000000436E4" class="pcalibre1 pcalibre2 pcalibre10">{</p></li>
<li id="P70004970270000000000000000436E5" data-uri="chapter05.xhtml#P70004970270000000000000000436E5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436E6" data-uri="chapter05.xhtml#P70004970270000000000000000436E6" class="pcalibre1 pcalibre2 pcalibre10">long cnt = n;</p></li>
<li id="P70004970270000000000000000436E7" data-uri="chapter05.xhtml#P70004970270000000000000000436E7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436E8" data-uri="chapter05.xhtml#P70004970270000000000000000436E8" class="pcalibre1 pcalibre2 pcalibre10">long val = 0;</p></li>
<li id="P70004970270000000000000000436E9" data-uri="chapter05.xhtml#P70004970270000000000000000436E9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436EA" data-uri="chapter05.xhtml#P70004970270000000000000000436EA" class="pcalibre1 pcalibre2 pcalibre10">(blank)</p></li>
<li id="P70004970270000000000000000436EB" data-uri="chapter05.xhtml#P70004970270000000000000000436EB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436EC" data-uri="chapter05.xhtml#P70004970270000000000000000436EC" class="pcalibre1 pcalibre2 pcalibre10">while (cnt) {</p></li>
<li id="P70004970270000000000000000436ED" data-uri="chapter05.xhtml#P70004970270000000000000000436ED" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436EE" data-uri="chapter05.xhtml#P70004970270000000000000000436EE" class="pcalibre1 pcalibre2 pcalibre10"> *dst = val;</p></li>
<li id="P70004970270000000000000000436EF" data-uri="chapter05.xhtml#P70004970270000000000000000436EF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436F0" data-uri="chapter05.xhtml#P70004970270000000000000000436F0" class="pcalibre1 pcalibre2 pcalibre10"> val = (*src)+1;</p></li>
<li id="P70004970270000000000000000436F1" data-uri="chapter05.xhtml#P70004970270000000000000000436F1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436F2" data-uri="chapter05.xhtml#P70004970270000000000000000436F2" class="pcalibre1 pcalibre2 pcalibre10"> cnt–;</p></li>
<li id="P70004970270000000000000000436F3" data-uri="chapter05.xhtml#P70004970270000000000000000436F3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436F4" data-uri="chapter05.xhtml#P70004970270000000000000000436F4" class="pcalibre1 pcalibre2 pcalibre10"> }</p></li>
<li id="P70004970270000000000000000436F5" data-uri="chapter05.xhtml#P70004970270000000000000000436F5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000436F6" data-uri="chapter05.xhtml#P70004970270000000000000000436F6" class="pcalibre1 pcalibre2 pcalibre10">}</p></li>
</ol>
<p id="P70004970270000000000000000436F7" data-uri="chapter05.xhtml#P70004970270000000000000000436F7" class="pcalibre8 pcalibre1 pcalibre2">The two execution illustrations are arranged per the following tables.</p>
<table id="P70004970270000000000000000436F8" data-uri="chapter05.xhtml#P70004970270000000000000000436F8" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th colspan="5" id="P70004970270000000000000000436F9" data-uri="chapter05.xhtml#P70004970270000000000000000436F9" class="pcalibre1 pcalibre2 calibre5">Example A: write_read(&amp;a[0], &amp;a[1], 3)</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P70004970270000000000000000436FA" data-uri="chapter05.xhtml#P70004970270000000000000000436FA" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P70004970270000000000000000436FB" data-uri="chapter05.xhtml#P70004970270000000000000000436FB" class="pcalibre1 pcalibre2 calibre5">Initial</th>
<th id="P70004970270000000000000000436FC" data-uri="chapter05.xhtml#P70004970270000000000000000436FC" class="pcalibre1 pcalibre2 calibre5">Iter. 1</th>
<th id="P70004970270000000000000000436FD" data-uri="chapter05.xhtml#P70004970270000000000000000436FD" class="pcalibre1 pcalibre2 calibre5">Iter. 2</th>
<th id="P70004970270000000000000000436FE" data-uri="chapter05.xhtml#P70004970270000000000000000436FE" class="pcalibre1 pcalibre2 calibre5">Iter. 3</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000436FF" data-uri="chapter05.xhtml#P70004970270000000000000000436FF" class="pcalibre1 pcalibre2 calibre7">cnt</td>
<td id="P7000497027000000000000000043700" data-uri="chapter05.xhtml#P7000497027000000000000000043700" class="pcalibre1 pcalibre2 calibre7">3</td>
<td id="P7000497027000000000000000043701" data-uri="chapter05.xhtml#P7000497027000000000000000043701" class="pcalibre1 pcalibre2 calibre7">2</td>
<td id="P7000497027000000000000000043702" data-uri="chapter05.xhtml#P7000497027000000000000000043702" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P7000497027000000000000000043703" data-uri="chapter05.xhtml#P7000497027000000000000000043703" class="pcalibre1 pcalibre2 calibre7">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043704" data-uri="chapter05.xhtml#P7000497027000000000000000043704" class="pcalibre1 pcalibre2 calibre7">a</td>
<td id="P7000497027000000000000000043705" data-uri="chapter05.xhtml#P7000497027000000000000000043705" class="pcalibre1 pcalibre2 calibre7">Negative 10 and 17</td>
<td id="P7000497027000000000000000043706" data-uri="chapter05.xhtml#P7000497027000000000000000043706" class="pcalibre1 pcalibre2 calibre7">Negative 10 and 2</td>
<td id="P7000497027000000000000000043707" data-uri="chapter05.xhtml#P7000497027000000000000000043707" class="pcalibre1 pcalibre2 calibre7">Negative 10 and negative 9</td>
<td id="P7000497027000000000000000043708" data-uri="chapter05.xhtml#P7000497027000000000000000043708" class="pcalibre1 pcalibre2 calibre7">Negative 10 and negative 9</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043709" data-uri="chapter05.xhtml#P7000497027000000000000000043709" class="pcalibre1 pcalibre2 calibre7">val</td>
<td id="P700049702700000000000000004370A" data-uri="chapter05.xhtml#P700049702700000000000000004370A" class="pcalibre1 pcalibre2 calibre7">0</td>
<td id="P700049702700000000000000004370B" data-uri="chapter05.xhtml#P700049702700000000000000004370B" class="pcalibre1 pcalibre2 calibre7">Negative 9</td>
<td id="P700049702700000000000000004370C" data-uri="chapter05.xhtml#P700049702700000000000000004370C" class="pcalibre1 pcalibre2 calibre7">Negative 9</td>
<td id="P700049702700000000000000004370D" data-uri="chapter05.xhtml#P700049702700000000000000004370D" class="pcalibre1 pcalibre2 calibre7">Negative 9</td>
</tr>
</tbody>
</table>
<table id="P700049702700000000000000004370E" data-uri="chapter05.xhtml#P700049702700000000000000004370E" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th colspan="5" id="P700049702700000000000000004370F" data-uri="chapter05.xhtml#P700049702700000000000000004370F" class="pcalibre1 pcalibre2 calibre5">Example B: write_read(&amp;a[0], &amp;a[0], 3)</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043710" data-uri="chapter05.xhtml#P7000497027000000000000000043710" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P7000497027000000000000000043711" data-uri="chapter05.xhtml#P7000497027000000000000000043711" class="pcalibre1 pcalibre2 calibre5">Initial</th>
<th id="P7000497027000000000000000043712" data-uri="chapter05.xhtml#P7000497027000000000000000043712" class="pcalibre1 pcalibre2 calibre5">Iter. 1</th>
<th id="P7000497027000000000000000043713" data-uri="chapter05.xhtml#P7000497027000000000000000043713" class="pcalibre1 pcalibre2 calibre5">Iter. 2</th>
<th id="P7000497027000000000000000043714" data-uri="chapter05.xhtml#P7000497027000000000000000043714" class="pcalibre1 pcalibre2 calibre5">Iter. 3</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043715" data-uri="chapter05.xhtml#P7000497027000000000000000043715" class="pcalibre1 pcalibre2 calibre7">cnt</td>
<td id="P7000497027000000000000000043716" data-uri="chapter05.xhtml#P7000497027000000000000000043716" class="pcalibre1 pcalibre2 calibre7">3</td>
<td id="P7000497027000000000000000043717" data-uri="chapter05.xhtml#P7000497027000000000000000043717" class="pcalibre1 pcalibre2 calibre7">2</td>
<td id="P7000497027000000000000000043718" data-uri="chapter05.xhtml#P7000497027000000000000000043718" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P7000497027000000000000000043719" data-uri="chapter05.xhtml#P7000497027000000000000000043719" class="pcalibre1 pcalibre2 calibre7">0</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004371A" data-uri="chapter05.xhtml#P700049702700000000000000004371A" class="pcalibre1 pcalibre2 calibre7">a</td>
<td id="P700049702700000000000000004371B" data-uri="chapter05.xhtml#P700049702700000000000000004371B" class="pcalibre1 pcalibre2 calibre7">Negative 10 and 17</td>
<td id="P700049702700000000000000004371C" data-uri="chapter05.xhtml#P700049702700000000000000004371C" class="pcalibre1 pcalibre2 calibre7">Negative 0 and 17</td>
<td id="P700049702700000000000000004371D" data-uri="chapter05.xhtml#P700049702700000000000000004371D" class="pcalibre1 pcalibre2 calibre7">1 and 17</td>
<td id="P700049702700000000000000004371E" data-uri="chapter05.xhtml#P700049702700000000000000004371E" class="pcalibre1 pcalibre2 calibre7">2 and 17</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004371F" data-uri="chapter05.xhtml#P700049702700000000000000004371F" class="pcalibre1 pcalibre2 calibre7">val</td>
<td id="P7000497027000000000000000043720" data-uri="chapter05.xhtml#P7000497027000000000000000043720" class="pcalibre1 pcalibre2 calibre7">0</td>
<td id="P7000497027000000000000000043721" data-uri="chapter05.xhtml#P7000497027000000000000000043721" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P7000497027000000000000000043722" data-uri="chapter05.xhtml#P7000497027000000000000000043722" class="pcalibre1 pcalibre2 calibre7">2</td>
<td id="P7000497027000000000000000043723" data-uri="chapter05.xhtml#P7000497027000000000000000043723" class="pcalibre1 pcalibre2 calibre7">3</td>
</tr>
</tbody>
</table>
</details>

</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043724" data-uri="chapter05.xhtml#P7000497027000000000000000043724">illustrates the potential interactions between loads and stores. This figure also shows two example executions of this function, when it is called for a two-element array a, with initial contents −10 and 17, and with argument <code id="P7000497027000000000000000043725" data-uri="chapter05.xhtml#P7000497027000000000000000043725" class="pcalibre1 calibre1 pcalibre2">cnt</code> equal to 3. These executions illustrate some subtleties of the load and store operations.</p>
<p id="P7000497027000000000000000043726" data-uri="chapter05.xhtml#P7000497027000000000000000043726" class="pcalibre8 pcalibre1 pcalibre2">In Example A of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.33</span></a>, argument <code id="P7000497027000000000000000043727" data-uri="chapter05.xhtml#P7000497027000000000000000043727" class="pcalibre1 calibre1 pcalibre2">src</code> is a pointer to array element <code id="P7000497027000000000000000043728" data-uri="chapter05.xhtml#P7000497027000000000000000043728" class="pcalibre1 calibre1 pcalibre2">a[0]</code>, while <code id="P7000497027000000000000000043729" data-uri="chapter05.xhtml#P7000497027000000000000000043729" class="pcalibre1 calibre1 pcalibre2">dest</code> is a pointer to array element <code id="P700049702700000000000000004372A" data-uri="chapter05.xhtml#P700049702700000000000000004372A" class="pcalibre1 calibre1 pcalibre2">a[1]</code>. In this case, each load by the pointer reference <code id="P700049702700000000000000004372B" data-uri="chapter05.xhtml#P700049702700000000000000004372B" class="pcalibre1 calibre1 pcalibre2">*src</code> will yield the value −10. Hence, after two iterations, the array elements will remain fixed at −10 and −9, respectively. The result of the read from <code id="P700049702700000000000000004372C" data-uri="chapter05.xhtml#P700049702700000000000000004372C" class="pcalibre1 calibre1 pcalibre2">src</code> is not affected by the write to <code id="P700049702700000000000000004372D" data-uri="chapter05.xhtml#P700049702700000000000000004372D" class="pcalibre1 calibre1 pcalibre2">dest</code>. Measuring this example over a larger number of iterations gives a CPE of 1.3.</p>
<p id="P700049702700000000000000004372E" data-uri="chapter05.xhtml#P700049702700000000000000004372E" class="pcalibre8 pcalibre1 pcalibre2">In Example B of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.33</span></a>, both arguments <code id="P700049702700000000000000004372F" data-uri="chapter05.xhtml#P700049702700000000000000004372F" class="pcalibre1 calibre1 pcalibre2">src</code> and <code id="P7000497027000000000000000043730" data-uri="chapter05.xhtml#P7000497027000000000000000043730" class="pcalibre1 calibre1 pcalibre2">dest</code> are pointers to array element <code id="P7000497027000000000000000043731" data-uri="chapter05.xhtml#P7000497027000000000000000043731" class="pcalibre1 calibre1 pcalibre2">a[0]</code>. In this case, each load by the pointer reference <code id="P7000497027000000000000000043732" data-uri="chapter05.xhtml#P7000497027000000000000000043732" class="pcalibre1 calibre1 pcalibre2">*src</code> will yield the value stored by the previous execution of the pointer reference <code id="P7000497027000000000000000043733" data-uri="chapter05.xhtml#P7000497027000000000000000043733" class="pcalibre1 calibre1 pcalibre2">*dest</code>.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004F90" data-uri="chapter05.xhtml#P7000497027000000000000000004F90">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004F91" title="557" data-uri="chapter05.xhtml#P7000497027000000000000000004F91" epub:type="pagebreak"></span>
<img alt="A diagram depicts interactions between load unit, store unit, and data cache." id="P7000497027000000000000000043734" data-uri="P700049702700000000000000000B723" src="../images/p557-1.png" class="pcalibre1 pcalibre2 pcalibre203"/>
<figcaption id="P7000497027000000000000000043735" data-uri="chapter05.xhtml#P7000497027000000000000000043735" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043736" data-uri="chapter05.xhtml#P7000497027000000000000000043736" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.34 </span>Detail of load and store units.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043737" data-uri="chapter05.xhtml#P7000497027000000000000000043737"><p id="P7000497027000000000000000043738" data-uri="chapter05.xhtml#P7000497027000000000000000043738" class="pcalibre1 pcalibre2 pcalibre10">The store unit maintains a buffer of pending writes. The load unit must check its address with those in the store unit to detect a write/read dependency.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000023A25" data-uri="chapter05.xhtml#P7000497027000000000000000023A25">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000043739" data-uri="chapter05.xhtml#P7000497027000000000000000043739" class="pcalibre1 pcalibre2 pcalibre10">A diagram shows a load unit sending address to store unit and data cache and receiving data from each. The store unit includes the store buffer, composed of matching addresses within address and data, each of which is sent to data cache.</p>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004373A" data-uri="chapter05.xhtml#P700049702700000000000000004373A">As a consequence, a series of ascending values will be stored in this location. In general, if function <code id="P700049702700000000000000004373B" data-uri="chapter05.xhtml#P700049702700000000000000004373B" class="pcalibre1 calibre1 pcalibre2">write_read</code> is called with arguments <code id="P700049702700000000000000004373C" data-uri="chapter05.xhtml#P700049702700000000000000004373C" class="pcalibre1 calibre1 pcalibre2">src</code> and <code id="P700049702700000000000000004373D" data-uri="chapter05.xhtml#P700049702700000000000000004373D" class="pcalibre1 calibre1 pcalibre2">dest</code> pointing to the same memory location, and with argument <code id="P700049702700000000000000004373E" data-uri="chapter05.xhtml#P700049702700000000000000004373E" class="pcalibre1 calibre1 pcalibre2">cnt</code> having some value <var class="pcalibre17 pcalibre2 pcalibre1">n</var> &gt; 0, the net effect is to set the location to <var class="pcalibre17 pcalibre2 pcalibre1">n</var> − 1. This example illustrates a phenomenon we will call a <i class="pcalibre17 pcalibre2 pcalibre1">write/read dependency</i>—the outcome of a memory read depends on a recent memory write. Our performance measurements show that Example B has a CPE of 7.3. The write/read dependency causes a slowdown in the processing of around 6 clock cycles.</p>
<p id="P700049702700000000000000004373F" data-uri="chapter05.xhtml#P700049702700000000000000004373F" class="pcalibre8 pcalibre1 pcalibre2">To see how the processor can distinguish between these two cases and why one runs slower than the other, we must take a more detailed look at the load and store execution units, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F90"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.34</span></a>. The store unit includes a <i class="pcalibre17 pcalibre2 pcalibre1">store buffer</i> containing the addresses and data of the store operations that have been issued to the store unit, but have not yet been completed, where completion involves updating the data cache. This buffer is provided so that a series of store operations can be executed without having to wait for each one to update the cache. When a load operation occurs, it must check the entries in the store buffer for matching addresses. If it finds a match (meaning that any of the bytes being written have the same address as any of the bytes being read), it retrieves the corresponding data entry as the result of the load operation.</p>
<p id="P7000497027000000000000000043740" data-uri="chapter05.xhtml#P7000497027000000000000000043740" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the following code for the inner loop of <code id="P7000497027000000000000000043741" data-uri="chapter05.xhtml#P7000497027000000000000000043741" class="pcalibre1 calibre1 pcalibre2">write_read</code>:</p>
<pre id="P7000497027000000000000000043742" data-uri="chapter05.xhtml#P7000497027000000000000000043742" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043743" data-uri="chapter05.xhtml#P7000497027000000000000000043743" class="calibre3 pcalibre1 pcalibre2">
<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of write_read</i>
<i class="pcalibre17 pcalibre2 pcalibre1">src in %rdi, dst in %rsi, val in %rax</i>
.L3:			<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
 movq	%rax, (%rsi)	  <i class="pcalibre17 pcalibre2 pcalibre1">Write val to dst</i>
 movq	(%rdi), %rax	  <i class="pcalibre17 pcalibre2 pcalibre1">t = *src</i>
 addq	$1, %rax	  <i class="pcalibre17 pcalibre2 pcalibre1">val = t+1</i>
 subq	$1, %rdx	  <i class="pcalibre17 pcalibre2 pcalibre1">cnt−</i>
 jne	. L3		  <i class="pcalibre17 pcalibre2 pcalibre1">If != 0, goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">loop</b>
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004FA1" data-uri="chapter05.xhtml#P7000497027000000000000000004FA1">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004FA2" title="558" data-uri="chapter05.xhtml#P7000497027000000000000000004FA2" epub:type="pagebreak"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for write_read." id="P7000497027000000000000000043744" data-uri="P700049702700000000000000000B724" src="../images/p558-1.png" class="pcalibre1 pcalibre2 pcalibre204"/>
<figcaption id="P7000497027000000000000000043745" data-uri="chapter05.xhtml#P7000497027000000000000000043745" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043746" data-uri="chapter05.xhtml#P7000497027000000000000000043746" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.35 </span>Graphical representation of inner-loop code for <code id="P7000497027000000000000000043747" data-uri="chapter05.xhtml#P7000497027000000000000000043747" class="pcalibre1 calibre1 pcalibre2">write_read</code>.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043748" data-uri="chapter05.xhtml#P7000497027000000000000000043748"><p id="P7000497027000000000000000043749" data-uri="chapter05.xhtml#P7000497027000000000000000043749" class="pcalibre1 pcalibre2 pcalibre10">The first <code id="P700049702700000000000000004374A" data-uri="chapter05.xhtml#P700049702700000000000000004374A" class="pcalibre1 calibre1 pcalibre2">movl</code> instruction is decoded into separate operations to compute the store address and to store the data to memory.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000023A38" data-uri="chapter05.xhtml#P7000497027000000000000000023A38">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P700049702700000000000000004374B" data-uri="chapter05.xhtml#P700049702700000000000000004374B" class="pcalibre8 pcalibre1 pcalibre2">A diagram has two rows of boxes, each with %rax, %rdi, %rsi, and %rdx, with output from top %rdi and %rsi to bottom %rdi and %rsi, respectively. A column of boxes includes the six operations summarized below, from top to bottom:</p>
<ul id="P700049702700000000000000004374C" data-uri="chapter05.xhtml#P700049702700000000000000004374C" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P700049702700000000000000004374D" data-uri="chapter05.xhtml#P700049702700000000000000004374D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004374E" data-uri="chapter05.xhtml#P700049702700000000000000004374E" class="pcalibre1 pcalibre2 pcalibre10">s_addr: receives input from top %rsi and sends output to s_data and load operations below</p></li>
<li id="P700049702700000000000000004374F" data-uri="chapter05.xhtml#P700049702700000000000000004374F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043750" data-uri="chapter05.xhtml#P7000497027000000000000000043750" class="pcalibre1 pcalibre2 pcalibre10">s_data: receives input from s_addr, with the two together representing movq %rax, (%rsi); receives input from top %rax and sends output to load below</p></li>
<li id="P7000497027000000000000000043751" data-uri="chapter05.xhtml#P7000497027000000000000000043751" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043752" data-uri="chapter05.xhtml#P7000497027000000000000000043752" class="pcalibre1 pcalibre2 pcalibre10">Load (movq (%rdi), %rax): receives input from s_addr, s_data, and top %rdi; sends output to add below</p></li>
<li id="P7000497027000000000000000043753" data-uri="chapter05.xhtml#P7000497027000000000000000043753" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043754" data-uri="chapter05.xhtml#P7000497027000000000000000043754" class="pcalibre1 pcalibre2 pcalibre10">add (addq $1, %rax): receives input from load and sends output to bottom %rax</p></li>
<li id="P7000497027000000000000000043755" data-uri="chapter05.xhtml#P7000497027000000000000000043755" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043756" data-uri="chapter05.xhtml#P7000497027000000000000000043756" class="pcalibre1 pcalibre2 pcalibre10">sub (subq $1, %rdx): receives input from top %rdx and sends output to bottom %rdx and jne below</p></li>
<li id="P7000497027000000000000000043757" data-uri="chapter05.xhtml#P7000497027000000000000000043757" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043758" data-uri="chapter05.xhtml#P7000497027000000000000000043758" class="pcalibre1 pcalibre2 pcalibre10">jne (jne loop): receives input from sub and sends output to bottom %rdx</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043759" data-uri="chapter05.xhtml#P7000497027000000000000000043759"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FA1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.35</span></a> shows a data-flow representation of this loop code. The instruction <code id="P700049702700000000000000004375A" data-uri="chapter05.xhtml#P700049702700000000000000004375A" class="pcalibre1 calibre1 pcalibre2">movq %rax,(%rsi)</code> is translated into two operations: The s_addr instruction computes the address for the store operation, creates an entry in the store buffer, and sets the address field for that entry. The s_data operation sets the data field for the entry. As we will see, the fact that these two computations are performed independently can be important to program performance. This motivates the separate functional units for these operations in the reference machine.</p>
<p id="P700049702700000000000000004375B" data-uri="chapter05.xhtml#P700049702700000000000000004375B" class="pcalibre8 pcalibre1 pcalibre2">In addition to the data dependencies between the operations caused by the writing and reading of registers, the arcs on the right of the operators denote a set of implicit dependencies for these operations. In particular, the address computation of the s_addr operation must clearly precede the s_data operation. In addition, the load operation generated by decoding the instruction <code id="P700049702700000000000000004375C" data-uri="chapter05.xhtml#P700049702700000000000000004375C" class="pcalibre1 calibre1 pcalibre2">movq</code> <code id="P700049702700000000000000004375D" data-uri="chapter05.xhtml#P700049702700000000000000004375D" class="pcalibre1 calibre1 pcalibre2">(%rdi), %rax</code> must check the addresses of any pending store operations, creating a data dependency between it and the s_addr operation. The figure shows a dashed arc between the s_data and load operations. This dependency is conditional: if the two addresses match, the load operation must wait until the s_data has deposited its result into the store buffer, but if the two addresses differ, the two operations can proceed independently.</p>
<p id="P700049702700000000000000004375E" data-uri="chapter05.xhtml#P700049702700000000000000004375E" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FB3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.36</span></a> illustrates the data dependencies between the operations for the inner loop of <code id="P700049702700000000000000004375F" data-uri="chapter05.xhtml#P700049702700000000000000004375F" class="pcalibre1 calibre1 pcalibre2">write_read</code>. In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FB3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.36(a)</span></a>, we have rearranged the operations to allow the dependencies to be seen more clearly. We have labeled the three dependencies involving the load and store operations for special attention. The arc labeled "1" represents the requirement that the store address must be computed before the data can be stored. The arc labeled "2" represents the need for the load operation to compare its address with that for any pending store operations. Finally, the dashed arc labeled "3" represents the conditional data dependency that arises when the load and store addresses match.</p>
<p id="P7000497027000000000000000043760" data-uri="chapter05.xhtml#P7000497027000000000000000043760" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FB3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.36(b)</span></a> illustrates what happens when we take away those operations that do not directly affect the flow of data from one iteration to the next. The data-flow graph shows just two chains of dependencies: the one on the left, with data values being stored, loaded, and incremented (only for the case of matching addresses); and the one on the right, decrementing variable <code id="P7000497027000000000000000043761" data-uri="chapter05.xhtml#P7000497027000000000000000043761" class="pcalibre1 calibre1 pcalibre2">cnt</code>.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004FB3" data-uri="chapter05.xhtml#P7000497027000000000000000004FB3">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004FB4" title="559" data-uri="chapter05.xhtml#P7000497027000000000000000004FB4" epub:type="pagebreak"></span>
<img alt="A diagram depicts two data-flow graphs for write_read." id="P7000497027000000000000000043762" data-uri="P700049702700000000000000000B725" src="../images/p559-1.png" class="pcalibre1 pcalibre2 pcalibre205"/>
<figcaption id="P7000497027000000000000000043763" data-uri="chapter05.xhtml#P7000497027000000000000000043763" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043764" data-uri="chapter05.xhtml#P7000497027000000000000000043764" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.36 </span>Abstracting the operations for <code id="P7000497027000000000000000043765" data-uri="chapter05.xhtml#P7000497027000000000000000043765" class="pcalibre1 calibre1 pcalibre2">write_read</code>.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043766" data-uri="chapter05.xhtml#P7000497027000000000000000043766"><p id="P7000497027000000000000000043767" data-uri="chapter05.xhtml#P7000497027000000000000000043767" class="pcalibre1 pcalibre2 pcalibre10">We first rearrange the operators of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FA1"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.35(a)</span></a> and then show only those operations that use values from one iteration to produce new values for the next (b).</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000023A56" data-uri="chapter05.xhtml#P7000497027000000000000000023A56">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P7000497027000000000000000043768" data-uri="chapter05.xhtml#P7000497027000000000000000043768">
<li id="P7000497027000000000000000043769" data-uri="chapter05.xhtml#P7000497027000000000000000043769" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004376A" data-uri="chapter05.xhtml#P700049702700000000000000004376A" class="pcalibre1 pcalibre2 pcalibre10">Data flows from top %rax to s_data to load (numbered 3) to add to bottom %rax; from %rdi to load; from %rsi to s_addr, with 1 to s_data and 2 to load; top %rdx to sub, which moves to jne and bottom %rdx.</p></li>
<li id="P700049702700000000000000004376B" data-uri="chapter05.xhtml#P700049702700000000000000004376B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004376C" data-uri="chapter05.xhtml#P700049702700000000000000004376C" class="pcalibre1 pcalibre2 pcalibre10">Data flows from top %rax through s_data, load, and add to bottom %rax; from top %rdx to sub to bottom %rdx.</p></li>
</ol>
</details>
</figcaption></figure>
<p id="P700049702700000000000000004376D" data-uri="chapter05.xhtml#P700049702700000000000000004376D" class="pcalibre8 pcalibre1 pcalibre2">We can now understand the performance characteristics of function <code id="P700049702700000000000000004376E" data-uri="chapter05.xhtml#P700049702700000000000000004376E" class="pcalibre1 calibre1 pcalibre2">write_read</code>. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FC7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.37</span></a> illustrates the data dependencies formed by multiple iterations of its inner loop. For the case of Example A in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004F75"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.33</span></a>, with differing source and destination addresses, the load and store operations can proceed independently, and hence the only critical path is formed by the decrementing of variable <code id="P700049702700000000000000004376F" data-uri="chapter05.xhtml#P700049702700000000000000004376F" class="pcalibre1 calibre1 pcalibre2">cnt</code>, resulting in a CPE bound of 1.0. For the case of Example B with matching source and destination addresses, the data dependency between the s_data and load instructions causes a critical path to form involving data being stored, loaded, and incremented. We found that these three operations in sequence require a total of around 7 clock cycles.</p>
<p id="P7000497027000000000000000043770" data-uri="chapter05.xhtml#P7000497027000000000000000043770" class="pcalibre8 pcalibre1 pcalibre2">As these two examples show, the implementation of memory operations involves many subtleties. With operations on registers, the processor can determine which instructions will affect which others as they are being decoded into operations. With memory operations, on the other hand, the processor cannot predict which will affect which others until the load and store addresses have been computed. Efficient handling of memory operations is critical to the performance of many programs. The memory subsystem makes use of many optimizations, such as the potential parallelism when operations can proceed independently.</p>
<section id="P7000497027000000000000000004FBF" data-uri="chapter05.xhtml#P7000497027000000000000000004FBF" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000043771" data-uri="chapter05.xhtml#P7000497027000000000000000043771" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.10 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005159">577</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000043772" data-uri="chapter05.xhtml#P7000497027000000000000000043772">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000043773" data-uri="chapter05.xhtml#P7000497027000000000000000043773">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043774" data-uri="chapter05.xhtml#P7000497027000000000000000043774"><p id="P7000497027000000000000000043775" data-uri="chapter05.xhtml#P7000497027000000000000000043775" class="pcalibre1 pcalibre2 pcalibre10">As another example of code with potential load-store interactions, consider the following function to copy the contents of one array to another:</p>
<pre id="P7000497027000000000000000043776" data-uri="chapter05.xhtml#P7000497027000000000000000043776" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043777" data-uri="chapter05.xhtml#P7000497027000000000000000043777" class="calibre3 pcalibre1 pcalibre2">
1	void copy_array(long *src, long *dest, long n)
2	{
3		long i;
4		for (i = 0; i &lt; n; i++)
5			dest[i] = src[i];
6	}
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004FC7" data-uri="chapter05.xhtml#P7000497027000000000000000004FC7">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004FC8" title="560" data-uri="chapter05.xhtml#P7000497027000000000000000004FC8" epub:type="pagebreak"></span>
<img alt="Example A shows a critical path flowing through sub operations. Example B shows a critical path flowing between groups through s_data, load, and add." id="P7000497027000000000000000043778" data-uri="P700049702700000000000000000B726" src="../images/p560-1.png" class="pcalibre1 pcalibre2 calibre49"/>
<figcaption id="P7000497027000000000000000043779" data-uri="chapter05.xhtml#P7000497027000000000000000043779" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004377A" data-uri="chapter05.xhtml#P700049702700000000000000004377A" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.37 </span>Data-flow representation of function <code id="P700049702700000000000000004377B" data-uri="chapter05.xhtml#P700049702700000000000000004377B" class="pcalibre1 calibre1 pcalibre2">write_read</code>.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P700049702700000000000000004377C" data-uri="chapter05.xhtml#P700049702700000000000000004377C"><p id="P700049702700000000000000004377D" data-uri="chapter05.xhtml#P700049702700000000000000004377D" class="pcalibre1 pcalibre2 pcalibre10">When the two addresses do not match, the only critical path is formed by the decrementing of <b class="pcalibre1 pcalibre2 pcalibre12">cnt</b> (Example A). When they do match, the chain of data being stored, loaded, and incremented forms the critical path (Example B).</p></div>
</figcaption></figure>
<p id="P700049702700000000000000004377E" data-uri="chapter05.xhtml#P700049702700000000000000004377E" class="pcalibre1 pcalibre2 pcalibre10">Suppose <code id="P700049702700000000000000004377F" data-uri="chapter05.xhtml#P700049702700000000000000004377F" class="pcalibre1 calibre1 pcalibre2">a</code> is an array of length 1,000 initialized so that each element <code id="P7000497027000000000000000043780" data-uri="chapter05.xhtml#P7000497027000000000000000043780" class="pcalibre1 calibre1 pcalibre2">a[<var class="pcalibre17 pcalibre2 pcalibre1">i</var>]</code> equals <i class="pcalibre17 pcalibre2 pcalibre1">i.</i></p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000043781" data-uri="chapter05.xhtml#P7000497027000000000000000043781">
<li id="P7000497027000000000000000043782" data-uri="chapter05.xhtml#P7000497027000000000000000043782" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043783" data-uri="chapter05.xhtml#P7000497027000000000000000043783" class="pcalibre1 pcalibre2 pcalibre10">What would be the effect of the call <code id="P7000497027000000000000000043784" data-uri="chapter05.xhtml#P7000497027000000000000000043784" class="pcalibre1 calibre1 pcalibre2">copy_array(a+1,a,999)?</code></p></li>
<li id="P7000497027000000000000000043785" data-uri="chapter05.xhtml#P7000497027000000000000000043785" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043786" data-uri="chapter05.xhtml#P7000497027000000000000000043786" class="pcalibre1 pcalibre2 pcalibre10">What would be the effect of the call <code id="P7000497027000000000000000043787" data-uri="chapter05.xhtml#P7000497027000000000000000043787" class="pcalibre1 calibre1 pcalibre2">copy_array(a,a+1,999)?</code></p></li>
<li id="P7000497027000000000000000043788" data-uri="chapter05.xhtml#P7000497027000000000000000043788" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043789" data-uri="chapter05.xhtml#P7000497027000000000000000043789" class="pcalibre1 pcalibre2 pcalibre10">Our performance measurements indicate that the call of part A has a CPE of 1.2 (which drops to 1.0 when the loop is unrolled by a factor of 4), while the call of part B has a CPE of 5.0. To what factor do you attribute this performance difference?</p></li>
<li id="P700049702700000000000000004378A" data-uri="chapter05.xhtml#P700049702700000000000000004378A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004378B" data-uri="chapter05.xhtml#P700049702700000000000000004378B" class="pcalibre1 pcalibre2 pcalibre10">What performance would you expect for the call <code id="P700049702700000000000000004378C" data-uri="chapter05.xhtml#P700049702700000000000000004378C" class="pcalibre1 calibre1 pcalibre2">copy_array (a,a, 999)?</code></p></li>
</ol></div></li>
</ol>
</section>
<section id="P7000497027000000000000000004FDE" data-uri="chapter05.xhtml#P7000497027000000000000000004FDE" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004378D" data-uri="chapter05.xhtml#P700049702700000000000000004378D" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004FE0" title="561" data-uri="chapter05.xhtml#P7000497027000000000000000004FE0" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.11 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005159">577</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004378E" data-uri="chapter05.xhtml#P700049702700000000000000004378E">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004378F" data-uri="chapter05.xhtml#P700049702700000000000000004378F">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043790" data-uri="chapter05.xhtml#P7000497027000000000000000043790"><p id="P7000497027000000000000000043791" data-uri="chapter05.xhtml#P7000497027000000000000000043791" class="pcalibre1 pcalibre2 pcalibre10">We saw that our measurements of the prefix-sum function <code id="P7000497027000000000000000043792" data-uri="chapter05.xhtml#P7000497027000000000000000043792" class="pcalibre1 calibre1 pcalibre2">psum1</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000493B.xhtml#P7000497027000000000000000004949"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1</span></a>) yield a CPE of 9.00 on a machine where the basic operation to be performed, floating-point addition, has a latency of just 3 clock cycles. Let us try to understand why our function performs so poorly.</p>
<p id="P7000497027000000000000000043793" data-uri="chapter05.xhtml#P7000497027000000000000000043793" class="pcalibre1 pcalibre2 pcalibre10">The following is the assembly code for the inner loop of the function:</p>
<pre id="P7000497027000000000000000043794" data-uri="chapter05.xhtml#P7000497027000000000000000043794" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043795" data-uri="chapter05.xhtml#P7000497027000000000000000043795" class="calibre3 pcalibre1 pcalibre2">
<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of psum1</i>
<i class="pcalibre17 pcalibre2 pcalibre1">a in %rdi, i in %rax, cnt in %rdx</i>
1	.L5:					<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	  vmovss −4(%rsi,%rax,4), %xmm0		  <i class="pcalibre17 pcalibre2 pcalibre1">Get p[i-1]</i>
3	  vaddss (%rdi,%rax,4), %xmm0, %xmm0	  <i class="pcalibre17 pcalibre2 pcalibre1">Add a[i]</i>
4	  vmovss %xmm0, (%rsi,%rax,4)		  <i class="pcalibre17 pcalibre2 pcalibre1">Store at p[i]</i>
5	  addq $1, %rax				  <i class="pcalibre17 pcalibre2 pcalibre1">Increment i</i>
6	  cmpq %rdx, %rax			  <i class="pcalibre17 pcalibre2 pcalibre1">Compare i : cnt</i>
7	  jne .L5				  <i class="pcalibre17 pcalibre2 pcalibre1">If ! =, goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">loop</b>
</code></pre>
<p id="P7000497027000000000000000043796" data-uri="chapter05.xhtml#P7000497027000000000000000043796" class="pcalibre1 pcalibre2 pcalibre10">Perform an analysis similar to those shown for <code id="P7000497027000000000000000043797" data-uri="chapter05.xhtml#P7000497027000000000000000043797" class="pcalibre1 calibre1 pcalibre2">combine3</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14</span></a>) and for <code id="P7000497027000000000000000043798" data-uri="chapter05.xhtml#P7000497027000000000000000043798" class="pcalibre1 calibre1 pcalibre2">write_read</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004FB3"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.36</span></a>) to diagram the data dependencies created by this loop, and hence the critical path that forms as the computation proceeds. Explain why the CPE is so high.</p></div></li>
</ol>
</section>
<section id="P7000497027000000000000000004FEC" data-uri="chapter05.xhtml#P7000497027000000000000000004FEC" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000043799" data-uri="chapter05.xhtml#P7000497027000000000000000043799" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005159">577</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004379A" data-uri="chapter05.xhtml#P700049702700000000000000004379A">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004379B" data-uri="chapter05.xhtml#P700049702700000000000000004379B">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004379C" data-uri="chapter05.xhtml#P700049702700000000000000004379C"><p id="P700049702700000000000000004379D" data-uri="chapter05.xhtml#P700049702700000000000000004379D" class="pcalibre1 pcalibre2 pcalibre10">Rewrite the code for <code id="P700049702700000000000000004379E" data-uri="chapter05.xhtml#P700049702700000000000000004379E" class="pcalibre1 calibre1 pcalibre2">psum1</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000493B.xhtml#P7000497027000000000000000004949"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1</span></a>) so that it does not need to repeatedly retrieve the value of <code id="P700049702700000000000000004379F" data-uri="chapter05.xhtml#P700049702700000000000000004379F" class="pcalibre1 calibre1 pcalibre2">p[i]</code> from memory. You do not need to use loop unrolling. We measured the resulting code to have a CPE of 3.00, limited by the latency of floating-point addition.</p></div></li>
</ol>
</section>
</section>
</section></body></html>
