<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>7.12 Position-Independent Code (PIC)</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000006428" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000044BE3" data-uri="chapter07.xhtml#P7000497027000000000000000044BE3" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">7.12 </span>Position-Independent Code (PIC)</h1></header>
<p id="P7000497027000000000000000044BE4" data-uri="chapter07.xhtml#P7000497027000000000000000044BE4" class="pcalibre8 pcalibre1 pcalibre2">A key purpose of shared libraries is to allow multiple running processes to share the same library code in memory and thus save precious memory resources. So how can multiple processes share a single copy of a program? One approach would be to assign a priori a dedicated chunk of the address space to each shared library, and then require the loader to always load the shared library at that address. While straightforward, this approach creates some serious problems. It would be an inefficient use of the address space because portions of the space would be allocated even if a process didn't use the library. It would also be difficult to manage. We would have to ensure that none of the chunks overlapped. Each time a library was modified, we would have to make sure that it still fit in its assigned chunk. If not, then we would have to find a new chunk. And if we created a new library, we would have to find room for it. Over time, given the hundreds of libraries and versions of libraries in a system, it would be difficult to keep the address space from fragmenting into lots of small unused but unusable holes. Even worse, the assignment of libraries to memory would be different for each system, thus creating even more management headaches.</p>
<p id="P7000497027000000000000000044BE5" data-uri="chapter07.xhtml#P7000497027000000000000000044BE5" class="pcalibre8 pcalibre1 pcalibre2">To avoid these problems, modern systems compile the code segments of shared modules so that they can be loaded anywhere in memory without having to be modified by the linker. With this approach, a single copy of a shared module's code segment can be shared by an unlimited number of processes. (Of course, each process will still get its own copy of the read/write data segment.)</p>
<p id="P7000497027000000000000000044BE6" data-uri="chapter07.xhtml#P7000497027000000000000000044BE6" class="pcalibre8 pcalibre1 pcalibre2">Code that can be loaded without needing any relocations is known as <i class="pcalibre17 pcalibre2 pcalibre1">position-independent code (PIC).</i> Users direct GNU compilation systems to generate PIC code with the <code id="P7000497027000000000000000044BE7" data-uri="chapter07.xhtml#P7000497027000000000000000044BE7" class="pcalibre1 calibre1 pcalibre2">-fpic</code> option to <span class="pcalibre1 pcalibre29 pcalibre2">gcc. </span>Shared libraries must always be compiled with this option.</p>
<p id="P7000497027000000000000000044BE8" data-uri="chapter07.xhtml#P7000497027000000000000000044BE8" class="pcalibre8 pcalibre1 pcalibre2">On x86-64 systems, references to symbols in the same executable object module require no special treatment to be PIC. These references can be compiled using PC-relative addressing and relocated by the static linker when it builds the object file. However, references to external procedures and global variables that are defined by shared modules require some special techniques, which we describe next.</p>
<section id="P700049702700000000000000000642F" data-uri="chapter07.xhtml#P700049702700000000000000000642F" class="pcalibre1 pcalibre2 pcalibre3">
<section id="P7000497027000000000000000006430" data-uri="chapter07.xhtml#P7000497027000000000000000006430" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000044BE9" data-uri="chapter07.xhtml#P7000497027000000000000000044BE9" epub:type="title">PIC Data References</h1></header>
<p id="P7000497027000000000000000044BEA" data-uri="chapter07.xhtml#P7000497027000000000000000044BEA" class="pcalibre8 pcalibre1 pcalibre2">Compilers generate PIC references to global variables by exploiting the following interesting fact: no matter where we load an object module (including shared</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000006433" data-uri="chapter07.xhtml#P7000497027000000000000000006433">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006434" title="705" data-uri="chapter07.xhtml#P7000497027000000000000000006434" epub:type="pagebreak"></span>
<img alt="A diagram illustrates using the GOT to reference a global variable." id="P7000497027000000000000000044BEB" data-uri="P700049702700000000000000000B75E" src="../images/p705-1.png" class="pcalibre239 pcalibre1 pcalibre2"/>
<figcaption id="P7000497027000000000000000044BEC" data-uri="chapter07.xhtml#P7000497027000000000000000044BEC" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000044BED" data-uri="chapter07.xhtml#P7000497027000000000000000044BED" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">7.18 </span>Using the GOT to reference a global variable.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000044BEE" data-uri="chapter07.xhtml#P7000497027000000000000000044BEE"><p id="P7000497027000000000000000044BEF" data-uri="chapter07.xhtml#P7000497027000000000000000044BEF" class="pcalibre1 pcalibre2 pcalibre10">The <code id="P7000497027000000000000000044BF0" data-uri="chapter07.xhtml#P7000497027000000000000000044BF0" class="pcalibre1 calibre1 pcalibre2">addvec</code> routine in <code id="P7000497027000000000000000044BF1" data-uri="chapter07.xhtml#P7000497027000000000000000044BF1" class="pcalibre1 calibre1 pcalibre2">libvector.so</code> references <code id="P7000497027000000000000000044BF2" data-uri="chapter07.xhtml#P7000497027000000000000000044BF2" class="pcalibre1 calibre1 pcalibre2">addcnt</code> indirectly through the GOT for <code id="P7000497027000000000000000044BF3" data-uri="chapter07.xhtml#P7000497027000000000000000044BF3" class="pcalibre1 calibre1 pcalibre2">libvector.so</code>.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000024F09" data-uri="chapter07.xhtml#P7000497027000000000000000024F09">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000044BF4" data-uri="chapter07.xhtml#P7000497027000000000000000044BF4" class="pcalibre8 pcalibre1 pcalibre2">A diagram shows data segment and code segment, linked by fixed distance of 0x2008b9 bytes at run time between GOT[3] and addl instruction. Components of each are summarized below.</p>
<ul id="P7000497027000000000000000044BF5" data-uri="chapter07.xhtml#P7000497027000000000000000044BF5" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000044BF6" data-uri="chapter07.xhtml#P7000497027000000000000000044BF6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044BF7" data-uri="chapter07.xhtml#P7000497027000000000000000044BF7" class="pcalibre1 pcalibre2 pcalibre10">Data segment: Global offset table (GOT) contains GOT[0]:…, GOT[1]:…, GOT[2]:…, GOT[3]: &amp;addcnt</p></li>
<li id="P7000497027000000000000000044BF8" data-uri="chapter07.xhtml#P7000497027000000000000000044BF8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044BF9" data-uri="chapter07.xhtml#P7000497027000000000000000044BF9" class="pcalibre1 pcalibre2 pcalibre10">Code segment: addvec:</p>
<ul id="P7000497027000000000000000044BFA" data-uri="chapter07.xhtml#P7000497027000000000000000044BFA" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000044BFB" data-uri="chapter07.xhtml#P7000497027000000000000000044BFB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044BFC" data-uri="chapter07.xhtml#P7000497027000000000000000044BFC" class="pcalibre1 pcalibre2 pcalibre10">Mov 0x2008b9(%rip), % rax</p></li>
<li id="P7000497027000000000000000044BFD" data-uri="chapter07.xhtml#P7000497027000000000000000044BFD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044BFE" data-uri="chapter07.xhtml#P7000497027000000000000000044BFE" class="pcalibre1 pcalibre2 pcalibre10">Addl $0x1, (%rax)</p></li>
<li id="P7000497027000000000000000044BFF" data-uri="chapter07.xhtml#P7000497027000000000000000044BFF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C00" data-uri="chapter07.xhtml#P7000497027000000000000000044C00" class="pcalibre1 pcalibre2 pcalibre10"># %rax=*GOT[3]=%addcnt</p></li>
<li id="P7000497027000000000000000044C01" data-uri="chapter07.xhtml#P7000497027000000000000000044C01" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C02" data-uri="chapter07.xhtml#P7000497027000000000000000044C02" class="pcalibre1 pcalibre2 pcalibre10"># addcnt++</p></li>
</ul></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000044C03" data-uri="chapter07.xhtml#P7000497027000000000000000044C03">object modules) in memory, the data segment is always the same distance from the code segment. Thus, the <i class="pcalibre17 pcalibre2 pcalibre1">distance</i> between any instruction in the code segment and any variable in the data segment is a run-time constant, independent of the absolute memory locations of the code and data segments.</p>
<p id="P7000497027000000000000000044C04" data-uri="chapter07.xhtml#P7000497027000000000000000044C04" class="pcalibre8 pcalibre1 pcalibre2">Compilers that want to generate PIC references to global variables exploit this fact by creating a table called the <i class="pcalibre17 pcalibre2 pcalibre1">global offset table (GOT)</i> at the beginning of the data segment. The GOT contains an 8-byte entry for each global data object (procedure or global variable) that is referenced by the object module. The compiler also generates a relocation record for each entry in the GOT. At load time, the dynamic linker relocates each GOT entry so that it contains the absolute address of the object. Each object module that references global objects has its own GOT.</p>
<p id="P7000497027000000000000000044C05" data-uri="chapter07.xhtml#P7000497027000000000000000044C05" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006433"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">7.18</span></a> shows the GOT from our example <code id="P7000497027000000000000000044C06" data-uri="chapter07.xhtml#P7000497027000000000000000044C06" class="pcalibre1 calibre1 pcalibre2">libvector.so</code> shared module. The <code id="P7000497027000000000000000044C07" data-uri="chapter07.xhtml#P7000497027000000000000000044C07" class="pcalibre1 calibre1 pcalibre2">addvec</code> routine loads the address of the global variable <code id="P7000497027000000000000000044C08" data-uri="chapter07.xhtml#P7000497027000000000000000044C08" class="pcalibre1 calibre1 pcalibre2">addcnt</code> indirectly via GOT[3] and then increments <code id="P7000497027000000000000000044C09" data-uri="chapter07.xhtml#P7000497027000000000000000044C09" class="pcalibre1 calibre1 pcalibre2">addcnt</code> in memory. The key idea here is that the offset in the PC-relative reference to <code id="P7000497027000000000000000044C0A" data-uri="chapter07.xhtml#P7000497027000000000000000044C0A" class="pcalibre1 calibre1 pcalibre2">GOT[3]</code> is a run-time constant.</p>
<p id="P7000497027000000000000000044C0B" data-uri="chapter07.xhtml#P7000497027000000000000000044C0B" class="pcalibre8 pcalibre1 pcalibre2">Since <code id="P7000497027000000000000000044C0C" data-uri="chapter07.xhtml#P7000497027000000000000000044C0C" class="pcalibre1 calibre1 pcalibre2">addcnt</code> is defined by the <code id="P7000497027000000000000000044C0D" data-uri="chapter07.xhtml#P7000497027000000000000000044C0D" class="pcalibre1 calibre1 pcalibre2">libvector.so</code> module, the compiler could have exploited the constant distance between the code and data segments by generating a direct PC-relative reference to <code id="P7000497027000000000000000044C0E" data-uri="chapter07.xhtml#P7000497027000000000000000044C0E" class="pcalibre1 calibre1 pcalibre2">addcnt</code> and adding a relocation for the linker to resolve when it builds the shared module. However, if <code id="P7000497027000000000000000044C0F" data-uri="chapter07.xhtml#P7000497027000000000000000044C0F" class="pcalibre1 calibre1 pcalibre2">addcnt</code> were defined by another shared module, then the indirect access through the GOT would be necessary. In this case, the compiler has chosen to use the most general solution, the GOT, for all references.</p>
</section>
<section id="P700049702700000000000000000644B" data-uri="chapter07.xhtml#P700049702700000000000000000644B" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000044C10" data-uri="chapter07.xhtml#P7000497027000000000000000044C10" epub:type="title">PIC Function Calls</h1></header>
<p id="P7000497027000000000000000044C11" data-uri="chapter07.xhtml#P7000497027000000000000000044C11" class="pcalibre8 pcalibre1 pcalibre2">Suppose that a program calls a function that is defined by a shared library. The compiler has no way of predicting the run-time address of the function, since the shared module that defines it could be loaded anywhere at run time. The normal approach would be to generate a relocation record for the reference, which <span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000644E" title="706" data-uri="chapter07.xhtml#P700049702700000000000000000644E" epub:type="pagebreak"></span>the dynamic linker could then resolve when the program was loaded. However, this approach would not be PIC, since it would require the linker to modify the code segment of the calling module. GNU compilation systems solve this problem using an interesting technique, called <i class="pcalibre17 pcalibre2 pcalibre1">lazy binding</i>, that defers the binding of each procedure address until the <i class="pcalibre17 pcalibre2 pcalibre1">first time</i> the procedure is called.</p>
<p id="P7000497027000000000000000044C12" data-uri="chapter07.xhtml#P7000497027000000000000000044C12" class="pcalibre8 pcalibre1 pcalibre2">The motivation for lazy binding is that a typical application program will call only a handful of the hundreds or thousands of functions exported by a shared library such as <code id="P7000497027000000000000000044C13" data-uri="chapter07.xhtml#P7000497027000000000000000044C13" class="pcalibre1 calibre1 pcalibre2">libc.so</code>. By deferring the resolution of a function's address until it is actually called, the dynamic linker can avoid hundreds or thousands of unnecessary relocations at load time. There is a nontrivial run-time overhead the first time the function is called, but each call thereafter costs only a single instruction and a memory reference for the indirection.</p>
<p id="P7000497027000000000000000044C14" data-uri="chapter07.xhtml#P7000497027000000000000000044C14" class="pcalibre8 pcalibre1 pcalibre2">Lazy binding is implemented with a compact yet somewhat complex interaction between two data structures: the GOT and the <i class="pcalibre17 pcalibre2 pcalibre1">procedure linkage table (PLT)</i>. If an object module calls any functions that are defined in shared libraries, then it has its own GOT and PLT. The GOT is part of the data segment. The PLT is part of the code segment.</p>
<p id="P7000497027000000000000000044C15" data-uri="chapter07.xhtml#P7000497027000000000000000044C15" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006457"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">7.19</span></a> shows how the PLT and GOT work together to resolve the address of a function at run time. First, let's examine the contents of each of these tables.</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P7000497027000000000000000044C16" data-uri="chapter07.xhtml#P7000497027000000000000000044C16">
<li id="P7000497027000000000000000044C17" data-uri="chapter07.xhtml#P7000497027000000000000000044C17" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C18" data-uri="chapter07.xhtml#P7000497027000000000000000044C18" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Procedure linkage table (PLT). </span>The PLT is an array of 16-byte code entries. <code id="P7000497027000000000000000044C19" data-uri="chapter07.xhtml#P7000497027000000000000000044C19" class="pcalibre1 calibre1 pcalibre2">PLT[0]</code> is a special entry that jumps into the dynamic linker. Each shared library function called by the executable has its own PLT entry. Each of</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000006457" data-uri="chapter07.xhtml#P7000497027000000000000000006457">
<img alt="Diagrams illustrate using the PLT and GOT to call external functions." id="P7000497027000000000000000044C1A" data-uri="P700049702700000000000000000B75F" src="../images/p706-1.png" class="pcalibre1 pcalibre2 pcalibre240"/>
<figcaption id="P7000497027000000000000000044C1B" data-uri="chapter07.xhtml#P7000497027000000000000000044C1B" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000044C1C" data-uri="chapter07.xhtml#P7000497027000000000000000044C1C" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">7.19 </span>Using the PLT and GOT to call external functions.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000044C1D" data-uri="chapter07.xhtml#P7000497027000000000000000044C1D"><p id="P7000497027000000000000000044C1E" data-uri="chapter07.xhtml#P7000497027000000000000000044C1E" class="pcalibre1 pcalibre2 pcalibre10">The dynamic linker resolves the address of <code id="P7000497027000000000000000044C1F" data-uri="chapter07.xhtml#P7000497027000000000000000044C1F" class="pcalibre1 calibre1 pcalibre2">addvec</code> the first time it is called.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000024F36" data-uri="chapter07.xhtml#P7000497027000000000000000024F36">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000044C20" data-uri="chapter07.xhtml#P7000497027000000000000000044C20" class="pcalibre1 pcalibre2 pcalibre40">Two diagrams show data segment and code segment, as summarized below.</p>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P7000497027000000000000000044C21" data-uri="chapter07.xhtml#P7000497027000000000000000044C21">
<li id="P7000497027000000000000000044C22" data-uri="chapter07.xhtml#P7000497027000000000000000044C22" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C23" data-uri="chapter07.xhtml#P7000497027000000000000000044C23" class="pcalibre1 pcalibre2 pcalibre40">First invocation of addvec</p>
<ul id="P7000497027000000000000000044C24" data-uri="chapter07.xhtml#P7000497027000000000000000044C24" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000044C25" data-uri="chapter07.xhtml#P7000497027000000000000000044C25" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C26" data-uri="chapter07.xhtml#P7000497027000000000000000044C26" class="pcalibre1 pcalibre2 pcalibre40">Data segment: Global offset table (GOT):</p>
<ul id="P7000497027000000000000000044C27" data-uri="chapter07.xhtml#P7000497027000000000000000044C27" class="pcalibre146 pcalibre2 pcalibre1">
<li id="P7000497027000000000000000044C28" data-uri="chapter07.xhtml#P7000497027000000000000000044C28" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C29" data-uri="chapter07.xhtml#P7000497027000000000000000044C29" class="pcalibre1 pcalibre2 pcalibre40">GOT[0]: addr of dynamic</p></li>
<li id="P7000497027000000000000000044C2A" data-uri="chapter07.xhtml#P7000497027000000000000000044C2A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C2B" data-uri="chapter07.xhtml#P7000497027000000000000000044C2B" class="pcalibre1 pcalibre2 pcalibre40">GOT[1]: addr of reloc entries</p></li>
<li id="P7000497027000000000000000044C2C" data-uri="chapter07.xhtml#P7000497027000000000000000044C2C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C2D" data-uri="chapter07.xhtml#P7000497027000000000000000044C2D" class="pcalibre1 pcalibre2 pcalibre40">GOT[2]: addr of dynamic linker</p></li>
<li id="P7000497027000000000000000044C2E" data-uri="chapter07.xhtml#P7000497027000000000000000044C2E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C2F" data-uri="chapter07.xhtml#P7000497027000000000000000044C2F" class="pcalibre1 pcalibre2 pcalibre40">GOT[3]: 0x4005b6 # sys startup</p></li>
<li id="P7000497027000000000000000044C30" data-uri="chapter07.xhtml#P7000497027000000000000000044C30" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C31" data-uri="chapter07.xhtml#P7000497027000000000000000044C31" class="pcalibre1 pcalibre2 pcalibre40">GOT[4]: 0x4005c6 # addvec()</p></li>
<li id="P7000497027000000000000000044C32" data-uri="chapter07.xhtml#P7000497027000000000000000044C32" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C33" data-uri="chapter07.xhtml#P7000497027000000000000000044C33" class="pcalibre1 pcalibre2 pcalibre40">GOT[5]: 0x4005d6 # printf()</p></li>
</ul></li>
<li id="P7000497027000000000000000044C34" data-uri="chapter07.xhtml#P7000497027000000000000000044C34" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C35" data-uri="chapter07.xhtml#P7000497027000000000000000044C35" class="pcalibre1 pcalibre2 pcalibre40">Code segment:</p>
<ul id="P7000497027000000000000000044C36" data-uri="chapter07.xhtml#P7000497027000000000000000044C36" class="pcalibre146 pcalibre2 pcalibre1">
<li id="P7000497027000000000000000044C37" data-uri="chapter07.xhtml#P7000497027000000000000000044C37" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C38" data-uri="chapter07.xhtml#P7000497027000000000000000044C38" class="pcalibre1 pcalibre2 pcalibre40">Callq 0x4005c0 # call addvec() (1 to line 4005c0: jmpq below)</p></li>
<li id="P7000497027000000000000000044C39" data-uri="chapter07.xhtml#P7000497027000000000000000044C39" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C3A" data-uri="chapter07.xhtml#P7000497027000000000000000044C3A" class="pcalibre1 pcalibre2 pcalibre40">Procedure linkage table (PLT):</p>
<ul id="P7000497027000000000000000044C3B" data-uri="chapter07.xhtml#P7000497027000000000000000044C3B" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000044C3C" data-uri="chapter07.xhtml#P7000497027000000000000000044C3C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C3D" data-uri="chapter07.xhtml#P7000497027000000000000000044C3D" class="pcalibre1 pcalibre2 pcalibre40"># PLT[0]: call dynamic linker</p></li>
<li id="P7000497027000000000000000044C3E" data-uri="chapter07.xhtml#P7000497027000000000000000044C3E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C3F" data-uri="chapter07.xhtml#P7000497027000000000000000044C3F" class="pcalibre1 pcalibre2 pcalibre40">4005a0: pushq *GOT[1]</p></li>
<li id="P7000497027000000000000000044C40" data-uri="chapter07.xhtml#P7000497027000000000000000044C40" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C41" data-uri="chapter07.xhtml#P7000497027000000000000000044C41" class="pcalibre1 pcalibre2 pcalibre40">4005a6: jmpq *GOT[2]</p></li>
<li id="P7000497027000000000000000044C42" data-uri="chapter07.xhtml#P7000497027000000000000000044C42" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C43" data-uri="chapter07.xhtml#P7000497027000000000000000044C43" class="pcalibre1 pcalibre2 pcalibre40">…</p></li>
<li id="P7000497027000000000000000044C44" data-uri="chapter07.xhtml#P7000497027000000000000000044C44" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C45" data-uri="chapter07.xhtml#P7000497027000000000000000044C45" class="pcalibre1 pcalibre2 pcalibre40"># PLT[2]: call addvec()</p></li>
<li id="P7000497027000000000000000044C46" data-uri="chapter07.xhtml#P7000497027000000000000000044C46" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C47" data-uri="chapter07.xhtml#P7000497027000000000000000044C47" class="pcalibre1 pcalibre2 pcalibre40">4005c0: jmpq *GOT[4] (2 to line below)</p></li>
<li id="P7000497027000000000000000044C48" data-uri="chapter07.xhtml#P7000497027000000000000000044C48" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C49" data-uri="chapter07.xhtml#P7000497027000000000000000044C49" class="pcalibre1 pcalibre2 pcalibre40">4005c6: pushq $0x1</p></li>
<li id="P7000497027000000000000000044C4A" data-uri="chapter07.xhtml#P7000497027000000000000000044C4A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C4B" data-uri="chapter07.xhtml#P7000497027000000000000000044C4B" class="pcalibre1 pcalibre2 pcalibre40">4005cb: jmpq 4005a0 (3 to line 4005a0: pushq above)</p></li>
</ul></li></ul></li></ul></li>
<li id="P7000497027000000000000000044C4C" data-uri="chapter07.xhtml#P7000497027000000000000000044C4C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C4D" data-uri="chapter07.xhtml#P7000497027000000000000000044C4D" class="pcalibre1 pcalibre2 pcalibre40">Subsequent invocations of addvec</p>
<ul id="P7000497027000000000000000044C4E" data-uri="chapter07.xhtml#P7000497027000000000000000044C4E" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000044C4F" data-uri="chapter07.xhtml#P7000497027000000000000000044C4F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C50" data-uri="chapter07.xhtml#P7000497027000000000000000044C50" class="pcalibre1 pcalibre2 pcalibre40">Data segment: Global offset table (GOT):</p>
<ul id="P7000497027000000000000000044C51" data-uri="chapter07.xhtml#P7000497027000000000000000044C51" class="pcalibre146 pcalibre2 pcalibre1">
<li id="P7000497027000000000000000044C52" data-uri="chapter07.xhtml#P7000497027000000000000000044C52" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C53" data-uri="chapter07.xhtml#P7000497027000000000000000044C53" class="pcalibre1 pcalibre2 pcalibre40">GOT[0]: addr of dynamic</p></li>
<li id="P7000497027000000000000000044C54" data-uri="chapter07.xhtml#P7000497027000000000000000044C54" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C55" data-uri="chapter07.xhtml#P7000497027000000000000000044C55" class="pcalibre1 pcalibre2 pcalibre40">GOT[1]: addr of reloc entries</p></li>
<li id="P7000497027000000000000000044C56" data-uri="chapter07.xhtml#P7000497027000000000000000044C56" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C57" data-uri="chapter07.xhtml#P7000497027000000000000000044C57" class="pcalibre1 pcalibre2 pcalibre40">GOT[2]: addr of dynamic linker</p></li>
<li id="P7000497027000000000000000044C58" data-uri="chapter07.xhtml#P7000497027000000000000000044C58" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C59" data-uri="chapter07.xhtml#P7000497027000000000000000044C59" class="pcalibre1 pcalibre2 pcalibre40">GOT[3]: 0x4005b6 # sys startup</p></li>
<li id="P7000497027000000000000000044C5A" data-uri="chapter07.xhtml#P7000497027000000000000000044C5A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C5B" data-uri="chapter07.xhtml#P7000497027000000000000000044C5B" class="pcalibre1 pcalibre2 pcalibre40">GOT[4]: &amp;addvec()</p></li>
<li id="P7000497027000000000000000044C5C" data-uri="chapter07.xhtml#P7000497027000000000000000044C5C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C5D" data-uri="chapter07.xhtml#P7000497027000000000000000044C5D" class="pcalibre1 pcalibre2 pcalibre40">GOT[5]: 0x4005d6 # printf()</p></li>
</ul></li>
<li id="P7000497027000000000000000044C5E" data-uri="chapter07.xhtml#P7000497027000000000000000044C5E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C5F" data-uri="chapter07.xhtml#P7000497027000000000000000044C5F" class="pcalibre1 pcalibre2 pcalibre40">Code segment:</p>
<ul id="P7000497027000000000000000044C60" data-uri="chapter07.xhtml#P7000497027000000000000000044C60" class="pcalibre146 pcalibre2 pcalibre1">
<li id="P7000497027000000000000000044C61" data-uri="chapter07.xhtml#P7000497027000000000000000044C61" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C62" data-uri="chapter07.xhtml#P7000497027000000000000000044C62" class="pcalibre1 pcalibre2 pcalibre40">Callq 0x4005c0 # call addvec() (1 to line 4005c0: jmpq below)</p></li>
<li id="P7000497027000000000000000044C63" data-uri="chapter07.xhtml#P7000497027000000000000000044C63" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C64" data-uri="chapter07.xhtml#P7000497027000000000000000044C64" class="pcalibre1 pcalibre2 pcalibre40">Procedure linkage table (PLT):</p>
<ul id="P7000497027000000000000000044C65" data-uri="chapter07.xhtml#P7000497027000000000000000044C65" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000044C66" data-uri="chapter07.xhtml#P7000497027000000000000000044C66" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C67" data-uri="chapter07.xhtml#P7000497027000000000000000044C67" class="pcalibre1 pcalibre2 pcalibre40"># PLT[0]: call dynamic linker</p></li>
<li id="P7000497027000000000000000044C68" data-uri="chapter07.xhtml#P7000497027000000000000000044C68" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C69" data-uri="chapter07.xhtml#P7000497027000000000000000044C69" class="pcalibre1 pcalibre2 pcalibre40">4005a0: pushq *GOT[1]</p></li>
<li id="P7000497027000000000000000044C6A" data-uri="chapter07.xhtml#P7000497027000000000000000044C6A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C6B" data-uri="chapter07.xhtml#P7000497027000000000000000044C6B" class="pcalibre1 pcalibre2 pcalibre40">4005a6: jmpq *GOT[2]</p></li>
<li id="P7000497027000000000000000044C6C" data-uri="chapter07.xhtml#P7000497027000000000000000044C6C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C6D" data-uri="chapter07.xhtml#P7000497027000000000000000044C6D" class="pcalibre1 pcalibre2 pcalibre40">…</p></li>
<li id="P7000497027000000000000000044C6E" data-uri="chapter07.xhtml#P7000497027000000000000000044C6E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C6F" data-uri="chapter07.xhtml#P7000497027000000000000000044C6F" class="pcalibre1 pcalibre2 pcalibre40"># PLT[2]: call addvec()</p></li>
<li id="P7000497027000000000000000044C70" data-uri="chapter07.xhtml#P7000497027000000000000000044C70" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C71" data-uri="chapter07.xhtml#P7000497027000000000000000044C71" class="pcalibre1 pcalibre2 pcalibre40">4005c0: jmpq *GOT[4] (2)</p></li>
<li id="P7000497027000000000000000044C72" data-uri="chapter07.xhtml#P7000497027000000000000000044C72" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C73" data-uri="chapter07.xhtml#P7000497027000000000000000044C73" class="pcalibre1 pcalibre2 pcalibre40">4005c6: pushq $0x1</p></li>
<li id="P7000497027000000000000000044C74" data-uri="chapter07.xhtml#P7000497027000000000000000044C74" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C75" data-uri="chapter07.xhtml#P7000497027000000000000000044C75" class="pcalibre1 pcalibre2 pcalibre40">4005cb: jmpq 4005a0</p></li>
</ul></li></ul></li></ul></li>
</ol>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P7000497027000000000000000044C76" data-uri="chapter07.xhtml#P7000497027000000000000000044C76"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000645F" title="707" data-uri="chapter07.xhtml#P700049702700000000000000000645F" epub:type="pagebreak"></span>these entries is responsible for invoking a specific function. <code id="P7000497027000000000000000044C77" data-uri="chapter07.xhtml#P7000497027000000000000000044C77" class="pcalibre1 calibre1 pcalibre2">PLT[1]</code> (not shown here) invokes the system startup function (<code id="P7000497027000000000000000044C78" data-uri="chapter07.xhtml#P7000497027000000000000000044C78" class="pcalibre1 calibre1 pcalibre2">__libc_start_main</code>), which initializes the execution environment, calls the main function, and handles its return value. Entries starting at <code id="P7000497027000000000000000044C79" data-uri="chapter07.xhtml#P7000497027000000000000000044C79" class="pcalibre1 calibre1 pcalibre2">PLT[2]</code> invoke functions called by the user code. In our example, <code id="P7000497027000000000000000044C7A" data-uri="chapter07.xhtml#P7000497027000000000000000044C7A" class="pcalibre1 calibre1 pcalibre2">PLT[2]</code> invokes <code id="P7000497027000000000000000044C7B" data-uri="chapter07.xhtml#P7000497027000000000000000044C7B" class="pcalibre1 calibre1 pcalibre2">addvec</code> and <code id="P7000497027000000000000000044C7C" data-uri="chapter07.xhtml#P7000497027000000000000000044C7C" class="pcalibre1 calibre1 pcalibre2">PLT[3]</code> (not shown) invokes <code id="P7000497027000000000000000044C7D" data-uri="chapter07.xhtml#P7000497027000000000000000044C7D" class="pcalibre1 calibre1 pcalibre2">printf</code>.</p></li>
<li id="P7000497027000000000000000044C7E" data-uri="chapter07.xhtml#P7000497027000000000000000044C7E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044C7F" data-uri="chapter07.xhtml#P7000497027000000000000000044C7F" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Global offset table (GOT). </span>As we have seen, the GOT is an array of 8-byte address entries. When used in conjunction with the PLT, <code id="P7000497027000000000000000044C80" data-uri="chapter07.xhtml#P7000497027000000000000000044C80" class="pcalibre1 calibre1 pcalibre2">GOT[0]</code> and <code id="P7000497027000000000000000044C81" data-uri="chapter07.xhtml#P7000497027000000000000000044C81" class="pcalibre1 calibre1 pcalibre2">GOT[1]</code> contain information that the dynamic linker uses when it resolves function addresses. <code id="P7000497027000000000000000044C82" data-uri="chapter07.xhtml#P7000497027000000000000000044C82" class="pcalibre1 calibre1 pcalibre2">GOT[2]</code> is the entry point for the dynamic linker in the <code id="P7000497027000000000000000044C83" data-uri="chapter07.xhtml#P7000497027000000000000000044C83" class="pcalibre1 calibre1 pcalibre2">ld-linux.so</code> module. Each of the remaining entries corresponds to a called function whose address needs to be resolved at run time. Each has a matching PLT entry. For example, <code id="P7000497027000000000000000044C84" data-uri="chapter07.xhtml#P7000497027000000000000000044C84" class="pcalibre1 calibre1 pcalibre2">GOT[4]</code> and <code id="P7000497027000000000000000044C85" data-uri="chapter07.xhtml#P7000497027000000000000000044C85" class="pcalibre1 calibre1 pcalibre2">PLT[2]</code> correspond to <code id="P7000497027000000000000000044C86" data-uri="chapter07.xhtml#P7000497027000000000000000044C86" class="pcalibre1 calibre1 pcalibre2">addvec</code>. Initially, each GOT entry points to the second instruction in the corresponding PLT entry.</p></li>
</ul>
<p id="P7000497027000000000000000044C87" data-uri="chapter07.xhtml#P7000497027000000000000000044C87" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006457"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">7.19(a)</span></a> shows how the GOT and PLT work together to lazily resolve the run-time address of function <code id="P7000497027000000000000000044C88" data-uri="chapter07.xhtml#P7000497027000000000000000044C88" class="pcalibre1 calibre1 pcalibre2">addvec</code> the first time it is called:</p>
<ol class="pcalibre1 pcalibre2 pcalibre235" id="P7000497027000000000000000044C89" data-uri="chapter07.xhtml#P7000497027000000000000000044C89">
<li class="pcalibre39 pcalibre2 pcalibre1" id="P7000497027000000000000000044C8A" data-uri="chapter07.xhtml#P7000497027000000000000000044C8A"><p id="P7000497027000000000000000044C8B" data-uri="chapter07.xhtml#P7000497027000000000000000044C8B" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre21 pcalibre2">Step </span><span class="pcalibre1 pcalibre21 pcalibre2">1. </span>Instead of directly calling <code id="P7000497027000000000000000044C8C" data-uri="chapter07.xhtml#P7000497027000000000000000044C8C" class="pcalibre1 calibre1 pcalibre2">addvec</code>, the program calls into <code id="P7000497027000000000000000044C8D" data-uri="chapter07.xhtml#P7000497027000000000000000044C8D" class="pcalibre1 calibre1 pcalibre2">PLT[2]</code>, which is the PLT entry for <code id="P7000497027000000000000000044C8E" data-uri="chapter07.xhtml#P7000497027000000000000000044C8E" class="pcalibre1 calibre1 pcalibre2">addvec</code>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" id="P7000497027000000000000000044C8F" data-uri="chapter07.xhtml#P7000497027000000000000000044C8F"><p id="P7000497027000000000000000044C90" data-uri="chapter07.xhtml#P7000497027000000000000000044C90" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre21 pcalibre2">Step </span><span class="pcalibre1 pcalibre21 pcalibre2">2.	 </span>The first PLT instruction does an indirect jump through <code id="P7000497027000000000000000044C91" data-uri="chapter07.xhtml#P7000497027000000000000000044C91" class="pcalibre1 calibre1 pcalibre2">GOT[4]</code>. Since each GOT entry initially points to the second instruction in its corresponding PLT entry, the indirect jump simply transfers control back to the next instruction in <code id="P7000497027000000000000000044C92" data-uri="chapter07.xhtml#P7000497027000000000000000044C92" class="pcalibre1 calibre1 pcalibre2">PLT[2]</code>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" id="P7000497027000000000000000044C93" data-uri="chapter07.xhtml#P7000497027000000000000000044C93"><p id="P7000497027000000000000000044C94" data-uri="chapter07.xhtml#P7000497027000000000000000044C94" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre21 pcalibre2">Step </span><span class="pcalibre1 pcalibre21 pcalibre2">3.	 </span>After pushing an ID for <code id="P7000497027000000000000000044C95" data-uri="chapter07.xhtml#P7000497027000000000000000044C95" class="pcalibre1 calibre1 pcalibre2">addvec (0x1)</code> onto the stack, <code id="P7000497027000000000000000044C96" data-uri="chapter07.xhtml#P7000497027000000000000000044C96" class="pcalibre1 calibre1 pcalibre2">PLT[2]</code> jumps to <code id="P7000497027000000000000000044C97" data-uri="chapter07.xhtml#P7000497027000000000000000044C97" class="pcalibre1 calibre1 pcalibre2">PLT[0]</code>.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" id="P7000497027000000000000000044C98" data-uri="chapter07.xhtml#P7000497027000000000000000044C98"><p id="P7000497027000000000000000044C99" data-uri="chapter07.xhtml#P7000497027000000000000000044C99" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre21 pcalibre2">Step </span><span class="pcalibre1 pcalibre21 pcalibre2">4.	 </span><code id="P7000497027000000000000000044C9A" data-uri="chapter07.xhtml#P7000497027000000000000000044C9A" class="pcalibre1 calibre1 pcalibre2">PLT[0]</code> pushes an argument for the dynamic linker indirectly through <code id="P7000497027000000000000000044C9B" data-uri="chapter07.xhtml#P7000497027000000000000000044C9B" class="pcalibre1 calibre1 pcalibre2">GOT[1]</code> and then jumps into the dynamic linker indirectly through <code id="P7000497027000000000000000044C9C" data-uri="chapter07.xhtml#P7000497027000000000000000044C9C" class="pcalibre1 calibre1 pcalibre2">GOT[2]</code>. The dynamic linker uses the two stack entries to determine the runtime location of <code id="P7000497027000000000000000044C9D" data-uri="chapter07.xhtml#P7000497027000000000000000044C9D" class="pcalibre1 calibre1 pcalibre2">addvec</code>, overwrites <code id="P7000497027000000000000000044C9E" data-uri="chapter07.xhtml#P7000497027000000000000000044C9E" class="pcalibre1 calibre1 pcalibre2">GOT[4]</code> with this address, and passes control to <code id="P7000497027000000000000000044C9F" data-uri="chapter07.xhtml#P7000497027000000000000000044C9F" class="pcalibre1 calibre1 pcalibre2">addvec</code>.</p></li>
</ol>
<p id="P7000497027000000000000000044CA0" data-uri="chapter07.xhtml#P7000497027000000000000000044CA0" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006457"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">7.19(b)</span></a> shows the control flow for any subsequent invocations of <code id="P7000497027000000000000000044CA1" data-uri="chapter07.xhtml#P7000497027000000000000000044CA1" class="pcalibre1 calibre1 pcalibre2">addvec</code>:</p>
<ol class="pcalibre1 pcalibre2 pcalibre235" id="P7000497027000000000000000044CA2" data-uri="chapter07.xhtml#P7000497027000000000000000044CA2">
<li class="pcalibre39 pcalibre2 pcalibre1" id="P7000497027000000000000000044CA3" data-uri="chapter07.xhtml#P7000497027000000000000000044CA3"> 
<p id="P7000497027000000000000000044CA4" data-uri="chapter07.xhtml#P7000497027000000000000000044CA4" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre21 pcalibre2">Step </span><span class="pcalibre1 pcalibre21 pcalibre2">1.	</span>Control passes to <code id="P7000497027000000000000000044CA5" data-uri="chapter07.xhtml#P7000497027000000000000000044CA5" class="pcalibre1 calibre1 pcalibre2">PLT[2]</code> as before.</p></li>
<li class="pcalibre39 pcalibre2 pcalibre1" id="P7000497027000000000000000044CA6" data-uri="chapter07.xhtml#P7000497027000000000000000044CA6"> 
<p id="P7000497027000000000000000044CA7" data-uri="chapter07.xhtml#P7000497027000000000000000044CA7" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre21 pcalibre2">Step </span><span class="pcalibre1 pcalibre21 pcalibre2">2.	</span>However, this time the indirect jump through <code id="P7000497027000000000000000044CA8" data-uri="chapter07.xhtml#P7000497027000000000000000044CA8" class="pcalibre1 calibre1 pcalibre2">GOT[4]</code> transfers control directly to <code id="P7000497027000000000000000044CA9" data-uri="chapter07.xhtml#P7000497027000000000000000044CA9" class="pcalibre1 calibre1 pcalibre2">addvec</code>.</p></li>
</ol>
</section>
</section>
</section></body></html>
