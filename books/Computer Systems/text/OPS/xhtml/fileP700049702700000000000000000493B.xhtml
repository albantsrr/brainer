<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.2 Expressing Program Performance</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P700049702700000000000000000493B" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000043082" data-uri="chapter05.xhtml#P7000497027000000000000000043082" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.2 </span>Expressing Program Performance</h1></header>
<p id="P7000497027000000000000000043083" data-uri="chapter05.xhtml#P7000497027000000000000000043083" class="pcalibre8 pcalibre1 pcalibre2">We introduce the metric <i class="pcalibre17 pcalibre2 pcalibre1">cycles per element</i>, abbreviated CPE, to express program performance in a way that can guide us in improving the code. CPE measurements help us understand the loop performance of an iterative program at a detailed level. It is appropriate for programs that perform a repetitive computation, such as processing the pixels in an image or computing the elements in a matrix product.</p>
<p id="P7000497027000000000000000043084" data-uri="chapter05.xhtml#P7000497027000000000000000043084" class="pcalibre8 pcalibre1 pcalibre2">The sequencing of activities by a processor is controlled by a clock providing a regular signal of some frequency, usually expressed in <i class="pcalibre17 pcalibre2 pcalibre1">gigahertz</i> (GHz), billions of cycles per second. For example, when product literature characterizes a system as a "4 GHz" processor, it means that the processor clock runs at 4.0 × 10<sup class="pcalibre1 pcalibre2 pcalibre85">−9</sup> cycles per second. The time required for each clock cycle is given by the reciprocal of the clock frequency. These typically are expressed in <i class="pcalibre17 pcalibre2 pcalibre1">nanoseconds</i> (1 nanosecond is 10<sup class="pcalibre1 pcalibre2 pcalibre85">−9</sup> seconds) or <i class="pcalibre17 pcalibre2 pcalibre1">picoseconds</i> (1 picosecond is 10<sup class="pcalibre1 pcalibre2 pcalibre85">−12</sup> seconds). For example, the period of a 4 GHz clock can be expressed as either 0.25 nanoseconds or 250 picoseconds. From a programmer's perspective, it is more instructive to express measurements in clock cycles rather than nanoseconds or picoseconds. That way, the measurements express how many instructions are being executed rather than how fast the clock runs.</p>
<p id="P7000497027000000000000000043085" data-uri="chapter05.xhtml#P7000497027000000000000000043085" class="pcalibre8 pcalibre1 pcalibre2">Many procedures contain a loop that iterates over a set of elements. For example, functions <code id="P7000497027000000000000000043086" data-uri="chapter05.xhtml#P7000497027000000000000000043086" class="pcalibre1 calibre1 pcalibre2">psum1</code> and <code id="P7000497027000000000000000043087" data-uri="chapter05.xhtml#P7000497027000000000000000043087" class="pcalibre1 calibre1 pcalibre2">psum2</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004949"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.1</span></a> both compute the <i class="pcalibre17 pcalibre2 pcalibre1">prefix sum</i> of a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. For a vector <span class="pcalibre1 inlineequation pcalibre2"><m:math display="inline" alttext="" data-uri="" altimg-width="139" altimg-height="16" altimg="../images/ch05-1.png"><m:mrow><m:mover accent="true"><m:mi>a</m:mi><m:mo>→</m:mo></m:mover><m:mo>=</m:mo><m:mrow><m:mo>〈</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mtext> </m:mtext><m:mo>,</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow><m:mo>〉</m:mo></m:mrow></m:mrow></m:math></span>, the prefix sum <span class="pcalibre1 inlineequation pcalibre2"><m:math display="inline" alttext="" data-uri="" altimg-width="201" altimg-height="21" altimg="../images/ch05-2.png"><m:mrow><m:mover accent="true"><m:mi>p</m:mi><m:mo>→</m:mo></m:mover><m:mo>=</m:mo><m:mrow><m:mo>〈</m:mo><m:mrow><m:msub><m:mi>p</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>p</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mtext> </m:mtext><m:mo>,</m:mo><m:msub><m:mi>p</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow><m:mo>〉</m:mo></m:mrow></m:mrow></m:math> </span>is defined as</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000043088" data-uri="chapter05.xhtml#P7000497027000000000000000043088">
<m:math display="block" alttext="" data-uri="" altimg-width="236" altimg-height="51" altimg="../images/ch05-3.png"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>p</m:mi><m:mn>0</m:mn></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>p</m:mi><m:mi>i</m:mi></m:msub><m:mo>=</m:mo><m:msub><m:mi>p</m:mi><m:mrow><m:mi>i</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mi>i</m:mi></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:mn>1</m:mn><m:mo>&lt;</m:mo><m:mi>i</m:mi><m:mo>&lt;</m:mo><m:mi>n</m:mi></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
<span class="pcalibre1 pcalibre76 pcalibre2">(5.1)</span>
</div>
<p id="P7000497027000000000000000043089" data-uri="chapter05.xhtml#P7000497027000000000000000043089" class="pcalibre8 pcalibre1 pcalibre2">Function <code id="P700049702700000000000000004308A" data-uri="chapter05.xhtml#P700049702700000000000000004308A" class="pcalibre1 calibre1 pcalibre2">psum1</code> computes one element of the result vector per iteration. Function <code id="P700049702700000000000000004308B" data-uri="chapter05.xhtml#P700049702700000000000000004308B" class="pcalibre1 calibre1 pcalibre2">psum2</code> uses a technique known as <i class="pcalibre17 pcalibre2 pcalibre1">loop unrolling</i> to compute two elements per iteration. We will explore the benefits of loop unrolling later in this chapter. (See Problems 5.11,5.12, and 5.19 for more about analyzing and optimizing the prefix-sum computation.)</p>
<p id="P700049702700000000000000004308C" data-uri="chapter05.xhtml#P700049702700000000000000004308C" class="pcalibre8 pcalibre1 pcalibre2">The time required by such a procedure can be characterized as a constant plus a factor proportional to the number of elements processed. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004951"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.2</span></a> shows a plot of the number of clock cycles required by the two functions for a range of values of <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. Using a <i class="pcalibre17 pcalibre2 pcalibre1">least squares fit</i>, we find that the run times (in clock cycles) for <code id="P700049702700000000000000004308D" data-uri="chapter05.xhtml#P700049702700000000000000004308D" class="pcalibre1 calibre1 pcalibre2">psum1</code> and <code id="P700049702700000000000000004308E" data-uri="chapter05.xhtml#P700049702700000000000000004308E" class="pcalibre1 calibre1 pcalibre2">psum2</code> can be approximated by the equations 368 + 9.0<var class="pcalibre17 pcalibre2 pcalibre1">n</var> and 368 + 6.0<var class="pcalibre17 pcalibre2 pcalibre1">n</var>, respectively. These equations indicate an overhead of 368 cycles due to the timing code and to initiate the procedure, set up the loop, and complete the</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004949" data-uri="chapter05.xhtml#P7000497027000000000000000004949">
<pre id="P700049702700000000000000004308F" data-uri="chapter05.xhtml#P700049702700000000000000004308F" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043090" data-uri="chapter05.xhtml#P7000497027000000000000000043090" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre123" id="P700049702700000000000000000494C" title="503" data-uri="chapter05.xhtml#P700049702700000000000000000494C" epub:type="pagebreak"></span>1	/* Compute prefix sum of vector a */
2	void pum1(float a[], float p[], long n)
3	{
4		long i;
5		p[0] = a[0];
6		for (i = 1; i &lt; n; i++)
7			p[i] = p[i-1] + a[i];
8	}
9	
10	void psum2(float a[], float p[], long n)
11	{
12		long i;
13		p[0] = a[0];
14		for (i = 1; i &lt; n-1; i+=2) {
15			float mid_val = p[i-1] + a[i];
16			p[i] = mid_val;
17			p[i+1] = mid_val + a[i+1];
18 }
19	/* For even n, finish remaining element */
20	if (i &lt; n)
21			p[i] = p[i-1] + a[i];
22	}
</code></pre>
<figcaption id="P7000497027000000000000000043091" data-uri="chapter05.xhtml#P7000497027000000000000000043091" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043092" data-uri="chapter05.xhtml#P7000497027000000000000000043092" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.1 </span>Prefix-sum functions.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000043093" data-uri="chapter05.xhtml#P7000497027000000000000000043093"><p id="P7000497027000000000000000043094" data-uri="chapter05.xhtml#P7000497027000000000000000043094" class="pcalibre1 pcalibre2 pcalibre10">These functions provide examples for how we express program performance.</p></div></figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004951" data-uri="chapter05.xhtml#P7000497027000000000000000004951">
<img alt="A graph of cycles versus elements shows two lines, the higher representing psum1 with slope = 9 and the lower representing psum2 with slope = 6." id="P7000497027000000000000000043095" data-uri="P700049702700000000000000000B70D" src="../images/p503-1.png" class="pcalibre1 pcalibre2 calibre43"/>
<figcaption id="P7000497027000000000000000043096" data-uri="chapter05.xhtml#P7000497027000000000000000043096" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043097" data-uri="chapter05.xhtml#P7000497027000000000000000043097" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.2 </span>Performance of prefix-sum functions.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000043098" data-uri="chapter05.xhtml#P7000497027000000000000000043098"><p id="P7000497027000000000000000043099" data-uri="chapter05.xhtml#P7000497027000000000000000043099" class="pcalibre1 pcalibre2 pcalibre10">The slope of the lines indicates the number of clock cycles per element (CPE).</p></div></figcaption></figure>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000004957" data-uri="chapter05.xhtml#P7000497027000000000000000004957"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P700049702700000000000000004309A" data-uri="chapter05.xhtml#P700049702700000000000000004309A" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004959" title="504" data-uri="chapter05.xhtml#P7000497027000000000000000004959" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>What is a least squares fit?</h1></header>
<p id="P700049702700000000000000004309B" data-uri="chapter05.xhtml#P700049702700000000000000004309B" class="pcalibre1 pcalibre2 pcalibre40">For a set of data points (<var class="pcalibre17 pcalibre2 pcalibre1">x</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">y</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>),. . . (<i class="pcalibre17 pcalibre2 pcalibre1">x<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i>, <i class="pcalibre17 pcalibre2 pcalibre1">y<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i>), we often try to draw a line that best approximates the X-Y trend represented by these data. With a least squares fit, we look for a line of the form <i class="pcalibre17 pcalibre2 pcalibre1">y = mx</i> + <var class="pcalibre17 pcalibre2 pcalibre1">b</var> that minimizes the following error measure:</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P700049702700000000000000004309C" data-uri="chapter05.xhtml#P700049702700000000000000004309C">
<m:math display="block" alttext="" data-uri="" altimg-width="184" altimg-height="34" altimg="../images/ch05-4.png"><m:mrow><m:mi>E</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>m</m:mi><m:mo>,</m:mo><m:mi>b</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:munder><m:mo>∑</m:mo><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mi>n</m:mi></m:mrow></m:munder><m:mrow><m:msup><m:mrow><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>m</m:mi><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>+</m:mo><m:mi>b</m:mi><m:mo>-</m:mo><m:msub><m:mi>y</m:mi><m:mi>i</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow><m:mn>2</m:mn></m:msup></m:mrow></m:mrow></m:math>
</div>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P700049702700000000000000004309D" data-uri="chapter05.xhtml#P700049702700000000000000004309D">An algorithm for computing <var class="pcalibre17 pcalibre2 pcalibre1">m</var> and <var class="pcalibre17 pcalibre2 pcalibre1">b</var> can be derived by finding the derivatives of <i class="pcalibre17 pcalibre2 pcalibre1">E(m, b)</i> with respect to <var class="pcalibre17 pcalibre2 pcalibre1">m</var> and <var class="pcalibre17 pcalibre2 pcalibre1">b</var> and setting them to 0.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004309E" data-uri="chapter05.xhtml#P700049702700000000000000004309E">procedure, plus a linear factor of 6.0 or 9.0 cycles per element. For large values of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> (say, greater than 200), the run times will be dominated by the linear factors. We refer to the coefficients in these terms as the effective number of cycles per element. We prefer measuring the number of cycles per <i class="pcalibre17 pcalibre2 pcalibre1">element</i> rather than the number of cycles per <i class="pcalibre17 pcalibre2 pcalibre1">iteration</i>, because techniques such as loop unrolling allow us to use fewer iterations to complete the computation, but our ultimate concern is how fast the procedure will run for a given vector length. We focus our efforts on minimizing the CPE for our computations. By this measure, <code id="P700049702700000000000000004309F" data-uri="chapter05.xhtml#P700049702700000000000000004309F" class="pcalibre1 calibre1 pcalibre2">psum2</code>, with a CPE of 6.0, is superior to <code id="P70004970270000000000000000430A0" data-uri="chapter05.xhtml#P70004970270000000000000000430A0" class="pcalibre1 calibre1 pcalibre2">psum1</code>, with a CPE of 9.0.</p>
<section id="P7000497027000000000000000004960" data-uri="chapter05.xhtml#P7000497027000000000000000004960" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000430A1" data-uri="chapter05.xhtml#P70004970270000000000000000430A1" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.2 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000005090.xhtml#P70004970270000000000000000050DD">573</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000430A2" data-uri="chapter05.xhtml#P70004970270000000000000000430A2">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000430A3" data-uri="chapter05.xhtml#P70004970270000000000000000430A3">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000430A4" data-uri="chapter05.xhtml#P70004970270000000000000000430A4"><p id="P70004970270000000000000000430A5" data-uri="chapter05.xhtml#P70004970270000000000000000430A5" class="pcalibre1 pcalibre2 pcalibre10">Later in this chapter we will start with a single function and generate many different variants that preserve the function's behavior, but with different performance characteristics. For three of these variants, we found that the run times (in clock cycles) can be approximated by the following functions:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P70004970270000000000000000430A6" data-uri="chapter05.xhtml#P70004970270000000000000000430A6">
<li id="P70004970270000000000000000430A7" data-uri="chapter05.xhtml#P70004970270000000000000000430A7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000430A8" data-uri="chapter05.xhtml#P70004970270000000000000000430A8" class="pcalibre1 pcalibre2 pcalibre40">Version 1: 60 + 35<var class="pcalibre17 pcalibre2 pcalibre1">n</var></p></li>
<li id="P70004970270000000000000000430A9" data-uri="chapter05.xhtml#P70004970270000000000000000430A9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000430AA" data-uri="chapter05.xhtml#P70004970270000000000000000430AA" class="pcalibre1 pcalibre2 pcalibre40">Version 2: 136 + 4<var class="pcalibre17 pcalibre2 pcalibre1">n</var></p></li>
<li id="P70004970270000000000000000430AB" data-uri="chapter05.xhtml#P70004970270000000000000000430AB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000430AC" data-uri="chapter05.xhtml#P70004970270000000000000000430AC" class="pcalibre1 pcalibre2 pcalibre40">Version 3: 157 + 1.25<var class="pcalibre17 pcalibre2 pcalibre1">n</var></p></li>
</ul>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000430AD" data-uri="chapter05.xhtml#P70004970270000000000000000430AD">For what values of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> would each version be the fastest of the three? Remember that <var class="pcalibre17 pcalibre2 pcalibre1">n</var> will always be an integer.</p></div></li>
</ol>
</section>
</section></body></html>
