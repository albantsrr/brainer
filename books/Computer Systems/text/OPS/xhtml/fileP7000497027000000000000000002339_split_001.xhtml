<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>3.6 Control</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000002339" class="pcalibre1 pcalibre2 pcalibre3">
<section id="P7000497027000000000000000002578" data-uri="chapter03.xhtml#P7000497027000000000000000002578" class="pcalibre1 pcalibre2 pcalibre3">
<section id="P700049702700000000000000000263D" data-uri="chapter03.xhtml#P700049702700000000000000000263D" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000408B0" data-uri="chapter03.xhtml#P70004970270000000000000000408B0" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000263F" title="219" data-uri="chapter03.xhtml#P700049702700000000000000000263F" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.20 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_000.xhtml#P7000497027000000000000000003611">333</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000408B1" data-uri="chapter03.xhtml#P70004970270000000000000000408B1">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000408B2" data-uri="chapter03.xhtml#P70004970270000000000000000408B2">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000408B3" data-uri="chapter03.xhtml#P70004970270000000000000000408B3"><p id="P70004970270000000000000000408B4" data-uri="chapter03.xhtml#P70004970270000000000000000408B4" class="pcalibre1 pcalibre2 pcalibre10">In the following C function, we have left the definition of operation <code id="P70004970270000000000000000408B5" data-uri="chapter03.xhtml#P70004970270000000000000000408B5" class="pcalibre1 calibre1 pcalibre2">OP</code> incomplete:</p>
<pre id="P70004970270000000000000000408B6" data-uri="chapter03.xhtml#P70004970270000000000000000408B6" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000408B7" data-uri="chapter03.xhtml#P70004970270000000000000000408B7" class="calibre3 pcalibre1 pcalibre2">
#define OP __________/* Unknown operator */
long arith(long x) {
	return x OP 8;
}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000408B8" data-uri="chapter03.xhtml#P70004970270000000000000000408B8">When compiled, <code id="P70004970270000000000000000408B9" data-uri="chapter03.xhtml#P70004970270000000000000000408B9" class="pcalibre1 calibre1 pcalibre2"><span class="pcalibre1 pcalibre29 pcalibre2">gcc</span></code> generates the following assembly code:</p>
<pre id="P70004970270000000000000000408BA" data-uri="chapter03.xhtml#P70004970270000000000000000408BA" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000408BB" data-uri="chapter03.xhtml#P70004970270000000000000000408BB" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long arith(long x</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi</i>
arith:
  leaq 7(%rdi), %rax
  testq %rdi, %rdi
  cmovns %rdi, %rax
  sarq $3, %rax
  ret
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000408BC" data-uri="chapter03.xhtml#P70004970270000000000000000408BC">
<li id="P70004970270000000000000000408BD" data-uri="chapter03.xhtml#P70004970270000000000000000408BD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000408BE" data-uri="chapter03.xhtml#P70004970270000000000000000408BE" class="pcalibre1 pcalibre2 pcalibre10">What operation is <code id="P70004970270000000000000000408BF" data-uri="chapter03.xhtml#P70004970270000000000000000408BF" class="pcalibre1 calibre1 pcalibre2">OP</code>?</p></li>
<li id="P70004970270000000000000000408C0" data-uri="chapter03.xhtml#P70004970270000000000000000408C0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000408C1" data-uri="chapter03.xhtml#P70004970270000000000000000408C1" class="pcalibre1 pcalibre2 pcalibre10">Annotate the code to explain how it works.</p></li>
</ol></div></li></ol>
</section>
<section id="P7000497027000000000000000002651" data-uri="chapter03.xhtml#P7000497027000000000000000002651" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000408C2" data-uri="chapter03.xhtml#P70004970270000000000000000408C2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.21 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_000.xhtml#P7000497027000000000000000003611">333</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000408C3" data-uri="chapter03.xhtml#P70004970270000000000000000408C3">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000408C4" data-uri="chapter03.xhtml#P70004970270000000000000000408C4">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000408C5" data-uri="chapter03.xhtml#P70004970270000000000000000408C5"><p id="P70004970270000000000000000408C6" data-uri="chapter03.xhtml#P70004970270000000000000000408C6" class="pcalibre1 pcalibre2 pcalibre10">Starting with C code of the form</p>
<pre id="P70004970270000000000000000408C7" data-uri="chapter03.xhtml#P70004970270000000000000000408C7" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000408C8" data-uri="chapter03.xhtml#P70004970270000000000000000408C8" class="calibre3 pcalibre1 pcalibre2">
long test(long x, long y) {
	long val = __________;
	if (__________) {
		if (__________)
			val = __________;
		else
			val = __________;
	} else if (__________)
		val = __________;
	return val;
}
</code></pre>
<p id="P70004970270000000000000000408C9" data-uri="chapter03.xhtml#P70004970270000000000000000408C9" class="pcalibre1 pcalibre2 pcalibre10"><code id="P70004970270000000000000000408CA" data-uri="chapter03.xhtml#P70004970270000000000000000408CA" class="pcalibre1 calibre1 pcalibre2"><span class="pcalibre1 pcalibre29 pcalibre2">gcc</span></code> generates the following assembly code:</p>
<pre id="P70004970270000000000000000408CB" data-uri="chapter03.xhtml#P70004970270000000000000000408CB" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000408CC" data-uri="chapter03.xhtml#P70004970270000000000000000408CC" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long test(long x, long y</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi, y in %rsi</i>
	test:
	  leaq	0(,%rdi,8), %rax
	  testq	%rsi, %rsi
	  jle	.L2
	  <span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000265D" title="220" data-uri="chapter03.xhtml#P700049702700000000000000000265D" epub:type="pagebreak"></span>movq %rsi, %rax
	  subq %rdi, %rax
	  movq %rdi, %rdx
	  andq %rsi, %rdx
	  cmpq %rsi, %rdi
	  cmovge %rdx, %rax
	  ret
	.L2:
	  addq %rsi, %rdi
	  cmpq $-2, %rsi
	  cmovle %rdi, %rax
	  ret
</code></pre>

<p id="P70004970270000000000000000408CD" data-uri="chapter03.xhtml#P70004970270000000000000000408CD" class="pcalibre1 pcalibre2 pcalibre10">Fill in the missing expressions in the C code.</p>
</div></li></ol>
</section>
</section>
<section id="P700049702700000000000000000265F" data-uri="chapter03.xhtml#P700049702700000000000000000265F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000408CE" data-uri="chapter03.xhtml#P70004970270000000000000000408CE" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.6.7 </span>Loops</h1></header>
<p id="P70004970270000000000000000408CF" data-uri="chapter03.xhtml#P70004970270000000000000000408CF" class="pcalibre8 pcalibre1 pcalibre2">C provides several looping constructsâ€”namely, <code id="P70004970270000000000000000408D0" data-uri="chapter03.xhtml#P70004970270000000000000000408D0" class="pcalibre1 calibre1 pcalibre2">do-while, while</code>, and <code id="P70004970270000000000000000408D1" data-uri="chapter03.xhtml#P70004970270000000000000000408D1" class="pcalibre1 calibre1 pcalibre2">for</code>. No corresponding instructions exist in machine code. Instead, combinations of conditional tests and jumps are used to implement the effect of loops. <code id="P70004970270000000000000000408D2" data-uri="chapter03.xhtml#P70004970270000000000000000408D2" class="pcalibre1 calibre1 pcalibre2">G<span class="pcalibre1 pcalibre29 pcalibre2">cc</span></code> and other compilers generate loop code based on the two basic loop patterns. We will study the translation of loops as a progression, starting with <code id="P70004970270000000000000000408D3" data-uri="chapter03.xhtml#P70004970270000000000000000408D3" class="pcalibre1 calibre1 pcalibre2">do-while</code> and then working toward ones with more complex implementations, covering both patterns.</p>
<section id="P7000497027000000000000000002666" data-uri="chapter03.xhtml#P7000497027000000000000000002666" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000408D4" data-uri="chapter03.xhtml#P70004970270000000000000000408D4" epub:type="title">Do-While Loops</h1></header>
<p id="P70004970270000000000000000408D5" data-uri="chapter03.xhtml#P70004970270000000000000000408D5" class="pcalibre8 pcalibre1 pcalibre2">The general form of a <code id="P70004970270000000000000000408D6" data-uri="chapter03.xhtml#P70004970270000000000000000408D6" class="pcalibre1 calibre1 pcalibre2">do-while</code> statement is as follows:</p>
<pre id="P70004970270000000000000000408D7" data-uri="chapter03.xhtml#P70004970270000000000000000408D7" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000408D8" data-uri="chapter03.xhtml#P70004970270000000000000000408D8" class="calibre3 pcalibre1 pcalibre2">
do
	<i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>
	while (<i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>);
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000408D9" data-uri="chapter03.xhtml#P70004970270000000000000000408D9">The effect of the loop is to repeatedly execute <i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>, evaluate <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>, and continue the loop if the evaluation result is nonzero. Observe that <i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i> is executed at least once.</p>
<p id="P70004970270000000000000000408DA" data-uri="chapter03.xhtml#P70004970270000000000000000408DA" class="pcalibre8 pcalibre1 pcalibre2">This general form can be translated into conditionals and <code id="P70004970270000000000000000408DB" data-uri="chapter03.xhtml#P70004970270000000000000000408DB" class="pcalibre1 calibre1 pcalibre2">goto</code> statements as follows:</p>
<pre id="P70004970270000000000000000408DC" data-uri="chapter03.xhtml#P70004970270000000000000000408DC" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000408DD" data-uri="chapter03.xhtml#P70004970270000000000000000408DD" class="calibre3 pcalibre1 pcalibre2">
loop:
	<i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>
	t = <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>;
	if (t)
	  goto loop;
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000408DE" data-uri="chapter03.xhtml#P70004970270000000000000000408DE">That is, on each iteration the program evaluates the body statement and then the test expression. If the test succeeds, the program goes back for another iteration.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002672" data-uri="chapter03.xhtml#P7000497027000000000000000002672">
<p id="P70004970270000000000000000408DF" data-uri="chapter03.xhtml#P70004970270000000000000000408DF" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000002674" title="221" data-uri="chapter03.xhtml#P7000497027000000000000000002674" epub:type="pagebreak"></span>(a) C code</p>
<pre id="P70004970270000000000000000408E0" data-uri="chapter03.xhtml#P70004970270000000000000000408E0" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000408E1" data-uri="chapter03.xhtml#P70004970270000000000000000408E1" class="calibre3 pcalibre1 pcalibre2">
long fact_do(long n)
{
	long result = 1;
	do {
		result *= n;
		n = n-1;
	} while (n &gt; 1);
	return result;
}
</code></pre>
<p id="P70004970270000000000000000408E2" data-uri="chapter03.xhtml#P70004970270000000000000000408E2" class="pcalibre8 pcalibre1 pcalibre2">(b) Equivalent goto version</p>
<pre id="P70004970270000000000000000408E3" data-uri="chapter03.xhtml#P70004970270000000000000000408E3" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000408E4" data-uri="chapter03.xhtml#P70004970270000000000000000408E4" class="calibre3 pcalibre1 pcalibre2">
long fact_do_goto(long n)
{
	long result = 1;
loop:
	result *= n;
	n = n-1;
	if (n &gt; 1)
		goto loop;
	return result;
}
</code></pre>
<p id="P70004970270000000000000000408E5" data-uri="chapter03.xhtml#P70004970270000000000000000408E5" class="pcalibre8 pcalibre1 pcalibre2">(c) Corresponding assembly-language code</p>
<pre id="P70004970270000000000000000408E6" data-uri="chapter03.xhtml#P70004970270000000000000000408E6" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000408E7" data-uri="chapter03.xhtml#P70004970270000000000000000408E7" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long fact_do(long n</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">n in %rdi</i>
1	fact_do:
2	  movl $1, %eax		  <i class="pcalibre17 pcalibre2 pcalibre1">Set result = 1</i>
3	.L2:				<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
4	  imulq	%rdi, %rax	  <i class="pcalibre17 pcalibre2 pcalibre1">Compute result *= n</i>
5	  subq	$1, %rdi	  <i class="pcalibre17 pcalibre2 pcalibre1">Decrement n</i>
6	  cmpq	$1, %rdi	  <i class="pcalibre17 pcalibre2 pcalibre1">Compare n:1</i>
7	  jg	.L2 <i class="pcalibre17 pcalibre2 pcalibre1">If &gt;,	  goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">loop</b>
8	  rep; ret		  <i class="pcalibre17 pcalibre2 pcalibre1">Return</i>
</code></pre>
<figcaption id="P70004970270000000000000000408E8" data-uri="chapter03.xhtml#P70004970270000000000000000408E8" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000408E9" data-uri="chapter03.xhtml#P70004970270000000000000000408E9" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.19 </span>Code for <code id="P70004970270000000000000000408EA" data-uri="chapter03.xhtml#P70004970270000000000000000408EA" class="pcalibre1 calibre1 pcalibre2">do-while</code> version of factorial program.</h1></header><div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000408EB" data-uri="chapter03.xhtml#P70004970270000000000000000408EB"><p id="P70004970270000000000000000408EC" data-uri="chapter03.xhtml#P70004970270000000000000000408EC" class="pcalibre1 pcalibre2 pcalibre10">A conditional jump causes the program to loop.</p></div></figcaption>
</figure>
<p id="P70004970270000000000000000408ED" data-uri="chapter03.xhtml#P70004970270000000000000000408ED" class="pcalibre8 pcalibre1 pcalibre2">As an example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002672"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.19(a)</span></a> shows an implementation of a routine to compute the factorial of its argument, written <var class="pcalibre17 pcalibre2 pcalibre1">n</var>!, with a do-while loop. This function only computes the proper value for <var class="pcalibre17 pcalibre2 pcalibre1">n</var> &gt; 0.</p>
<section id="P7000497027000000000000000002683" data-uri="chapter03.xhtml#P7000497027000000000000000002683" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P70004970270000000000000000408EE" data-uri="chapter03.xhtml#P70004970270000000000000000408EE" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.22 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_000.xhtml#P7000497027000000000000000003611">333</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre128" id="P70004970270000000000000000408EF" data-uri="chapter03.xhtml#P70004970270000000000000000408EF">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000408F0" data-uri="chapter03.xhtml#P70004970270000000000000000408F0">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000408F1" data-uri="chapter03.xhtml#P70004970270000000000000000408F1"><p id="P70004970270000000000000000408F2" data-uri="chapter03.xhtml#P70004970270000000000000000408F2" class="pcalibre1 pcalibre2 pcalibre10">What is the maximum value of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> for which we can represent <var class="pcalibre17 pcalibre2 pcalibre1">n</var>! with a 32-bit <code id="P70004970270000000000000000408F3" data-uri="chapter03.xhtml#P70004970270000000000000000408F3" class="pcalibre1 calibre1 pcalibre2">int?</code></p></div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000408F4" data-uri="chapter03.xhtml#P70004970270000000000000000408F4">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000408F5" data-uri="chapter03.xhtml#P70004970270000000000000000408F5"><p id="P70004970270000000000000000408F6" data-uri="chapter03.xhtml#P70004970270000000000000000408F6" class="pcalibre1 pcalibre2 pcalibre10">What about for a 64-bit <code id="P70004970270000000000000000408F7" data-uri="chapter03.xhtml#P70004970270000000000000000408F7" class="pcalibre1 calibre1 pcalibre2">long?</code></p></div></li>
</ol>
</section>
<p id="P70004970270000000000000000408F8" data-uri="chapter03.xhtml#P70004970270000000000000000408F8" class="pcalibre8 pcalibre1 pcalibre2">The goto code shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002672"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.19(b)</span></a> shows how the loop gets turned into a lower-level combination of tests and conditional jumps. Following the initialization of <code id="P70004970270000000000000000408F9" data-uri="chapter03.xhtml#P70004970270000000000000000408F9" class="pcalibre1 calibre1 pcalibre2">result</code>, the program begins looping. First it executes the body of the loop, consisting here of updates to variables <code id="P70004970270000000000000000408FA" data-uri="chapter03.xhtml#P70004970270000000000000000408FA" class="pcalibre1 calibre1 pcalibre2">result</code> and <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. It then tests whether <var class="pcalibre17 pcalibre2 pcalibre1">n</var> &gt; 1, and, if so, it jumps back to the beginning of the loop. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002672"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.19(c)</span></a> shows</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000002691" data-uri="chapter03.xhtml#P7000497027000000000000000002691"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P70004970270000000000000000408FB" data-uri="chapter03.xhtml#P70004970270000000000000000408FB" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002693" title="222" data-uri="chapter03.xhtml#P7000497027000000000000000002693" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Reverse engineering loops</h1></header>
<p id="P70004970270000000000000000408FC" data-uri="chapter03.xhtml#P70004970270000000000000000408FC" class="pcalibre1 pcalibre2 pcalibre40">A key to understanding how the generated assembly code relates to the original source code is to find a mapping between program values and registers. This task was simple enough for the loop of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002672"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.19</span></a>, but it can be much more challenging for more complex programs. The C compiler will often rearrange the computations, so that some variables in the C code have no counterpart in the machine code, and new values are introduced into the machine code that do not exist in the source code. Moreover, it will often try to minimize register usage by mapping multiple program values onto a single register.</p>
<p id="P70004970270000000000000000408FD" data-uri="chapter03.xhtml#P70004970270000000000000000408FD" class="pcalibre1 pcalibre2 pcalibre10">The process we described for <code id="P70004970270000000000000000408FE" data-uri="chapter03.xhtml#P70004970270000000000000000408FE" class="pcalibre1 calibre1 pcalibre2">fact_do</code> works as a general strategy for reverse engineering loops. Look at how registers are initialized before the loop, updated and tested within the loop, and used after the loop. Each of these provides a clue that can be combined to solve a puzzle. Be prepared for surprising transformations, some of which are clearly cases where the compiler was able to optimize the code, and others where it is hard to explain why the compiler chose that particular strategy.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000408FF" data-uri="chapter03.xhtml#P70004970270000000000000000408FF">the assembly code from which the goto code was generated. The conditional jump instruction <code id="P7000497027000000000000000040900" data-uri="chapter03.xhtml#P7000497027000000000000000040900" class="pcalibre1 calibre1 pcalibre2">jg</code> (line 7) is the key instruction in implementing a loop. It determines whether to continue iterating or to exit the loop.</p>
<p id="P7000497027000000000000000040901" data-uri="chapter03.xhtml#P7000497027000000000000000040901" class="pcalibre8 pcalibre1 pcalibre2">Reverse engineering assembly code, such as that of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002672"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.19(c)</span></a>, requires determining which registers are used for which program values. In this case, the mapping is fairly simple to determine: We know that <var class="pcalibre17 pcalibre2 pcalibre1">n</var> will be passed to the function in register <code id="P7000497027000000000000000040902" data-uri="chapter03.xhtml#P7000497027000000000000000040902" class="pcalibre1 calibre1 pcalibre2">%rdi</code>. We can see register <code id="P7000497027000000000000000040903" data-uri="chapter03.xhtml#P7000497027000000000000000040903" class="pcalibre1 calibre1 pcalibre2">%rax</code> getting initialized to 1 (line 2). (Recall that, although the instruction has <code id="P7000497027000000000000000040904" data-uri="chapter03.xhtml#P7000497027000000000000000040904" class="pcalibre1 calibre1 pcalibre2">%eax</code> as its destination, it will also set the upper 4 bytes of <code id="P7000497027000000000000000040905" data-uri="chapter03.xhtml#P7000497027000000000000000040905" class="pcalibre1 calibre1 pcalibre2">%rax</code> to 0.) We can see that this register is also updated by multiplication on line 4. Furthermore, since <code id="P7000497027000000000000000040906" data-uri="chapter03.xhtml#P7000497027000000000000000040906" class="pcalibre1 calibre1 pcalibre2">%rax</code> is used to return the function value, it is often chosen to hold program values that are returned. We therefore conclude that <code id="P7000497027000000000000000040907" data-uri="chapter03.xhtml#P7000497027000000000000000040907" class="pcalibre1 calibre1 pcalibre2">%rax</code> corresponds to program value <code id="P7000497027000000000000000040908" data-uri="chapter03.xhtml#P7000497027000000000000000040908" class="pcalibre1 calibre1 pcalibre2">result</code>.</p>
<section id="P70004970270000000000000000026A1" data-uri="chapter03.xhtml#P70004970270000000000000000026A1" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P7000497027000000000000000040909" data-uri="chapter03.xhtml#P7000497027000000000000000040909" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.23 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_000.xhtml#P700049702700000000000000000362F">334</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004090A" data-uri="chapter03.xhtml#P700049702700000000000000004090A">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004090B" data-uri="chapter03.xhtml#P700049702700000000000000004090B">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004090C" data-uri="chapter03.xhtml#P700049702700000000000000004090C"><p id="P700049702700000000000000004090D" data-uri="chapter03.xhtml#P700049702700000000000000004090D" class="pcalibre1 pcalibre2 pcalibre10">For the C code</p>
<pre id="P700049702700000000000000004090E" data-uri="chapter03.xhtml#P700049702700000000000000004090E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004090F" data-uri="chapter03.xhtml#P700049702700000000000000004090F" class="calibre3 pcalibre1 pcalibre2">
long dw_loop(long x) {
    long y = x*x;
    long *p = &amp;x;
    long n = 2*x;
    do {
       x += y;
       (*p)++;
       n--;
    } while (n &gt; 0);
    return x;
}
</code></pre>
<p id="P7000497027000000000000000040910" data-uri="chapter03.xhtml#P7000497027000000000000000040910" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the following assembly code:</p>
<pre id="P7000497027000000000000000040911" data-uri="chapter03.xhtml#P7000497027000000000000000040911" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040912" data-uri="chapter03.xhtml#P7000497027000000000000000040912" class="calibre3 pcalibre1 pcalibre2">
	<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000026AC" title="223" data-uri="chapter03.xhtml#P70004970270000000000000000026AC" epub:type="pagebreak"></span><i class="pcalibre17 pcalibre2 pcalibre1">long dw_loop(long x</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">x initially in %rdi</i>
1	dw_loop:
2	  movq	%rdi, %rax
3	  movq	%rdi, %rcx
4	  imulq	%rdi, %rcx
5	  leaq	(%rdi,%rdi), %rdx
6	.L2:
7	  leaq	1(%rcx,%rax), %rax
8	  subq	$1, %rdx
9	  testq	%rdx, %rdx
10	  jg	.L2
11	  rep; ret
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000040913" data-uri="chapter03.xhtml#P7000497027000000000000000040913">
<li id="P7000497027000000000000000040914" data-uri="chapter03.xhtml#P7000497027000000000000000040914" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040915" data-uri="chapter03.xhtml#P7000497027000000000000000040915" class="pcalibre1 pcalibre2 pcalibre10">Which registers are used to hold program values x, y, and n?</p></li>
<li id="P7000497027000000000000000040916" data-uri="chapter03.xhtml#P7000497027000000000000000040916" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040917" data-uri="chapter03.xhtml#P7000497027000000000000000040917" class="pcalibre1 pcalibre2 pcalibre10">How has the compiler eliminated the need for pointer variable <code id="P7000497027000000000000000040918" data-uri="chapter03.xhtml#P7000497027000000000000000040918" class="pcalibre1 calibre1 pcalibre2">p</code> and the pointer dereferencing implied by the expression <code id="P7000497027000000000000000040919" data-uri="chapter03.xhtml#P7000497027000000000000000040919" class="pcalibre1 calibre1 pcalibre2">(*p)++?</code></p></li>
<li id="P700049702700000000000000004091A" data-uri="chapter03.xhtml#P700049702700000000000000004091A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004091B" data-uri="chapter03.xhtml#P700049702700000000000000004091B" class="pcalibre1 pcalibre2 pcalibre10">Add annotations to the assembly code describing the operation of the program, similar to those shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002672"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.19(c)</span></a>.</p></li>
</ol></div></li></ol>
</section>
</section>
<section id="P70004970270000000000000000026B6" data-uri="chapter03.xhtml#P70004970270000000000000000026B6" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004091C" data-uri="chapter03.xhtml#P700049702700000000000000004091C" epub:type="title">While Loops</h1></header>
<p id="P700049702700000000000000004091D" data-uri="chapter03.xhtml#P700049702700000000000000004091D" class="pcalibre8 pcalibre1 pcalibre2">The general form of a <code id="P700049702700000000000000004091E" data-uri="chapter03.xhtml#P700049702700000000000000004091E" class="pcalibre1 calibre1 pcalibre2">while</code> statement is as follows:</p>
<pre id="P700049702700000000000000004091F" data-uri="chapter03.xhtml#P700049702700000000000000004091F" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040920" data-uri="chapter03.xhtml#P7000497027000000000000000040920" class="calibre3 pcalibre1 pcalibre2">
while (<i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040921" data-uri="chapter03.xhtml#P7000497027000000000000000040921">It differs from <code id="P7000497027000000000000000040922" data-uri="chapter03.xhtml#P7000497027000000000000000040922" class="pcalibre1 calibre1 pcalibre2">do-while</code> in that <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i> is evaluated and the loop is potentially terminated before the first execution of <i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>. There are a number of ways to translate a <code id="P7000497027000000000000000040923" data-uri="chapter03.xhtml#P7000497027000000000000000040923" class="pcalibre1 calibre1 pcalibre2">while loop</code> into machine code, two of which are used in code generated by <code id="P7000497027000000000000000040924" data-uri="chapter03.xhtml#P7000497027000000000000000040924" class="pcalibre1 calibre1 pcalibre2"><span class="pcalibre1 pcalibre29 pcalibre2">gcc</span></code>. Both use the same loop structure as we saw for <code id="P7000497027000000000000000040925" data-uri="chapter03.xhtml#P7000497027000000000000000040925" class="pcalibre1 calibre1 pcalibre2">do-while loops</code> but differ in how to implement the initial test.</p>
<p id="P7000497027000000000000000040926" data-uri="chapter03.xhtml#P7000497027000000000000000040926" class="pcalibre8 pcalibre1 pcalibre2">The first translation method, which we refer to as <i class="pcalibre17 pcalibre2 pcalibre1">jump to middle</i>, performs the initial test by performing an unconditional jump to the test at the end of the loop. It can be expressed by the following template for translating from the general <code id="P7000497027000000000000000040927" data-uri="chapter03.xhtml#P7000497027000000000000000040927" class="pcalibre1 calibre1 pcalibre2">while loop</code> form to goto code:</p>
<pre id="P7000497027000000000000000040928" data-uri="chapter03.xhtml#P7000497027000000000000000040928" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040929" data-uri="chapter03.xhtml#P7000497027000000000000000040929" class="calibre3 pcalibre1 pcalibre2">
	goto test;
loop:
	<i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>
test:
	t = <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>;
	if (t)
		goto loop;
</code></pre>
<p id="P700049702700000000000000004092A" data-uri="chapter03.xhtml#P700049702700000000000000004092A" class="pcalibre8 pcalibre1 pcalibre2">As an example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P70004970270000000000000000026C7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.20(a)</span></a> shows an implementation of the factorial function using a <code id="P700049702700000000000000004092B" data-uri="chapter03.xhtml#P700049702700000000000000004092B" class="pcalibre1 calibre1 pcalibre2">while</code> loop. This function correctly computes 0! = 1. The adjacent</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000026C7" data-uri="chapter03.xhtml#P70004970270000000000000000026C7">
<p id="P700049702700000000000000004092C" data-uri="chapter03.xhtml#P700049702700000000000000004092C" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre123" id="P70004970270000000000000000026C9" title="224" data-uri="chapter03.xhtml#P70004970270000000000000000026C9" epub:type="pagebreak"></span>(a) C code</p>
<pre id="P700049702700000000000000004092D" data-uri="chapter03.xhtml#P700049702700000000000000004092D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004092E" data-uri="chapter03.xhtml#P700049702700000000000000004092E" class="calibre3 pcalibre1 pcalibre2">
long fact_while(long n)
{
	long result = 1;
	while (n &gt; 1) {
		result *= n;
		n = n-1;
	}
	return result;
}
</code></pre>
<p id="P700049702700000000000000004092F" data-uri="chapter03.xhtml#P700049702700000000000000004092F" class="pcalibre8 pcalibre1 pcalibre2">(b) Equivalent goto version</p>
<pre id="P7000497027000000000000000040930" data-uri="chapter03.xhtml#P7000497027000000000000000040930" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040931" data-uri="chapter03.xhtml#P7000497027000000000000000040931" class="calibre3 pcalibre1 pcalibre2">
long fact_while_jm_goto(long n)
{
	long result = 1;
	goto test;
loop:
	result *= n;
	n = n-1;
test:
	if (n &gt; 1)
	goto loop;
	return result;
}
</code></pre>
<p id="P7000497027000000000000000040932" data-uri="chapter03.xhtml#P7000497027000000000000000040932" class="pcalibre8 pcalibre1 pcalibre2">(c) Corresponding assembly-language code</p>
<pre id="P7000497027000000000000000040933" data-uri="chapter03.xhtml#P7000497027000000000000000040933" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040934" data-uri="chapter03.xhtml#P7000497027000000000000000040934" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long fact_while(long n</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">n in %rdi</i>
	fact_while:
	  movl	$1, %eax	<i class="pcalibre17 pcalibre2 pcalibre1">Set result = 1</i>
	  jmp	.L5		<i class="pcalibre17 pcalibre2 pcalibre1">Goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">test</b>
	.L6:		    <b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
	  imulq	%rdi, %rax	 <i class="pcalibre17 pcalibre2 pcalibre1">Compute result *= n</i>
	  subq	$1, %rdi	<i class="pcalibre17 pcalibre2 pcalibre1">Decrement n</i>
	.L5:		    <b class="pcalibre1 pcalibre2 pcalibre12">test:</b>
	  cmpq	$1, %rdi	 <i class="pcalibre17 pcalibre2 pcalibre1">Compare n:1</i>
	  jg	.L6		<i class="pcalibre17 pcalibre2 pcalibre1">If &gt;, goto</i> loop
	  rep; ret		<i class="pcalibre17 pcalibre2 pcalibre1">Return</i>
</code></pre>
<figcaption id="P7000497027000000000000000040935" data-uri="chapter03.xhtml#P7000497027000000000000000040935" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000040936" data-uri="chapter03.xhtml#P7000497027000000000000000040936" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.20 </span>C and assembly code for <code id="P7000497027000000000000000040937" data-uri="chapter03.xhtml#P7000497027000000000000000040937" class="pcalibre1 calibre1 pcalibre2">while</code> version of factorial using jump-to-middle translation.</h1></header><div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000040938" data-uri="chapter03.xhtml#P7000497027000000000000000040938"><p id="P7000497027000000000000000040939" data-uri="chapter03.xhtml#P7000497027000000000000000040939" class="pcalibre1 pcalibre2 pcalibre10">The C function <code id="P700049702700000000000000004093A" data-uri="chapter03.xhtml#P700049702700000000000000004093A" class="pcalibre1 calibre1 pcalibre2">fact_while_jm_goto</code> illustrates the operation of the assembly-code version.</p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004093B" data-uri="chapter03.xhtml#P700049702700000000000000004093B">function <code id="P700049702700000000000000004093C" data-uri="chapter03.xhtml#P700049702700000000000000004093C" class="pcalibre1 calibre1 pcalibre2">fact_while_jm_goto</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P70004970270000000000000000026C7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.20(b)</span></a>) is a C rendition of the assembly code generated by <code id="P700049702700000000000000004093D" data-uri="chapter03.xhtml#P700049702700000000000000004093D" class="pcalibre1 calibre1 pcalibre2"><span class="pcalibre1 pcalibre29 pcalibre2">gcc</span></code> when optimization is specified with the command-line option <code id="P700049702700000000000000004093E" data-uri="chapter03.xhtml#P700049702700000000000000004093E" class="pcalibre1 calibre1 pcalibre2">-0g</code>. Comparing the goto code generated for <code id="P700049702700000000000000004093F" data-uri="chapter03.xhtml#P700049702700000000000000004093F" class="pcalibre1 calibre1 pcalibre2">fact_while</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P70004970270000000000000000026C7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.20(b)</span></a>) to that for <code id="P7000497027000000000000000040940" data-uri="chapter03.xhtml#P7000497027000000000000000040940" class="pcalibre1 calibre1 pcalibre2">fact_do</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002672"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.19(b)</span></a>), we see that they are very similar, except that the statement <code id="P7000497027000000000000000040941" data-uri="chapter03.xhtml#P7000497027000000000000000040941" class="pcalibre1 calibre1 pcalibre2">goto test</code> before the loop causes the program to first perform the test of <code id="P7000497027000000000000000040942" data-uri="chapter03.xhtml#P7000497027000000000000000040942" class="pcalibre1 calibre1 pcalibre2">n</code> before modifying the values of <code id="P7000497027000000000000000040943" data-uri="chapter03.xhtml#P7000497027000000000000000040943" class="pcalibre1 calibre1 pcalibre2">result</code> or <code id="P7000497027000000000000000040944" data-uri="chapter03.xhtml#P7000497027000000000000000040944" class="pcalibre1 calibre1 pcalibre2">n</code>. The bottom portion of the figure (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P70004970270000000000000000026C7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.20(c)</span></a>) shows the actual assembly code generated.</p>
<section id="P70004970270000000000000000026E2" data-uri="chapter03.xhtml#P70004970270000000000000000026E2" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P7000497027000000000000000040945" data-uri="chapter03.xhtml#P7000497027000000000000000040945" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.24 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_000.xhtml#P7000497027000000000000000003676">335</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000040946" data-uri="chapter03.xhtml#P7000497027000000000000000040946">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000040947" data-uri="chapter03.xhtml#P7000497027000000000000000040947">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000040948" data-uri="chapter03.xhtml#P7000497027000000000000000040948"><p id="P7000497027000000000000000040949" data-uri="chapter03.xhtml#P7000497027000000000000000040949" class="pcalibre1 pcalibre2 pcalibre10">For C code having the general form</p>
<pre id="P700049702700000000000000004094A" data-uri="chapter03.xhtml#P700049702700000000000000004094A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004094B" data-uri="chapter03.xhtml#P700049702700000000000000004094B" class="calibre3 pcalibre1 pcalibre2">
long loop_while(long a, long b)
{
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000026EA" title="225" data-uri="chapter03.xhtml#P70004970270000000000000000026EA" epub:type="pagebreak"></span>long result = __________;
while (__________) {
	result = __________;
	a = __________;
  }
  return result;
}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P700049702700000000000000004094C" data-uri="chapter03.xhtml#P700049702700000000000000004094C"><span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>, run with command-line option <code id="P700049702700000000000000004094D" data-uri="chapter03.xhtml#P700049702700000000000000004094D" class="pcalibre1 calibre1 pcalibre2">-0g</code>, produces the following code:</p>
<pre id="P700049702700000000000000004094E" data-uri="chapter03.xhtml#P700049702700000000000000004094E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004094F" data-uri="chapter03.xhtml#P700049702700000000000000004094F" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long loop_while(long a, long b</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">a in %rdi, b in %rsi</i>
1	loop_while:
2	  movl	$1, %eax
3	  jmp	.L2
4	.L3:
5	  leaq	(%rdi,%rsi), %rdx
6	  imulq	%rdx, %rax
7	  addq	$1, %rdi
8	.L2:
9	  cmpq	%rsi, %rdi
10	  jl	.L3
11	  rep; ret
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000040950" data-uri="chapter03.xhtml#P7000497027000000000000000040950">We can see that the compiler used a jump-to-middle translation, using the <code id="P7000497027000000000000000040951" data-uri="chapter03.xhtml#P7000497027000000000000000040951" class="pcalibre1 calibre1 pcalibre2">jmp</code> instruction on line 3 to jump to the test starting with label <code id="P7000497027000000000000000040952" data-uri="chapter03.xhtml#P7000497027000000000000000040952" class="pcalibre1 calibre1 pcalibre2">.L2.</code> Fill in the missing parts of the C code.</p>
</div></li></ol>
</section>
<p id="P7000497027000000000000000040953" data-uri="chapter03.xhtml#P7000497027000000000000000040953" class="pcalibre8 pcalibre1 pcalibre2">The second translation method, which we refer to as <i class="pcalibre17 pcalibre2 pcalibre1">guarded do</i>, first transforms the code into a <code id="P7000497027000000000000000040954" data-uri="chapter03.xhtml#P7000497027000000000000000040954" class="pcalibre1 calibre1 pcalibre2">do-while</code> loop by using a conditional branch to skip over the loop if the initial test fails. <code id="P7000497027000000000000000040955" data-uri="chapter03.xhtml#P7000497027000000000000000040955" class="pcalibre1 calibre1 pcalibre2">G<span class="pcalibre1 pcalibre29 pcalibre2">cc</span></code> follows this strategy when compiling with higher levels of optimization, for example, with command-line option <code id="P7000497027000000000000000040956" data-uri="chapter03.xhtml#P7000497027000000000000000040956" class="pcalibre1 calibre1 pcalibre2">-01</code>. This method can be expressed by the following template for translating from the general while loop form to a <code id="P7000497027000000000000000040957" data-uri="chapter03.xhtml#P7000497027000000000000000040957" class="pcalibre1 calibre1 pcalibre2">do-while</code> loop:</p>
<pre id="P7000497027000000000000000040958" data-uri="chapter03.xhtml#P7000497027000000000000000040958" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040959" data-uri="chapter03.xhtml#P7000497027000000000000000040959" class="calibre3 pcalibre1 pcalibre2">
t = <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>;
if (!t)
	goto done;
do
	<i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>
	while (<i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>);
done:
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004095A" data-uri="chapter03.xhtml#P700049702700000000000000004095A">This, in turn, can be transformed into goto code as</p>
<pre id="P700049702700000000000000004095B" data-uri="chapter03.xhtml#P700049702700000000000000004095B" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004095C" data-uri="chapter03.xhtml#P700049702700000000000000004095C" class="calibre3 pcalibre1 pcalibre2">
t = <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>;
if (!t)
	goto done;
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000026FC" title="226" data-uri="chapter03.xhtml#P70004970270000000000000000026FC" epub:type="pagebreak"></span>loop:
	<i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>
	t = <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>;
	if (t)
	goto loop;
done:
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004095D" data-uri="chapter03.xhtml#P700049702700000000000000004095D">Using this implementation strategy, the compiler can often optimize the initial test, for example, determining that the test condition will always hold.</p>
<p id="P700049702700000000000000004095E" data-uri="chapter03.xhtml#P700049702700000000000000004095E" class="pcalibre8 pcalibre1 pcalibre2">As an example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P700049702700000000000000000270A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.21</span></a> shows the same C code for a factorial function as in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P70004970270000000000000000026C7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.20</span></a>, but demonstrates the compilation that occurs when <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>is given command-line option -01. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P700049702700000000000000000270A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.21(c)</span></a> shows the actual assembly code generated, while <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P700049702700000000000000000270A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.21(b)</span></a> renders this assembly code in a more readable C representation. Referring to this goto code, we see that the loop will be skipped if <var class="pcalibre17 pcalibre2 pcalibre1">n</var> â‰¤ 1, for the initial value of <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. The loop itself has the same general structure as that generated for the do-while version of the function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002672"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.19</span></a>). One interesting feature, however, is that the loop test (line 9 of the assembly code) has been changed from <var class="pcalibre17 pcalibre2 pcalibre1">n</var> &gt; 1 in the original C code to <var class="pcalibre17 pcalibre2 pcalibre1">n</var> â‰  1. The compiler has determined that the loop can only be entered when <var class="pcalibre17 pcalibre2 pcalibre1">n</var> &gt; 1, and that decrementing <var class="pcalibre17 pcalibre2 pcalibre1">n</var> will result in either <var class="pcalibre17 pcalibre2 pcalibre1">n</var> &gt; 1 or <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 1. Therefore, the test <var class="pcalibre17 pcalibre2 pcalibre1">n</var> â‰  1 will be equivalent to the test <var class="pcalibre17 pcalibre2 pcalibre1">n</var> â‰¤ 1.</p>
<section id="P70004970270000000000000000026FF" data-uri="chapter03.xhtml#P70004970270000000000000000026FF" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P700049702700000000000000004095F" data-uri="chapter03.xhtml#P700049702700000000000000004095F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.25 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_000.xhtml#P7000497027000000000000000003676">335</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000040960" data-uri="chapter03.xhtml#P7000497027000000000000000040960">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000040961" data-uri="chapter03.xhtml#P7000497027000000000000000040961">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000040962" data-uri="chapter03.xhtml#P7000497027000000000000000040962"><p id="P7000497027000000000000000040963" data-uri="chapter03.xhtml#P7000497027000000000000000040963" class="pcalibre1 pcalibre2 pcalibre10">For C code having the general form</p></div>
<pre id="P7000497027000000000000000040964" data-uri="chapter03.xhtml#P7000497027000000000000000040964" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040965" data-uri="chapter03.xhtml#P7000497027000000000000000040965" class="calibre3 pcalibre1 pcalibre2">
long loop_while2(long a, long b)
{
	long result= __________;
	while(__________) {
		result = __________;
		b= __________;
	}
	return result;
}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000040966" data-uri="chapter03.xhtml#P7000497027000000000000000040966"><span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>, run with command-line option -01, produces the following code:</p>
<pre id="P7000497027000000000000000040967" data-uri="chapter03.xhtml#P7000497027000000000000000040967" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040968" data-uri="chapter03.xhtml#P7000497027000000000000000040968" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">a in %rdi, b in %rsi</i>
1	loop_while2:
2	testq	%rsi, %rsi
3	jle	.L8
4	movq	%rsi, %rax
5	.L7:
6	imulq	%rdi, %rax
7	subq	%rdi, %rsi
8	testq	%rsi, %rsi
</code></pre>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000270A" data-uri="chapter03.xhtml#P700049702700000000000000000270A">
<p id="P7000497027000000000000000040969" data-uri="chapter03.xhtml#P7000497027000000000000000040969" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre123" id="P700049702700000000000000000270C" title="227" data-uri="chapter03.xhtml#P700049702700000000000000000270C" epub:type="pagebreak"></span>(a) C code</p>
<pre id="P700049702700000000000000004096A" data-uri="chapter03.xhtml#P700049702700000000000000004096A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004096B" data-uri="chapter03.xhtml#P700049702700000000000000004096B" class="calibre3 pcalibre1 pcalibre2">
long fact_while (long n)
{
	long result = 1;
	while (n &gt; 1) {
		result *= n;
		n = n-1;
	}
	return result;
}
</code></pre>
<p id="P700049702700000000000000004096C" data-uri="chapter03.xhtml#P700049702700000000000000004096C" class="pcalibre1 pcalibre2 pcalibre10">(b) Equivalent goto version</p>
<pre id="P700049702700000000000000004096D" data-uri="chapter03.xhtml#P700049702700000000000000004096D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004096E" data-uri="chapter03.xhtml#P700049702700000000000000004096E" class="calibre3 pcalibre1 pcalibre2">
long fact_while_gd_goto(long n)
{
	long result = 1;
	if (n &lt;= 1)
		goto done;
	loop:
	result *= n;
	n = n-1;
	if (n != 1)
		goto loop;
	done:
		return result;
}
</code></pre>
<p id="P700049702700000000000000004096F" data-uri="chapter03.xhtml#P700049702700000000000000004096F" class="pcalibre1 pcalibre2 pcalibre10">(c) Corresponding assembly-language code</p>
<pre id="P7000497027000000000000000040970" data-uri="chapter03.xhtml#P7000497027000000000000000040970" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040971" data-uri="chapter03.xhtml#P7000497027000000000000000040971" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long fact_while(long n</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">n in %rdi</i>
1	fact_while:
2	  cmpq	$1, %rdi	<i class="pcalibre17 pcalibre2 pcalibre1">Compare n:1</i>
3	  jle	.L7		<i class="pcalibre17 pcalibre2 pcalibre1">If &lt;=, goto</i> done
4	  movl	$1, %eax	<i class="pcalibre17 pcalibre2 pcalibre1">Set result = 1</i>
5	.L6:		   <b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
6	  imulq %rdi, %rax	<i class="pcalibre17 pcalibre2 pcalibre1">Compute result *= n</i>
7	  subq $1, %rdi		<i class="pcalibre17 pcalibre2 pcalibre1">Decrement n</i>
8	  cmpq $1, %rdi		<i class="pcalibre17 pcalibre2 pcalibre1">Compare n:1</i>
9	  jne .L6		<i class="pcalibre17 pcalibre2 pcalibre1">If !=, goto</i> loop
10	  rep; ret		<i class="pcalibre17 pcalibre2 pcalibre1">Return</i>
11	.L7:		   <b class="pcalibre1 pcalibre2 pcalibre12">done:</b>
12	  movl $1, %eax		 <i class="pcalibre17 pcalibre2 pcalibre1">Compute result = 1</i>
13	  ret			 <i class="pcalibre17 pcalibre2 pcalibre1">Return</i>
</code></pre>
<figcaption id="P7000497027000000000000000040972" data-uri="chapter03.xhtml#P7000497027000000000000000040972" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000040973" data-uri="chapter03.xhtml#P7000497027000000000000000040973" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.21 </span>C and assembly code for <code id="P7000497027000000000000000040974" data-uri="chapter03.xhtml#P7000497027000000000000000040974" class="pcalibre1 calibre1 pcalibre2">while</code> version of factorial using guarded-do translation.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000040975" data-uri="chapter03.xhtml#P7000497027000000000000000040975"><p id="P7000497027000000000000000040976" data-uri="chapter03.xhtml#P7000497027000000000000000040976" class="pcalibre1 pcalibre2 pcalibre10">The <code id="P7000497027000000000000000040977" data-uri="chapter03.xhtml#P7000497027000000000000000040977" class="pcalibre1 calibre1 pcalibre2">fact_while_gd_goto</code> function illustrates the operation of the assembly-code version.</p></div></figcaption>
</figure>
<pre id="P7000497027000000000000000040978" data-uri="chapter03.xhtml#P7000497027000000000000000040978" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040979" data-uri="chapter03.xhtml#P7000497027000000000000000040979" class="calibre3 pcalibre1 pcalibre2">
9	  jg	.L7
10	  rep; ret
11	.L8:
12	  movq	%rsi, %rax
13	  ret
</code></pre>


<p id="P700049702700000000000000004097A" data-uri="chapter03.xhtml#P700049702700000000000000004097A" class="pcalibre1 pcalibre2 pcalibre10">We can see that the compiler used a guarded-do translation, using the <code id="P700049702700000000000000004097B" data-uri="chapter03.xhtml#P700049702700000000000000004097B" class="pcalibre1 calibre1 pcalibre2">jle</code> instruction on line 3 to skip over the loop code when the initial test fails. Fill in the missing parts of the C code. Note that the control structure in the assembly <span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000271F" title="228" data-uri="chapter03.xhtml#P700049702700000000000000000271F" epub:type="pagebreak"></span>code does not exactly match what would be obtained by a direct translation of the C code according to our translation rules. In particular, it has two different ret instructions (lines 10 and 13). However, you can fill out the missing portions of the C code in a way that it will have equivalent behavior to the assembly code.</p>
</li></ol>
</section>
<section id="P7000497027000000000000000002720" data-uri="chapter03.xhtml#P7000497027000000000000000002720" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P700049702700000000000000004097C" data-uri="chapter03.xhtml#P700049702700000000000000004097C" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.26 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_000.xhtml#P7000497027000000000000000003688">336</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004097D" data-uri="chapter03.xhtml#P700049702700000000000000004097D">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004097E" data-uri="chapter03.xhtml#P700049702700000000000000004097E">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004097F" data-uri="chapter03.xhtml#P700049702700000000000000004097F"><p id="P7000497027000000000000000040980" data-uri="chapter03.xhtml#P7000497027000000000000000040980" class="pcalibre1 pcalibre2 pcalibre10">A function <code id="P7000497027000000000000000040981" data-uri="chapter03.xhtml#P7000497027000000000000000040981" class="pcalibre1 calibre1 pcalibre2">fun_a</code> has the following overall structure:</p>
<pre id="P7000497027000000000000000040982" data-uri="chapter03.xhtml#P7000497027000000000000000040982" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040983" data-uri="chapter03.xhtml#P7000497027000000000000000040983" class="calibre3 pcalibre1 pcalibre2">
long fun_a(unsigned long x) {
	long val = 0;
	while (...){
	  â‹®
	}
	return ...;
}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000040984" data-uri="chapter03.xhtml#P7000497027000000000000000040984">The <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>C compiler generates the following assembly code:</p>
<pre id="P7000497027000000000000000040985" data-uri="chapter03.xhtml#P7000497027000000000000000040985" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040986" data-uri="chapter03.xhtml#P7000497027000000000000000040986" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long fun_a(unsigned long x</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi</i>
1	fun_a:
2	  movl	$0, %eax
3	  jmp	.L5
4	.L6:
5	  xorq	%rdi, %rax
6	  shrq	%rdi			<i class="pcalibre17 pcalibre2 pcalibre1">Shift right by 1</i>
7	.L5:
8	  testq	%rdi, %rdi
9	  jne	.L6
10	  andl	$1, %eax
11	  ret
</code></pre>
<p id="P7000497027000000000000000040987" data-uri="chapter03.xhtml#P7000497027000000000000000040987" class="pcalibre1 pcalibre2 pcalibre10">Reverse engineer the operation of this code and then do the following:</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000040988" data-uri="chapter03.xhtml#P7000497027000000000000000040988">
<li id="P7000497027000000000000000040989" data-uri="chapter03.xhtml#P7000497027000000000000000040989" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004098A" data-uri="chapter03.xhtml#P700049702700000000000000004098A" class="pcalibre1 pcalibre2 pcalibre10">Determine what loop translation method was used.</p></li>
<li id="P700049702700000000000000004098B" data-uri="chapter03.xhtml#P700049702700000000000000004098B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004098C" data-uri="chapter03.xhtml#P700049702700000000000000004098C" class="pcalibre1 pcalibre2 pcalibre10">Use the assembly-code version to fill in the missing parts of the C code.</p></li>
<li id="P700049702700000000000000004098D" data-uri="chapter03.xhtml#P700049702700000000000000004098D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004098E" data-uri="chapter03.xhtml#P700049702700000000000000004098E" class="pcalibre1 pcalibre2 pcalibre10">Describe in English what this function computes.</p></li>
</ol>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000002734" data-uri="chapter03.xhtml#P7000497027000000000000000002734" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004098F" data-uri="chapter03.xhtml#P700049702700000000000000004098F" epub:type="title">For Loops</h1></header>
<p id="P7000497027000000000000000040990" data-uri="chapter03.xhtml#P7000497027000000000000000040990" class="pcalibre8 pcalibre1 pcalibre2">The general form of a <code id="P7000497027000000000000000040991" data-uri="chapter03.xhtml#P7000497027000000000000000040991" class="pcalibre1 calibre1 pcalibre2">for loop</code> is as follows:</p>
<pre id="P7000497027000000000000000040992" data-uri="chapter03.xhtml#P7000497027000000000000000040992" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040993" data-uri="chapter03.xhtml#P7000497027000000000000000040993" class="calibre3 pcalibre1 pcalibre2">
for (<i class="pcalibre17 pcalibre2 pcalibre1">init-expr</i>; <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>; <i class="pcalibre17 pcalibre2 pcalibre1">update-expr</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040994" data-uri="chapter03.xhtml#P7000497027000000000000000040994"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000273B" title="229" data-uri="chapter03.xhtml#P700049702700000000000000000273B" epub:type="pagebreak"></span>The C language standard states (with one exception, highlighted in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002782"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.29</span></a>) that the behavior of such a loop is identical to the following code using a while loop:</p>
<pre id="P7000497027000000000000000040995" data-uri="chapter03.xhtml#P7000497027000000000000000040995" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040996" data-uri="chapter03.xhtml#P7000497027000000000000000040996" class="calibre3 pcalibre1 pcalibre2">
<i class="pcalibre17 pcalibre2 pcalibre1">init-expr</i>;
while (<i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>) {
	  <i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>
	  <i class="pcalibre17 pcalibre2 pcalibre1">update-expr</i>;
}
</code></pre>
<p id="P7000497027000000000000000040997" data-uri="chapter03.xhtml#P7000497027000000000000000040997" class="pcalibre8 pcalibre1 pcalibre2">The program first evaluates the initialization expression <i class="pcalibre17 pcalibre2 pcalibre1">init-expr</i>. It enters a loop where it first evaluates the test condition <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>, exiting if the test fails, then executes the body of the loop <i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>, and finally evaluates the update expression <i class="pcalibre17 pcalibre2 pcalibre1">update-expr</i>.</p>
<p id="P7000497027000000000000000040998" data-uri="chapter03.xhtml#P7000497027000000000000000040998" class="pcalibre8 pcalibre1 pcalibre2">The code generated by <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>for a <code id="P7000497027000000000000000040999" data-uri="chapter03.xhtml#P7000497027000000000000000040999" class="pcalibre1 calibre1 pcalibre2">for loop</code> then follows one of our two translation strategies for <code id="P700049702700000000000000004099A" data-uri="chapter03.xhtml#P700049702700000000000000004099A" class="pcalibre1 calibre1 pcalibre2">while loop</code>s, depending on the optimization level. That is, the jump-to-middle strategy yields the goto code</p>
<pre id="P700049702700000000000000004099B" data-uri="chapter03.xhtml#P700049702700000000000000004099B" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004099C" data-uri="chapter03.xhtml#P700049702700000000000000004099C" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">init-expr</i>;
	goto test;
loop:
	<i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">update-expr</i>;
test:
	t = <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>;
	if (t)
	  goto loop;
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004099D" data-uri="chapter03.xhtml#P700049702700000000000000004099D">while the guarded-do strategy yields</p>
<pre id="P700049702700000000000000004099E" data-uri="chapter03.xhtml#P700049702700000000000000004099E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004099F" data-uri="chapter03.xhtml#P700049702700000000000000004099F" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">init-expr</i>;
	t = <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>;
	if (!t)
	  goto done;
loop:
	<i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">update-expr</i>;
	t = <i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>;
	if (t)
	  goto loop;
	done:
</code></pre>
<p id="P70004970270000000000000000409A0" data-uri="chapter03.xhtml#P70004970270000000000000000409A0" class="pcalibre8 pcalibre1 pcalibre2">As examples, consider a factorial function written with a <code id="P70004970270000000000000000409A1" data-uri="chapter03.xhtml#P70004970270000000000000000409A1" class="pcalibre1 calibre1 pcalibre2">for loop</code>:</p>
<pre id="P70004970270000000000000000409A2" data-uri="chapter03.xhtml#P70004970270000000000000000409A2" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000409A3" data-uri="chapter03.xhtml#P70004970270000000000000000409A3" class="calibre3 pcalibre1 pcalibre2">
long fact_for(long n)
{
	long i;
	long result = 1;
	<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000274B" title="230" data-uri="chapter03.xhtml#P700049702700000000000000000274B" epub:type="pagebreak"></span>for (i = 2; i &lt;= n; i++)
	  result *= i;
	return result;
}
</code></pre>
<p id="P70004970270000000000000000409A4" data-uri="chapter03.xhtml#P70004970270000000000000000409A4" class="pcalibre8 pcalibre1 pcalibre2">As shown, the natural way of writing a factorial function with a <code id="P70004970270000000000000000409A5" data-uri="chapter03.xhtml#P70004970270000000000000000409A5" class="pcalibre1 calibre1 pcalibre2">for loop</code> is to multiply factors from 2 up to <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, and so this function is quite different from the code we showed using either a <code id="P70004970270000000000000000409A6" data-uri="chapter03.xhtml#P70004970270000000000000000409A6" class="pcalibre1 calibre1 pcalibre2">while</code> or a <code id="P70004970270000000000000000409A7" data-uri="chapter03.xhtml#P70004970270000000000000000409A7" class="pcalibre1 calibre1 pcalibre2">do-while loop</code>.</p>
<p id="P70004970270000000000000000409A8" data-uri="chapter03.xhtml#P70004970270000000000000000409A8" class="pcalibre8 pcalibre1 pcalibre2">We can identify the different components of the <code id="P70004970270000000000000000409A9" data-uri="chapter03.xhtml#P70004970270000000000000000409A9" class="pcalibre1 calibre1 pcalibre2">for loop</code> in this code as follows:</p>
<pre id="P70004970270000000000000000409AA" data-uri="chapter03.xhtml#P70004970270000000000000000409AA" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000409AB" data-uri="chapter03.xhtml#P70004970270000000000000000409AB" class="calibre3 pcalibre1 pcalibre2">
<i class="pcalibre17 pcalibre2 pcalibre1">init-expr</i>		i=2
<i class="pcalibre17 pcalibre2 pcalibre1">test-expr</i>		i &lt;= n
<i class="pcalibre17 pcalibre2 pcalibre1">update-expr</i>		i++
<i class="pcalibre17 pcalibre2 pcalibre1">body-statement</i>	result *= i;
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000409AC" data-uri="chapter03.xhtml#P70004970270000000000000000409AC">Substituting these components into the template we have shown to transform a <code id="P70004970270000000000000000409AD" data-uri="chapter03.xhtml#P70004970270000000000000000409AD" class="pcalibre1 calibre1 pcalibre2">for loop</code> into a <code id="P70004970270000000000000000409AE" data-uri="chapter03.xhtml#P70004970270000000000000000409AE" class="pcalibre1 calibre1 pcalibre2">while loop</code> yields the following:</p>
<pre id="P70004970270000000000000000409AF" data-uri="chapter03.xhtml#P70004970270000000000000000409AF" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000409B0" data-uri="chapter03.xhtml#P70004970270000000000000000409B0" class="calibre3 pcalibre1 pcalibre2">
long fact_for_while(long n)
{
	long i = 2;
	long result = 1;
	while (i &lt;= n) {
	  result *= i;
	  i++;
	}
	return result;
}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000409B1" data-uri="chapter03.xhtml#P70004970270000000000000000409B1">Applying the jump-to-middle transformation to the <code id="P70004970270000000000000000409B2" data-uri="chapter03.xhtml#P70004970270000000000000000409B2" class="pcalibre1 calibre1 pcalibre2">while loop</code> then yields the following version in goto code:</p>
<pre id="P70004970270000000000000000409B3" data-uri="chapter03.xhtml#P70004970270000000000000000409B3" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000409B4" data-uri="chapter03.xhtml#P70004970270000000000000000409B4" class="calibre3 pcalibre1 pcalibre2">
long fact_for_jm_goto(long n)
{
	long i = 2;
	long result = 1;
	goto test;
loop:
	result *= i;
	i++;
test:
	if (i &lt;= n)
	  goto loop;
	return result;
}
</code></pre>
<p id="P70004970270000000000000000409B5" data-uri="chapter03.xhtml#P70004970270000000000000000409B5" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000275E" title="231" data-uri="chapter03.xhtml#P700049702700000000000000000275E" epub:type="pagebreak"></span>Indeed, a close examination of the assembly code produced by <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>with command-line option <code id="P70004970270000000000000000409B6" data-uri="chapter03.xhtml#P70004970270000000000000000409B6" class="pcalibre1 calibre1 pcalibre2">-0g</code> closely follows this template:</p>
<pre id="P70004970270000000000000000409B7" data-uri="chapter03.xhtml#P70004970270000000000000000409B7" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000409B8" data-uri="chapter03.xhtml#P70004970270000000000000000409B8" class="calibre3 pcalibre1 pcalibre2">
  <i class="pcalibre17 pcalibre2 pcalibre1">long fact_for(long n</i>)
  <i class="pcalibre17 pcalibre2 pcalibre1">n in %rdi</i>
fact_for:
  movl $1, %eax	     <i class="pcalibre17 pcalibre2 pcalibre1">Set result = 1</i>
  movl $2, %edx	     <i class="pcalibre17 pcalibre2 pcalibre1">Set i = 2</i>
  jmp .L8	     <i class="pcalibre17 pcalibre2 pcalibre1">Goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">test</b>
.L9:		  <b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
  imulq %rdx, %rax   <i class="pcalibre17 pcalibre2 pcalibre1">Compute result *= i</i>
  addq $1, %rdx	     <i class="pcalibre17 pcalibre2 pcalibre1">Increment i</i>
.L8:              <b class="pcalibre1 pcalibre2 pcalibre12">test:</b>
  cmpq %rdi, %rdx    <i class="pcalibre17 pcalibre2 pcalibre1">Compare i:n</i>
  jle .L9         <i class="pcalibre17 pcalibre2 pcalibre1">If &lt;=, goto</i> loop
  rep; ret        <i class="pcalibre17 pcalibre2 pcalibre1">Return</i>
</code></pre>
<section id="P7000497027000000000000000002762" data-uri="chapter03.xhtml#P7000497027000000000000000002762" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P70004970270000000000000000409B9" data-uri="chapter03.xhtml#P70004970270000000000000000409B9" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.27 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_000.xhtml#P7000497027000000000000000003688">336</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000409BA" data-uri="chapter03.xhtml#P70004970270000000000000000409BA">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000409BB" data-uri="chapter03.xhtml#P70004970270000000000000000409BB">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000409BC" data-uri="chapter03.xhtml#P70004970270000000000000000409BC"><p id="P70004970270000000000000000409BD" data-uri="chapter03.xhtml#P70004970270000000000000000409BD" class="pcalibre1 pcalibre2 pcalibre10">Write goto code for <code id="P70004970270000000000000000409BE" data-uri="chapter03.xhtml#P70004970270000000000000000409BE" class="pcalibre1 calibre1 pcalibre2">fact_for</code> based on first transforming it to a <code id="P70004970270000000000000000409BF" data-uri="chapter03.xhtml#P70004970270000000000000000409BF" class="pcalibre1 calibre1 pcalibre2">while loop</code> and then applying the guarded-do transformation.</p></div>
</li></ol>
</section>
<p id="P70004970270000000000000000409C0" data-uri="chapter03.xhtml#P70004970270000000000000000409C0" class="pcalibre8 pcalibre1 pcalibre2">We see from this presentation that all three forms of loops in Câ€”<code id="P70004970270000000000000000409C1" data-uri="chapter03.xhtml#P70004970270000000000000000409C1" class="pcalibre1 calibre1 pcalibre2">do-while, while</code>, and <code id="P70004970270000000000000000409C2" data-uri="chapter03.xhtml#P70004970270000000000000000409C2" class="pcalibre1 calibre1 pcalibre2">for</code>â€”can be translated by a simple strategy, generating code that contains one or more conditional branches. Conditional transfer of control provides the basic mechanism for translating loops into machine code.</p>
<section id="P700049702700000000000000000276D" data-uri="chapter03.xhtml#P700049702700000000000000000276D" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P70004970270000000000000000409C3" data-uri="chapter03.xhtml#P70004970270000000000000000409C3" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.28 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_000.xhtml#P7000497027000000000000000003688">336</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000409C4" data-uri="chapter03.xhtml#P70004970270000000000000000409C4">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000409C5" data-uri="chapter03.xhtml#P70004970270000000000000000409C5">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000409C6" data-uri="chapter03.xhtml#P70004970270000000000000000409C6"><p id="P70004970270000000000000000409C7" data-uri="chapter03.xhtml#P70004970270000000000000000409C7" class="pcalibre1 pcalibre2 pcalibre10">A function <code id="P70004970270000000000000000409C8" data-uri="chapter03.xhtml#P70004970270000000000000000409C8" class="pcalibre1 calibre1 pcalibre2">fun_b</code> has the following overall structure:</p>
<pre id="P70004970270000000000000000409C9" data-uri="chapter03.xhtml#P70004970270000000000000000409C9" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000409CA" data-uri="chapter03.xhtml#P70004970270000000000000000409CA" class="calibre3 pcalibre1 pcalibre2">
long fun_b(unsigned long x) {
     long val = 0;
     long i;
     for ( ...; ...; ...) {
	 â‹®
     }
     return val;
}
</code></pre>

<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000409CB" data-uri="chapter03.xhtml#P70004970270000000000000000409CB">The <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>C compiler generates the following assembly code:</p>
<pre id="P70004970270000000000000000409CC" data-uri="chapter03.xhtml#P70004970270000000000000000409CC" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000409CD" data-uri="chapter03.xhtml#P70004970270000000000000000409CD" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long fun_b(unsigned long x</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi</i>
1	fun_b:
2	movl	$64, %edx
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002779" title="232" data-uri="chapter03.xhtml#P7000497027000000000000000002779" epub:type="pagebreak"></span>3	movl	$0, %eax
4  .L10:
5	movq	%rdi, %rcx
6	andl	$1, %ecx
7	addq	%rax, %rax
8	orq	%rcx, %rax
9	shrq	%rdi		<i class="pcalibre17 pcalibre2 pcalibre1">Shift right by 1</i>
10	subq	$1, %rdx
11	jne	.L10
12	rep; ret
</code></pre>
<p id="P70004970270000000000000000409CE" data-uri="chapter03.xhtml#P70004970270000000000000000409CE" class="pcalibre1 pcalibre2 pcalibre10">Reverse engineer the operation of this code and then do the following:</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000409CF" data-uri="chapter03.xhtml#P70004970270000000000000000409CF">
<li id="P70004970270000000000000000409D0" data-uri="chapter03.xhtml#P70004970270000000000000000409D0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000409D1" data-uri="chapter03.xhtml#P70004970270000000000000000409D1" class="pcalibre1 pcalibre2 pcalibre10">Use the assembly-code version to fill in the missing parts of the C code.</p></li>
<li id="P70004970270000000000000000409D2" data-uri="chapter03.xhtml#P70004970270000000000000000409D2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000409D3" data-uri="chapter03.xhtml#P70004970270000000000000000409D3" class="pcalibre1 pcalibre2 pcalibre10">Explain why there is neither an initial test before the loop nor an initial jump to the test portion of the loop.</p></li>
<li id="P70004970270000000000000000409D4" data-uri="chapter03.xhtml#P70004970270000000000000000409D4" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000409D5" data-uri="chapter03.xhtml#P70004970270000000000000000409D5" class="pcalibre1 pcalibre2 pcalibre10">Describe in English what this function computes.</p></li>
</ol>
</div>
</li></ol>
</section>
<section id="P7000497027000000000000000002782" data-uri="chapter03.xhtml#P7000497027000000000000000002782" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P70004970270000000000000000409D6" data-uri="chapter03.xhtml#P70004970270000000000000000409D6" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.29 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_000.xhtml#P70004970270000000000000000036A9">337</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000409D7" data-uri="chapter03.xhtml#P70004970270000000000000000409D7">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000409D8" data-uri="chapter03.xhtml#P70004970270000000000000000409D8">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000409D9" data-uri="chapter03.xhtml#P70004970270000000000000000409D9"><p id="P70004970270000000000000000409DA" data-uri="chapter03.xhtml#P70004970270000000000000000409DA" class="pcalibre1 pcalibre2 pcalibre10">Executing a <code id="P70004970270000000000000000409DB" data-uri="chapter03.xhtml#P70004970270000000000000000409DB" class="pcalibre1 calibre1 pcalibre2">continue</code> statement in C causes the program to jump to the end of the current loop iteration. The stated rule for translating a <code id="P70004970270000000000000000409DC" data-uri="chapter03.xhtml#P70004970270000000000000000409DC" class="pcalibre1 calibre1 pcalibre2">for loop</code> into a <code id="P70004970270000000000000000409DD" data-uri="chapter03.xhtml#P70004970270000000000000000409DD" class="pcalibre1 calibre1 pcalibre2">while loop</code> needs some refinement when dealing with <code id="P70004970270000000000000000409DE" data-uri="chapter03.xhtml#P70004970270000000000000000409DE" class="pcalibre1 calibre1 pcalibre2">continue</code> statements. For example, consider the following code:</p>
<pre id="P70004970270000000000000000409DF" data-uri="chapter03.xhtml#P70004970270000000000000000409DF" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000409E0" data-uri="chapter03.xhtml#P70004970270000000000000000409E0" class="calibre3 pcalibre1 pcalibre2">
/* Example of for loop containing a continue statement */
/* Sum even numbers between 0 and 9 */
long sum = 0;
long i;
for (i = 0; i &lt; 10; i++) {
	if (i &amp; 1)
	  continue;
	sum += i;
}
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000409E1" data-uri="chapter03.xhtml#P70004970270000000000000000409E1">
<li id="P70004970270000000000000000409E2" data-uri="chapter03.xhtml#P70004970270000000000000000409E2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000409E3" data-uri="chapter03.xhtml#P70004970270000000000000000409E3" class="pcalibre1 pcalibre2 pcalibre10">What would we get if we naively applied our rule for translating the <code id="P70004970270000000000000000409E4" data-uri="chapter03.xhtml#P70004970270000000000000000409E4" class="pcalibre1 calibre1 pcalibre2">for loop</code> into a <code id="P70004970270000000000000000409E5" data-uri="chapter03.xhtml#P70004970270000000000000000409E5" class="pcalibre1 calibre1 pcalibre2">while loop</code>? What would be wrong with this code?</p></li>
<li id="P70004970270000000000000000409E6" data-uri="chapter03.xhtml#P70004970270000000000000000409E6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000409E7" data-uri="chapter03.xhtml#P70004970270000000000000000409E7" class="pcalibre1 pcalibre2 pcalibre10">How could you replace the <code id="P70004970270000000000000000409E8" data-uri="chapter03.xhtml#P70004970270000000000000000409E8" class="pcalibre1 calibre1 pcalibre2">continue</code> statement with a <code id="P70004970270000000000000000409E9" data-uri="chapter03.xhtml#P70004970270000000000000000409E9" class="pcalibre1 calibre1 pcalibre2">goto</code> statement to ensure that the <code id="P70004970270000000000000000409EA" data-uri="chapter03.xhtml#P70004970270000000000000000409EA" class="pcalibre1 calibre1 pcalibre2">while loop</code> correctly duplicates the behavior of the <code id="P70004970270000000000000000409EB" data-uri="chapter03.xhtml#P70004970270000000000000000409EB" class="pcalibre1 calibre1 pcalibre2">for loop</code>?</p></li>
</ol></div></li></ol>
</section>
</section>
</section>
<section id="P7000497027000000000000000002799" data-uri="chapter03.xhtml#P7000497027000000000000000002799" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000409EC" data-uri="chapter03.xhtml#P70004970270000000000000000409EC" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.6.8 </span>Switch Statements</h1></header>
<p id="P70004970270000000000000000409ED" data-uri="chapter03.xhtml#P70004970270000000000000000409ED" class="pcalibre8 pcalibre1 pcalibre2">A <code id="P70004970270000000000000000409EE" data-uri="chapter03.xhtml#P70004970270000000000000000409EE" class="pcalibre1 calibre1 pcalibre2">switch</code> statement provides a multiway branching capability based on the value of an integer index. They are particularly useful when dealing with tests where <span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000279D" title="233" data-uri="chapter03.xhtml#P700049702700000000000000000279D" epub:type="pagebreak"></span>there can be a large number of possible outcomes. Not only do they make the C code more readable, but they also allow an efficient implementation using a data structure called a<i class="pcalibre17 pcalibre2 pcalibre1">jump table</i>.A jump table is an array where entry<var class="pcalibre17 pcalibre2 pcalibre1">i</var> is the address of a code segment implementing the action the program should take when the switch index equals <var class="pcalibre17 pcalibre2 pcalibre1">i</var>. The code performs an array reference into the jump table using the switch index to determine the target for a jump instruction. The advantage of using a jump table over a long sequence of if-else statements is that the time taken to perform the switch is independent of the number of switch cases. G<span class="pcalibre1 pcalibre29 pcalibre2">cc </span>selects the method of translating a <code id="P70004970270000000000000000409EF" data-uri="chapter03.xhtml#P70004970270000000000000000409EF" class="pcalibre1 calibre1 pcalibre2">switch</code> statement based on the number of cases and the sparsity of the case values. Jump tables are used when there are a number of cases (e.g., four or more) and they span a small range of values.</p>
<p id="P70004970270000000000000000409F0" data-uri="chapter03.xhtml#P70004970270000000000000000409F0" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P70004970270000000000000000027B9"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.22(a)</span></a> shows an example of a C <code id="P70004970270000000000000000409F1" data-uri="chapter03.xhtml#P70004970270000000000000000409F1" class="pcalibre1 calibre1 pcalibre2">switch</code> statement. This example has a number of interesting features, including case labels that do not span a contiguous range (there are no labels for cases 101 and 105), cases with multiple labels (cases 104 and 106), and cases that <i class="pcalibre17 pcalibre2 pcalibre1">fall through</i> to other cases (case 102) because the code for the case does not end with a <code id="P70004970270000000000000000409F2" data-uri="chapter03.xhtml#P70004970270000000000000000409F2" class="pcalibre1 calibre1 pcalibre2">break</code> statement.</p>
<p id="P70004970270000000000000000409F3" data-uri="chapter03.xhtml#P70004970270000000000000000409F3" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P70004970270000000000000000027CC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.23</span></a> shows the assembly code generated when compiling <code id="P70004970270000000000000000409F4" data-uri="chapter03.xhtml#P70004970270000000000000000409F4" class="pcalibre1 calibre1 pcalibre2">switch_eg.</code> The behavior of this code is shown in C as the procedure <code id="P70004970270000000000000000409F5" data-uri="chapter03.xhtml#P70004970270000000000000000409F5" class="pcalibre1 calibre1 pcalibre2">switch_eg_impl</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P70004970270000000000000000027B9"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.22(b)</span></a>. This code makes use of support provided by <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>for jump tables, as an extension to the C language. The array <code id="P70004970270000000000000000409F6" data-uri="chapter03.xhtml#P70004970270000000000000000409F6" class="pcalibre1 calibre1 pcalibre2">jt</code> contains seven entries, each of which is the address of a block of code. These locations are defined by labels in the code and indicated in the entries in <code id="P70004970270000000000000000409F7" data-uri="chapter03.xhtml#P70004970270000000000000000409F7" class="pcalibre1 calibre1 pcalibre2">jt</code> by code pointers, consisting of the labels prefixed by <code id="P70004970270000000000000000409F8" data-uri="chapter03.xhtml#P70004970270000000000000000409F8" class="pcalibre1 calibre1 pcalibre2">&amp;&amp;.</code> (Recall that the operator <code id="P70004970270000000000000000409F9" data-uri="chapter03.xhtml#P70004970270000000000000000409F9" class="pcalibre1 calibre1 pcalibre2">`&amp;'</code> creates a pointer for a data value. In making this extension, the authors of <span class="pcalibre1 pcalibre29 pcalibre2">Gcc </span>created a new operator <code id="P70004970270000000000000000409FA" data-uri="chapter03.xhtml#P70004970270000000000000000409FA" class="pcalibre1 calibre1 pcalibre2">&amp;&amp;</code> to create a pointer for a code location.) We recommend that you study the C procedure <code id="P70004970270000000000000000409FB" data-uri="chapter03.xhtml#P70004970270000000000000000409FB" class="pcalibre1 calibre1 pcalibre2">switch_eg_impl</code> and how it relates to the assembly-code version.</p>
<p id="P70004970270000000000000000409FC" data-uri="chapter03.xhtml#P70004970270000000000000000409FC" class="pcalibre8 pcalibre1 pcalibre2">Our original C code has cases for values 100, 102â€“104, and 106, but the switch variable <code id="P70004970270000000000000000409FD" data-uri="chapter03.xhtml#P70004970270000000000000000409FD" class="pcalibre1 calibre1 pcalibre2">n</code> can be an arbitrary integer. The compiler first shifts the range to between 0 and 6 by subtracting 100 from <code id="P70004970270000000000000000409FE" data-uri="chapter03.xhtml#P70004970270000000000000000409FE" class="pcalibre1 calibre1 pcalibre2">n</code>, creating a new program variable that we call index in our C version. It further simplifies the branching possibilities by treating <code id="P70004970270000000000000000409FF" data-uri="chapter03.xhtml#P70004970270000000000000000409FF" class="pcalibre1 calibre1 pcalibre2">index</code> as an <i class="pcalibre17 pcalibre2 pcalibre1">unsigned</i> value, making use of the fact that negative numbers in a two's-complement representation map to large positive numbers in an unsigned representation. It can therefore test whether <code id="P7000497027000000000000000040A00" data-uri="chapter03.xhtml#P7000497027000000000000000040A00" class="pcalibre1 calibre1 pcalibre2">index</code> is outside of the range 0â€“6 by testing whether it is greater than 6. In the C and assembly code, there are five distinct locations to jump to, based on the value of <code id="P7000497027000000000000000040A01" data-uri="chapter03.xhtml#P7000497027000000000000000040A01" class="pcalibre1 calibre1 pcalibre2">index</code>. These are <code id="P7000497027000000000000000040A02" data-uri="chapter03.xhtml#P7000497027000000000000000040A02" class="pcalibre1 calibre1 pcalibre2">loc_A</code> (identified in the assembly code as <code id="P7000497027000000000000000040A03" data-uri="chapter03.xhtml#P7000497027000000000000000040A03" class="pcalibre1 calibre1 pcalibre2">.L3), loc_B (.L5), loc_C (.L6), loc_D (.L7)</code>, and <code id="P7000497027000000000000000040A04" data-uri="chapter03.xhtml#P7000497027000000000000000040A04" class="pcalibre1 calibre1 pcalibre2">loc_def (.L8)</code>, where the latter is the destination for the default case. Each of these labels identifies a block of code implementing one of thecase branches. In both the C and the assembly code, the program compares index to 6 and jumps to the code for the default case if it is greater.</p>
<p id="P7000497027000000000000000040A05" data-uri="chapter03.xhtml#P7000497027000000000000000040A05" class="pcalibre8 pcalibre1 pcalibre2">The key step in executing a <code id="P7000497027000000000000000040A06" data-uri="chapter03.xhtml#P7000497027000000000000000040A06" class="pcalibre1 calibre1 pcalibre2">switch</code> statement is to access a code location through the jump table. This occurs in line 16 in the C code, with a <code id="P7000497027000000000000000040A07" data-uri="chapter03.xhtml#P7000497027000000000000000040A07" class="pcalibre1 calibre1 pcalibre2">goto</code> statement that references the jump table <code id="P7000497027000000000000000040A08" data-uri="chapter03.xhtml#P7000497027000000000000000040A08" class="pcalibre1 calibre1 pcalibre2">jt</code>. This <i class="pcalibre17 pcalibre2 pcalibre1">computed goto</i> is supported by <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>as an extension to the C language. In our assembly-code version, a similar operation occurs on line 5, where the <code id="P7000497027000000000000000040A09" data-uri="chapter03.xhtml#P7000497027000000000000000040A09" class="pcalibre1 calibre1 pcalibre2">jmp</code> instruction's operand is prefixed with `*', indicating</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000027B9" data-uri="chapter03.xhtml#P70004970270000000000000000027B9">
<p id="P7000497027000000000000000040A0A" data-uri="chapter03.xhtml#P7000497027000000000000000040A0A" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre123" id="P70004970270000000000000000027BB" title="234" data-uri="chapter03.xhtml#P70004970270000000000000000027BB" epub:type="pagebreak"></span>(a) Switch statement</p>
<pre id="P7000497027000000000000000040A0B" data-uri="chapter03.xhtml#P7000497027000000000000000040A0B" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040A0C" data-uri="chapter03.xhtml#P7000497027000000000000000040A0C" class="calibre3 pcalibre1 pcalibre2">
void switch_eg(long x, long n, long *dest)
{
	long val = x;
	
	switch (n) {

	case 100:
	  val *= 13;
	  break;

	case 102:
	  val += 10;
	  /* Fall through */

	case 103:
	  val += 11;
	  break;

	case 104:
	case 106:
	  val *= val;
	  break;

	default:
	  val = 0;
	}
	*dest = val;
	}
</code></pre>
<p id="P7000497027000000000000000040A0D" data-uri="chapter03.xhtml#P7000497027000000000000000040A0D" class="pcalibre8 pcalibre1 pcalibre2">(b) Translation into extended C</p>
<pre id="P7000497027000000000000000040A0E" data-uri="chapter03.xhtml#P7000497027000000000000000040A0E" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040A0F" data-uri="chapter03.xhtml#P7000497027000000000000000040A0F" class="calibre3 pcalibre1 pcalibre2">
1	void switch_eg_impl(long x, long n,
2						long *dest)
3	{
4		/* Table of code pointers */
5		static void *jt[7] = {
6			&amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B,
7			&amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def,
8			&amp;&amp;loc_D
9		};
10		unsigned long index = n - 100;
11		long val;
12
13		if (index &gt; 6)
14			goto loc_def;
15		/* Multiway branch */
16		goto *jt[index];
17
18	loc_A: /* Case 100 */
19		val = x * 13;
20		goto done;
21	loc_B: /* Case 102 */
22		x = x + 10;
23		/* Fall through */
24	loc_C: /* Case 103 */
25		val = x + 11;
26		goto done;
27	loc_D: /* Cases 104, 106 */
28		val = x * x;
29		goto done;
30	loc_def: /* Default case */
31		val = 0;
32	done:
33		*dest = val;
34	}
</code></pre>
<figcaption id="P7000497027000000000000000040A10" data-uri="chapter03.xhtml#P7000497027000000000000000040A10" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000040A11" data-uri="chapter03.xhtml#P7000497027000000000000000040A11" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.22 </span>Example <code id="P7000497027000000000000000040A12" data-uri="chapter03.xhtml#P7000497027000000000000000040A12" class="pcalibre1 calibre1 pcalibre2">switch</code> statement and its translation into extended C.</h1></header><div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000040A13" data-uri="chapter03.xhtml#P7000497027000000000000000040A13"><p id="P7000497027000000000000000040A14" data-uri="chapter03.xhtml#P7000497027000000000000000040A14" class="pcalibre1 pcalibre2 pcalibre10">The translation shows the structure of <code id="P7000497027000000000000000040A15" data-uri="chapter03.xhtml#P7000497027000000000000000040A15" class="pcalibre1 calibre1 pcalibre2">jump</code> table <code id="P7000497027000000000000000040A16" data-uri="chapter03.xhtml#P7000497027000000000000000040A16" class="pcalibre1 calibre1 pcalibre2">jt</code> and how it is accessed. Such tables are supported by <span class="pcalibre1 pcalibre2 pcalibre84">gcc </span>as an extension to the C language.</p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040A17" data-uri="chapter03.xhtml#P7000497027000000000000000040A17">an indirect jump, and the operand specifies a memory location indexed by register <code id="P7000497027000000000000000040A18" data-uri="chapter03.xhtml#P7000497027000000000000000040A18" class="pcalibre1 calibre1 pcalibre2">%eax</code>, which holds the value of <code id="P7000497027000000000000000040A19" data-uri="chapter03.xhtml#P7000497027000000000000000040A19" class="pcalibre1 calibre1 pcalibre2">index</code>. (We will see in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002B19.xhtml#P7000497027000000000000000002B19"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.8</span></a> how array references are translated into machine code.)</p>
<p id="P7000497027000000000000000040A1A" data-uri="chapter03.xhtml#P7000497027000000000000000040A1A" class="pcalibre8 pcalibre1 pcalibre2">Our C code declares the jump table as an array of seven elements, each of which is a pointer to a code location. These elements span values 0â€“6 of</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000027CC" data-uri="chapter03.xhtml#P70004970270000000000000000027CC">
<pre id="P7000497027000000000000000040A1B" data-uri="chapter03.xhtml#P7000497027000000000000000040A1B" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040A1C" data-uri="chapter03.xhtml#P7000497027000000000000000040A1C" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000027CF" title="235" data-uri="chapter03.xhtml#P70004970270000000000000000027CF" epub:type="pagebreak"></span>	<i class="pcalibre17 pcalibre2 pcalibre1">void switch_eg(long x, long n, long *dest</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi, n in %rsi, dest in %rdx</i>
1	switch_eg:
2	  subq $100, %rsi		<i class="pcalibre17 pcalibre2 pcalibre1">Compute index = n-100</i>
3	  cmpq $6, %rsi			<i class="pcalibre17 pcalibre2 pcalibre1">Compare index:6</i>
4	  ja .L8			<i class="pcalibre17 pcalibre2 pcalibre1">If &gt;, goto</i> loc_def
5	  jmp *.L4 (,%rsi,8)		<i class="pcalibre17 pcalibre2 pcalibre1">Goto *jg[index]</i>
6	.L3:			    loc_A:
7	  leaq (%rdi,%rdi,2), %rax	<i class="pcalibre17 pcalibre2 pcalibre1">3*x</i>
8	  leaq (%rdi,%rax,4), %rdi	<i class="pcalibre17 pcalibre2 pcalibre1">val = 13*x</i>
9	  jmp .L2			<i class="pcalibre17 pcalibre2 pcalibre1">Goto</i> done
10	.L5:			    loc_B:
11	  addq $10, %rdi		<i class="pcalibre17 pcalibre2 pcalibre1">x = x + 10</i>
12	.L6:			    loc_C:
13	  addq $11, %rdi		<i class="pcalibre17 pcalibre2 pcalibre1">val = x + 11</i>
14	  jmp .L2			<i class="pcalibre17 pcalibre2 pcalibre1">Goto</i> done
15	.L7:			    loc_D:
16	  imulq %rdi, %rdi		<i class="pcalibre17 pcalibre2 pcalibre1">val = x * x</i>
17	  jmp .L2			<i class="pcalibre17 pcalibre2 pcalibre1">Goto</i> done
18	.L8:			   loc_def:
19	  movl $0, %edi			<i class="pcalibre17 pcalibre2 pcalibre1">val = 0</i>
20	.L2:				done:
21	  movq %rdi, (%rdx)		<i class="pcalibre17 pcalibre2 pcalibre1">*dest = val</i>
22	  ret				<i class="pcalibre17 pcalibre2 pcalibre1">Return</i>
</code></pre>
<figcaption id="P7000497027000000000000000040A1D" data-uri="chapter03.xhtml#P7000497027000000000000000040A1D" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000040A1E" data-uri="chapter03.xhtml#P7000497027000000000000000040A1E" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.23 </span>Assembly code for <code id="P7000497027000000000000000040A1F" data-uri="chapter03.xhtml#P7000497027000000000000000040A1F" class="pcalibre1 calibre1 pcalibre2">switch</code> statement example in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P70004970270000000000000000027B9"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">3.22</span></a>.</h1></header></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000040A20" data-uri="chapter03.xhtml#P7000497027000000000000000040A20"><code id="P7000497027000000000000000040A21" data-uri="chapter03.xhtml#P7000497027000000000000000040A21" class="pcalibre1 calibre1 pcalibre2">index</code>, corresponding to values 100â€“106 of <code id="P7000497027000000000000000040A22" data-uri="chapter03.xhtml#P7000497027000000000000000040A22" class="pcalibre1 calibre1 pcalibre2">n</code>. Observe that the jump table handles duplicate cases by simply having the same code label <code id="P7000497027000000000000000040A23" data-uri="chapter03.xhtml#P7000497027000000000000000040A23" class="pcalibre1 calibre1 pcalibre2">(loc_D)</code> for entries 4 and 6, and it handles missing cases by using the label for the default case <code id="P7000497027000000000000000040A24" data-uri="chapter03.xhtml#P7000497027000000000000000040A24" class="pcalibre1 calibre1 pcalibre2">(loc_def)</code> as entries 1 and 5.</p>
<p id="P7000497027000000000000000040A25" data-uri="chapter03.xhtml#P7000497027000000000000000040A25" class="pcalibre8 pcalibre1 pcalibre2">In the assembly code, the jump table is indicated by the following declarations, to which we have added comments:</p>
<pre id="P7000497027000000000000000040A26" data-uri="chapter03.xhtml#P7000497027000000000000000040A26" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040A27" data-uri="chapter03.xhtml#P7000497027000000000000000040A27" class="calibre3 pcalibre1 pcalibre2">
1	  .section	.rodata
2	  .align 8		<i class="pcalibre17 pcalibre2 pcalibre1">Align address to multiple of 8</i>
3	.L4:
4	  .quad	.L3		<i class="pcalibre17 pcalibre2 pcalibre1">Case 100: loc_A</i>
5	  .quad	.L8		<i class="pcalibre17 pcalibre2 pcalibre1">Case 101: loc_def</i>
6	  .quad	.L5		<i class="pcalibre17 pcalibre2 pcalibre1">Case 102: loc_B</i>
7	  .quad	.L6		<i class="pcalibre17 pcalibre2 pcalibre1">Case 103: loc_C</i>
8	  .quad	.L7		<i class="pcalibre17 pcalibre2 pcalibre1">Case 104: loc_D</i>
9	  .quad	.L8		<i class="pcalibre17 pcalibre2 pcalibre1">Case 105: loc_def</i>
10	  .quad	.L7		<i class="pcalibre17 pcalibre2 pcalibre1">Case 106: loc_D</i>
</code></pre>
<p id="P7000497027000000000000000040A28" data-uri="chapter03.xhtml#P7000497027000000000000000040A28" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000027DC" title="236" data-uri="chapter03.xhtml#P70004970270000000000000000027DC" epub:type="pagebreak"></span>These declarations state that within the segment of the object-code file called <code id="P7000497027000000000000000040A29" data-uri="chapter03.xhtml#P7000497027000000000000000040A29" class="pcalibre1 calibre1 pcalibre2">.rodata</code> (for "read-only data"), there should be a sequence of seven "quad" (8-byte) words, where the value of each word is given by the instruction address associated with the indicated assembly-code labels (e.g., <code id="P7000497027000000000000000040A2A" data-uri="chapter03.xhtml#P7000497027000000000000000040A2A" class="pcalibre1 calibre1 pcalibre2">.L3</code>). Label <code id="P7000497027000000000000000040A2B" data-uri="chapter03.xhtml#P7000497027000000000000000040A2B" class="pcalibre1 calibre1 pcalibre2">.L4</code> marks the start of this allocation. The address associated with this label serves as the base for the indirect jump (line 5).</p>
<p id="P7000497027000000000000000040A2C" data-uri="chapter03.xhtml#P7000497027000000000000000040A2C" class="pcalibre8 pcalibre1 pcalibre2">The different code blocks (C labels <code id="P7000497027000000000000000040A2D" data-uri="chapter03.xhtml#P7000497027000000000000000040A2D" class="pcalibre1 calibre1 pcalibre2">loc_A</code> through <code id="P7000497027000000000000000040A2E" data-uri="chapter03.xhtml#P7000497027000000000000000040A2E" class="pcalibre1 calibre1 pcalibre2">loc_D</code> and <code id="P7000497027000000000000000040A2F" data-uri="chapter03.xhtml#P7000497027000000000000000040A2F" class="pcalibre1 calibre1 pcalibre2">loc_def</code>) implement the different branches of the <code id="P7000497027000000000000000040A30" data-uri="chapter03.xhtml#P7000497027000000000000000040A30" class="pcalibre1 calibre1 pcalibre2">switch</code> statement. Most of them simply compute a value for <code id="P7000497027000000000000000040A31" data-uri="chapter03.xhtml#P7000497027000000000000000040A31" class="pcalibre1 calibre1 pcalibre2">val</code> and then go to the end of the function. Similarly, the assembly-code blocks compute a value for register <code id="P7000497027000000000000000040A32" data-uri="chapter03.xhtml#P7000497027000000000000000040A32" class="pcalibre1 calibre1 pcalibre2">%rdi</code> and jump to the position indicated by label <code id="P7000497027000000000000000040A33" data-uri="chapter03.xhtml#P7000497027000000000000000040A33" class="pcalibre1 calibre1 pcalibre2">.L2</code> at the end of the function. Only the code for case label 102 does not follow this pattern, to account for the way the code for this case falls through to the block with label 103 in the original C code. This is handled in the assembly-code block starting with label <code id="P7000497027000000000000000040A34" data-uri="chapter03.xhtml#P7000497027000000000000000040A34" class="pcalibre1 calibre1 pcalibre2">.L5</code>, by omitting the <code id="P7000497027000000000000000040A35" data-uri="chapter03.xhtml#P7000497027000000000000000040A35" class="pcalibre1 calibre1 pcalibre2">jmp</code> instruction at the end of the block, so that the code continues execution of the next block. Similarly, the C version <code id="P7000497027000000000000000040A36" data-uri="chapter03.xhtml#P7000497027000000000000000040A36" class="pcalibre1 calibre1 pcalibre2">switch_eg_impl</code> has no <code id="P7000497027000000000000000040A37" data-uri="chapter03.xhtml#P7000497027000000000000000040A37" class="pcalibre1 calibre1 pcalibre2">goto</code> statement at the end of the block starting with label <code id="P7000497027000000000000000040A38" data-uri="chapter03.xhtml#P7000497027000000000000000040A38" class="pcalibre1 calibre1 pcalibre2">loc_B.</code></p>
<p id="P7000497027000000000000000040A39" data-uri="chapter03.xhtml#P7000497027000000000000000040A39" class="pcalibre8 pcalibre1 pcalibre2">Examining all of this code requires careful study, but the key point is to see that the use of a jump table allows a very efficient way to implement a multiway branch. In our case, the program could branch to five distinct locations with a single jump table reference. Even if we had a <code id="P7000497027000000000000000040A3A" data-uri="chapter03.xhtml#P7000497027000000000000000040A3A" class="pcalibre1 calibre1 pcalibre2">switch</code> statement with hundreds of cases, they could be handled by a single jump table access.</p>
<section id="P70004970270000000000000000027EF" data-uri="chapter03.xhtml#P70004970270000000000000000027EF" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000040A3B" data-uri="chapter03.xhtml#P7000497027000000000000000040A3B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.30 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P70004970270000000000000000036C5">338</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000040A3C" data-uri="chapter03.xhtml#P7000497027000000000000000040A3C">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000040A3D" data-uri="chapter03.xhtml#P7000497027000000000000000040A3D">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000040A3E" data-uri="chapter03.xhtml#P7000497027000000000000000040A3E"><p id="P7000497027000000000000000040A3F" data-uri="chapter03.xhtml#P7000497027000000000000000040A3F" class="pcalibre1 pcalibre2 pcalibre10">In the C function that follows, we have omitted the body of the <code id="P7000497027000000000000000040A40" data-uri="chapter03.xhtml#P7000497027000000000000000040A40" class="pcalibre1 calibre1 pcalibre2">switch</code> statement. In the C code, the case labels did not span a contiguous range, and some cases had multiple labels.</p>
<pre id="P7000497027000000000000000040A41" data-uri="chapter03.xhtml#P7000497027000000000000000040A41" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040A42" data-uri="chapter03.xhtml#P7000497027000000000000000040A42" class="calibre3 pcalibre1 pcalibre2">
void switch2 (long x, long *dest) {
	long val = 0;
	switch (x) {
	   â‹® <i class="pcalibre17 pcalibre2 pcalibre1">Body of switch statement omitted</i>
	}
	*dest = val;
}
</code></pre>
<p id="P7000497027000000000000000040A43" data-uri="chapter03.xhtml#P7000497027000000000000000040A43" class="pcalibre1 pcalibre2 pcalibre10">In compiling the function, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the assembly code that follows for the initial part of the procedure, with variable <code id="P7000497027000000000000000040A44" data-uri="chapter03.xhtml#P7000497027000000000000000040A44" class="pcalibre1 calibre1 pcalibre2">x</code> in <code id="P7000497027000000000000000040A45" data-uri="chapter03.xhtml#P7000497027000000000000000040A45" class="pcalibre1 calibre1 pcalibre2">%rdi:</code></p>
<pre id="P7000497027000000000000000040A46" data-uri="chapter03.xhtml#P7000497027000000000000000040A46" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040A47" data-uri="chapter03.xhtml#P7000497027000000000000000040A47" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">void switch2(long x, long *dest</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi</i>
1	switch2:
2	  addq	$1, %rdi
3	  cmpq	$8, %rdi
4	  ja	.L2
5	  jmp	*.L4(,%rdi,8)
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000040A48" data-uri="chapter03.xhtml#P7000497027000000000000000040A48"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000027FE" title="237" data-uri="chapter03.xhtml#P70004970270000000000000000027FE" epub:type="pagebreak"></span>It generates the following code for the jump table:</p>
<pre id="P7000497027000000000000000040A49" data-uri="chapter03.xhtml#P7000497027000000000000000040A49" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040A4A" data-uri="chapter03.xhtml#P7000497027000000000000000040A4A" class="calibre3 pcalibre1 pcalibre2">
1	.L4:
2	.quad	.L9
3	.quad	.L5
4	.quad	.L6
5	.quad	.L7
6	.quad	.L2
7	.quad	.L7
8	.quad	.L8
9	.quad	.L2
10	.quad	.L5
</code></pre>
<p id="P7000497027000000000000000040A4B" data-uri="chapter03.xhtml#P7000497027000000000000000040A4B" class="pcalibre1 pcalibre2 pcalibre10">Based on this information, answer the following questions:</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000040A4C" data-uri="chapter03.xhtml#P7000497027000000000000000040A4C">
<li id="P7000497027000000000000000040A4D" data-uri="chapter03.xhtml#P7000497027000000000000000040A4D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040A4E" data-uri="chapter03.xhtml#P7000497027000000000000000040A4E" class="pcalibre1 pcalibre2 pcalibre10">What were the values of the case labels in the <code id="P7000497027000000000000000040A4F" data-uri="chapter03.xhtml#P7000497027000000000000000040A4F" class="pcalibre1 calibre1 pcalibre2">switch</code> statement?</p></li>
<li id="P7000497027000000000000000040A50" data-uri="chapter03.xhtml#P7000497027000000000000000040A50" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000040A51" data-uri="chapter03.xhtml#P7000497027000000000000000040A51" class="pcalibre1 pcalibre2 pcalibre10">What cases had multiple labels in the C code?</p></li>
</ol></div></li></ol>
</section>
<section id="P7000497027000000000000000002808" data-uri="chapter03.xhtml#P7000497027000000000000000002808" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000040A52" data-uri="chapter03.xhtml#P7000497027000000000000000040A52" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.31 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P70004970270000000000000000036C5">338</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000040A53" data-uri="chapter03.xhtml#P7000497027000000000000000040A53">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000040A54" data-uri="chapter03.xhtml#P7000497027000000000000000040A54">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000040A55" data-uri="chapter03.xhtml#P7000497027000000000000000040A55"><p id="P7000497027000000000000000040A56" data-uri="chapter03.xhtml#P7000497027000000000000000040A56" class="pcalibre1 pcalibre2 pcalibre10">For a C function <code id="P7000497027000000000000000040A57" data-uri="chapter03.xhtml#P7000497027000000000000000040A57" class="pcalibre1 calibre1 pcalibre2">switcher</code> with the general structure</p>
<pre id="P7000497027000000000000000040A58" data-uri="chapter03.xhtml#P7000497027000000000000000040A58" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040A59" data-uri="chapter03.xhtml#P7000497027000000000000000040A59" class="calibre3 pcalibre1 pcalibre2">
void switcher(long a, long b, long c, long *dest)
{
	long val;
	switch(a) {
	case __________:	/* CaseA*/
	  c= __________;
	  /* Fall through */
	case __________:	/* Case B */
	  val= __________;
	  break;
	case __________:	/* Case C */
	case __________:	/* Case D */
	  val = __________;
	  break;
	case __________:	/* Case E */
	  val = __________;
	  break;
	default:
	  val = __________;
	}
	*dest = val;
}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000040A5A" data-uri="chapter03.xhtml#P7000497027000000000000000040A5A"><span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the assembly code and jump table shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002815"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.24</span></a>.</p>
<p id="P7000497027000000000000000040A5B" data-uri="chapter03.xhtml#P7000497027000000000000000040A5B" class="pcalibre1 pcalibre2 pcalibre10">Fill in the missing parts of the C code. Except for the ordering of case labels <code id="P7000497027000000000000000040A5C" data-uri="chapter03.xhtml#P7000497027000000000000000040A5C" class="pcalibre1 calibre1 pcalibre2">C</code> and <code id="P7000497027000000000000000040A5D" data-uri="chapter03.xhtml#P7000497027000000000000000040A5D" class="pcalibre1 calibre1 pcalibre2">D</code>, there is only one way to fit the different cases into the template.</p>
</div></li></ol>
</section>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002815" data-uri="chapter03.xhtml#P7000497027000000000000000002815">
<p id="P7000497027000000000000000040A5E" data-uri="chapter03.xhtml#P7000497027000000000000000040A5E" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000002817" title="238" data-uri="chapter03.xhtml#P7000497027000000000000000002817" epub:type="pagebreak"></span>(a) Code</p>
<pre id="P7000497027000000000000000040A5F" data-uri="chapter03.xhtml#P7000497027000000000000000040A5F" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040A60" data-uri="chapter03.xhtml#P7000497027000000000000000040A60" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">void switcher(long a, long b, long c, long *dest</i>)
	<i class="pcalibre17 pcalibre2 pcalibre1">a in %rsi, b in %rdi, c in %rdx, d in %rcx</i>
1	switcher:
2	  cmpq	$7, %rdi
3	  ja	.L2
4	  jmp	*.L4(,%rdi,8)
5	  .section	.rodata
6	.L7:
7	  xorq	$15, %rsi
8	  movq	%rsi, %rdx
9	.L3:
10	  leaq	112(%rdx), %rdi
11	  jmp	.L6
12  .L5:
13	  leaq	(%rdx,%rsi), %rdi
14	  salq	$2, %rdi
15	  jmp	.L6
16	.L2:
17	  movq	%rsi, %rdi
18	.L6:
19	  movq	%rdi, (%rcx)
20	  ret
</code></pre>
<p id="P7000497027000000000000000040A61" data-uri="chapter03.xhtml#P7000497027000000000000000040A61" class="pcalibre8 pcalibre1 pcalibre2">(b) Jump table</p>
<pre id="P7000497027000000000000000040A62" data-uri="chapter03.xhtml#P7000497027000000000000000040A62" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000040A63" data-uri="chapter03.xhtml#P7000497027000000000000000040A63" class="calibre3 pcalibre1 pcalibre2">
1	.L4:
2	.quad	.L3
3	.quad	.L2
4	.quad	.L5
5	.quad	.L2
6	.quad	.L6
7	.quad	.L7
8	.quad	.L2
9	.quad	.L5
</code></pre>
<figcaption id="P7000497027000000000000000040A64" data-uri="chapter03.xhtml#P7000497027000000000000000040A64" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000040A65" data-uri="chapter03.xhtml#P7000497027000000000000000040A65" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.24 </span>Assembly code and jump table for <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_001.xhtml#P7000497027000000000000000002808"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">3.31</span></a>.</h1></header></figcaption>
</figure>
</section>
</section></body></html>
