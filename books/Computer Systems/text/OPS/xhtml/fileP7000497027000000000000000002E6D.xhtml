<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>3.10 Combining Control and Data in Machine-Level Programs</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000002E6D" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P70004970270000000000000000410B2" data-uri="chapter03.xhtml#P70004970270000000000000000410B2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.10 </span>Combining Control and Data in Machine-Level Programs</h1></header>
<p id="P70004970270000000000000000410B3" data-uri="chapter03.xhtml#P70004970270000000000000000410B3" class="pcalibre8 pcalibre1 pcalibre2">So far, we have looked separately at how machine-level code implements the control aspects of a program and how it implements different data structures. In this section, we look at ways in which data and control interact with each other. We start by taking a deep look into pointers, one of the most important concepts in the C programming language, but one for which many programmers only have a shallow understanding. We review the use of the symbolic debugger <span class="pcalibre1 pcalibre29 pcalibre2">gdb</span> for examining the detailed operation of machine-level programs. Next, we see how understanding machine-level programs enables us to study buffer overflow, an important security vulnerability in many real-world systems. Finally, we examine <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002E70" title="277" data-uri="chapter03.xhtml#P7000497027000000000000000002E70" epub:type="pagebreak"></span>how machine-level programs implement cases where the amount of stack storage required by a function can vary from one execution to another.</p>
<section id="P7000497027000000000000000002E71" data-uri="chapter03.xhtml#P7000497027000000000000000002E71" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000410B4" data-uri="chapter03.xhtml#P70004970270000000000000000410B4" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.10.1 </span>Understanding Pointers</h1></header>
<p id="P70004970270000000000000000410B5" data-uri="chapter03.xhtml#P70004970270000000000000000410B5" class="pcalibre8 pcalibre1 pcalibre2">Pointers are a central feature of the C programming language. They serve as a uniform way to generate references to elements within different data structures. Pointers are a source of confusion for novice programmers, but the underlying concepts are fairly simple. Here we highlight some key principles of pointers and their mapping into machine code.</p>
<ul id="P70004970270000000000000000410B6" data-uri="chapter03.xhtml#P70004970270000000000000000410B6" class="pcalibre1 calibre9 pcalibre2">
<li id="P70004970270000000000000000410B7" data-uri="chapter03.xhtml#P70004970270000000000000000410B7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410B8" data-uri="chapter03.xhtml#P70004970270000000000000000410B8" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Every pointer has an associated type. </span>This type indicates what kind of object the pointer points to. Using the following pointer declarations as illustrations</p>
<pre id="P70004970270000000000000000410B9" data-uri="chapter03.xhtml#P70004970270000000000000000410B9" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000410BA" data-uri="chapter03.xhtml#P70004970270000000000000000410BA" class="calibre3 pcalibre1 pcalibre2">
int *ip; char **cpp;
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000410BB" data-uri="chapter03.xhtml#P70004970270000000000000000410BB">variable <code id="P70004970270000000000000000410BC" data-uri="chapter03.xhtml#P70004970270000000000000000410BC" class="pcalibre1 calibre1 pcalibre2">ip</code> is a pointer to an object of type <code id="P70004970270000000000000000410BD" data-uri="chapter03.xhtml#P70004970270000000000000000410BD" class="pcalibre1 calibre1 pcalibre2">int</code>, while <code id="P70004970270000000000000000410BE" data-uri="chapter03.xhtml#P70004970270000000000000000410BE" class="pcalibre1 calibre1 pcalibre2">cpp</code> is a pointer to an object that itself is a pointer to an object of type <code id="P70004970270000000000000000410BF" data-uri="chapter03.xhtml#P70004970270000000000000000410BF" class="pcalibre1 calibre1 pcalibre2">char</code>. In general, if the object has type <var class="pcalibre17 pcalibre2 pcalibre1">T</var>, then the pointer has type *<var class="pcalibre17 pcalibre2 pcalibre1">T</var>. The special <code id="P70004970270000000000000000410C0" data-uri="chapter03.xhtml#P70004970270000000000000000410C0" class="pcalibre1 calibre1 pcalibre2">void</code> * type represents a generic pointer. For example, the <code id="P70004970270000000000000000410C1" data-uri="chapter03.xhtml#P70004970270000000000000000410C1" class="pcalibre1 calibre1 pcalibre2">malloc</code> function returns a generic pointer, which is converted to a typed pointer via either an explicit cast or by the implicit casting of the assignment operation. Pointer types are not part of machine code; they are an abstraction provided by C to help programmers avoid addressing errors.</p></li>
<li id="P70004970270000000000000000410C2" data-uri="chapter03.xhtml#P70004970270000000000000000410C2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410C3" data-uri="chapter03.xhtml#P70004970270000000000000000410C3" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Every pointer has a value. </span>This value is an address of some object of the designated type. The special <code id="P70004970270000000000000000410C4" data-uri="chapter03.xhtml#P70004970270000000000000000410C4" class="pcalibre1 calibre1 pcalibre2">NULL (0)</code> value indicates that the pointer does not point anywhere.</p></li>
<li id="P70004970270000000000000000410C5" data-uri="chapter03.xhtml#P70004970270000000000000000410C5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410C6" data-uri="chapter03.xhtml#P70004970270000000000000000410C6" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Pointers are created with the `&amp;' operator. </span>This operator can be applied to any C expression that is categorized as an <i class="pcalibre17 pcalibre2 pcalibre1">lvalue</i>, meaning an expression that can appear on the left side of an assignment. Examples include variables and the elements of structures, unions, and arrays. We have seen that the machine-code realization of the `&amp;' operator often uses the <code id="P70004970270000000000000000410C7" data-uri="chapter03.xhtml#P70004970270000000000000000410C7" class="pcalibre1 calibre1 pcalibre2">leaq</code> instruction to compute the expression value, since this instruction is designed to compute the address of a memory reference.</p></li>
<li id="P70004970270000000000000000410C8" data-uri="chapter03.xhtml#P70004970270000000000000000410C8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410C9" data-uri="chapter03.xhtml#P70004970270000000000000000410C9" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Pointers are dereferenced with the `*' operator. </span>The result is a value having the type associated with the pointer. Dereferencing is implemented by a memory reference, either storing to or retrieving from the specified address.</p></li>
<li id="P70004970270000000000000000410CA" data-uri="chapter03.xhtml#P70004970270000000000000000410CA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410CB" data-uri="chapter03.xhtml#P70004970270000000000000000410CB" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Arrays and pointers are closely related. </span>The name of an array canbe referenced (but not updated) as if it were a pointer variable. Array referencing (e.g., <code id="P70004970270000000000000000410CC" data-uri="chapter03.xhtml#P70004970270000000000000000410CC" class="pcalibre1 calibre1 pcalibre2">a[3]</code>) has the exact same effect as pointer arithmetic and dereferencing (e.g., <code id="P70004970270000000000000000410CD" data-uri="chapter03.xhtml#P70004970270000000000000000410CD" class="pcalibre1 calibre1 pcalibre2">*(a+3)</code>). Both array referencing and pointer arithmetic require scaling the offsets by the object size. When we write an expression <code id="P70004970270000000000000000410CE" data-uri="chapter03.xhtml#P70004970270000000000000000410CE" class="pcalibre1 calibre1 pcalibre2">p+i</code> for pointer <code id="P70004970270000000000000000410CF" data-uri="chapter03.xhtml#P70004970270000000000000000410CF" class="pcalibre1 calibre1 pcalibre2">p</code> with value <code id="P70004970270000000000000000410D0" data-uri="chapter03.xhtml#P70004970270000000000000000410D0" class="pcalibre1 calibre1 pcalibre2"><var class="pcalibre17 pcalibre2 pcalibre1">p</var></code>, the resulting address is computed as <i class="pcalibre17 pcalibre2 pcalibre1"><code id="P70004970270000000000000000410D1" data-uri="chapter03.xhtml#P70004970270000000000000000410D1" class="pcalibre1 calibre1 pcalibre2">p</code></i> + <var class="pcalibre17 pcalibre2 pcalibre1">L</var> Â· <var class="pcalibre17 pcalibre2 pcalibre1">i</var>, where <var class="pcalibre17 pcalibre2 pcalibre1">L</var> is the size of the data type associated with <code id="P70004970270000000000000000410D2" data-uri="chapter03.xhtml#P70004970270000000000000000410D2" class="pcalibre1 calibre1 pcalibre2">p</code>.</p></li>
<li id="P70004970270000000000000000410D3" data-uri="chapter03.xhtml#P70004970270000000000000000410D3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410D4" data-uri="chapter03.xhtml#P70004970270000000000000000410D4" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002E93" title="278" data-uri="chapter03.xhtml#P7000497027000000000000000002E93" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre41">Casting from one type of pointer to another changes its type but not its value. </span>One effect of casting is to change any scaling of pointer arithmetic. So, for example, if <code id="P70004970270000000000000000410D5" data-uri="chapter03.xhtml#P70004970270000000000000000410D5" class="pcalibre1 calibre1 pcalibre2">p</code> is a pointer of type <code id="P70004970270000000000000000410D6" data-uri="chapter03.xhtml#P70004970270000000000000000410D6" class="pcalibre1 calibre1 pcalibre2">char</code> * having value <i class="pcalibre17 pcalibre2 pcalibre1"><code id="P70004970270000000000000000410D7" data-uri="chapter03.xhtml#P70004970270000000000000000410D7" class="pcalibre1 calibre1 pcalibre2">p</code></i>, then the expression (<code id="P70004970270000000000000000410D8" data-uri="chapter03.xhtml#P70004970270000000000000000410D8" class="pcalibre1 calibre1 pcalibre2">int *) p+7</code> computes <code id="P70004970270000000000000000410D9" data-uri="chapter03.xhtml#P70004970270000000000000000410D9" class="pcalibre1 calibre1 pcalibre2"><var class="pcalibre17 pcalibre2 pcalibre1">p</var></code> + 28, while <code id="P70004970270000000000000000410DA" data-uri="chapter03.xhtml#P70004970270000000000000000410DA" class="pcalibre1 calibre1 pcalibre2">(int *) (p+7)</code> computes <code id="P70004970270000000000000000410DB" data-uri="chapter03.xhtml#P70004970270000000000000000410DB" class="pcalibre1 calibre1 pcalibre2"><var class="pcalibre17 pcalibre2 pcalibre1">p</var> + 7</code>. (Recall that casting has higher precedence than addition.)</p></li>
<li id="P70004970270000000000000000410DC" data-uri="chapter03.xhtml#P70004970270000000000000000410DC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000410DD" data-uri="chapter03.xhtml#P70004970270000000000000000410DD" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Pointers can also point to functions. </span>This provides a powerful capability for storing and passing references to code, which can be invoked in some other part of the program. For example, if we have a function defined by the prototype</p>
<pre id="P70004970270000000000000000410DE" data-uri="chapter03.xhtml#P70004970270000000000000000410DE" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000410DF" data-uri="chapter03.xhtml#P70004970270000000000000000410DF" class="calibre3 pcalibre1 pcalibre2">
int fun(int x, int *p);
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000410E0" data-uri="chapter03.xhtml#P70004970270000000000000000410E0">then we can declare and assign a pointer <code id="P70004970270000000000000000410E1" data-uri="chapter03.xhtml#P70004970270000000000000000410E1" class="pcalibre1 calibre1 pcalibre2">fp</code> to this function by the following code sequence:</p>
<pre id="P70004970270000000000000000410E2" data-uri="chapter03.xhtml#P70004970270000000000000000410E2" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000410E3" data-uri="chapter03.xhtml#P70004970270000000000000000410E3" class="calibre3 pcalibre1 pcalibre2">int (*fp)(int, int *); fp = fun;
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000410E4" data-uri="chapter03.xhtml#P70004970270000000000000000410E4">We can then invoke the function using this pointer:</p>
<pre id="P70004970270000000000000000410E5" data-uri="chapter03.xhtml#P70004970270000000000000000410E5" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000410E6" data-uri="chapter03.xhtml#P70004970270000000000000000410E6" class="calibre3 pcalibre1 pcalibre2">
int y = 1;
int result = fp(3, &amp;y);
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000410E7" data-uri="chapter03.xhtml#P70004970270000000000000000410E7">The value of a function pointer is the address of the first instruction in the machine-code representation of the function.</p></li>
</ul>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000002EA7" data-uri="chapter03.xhtml#P7000497027000000000000000002EA7"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P70004970270000000000000000410E8" data-uri="chapter03.xhtml#P70004970270000000000000000410E8" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre34">New to C? </span>Function pointers</h1></header>
<p id="P70004970270000000000000000410E9" data-uri="chapter03.xhtml#P70004970270000000000000000410E9" class="pcalibre1 pcalibre2 pcalibre40">The syntax for declaring function pointers is especially difficult for novice programmers to understand. For a declaration such as</p>
<pre id="P70004970270000000000000000410EA" data-uri="chapter03.xhtml#P70004970270000000000000000410EA" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000410EB" data-uri="chapter03.xhtml#P70004970270000000000000000410EB" class="calibre3 pcalibre1 pcalibre2">
int (*f)(int*);
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P70004970270000000000000000410EC" data-uri="chapter03.xhtml#P70004970270000000000000000410EC">it helps to read it starting from the inside (starting with `<code id="P70004970270000000000000000410ED" data-uri="chapter03.xhtml#P70004970270000000000000000410ED" class="pcalibre1 calibre1 pcalibre2">f</code>') and working outward. Thus, we see that <code id="P70004970270000000000000000410EE" data-uri="chapter03.xhtml#P70004970270000000000000000410EE" class="pcalibre1 calibre1 pcalibre2">f</code> is a pointer, as indicated by (<code id="P70004970270000000000000000410EF" data-uri="chapter03.xhtml#P70004970270000000000000000410EF" class="pcalibre1 calibre1 pcalibre2">*f</code>). It is a pointer to a function that has a single <code id="P70004970270000000000000000410F0" data-uri="chapter03.xhtml#P70004970270000000000000000410F0" class="pcalibre1 calibre1 pcalibre2">int</code> * as an argument, as indicated by <code id="P70004970270000000000000000410F1" data-uri="chapter03.xhtml#P70004970270000000000000000410F1" class="pcalibre1 calibre1 pcalibre2">(*f)(int*)</code>. Finally, we see that it is a pointer to a function that takes an <code id="P70004970270000000000000000410F2" data-uri="chapter03.xhtml#P70004970270000000000000000410F2" class="pcalibre1 calibre1 pcalibre2">int</code> * as an argument and returns <code id="P70004970270000000000000000410F3" data-uri="chapter03.xhtml#P70004970270000000000000000410F3" class="pcalibre1 calibre1 pcalibre2">int</code>.</p>
<p id="P70004970270000000000000000410F4" data-uri="chapter03.xhtml#P70004970270000000000000000410F4" class="pcalibre1 pcalibre2 pcalibre40">The parentheses around *<code id="P70004970270000000000000000410F5" data-uri="chapter03.xhtml#P70004970270000000000000000410F5" class="pcalibre1 calibre1 pcalibre2">f</code> are required, because otherwise the declaration</p>
<pre id="P70004970270000000000000000410F6" data-uri="chapter03.xhtml#P70004970270000000000000000410F6" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000410F7" data-uri="chapter03.xhtml#P70004970270000000000000000410F7" class="calibre3 pcalibre1 pcalibre2">
int *f(int*);
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P70004970270000000000000000410F8" data-uri="chapter03.xhtml#P70004970270000000000000000410F8">would be read as</p>
<pre id="P70004970270000000000000000410F9" data-uri="chapter03.xhtml#P70004970270000000000000000410F9" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000410FA" data-uri="chapter03.xhtml#P70004970270000000000000000410FA" class="calibre3 pcalibre1 pcalibre2">
(int *) f(int*);
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P70004970270000000000000000410FB" data-uri="chapter03.xhtml#P70004970270000000000000000410FB">That is, it would be interpreted as a function prototype, declaring a function <code id="P70004970270000000000000000410FC" data-uri="chapter03.xhtml#P70004970270000000000000000410FC" class="pcalibre1 calibre1 pcalibre2">f</code> that has an <code id="P70004970270000000000000000410FD" data-uri="chapter03.xhtml#P70004970270000000000000000410FD" class="pcalibre1 calibre1 pcalibre2">int</code> * as its argument and returns an <code id="P70004970270000000000000000410FE" data-uri="chapter03.xhtml#P70004970270000000000000000410FE" class="pcalibre1 calibre1 pcalibre2">int</code> *.</p>
<p id="P70004970270000000000000000410FF" data-uri="chapter03.xhtml#P70004970270000000000000000410FF" class="pcalibre1 pcalibre2 pcalibre10">Kernighan and Ritchie <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41C">[61,</a> Sect. 5.12] present a helpful tutorial on reading C declarations.</p>
</aside>
</section>
<section id="P7000497027000000000000000002EC0" data-uri="chapter03.xhtml#P7000497027000000000000000002EC0" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041100" data-uri="chapter03.xhtml#P7000497027000000000000000041100" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002EC2" title="279" data-uri="chapter03.xhtml#P7000497027000000000000000002EC2" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">3.10.2 </span>Life in the Real World: Using the <span class="pcalibre1 pcalibre29 pcalibre2">gdb </span>Debugger</h1></header>
<p id="P7000497027000000000000000041101" data-uri="chapter03.xhtml#P7000497027000000000000000041101" class="pcalibre8 pcalibre1 pcalibre2">The GNU debugger <span class="pcalibre1 pcalibre29 pcalibre2">gdb </span>provides a number of useful features to support the run-time evaluation and analysis of machine-level programs. With the examples and exercises in this book, we attempt to infer the behavior of a program by just looking at the code. Using <span class="pcalibre1 pcalibre29 pcalibre2">gdb</span>, it becomes possible to study the behavior by watching the program in action while having considerable control over its execution.</p>
<p id="P7000497027000000000000000041102" data-uri="chapter03.xhtml#P7000497027000000000000000041102" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000002ED2"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.39</span></a> shows examples of some <span class="pcalibre1 pcalibre29 pcalibre2">gdb </span>commands that help when working with machine-level x86-64 programs. It is very helpful to first run <span class="pcalibre1 pcalibre29 pcalibre2">objdump </span>to get a disassembled version of the program. Our examples are based on running <span class="pcalibre1 pcalibre29 pcalibre2">gdb </span>on the file <code id="P7000497027000000000000000041103" data-uri="chapter03.xhtml#P7000497027000000000000000041103" class="pcalibre1 calibre1 pcalibre2">prog</code>, described and disassembled on page 175. We start <span class="pcalibre1 pcalibre29 pcalibre2">gdb </span>with the following command line:</p>
<pre id="P7000497027000000000000000041104" data-uri="chapter03.xhtml#P7000497027000000000000000041104" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041105" data-uri="chapter03.xhtml#P7000497027000000000000000041105" class="calibre3 pcalibre1 pcalibre2">
linux&gt; <i class="pcalibre17 pcalibre2 pcalibre1">gdb prog</i>
</code></pre>
<p id="P7000497027000000000000000041106" data-uri="chapter03.xhtml#P7000497027000000000000000041106" class="pcalibre8 pcalibre1 pcalibre2">The general scheme is to set breakpoints near points of interest in the program. These can be set to just after the entry of a function or at a program address. When one of the breakpoints is hit during program execution, the program will halt and return control to the user. From a breakpoint, we can examine different registers and memory locations in various formats. We can also single-step the program, running just a few instructions at a time, or we can proceed to the next breakpoint.</p>
<p id="P7000497027000000000000000041107" data-uri="chapter03.xhtml#P7000497027000000000000000041107" class="pcalibre8 pcalibre1 pcalibre2">As our examples suggest, <span class="pcalibre1 pcalibre29 pcalibre2">gdb </span>has an obscure command syntax, but the online help information (invoked within <span class="pcalibre1 pcalibre29 pcalibre2">gdb </span>with the <code id="P7000497027000000000000000041108" data-uri="chapter03.xhtml#P7000497027000000000000000041108" class="pcalibre1 calibre1 pcalibre2">help</code> command) overcomes this shortcoming. Rather than using the command-line interface to <span class="pcalibre1 pcalibre29 pcalibre2">gdb</span>, many programmers prefer using <span class="pcalibre1 pcalibre29 pcalibre2">ddd</span>, an extension to <span class="pcalibre1 pcalibre29 pcalibre2">gdb </span>that provides a graphical user interface.</p>
</section>
<section id="P7000497027000000000000000002ECB" data-uri="chapter03.xhtml#P7000497027000000000000000002ECB" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041109" data-uri="chapter03.xhtml#P7000497027000000000000000041109" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.10.3 </span>Out-of-Bounds Memory References and Buffer Overflow</h1></header>
<p id="P700049702700000000000000004110A" data-uri="chapter03.xhtml#P700049702700000000000000004110A" class="pcalibre8 pcalibre1 pcalibre2">We have seen that C does not perform any bounds checking for array references, and that local variables are stored on the stack along with state information such as saved register values and return addresses. This combination can lead to serious program errors, where the state stored on the stack gets corrupted by a write to an out-of-bounds array element. When the program then tries to reload the register or execute a <code id="P700049702700000000000000004110B" data-uri="chapter03.xhtml#P700049702700000000000000004110B" class="pcalibre1 calibre1 pcalibre2">ret</code> instruction with this corrupted state, things can go seriously wrong.</p>
<p id="P700049702700000000000000004110C" data-uri="chapter03.xhtml#P700049702700000000000000004110C" class="pcalibre8 pcalibre1 pcalibre2">A particularly common source of state corruption is known as <i class="pcalibre17 pcalibre2 pcalibre1">buffer overflow</i>. Typically, some character array is allocated on the stack to hold a string, but the size of the string exceeds the space allocated for the array. This is demonstrated by the following program example:</p>
<pre id="P700049702700000000000000004110D" data-uri="chapter03.xhtml#P700049702700000000000000004110D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004110E" data-uri="chapter03.xhtml#P700049702700000000000000004110E" class="calibre3 pcalibre1 pcalibre2">
/* Implementation of library function gets() */
char *gets(char *s)
{
	int c;
	char *dest = s;
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002ED2" data-uri="chapter03.xhtml#P7000497027000000000000000002ED2">
<table class="pcalibre1 pcalibre2 pcalibre43" id="P700049702700000000000000004110F" data-uri="chapter03.xhtml#P700049702700000000000000004110F">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000041110" data-uri="chapter03.xhtml#P7000497027000000000000000041110" class="pcalibre1 pcalibre2 calibre5"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000002ED5" title="280" data-uri="chapter03.xhtml#P7000497027000000000000000002ED5" epub:type="pagebreak"></span>Command</th>
<th id="P7000497027000000000000000041111" data-uri="chapter03.xhtml#P7000497027000000000000000041111" class="pcalibre1 pcalibre2 calibre5">Effect</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P7000497027000000000000000041112" data-uri="chapter03.xhtml#P7000497027000000000000000041112" class="pcalibre1 pcalibre2 calibre7">Starting and stopping</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041113" data-uri="chapter03.xhtml#P7000497027000000000000000041113" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041114" data-uri="chapter03.xhtml#P7000497027000000000000000041114" class="calibre3 pcalibre1 pcalibre2">quit</code></td>
<td id="P7000497027000000000000000041115" data-uri="chapter03.xhtml#P7000497027000000000000000041115" class="pcalibre1 pcalibre2 calibre7">Exit <span class="pcalibre1 pcalibre2 pcalibre84">gdb</span></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041116" data-uri="chapter03.xhtml#P7000497027000000000000000041116" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041117" data-uri="chapter03.xhtml#P7000497027000000000000000041117" class="calibre3 pcalibre1 pcalibre2">run</code></td>
<td id="P7000497027000000000000000041118" data-uri="chapter03.xhtml#P7000497027000000000000000041118" class="pcalibre1 pcalibre2 calibre7">Run your program (give command-line arguments here)</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041119" data-uri="chapter03.xhtml#P7000497027000000000000000041119" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004111A" data-uri="chapter03.xhtml#P700049702700000000000000004111A" class="calibre3 pcalibre1 pcalibre2">kill</code></td>
<td id="P700049702700000000000000004111B" data-uri="chapter03.xhtml#P700049702700000000000000004111B" class="pcalibre1 pcalibre2 calibre7">Stop your program</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P700049702700000000000000004111C" data-uri="chapter03.xhtml#P700049702700000000000000004111C" class="pcalibre1 pcalibre2 calibre7">Breakpoints</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004111D" data-uri="chapter03.xhtml#P700049702700000000000000004111D" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004111E" data-uri="chapter03.xhtml#P700049702700000000000000004111E" class="calibre3 pcalibre1 pcalibre2">break multstore</code></td>
<td id="P700049702700000000000000004111F" data-uri="chapter03.xhtml#P700049702700000000000000004111F" class="pcalibre1 pcalibre2 calibre7">Set breakpoint at entry to function multstore</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041120" data-uri="chapter03.xhtml#P7000497027000000000000000041120" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041121" data-uri="chapter03.xhtml#P7000497027000000000000000041121" class="calibre3 pcalibre1 pcalibre2">break *0x400540</code></td>
<td id="P7000497027000000000000000041122" data-uri="chapter03.xhtml#P7000497027000000000000000041122" class="pcalibre1 pcalibre2 calibre7">Set breakpoint at address <code id="P7000497027000000000000000041123" data-uri="chapter03.xhtml#P7000497027000000000000000041123" class="calibre3 pcalibre1 pcalibre2">0x400540</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041124" data-uri="chapter03.xhtml#P7000497027000000000000000041124" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041125" data-uri="chapter03.xhtml#P7000497027000000000000000041125" class="calibre3 pcalibre1 pcalibre2">delete 1</code></td>
<td id="P7000497027000000000000000041126" data-uri="chapter03.xhtml#P7000497027000000000000000041126" class="pcalibre1 pcalibre2 calibre7">Delete breakpoint 1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041127" data-uri="chapter03.xhtml#P7000497027000000000000000041127" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041128" data-uri="chapter03.xhtml#P7000497027000000000000000041128" class="calibre3 pcalibre1 pcalibre2">delete</code></td>
<td id="P7000497027000000000000000041129" data-uri="chapter03.xhtml#P7000497027000000000000000041129" class="pcalibre1 pcalibre2 calibre7">Delete all breakpoints</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P700049702700000000000000004112A" data-uri="chapter03.xhtml#P700049702700000000000000004112A" class="pcalibre1 pcalibre2 calibre7">Execution</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004112B" data-uri="chapter03.xhtml#P700049702700000000000000004112B" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004112C" data-uri="chapter03.xhtml#P700049702700000000000000004112C" class="calibre3 pcalibre1 pcalibre2">stepi</code></td>
<td id="P700049702700000000000000004112D" data-uri="chapter03.xhtml#P700049702700000000000000004112D" class="pcalibre1 pcalibre2 calibre7">Execute one instruction</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004112E" data-uri="chapter03.xhtml#P700049702700000000000000004112E" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004112F" data-uri="chapter03.xhtml#P700049702700000000000000004112F" class="calibre3 pcalibre1 pcalibre2">stepi 4</code></td>
<td id="P7000497027000000000000000041130" data-uri="chapter03.xhtml#P7000497027000000000000000041130" class="pcalibre1 pcalibre2 calibre7">Execute four instructions</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041131" data-uri="chapter03.xhtml#P7000497027000000000000000041131" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041132" data-uri="chapter03.xhtml#P7000497027000000000000000041132" class="calibre3 pcalibre1 pcalibre2">nexti</code></td>
<td id="P7000497027000000000000000041133" data-uri="chapter03.xhtml#P7000497027000000000000000041133" class="pcalibre1 pcalibre2 calibre7">Like <code id="P7000497027000000000000000041134" data-uri="chapter03.xhtml#P7000497027000000000000000041134" class="calibre3 pcalibre1 pcalibre2">stepi</code>, but proceed through function calls</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041135" data-uri="chapter03.xhtml#P7000497027000000000000000041135" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041136" data-uri="chapter03.xhtml#P7000497027000000000000000041136" class="calibre3 pcalibre1 pcalibre2">continue</code></td>
<td id="P7000497027000000000000000041137" data-uri="chapter03.xhtml#P7000497027000000000000000041137" class="pcalibre1 pcalibre2 calibre7">Resume execution</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041138" data-uri="chapter03.xhtml#P7000497027000000000000000041138" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041139" data-uri="chapter03.xhtml#P7000497027000000000000000041139" class="calibre3 pcalibre1 pcalibre2">finish</code></td>
<td id="P700049702700000000000000004113A" data-uri="chapter03.xhtml#P700049702700000000000000004113A" class="pcalibre1 pcalibre2 calibre7">Run until current function returns</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P700049702700000000000000004113B" data-uri="chapter03.xhtml#P700049702700000000000000004113B" class="pcalibre1 pcalibre2 calibre7">Examining code</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004113C" data-uri="chapter03.xhtml#P700049702700000000000000004113C" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004113D" data-uri="chapter03.xhtml#P700049702700000000000000004113D" class="calibre3 pcalibre1 pcalibre2">disas</code></td>
<td id="P700049702700000000000000004113E" data-uri="chapter03.xhtml#P700049702700000000000000004113E" class="pcalibre1 pcalibre2 calibre7">Disassemble current function</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004113F" data-uri="chapter03.xhtml#P700049702700000000000000004113F" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041140" data-uri="chapter03.xhtml#P7000497027000000000000000041140" class="calibre3 pcalibre1 pcalibre2">disas multstore</code></td>
<td id="P7000497027000000000000000041141" data-uri="chapter03.xhtml#P7000497027000000000000000041141" class="pcalibre1 pcalibre2 calibre7">Disassemble function <code id="P7000497027000000000000000041142" data-uri="chapter03.xhtml#P7000497027000000000000000041142" class="calibre3 pcalibre1 pcalibre2">multstore</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041143" data-uri="chapter03.xhtml#P7000497027000000000000000041143" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041144" data-uri="chapter03.xhtml#P7000497027000000000000000041144" class="calibre3 pcalibre1 pcalibre2">disas 0x400544</code></td>
<td id="P7000497027000000000000000041145" data-uri="chapter03.xhtml#P7000497027000000000000000041145" class="pcalibre1 pcalibre2 calibre7">Disassemble function around address <code id="P7000497027000000000000000041146" data-uri="chapter03.xhtml#P7000497027000000000000000041146" class="calibre3 pcalibre1 pcalibre2">0x400544</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041147" data-uri="chapter03.xhtml#P7000497027000000000000000041147" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041148" data-uri="chapter03.xhtml#P7000497027000000000000000041148" class="calibre3 pcalibre1 pcalibre2">disas 0x400540, 0x40054d</code></td>
<td id="P7000497027000000000000000041149" data-uri="chapter03.xhtml#P7000497027000000000000000041149" class="pcalibre1 pcalibre2 calibre7">Disassemble code within specified address range</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004114A" data-uri="chapter03.xhtml#P700049702700000000000000004114A" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004114B" data-uri="chapter03.xhtml#P700049702700000000000000004114B" class="calibre3 pcalibre1 pcalibre2">print /x $rip</code></td>
<td id="P700049702700000000000000004114C" data-uri="chapter03.xhtml#P700049702700000000000000004114C" class="pcalibre1 pcalibre2 calibre7">Print program counter in hex</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P700049702700000000000000004114D" data-uri="chapter03.xhtml#P700049702700000000000000004114D" class="pcalibre1 pcalibre2 calibre7">Examining data</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004114E" data-uri="chapter03.xhtml#P700049702700000000000000004114E" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004114F" data-uri="chapter03.xhtml#P700049702700000000000000004114F" class="calibre3 pcalibre1 pcalibre2">print $rax</code></td>
<td id="P7000497027000000000000000041150" data-uri="chapter03.xhtml#P7000497027000000000000000041150" class="pcalibre1 pcalibre2 calibre7">Print contents of <code id="P7000497027000000000000000041151" data-uri="chapter03.xhtml#P7000497027000000000000000041151" class="calibre3 pcalibre1 pcalibre2">%rax</code> in decimal</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041152" data-uri="chapter03.xhtml#P7000497027000000000000000041152" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041153" data-uri="chapter03.xhtml#P7000497027000000000000000041153" class="calibre3 pcalibre1 pcalibre2">print /x $rax</code></td>
<td id="P7000497027000000000000000041154" data-uri="chapter03.xhtml#P7000497027000000000000000041154" class="pcalibre1 pcalibre2 calibre7">Print contents of <code id="P7000497027000000000000000041155" data-uri="chapter03.xhtml#P7000497027000000000000000041155" class="calibre3 pcalibre1 pcalibre2">%rax</code> in hex</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041156" data-uri="chapter03.xhtml#P7000497027000000000000000041156" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041157" data-uri="chapter03.xhtml#P7000497027000000000000000041157" class="calibre3 pcalibre1 pcalibre2">print /t $rax</code></td>
<td id="P7000497027000000000000000041158" data-uri="chapter03.xhtml#P7000497027000000000000000041158" class="pcalibre1 pcalibre2 calibre7">Print contents of <code id="P7000497027000000000000000041159" data-uri="chapter03.xhtml#P7000497027000000000000000041159" class="calibre3 pcalibre1 pcalibre2">%rax</code> in binary</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004115A" data-uri="chapter03.xhtml#P700049702700000000000000004115A" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004115B" data-uri="chapter03.xhtml#P700049702700000000000000004115B" class="calibre3 pcalibre1 pcalibre2">print 0x100</code></td>
<td id="P700049702700000000000000004115C" data-uri="chapter03.xhtml#P700049702700000000000000004115C" class="pcalibre1 pcalibre2 calibre7">Print decimal representation of <code id="P700049702700000000000000004115D" data-uri="chapter03.xhtml#P700049702700000000000000004115D" class="calibre3 pcalibre1 pcalibre2">0x100</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004115E" data-uri="chapter03.xhtml#P700049702700000000000000004115E" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004115F" data-uri="chapter03.xhtml#P700049702700000000000000004115F" class="calibre3 pcalibre1 pcalibre2">print /x 555</code></td>
<td id="P7000497027000000000000000041160" data-uri="chapter03.xhtml#P7000497027000000000000000041160" class="pcalibre1 pcalibre2 calibre7">Print hex representation of 555</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041161" data-uri="chapter03.xhtml#P7000497027000000000000000041161" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041162" data-uri="chapter03.xhtml#P7000497027000000000000000041162" class="calibre3 pcalibre1 pcalibre2">print /x ($rsp+8)</code></td>
<td id="P7000497027000000000000000041163" data-uri="chapter03.xhtml#P7000497027000000000000000041163" class="pcalibre1 pcalibre2 calibre7">Print contents of <code id="P7000497027000000000000000041164" data-uri="chapter03.xhtml#P7000497027000000000000000041164" class="calibre3 pcalibre1 pcalibre2">%rsp</code> plus 8 in hex</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041165" data-uri="chapter03.xhtml#P7000497027000000000000000041165" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041166" data-uri="chapter03.xhtml#P7000497027000000000000000041166" class="calibre3 pcalibre1 pcalibre2">print *(long *) 0x7fffffffe818</code></td>
<td id="P7000497027000000000000000041167" data-uri="chapter03.xhtml#P7000497027000000000000000041167" class="pcalibre1 pcalibre2 calibre7">Print long integer at address <code id="P7000497027000000000000000041168" data-uri="chapter03.xhtml#P7000497027000000000000000041168" class="calibre3 pcalibre1 pcalibre2">0x7fffffffe818</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041169" data-uri="chapter03.xhtml#P7000497027000000000000000041169" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004116A" data-uri="chapter03.xhtml#P700049702700000000000000004116A" class="calibre3 pcalibre1 pcalibre2">print *(long *) ($rsp+8)</code></td>
<td id="P700049702700000000000000004116B" data-uri="chapter03.xhtml#P700049702700000000000000004116B" class="pcalibre1 pcalibre2 calibre7">Print long integer at address <code id="P700049702700000000000000004116C" data-uri="chapter03.xhtml#P700049702700000000000000004116C" class="calibre3 pcalibre1 pcalibre2">%rsp</code> + 8</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004116D" data-uri="chapter03.xhtml#P700049702700000000000000004116D" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004116E" data-uri="chapter03.xhtml#P700049702700000000000000004116E" class="calibre3 pcalibre1 pcalibre2">x/2g 0x7fffffffe818</code></td>
<td id="P700049702700000000000000004116F" data-uri="chapter03.xhtml#P700049702700000000000000004116F" class="pcalibre1 pcalibre2 calibre7">Examine two (8-byte) words starting at address <code id="P7000497027000000000000000041170" data-uri="chapter03.xhtml#P7000497027000000000000000041170" class="calibre3 pcalibre1 pcalibre2">0x7fffffffe818</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041171" data-uri="chapter03.xhtml#P7000497027000000000000000041171" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041172" data-uri="chapter03.xhtml#P7000497027000000000000000041172" class="calibre3 pcalibre1 pcalibre2">x/20b multstore</code></td>
<td id="P7000497027000000000000000041173" data-uri="chapter03.xhtml#P7000497027000000000000000041173" class="pcalibre1 pcalibre2 calibre7">Examine first 20 bytes of function <code id="P7000497027000000000000000041174" data-uri="chapter03.xhtml#P7000497027000000000000000041174" class="calibre3 pcalibre1 pcalibre2">multstore</code></td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P7000497027000000000000000041175" data-uri="chapter03.xhtml#P7000497027000000000000000041175" class="pcalibre1 pcalibre2 calibre7">Useful information</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041176" data-uri="chapter03.xhtml#P7000497027000000000000000041176" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041177" data-uri="chapter03.xhtml#P7000497027000000000000000041177" class="calibre3 pcalibre1 pcalibre2">info frame</code></td>
<td id="P7000497027000000000000000041178" data-uri="chapter03.xhtml#P7000497027000000000000000041178" class="pcalibre1 pcalibre2 calibre7">Information about current stack frame</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041179" data-uri="chapter03.xhtml#P7000497027000000000000000041179" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004117A" data-uri="chapter03.xhtml#P700049702700000000000000004117A" class="calibre3 pcalibre1 pcalibre2">info registers</code></td>
<td id="P700049702700000000000000004117B" data-uri="chapter03.xhtml#P700049702700000000000000004117B" class="pcalibre1 pcalibre2 calibre7">Values of all the registers</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004117C" data-uri="chapter03.xhtml#P700049702700000000000000004117C" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004117D" data-uri="chapter03.xhtml#P700049702700000000000000004117D" class="calibre3 pcalibre1 pcalibre2">help</code></td>
<td id="P700049702700000000000000004117E" data-uri="chapter03.xhtml#P700049702700000000000000004117E" class="pcalibre1 pcalibre2 calibre7">Get information about <span class="pcalibre1 pcalibre2 pcalibre84">gdb</span></td>
</tr>
</tbody>
</table>
<figcaption id="P700049702700000000000000004117F" data-uri="chapter03.xhtml#P700049702700000000000000004117F" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041180" data-uri="chapter03.xhtml#P7000497027000000000000000041180" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.39 </span>Example <span class="pcalibre1 pcalibre2 pcalibre84">gdb </span>commands.</h1></header><div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000041181" data-uri="chapter03.xhtml#P7000497027000000000000000041181"><p id="P7000497027000000000000000041182" data-uri="chapter03.xhtml#P7000497027000000000000000041182" class="pcalibre1 pcalibre2 pcalibre10">These examples illustrate some of the ways <span class="pcalibre1 pcalibre2 pcalibre84">gdb </span>supports debugging of machine-level programs.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002F48" data-uri="chapter03.xhtml#P7000497027000000000000000002F48">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002F49" title="281" data-uri="chapter03.xhtml#P7000497027000000000000000002F49" epub:type="pagebreak"></span>
<img alt="A diagram illustrates a stack organization for echo function." id="P7000497027000000000000000041183" data-uri="P700049702700000000000000000B6C1" src="../images/p281-1.png" class="pcalibre1 pcalibre2 pcalibre135"/>
<figcaption id="P7000497027000000000000000041184" data-uri="chapter03.xhtml#P7000497027000000000000000041184" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041185" data-uri="chapter03.xhtml#P7000497027000000000000000041185" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.40 </span>Stack organization for <code id="P7000497027000000000000000041186" data-uri="chapter03.xhtml#P7000497027000000000000000041186" class="pcalibre1 calibre1 pcalibre2">echo</code> function.</h1></header><div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041187" data-uri="chapter03.xhtml#P7000497027000000000000000041187"><p id="P7000497027000000000000000041188" data-uri="chapter03.xhtml#P7000497027000000000000000041188" class="pcalibre1 pcalibre2 pcalibre10">Character array <code id="P7000497027000000000000000041189" data-uri="chapter03.xhtml#P7000497027000000000000000041189" class="pcalibre1 calibre1 pcalibre2">buf</code> is just part of the saved state. An out-of-bounds write to <code id="P700049702700000000000000004118A" data-uri="chapter03.xhtml#P700049702700000000000000004118A" class="pcalibre1 calibre1 pcalibre2">buf</code> can corrupt the program state.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000021461" data-uri="chapter03.xhtml#P7000497027000000000000000021461">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P700049702700000000000000004118B" data-uri="chapter03.xhtml#P700049702700000000000000004118B" class="pcalibre8 pcalibre1 pcalibre2">A diagram has two parts, from bottom to top:</p>
<p id="P700049702700000000000000004118C" data-uri="chapter03.xhtml#P700049702700000000000000004118C" class="pcalibre8 pcalibre1 pcalibre2">Stack frame for echo with buf = %rsp at the bottom containing [7][6][5][4][3][2][1][0]</p>
<p id="P700049702700000000000000004118D" data-uri="chapter03.xhtml#P700049702700000000000000004118D" class="pcalibre1 pcalibre2 pcalibre10">Stack frame for caller with %rsp+24 on bottom containing Return address</p>
</details>
</figcaption></figure>
<pre id="P700049702700000000000000004118E" data-uri="chapter03.xhtml#P700049702700000000000000004118E" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004118F" data-uri="chapter03.xhtml#P700049702700000000000000004118F" class="calibre3 pcalibre1 pcalibre2">
while ((c = getchar()) != `n' &amp;&amp; c != EOF)
	*dest++ = c;
if (c == EOF &amp;&amp; dest == s)
	/* No characters read */
	return NULL;
*dest++ = `0'; /* Terminate string */
return s;
}
/* Read input line and write it back */
void echo()
{
	char buf[8]; /* Way too small! */
	gets(buf);
	puts(buf);
}
</code></pre>
<p id="P7000497027000000000000000041190" data-uri="chapter03.xhtml#P7000497027000000000000000041190" class="pcalibre8 pcalibre1 pcalibre2">The preceding code shows an implementation of the library function gets to demonstrate a serious problem with this function. It reads a line from the standard input, stopping when either a terminating newline character or some error condition is encountered. It copies this string to the location designated by argument <code id="P7000497027000000000000000041191" data-uri="chapter03.xhtml#P7000497027000000000000000041191" class="pcalibre1 calibre1 pcalibre2">s</code> and terminates the string with a null character. We show the use of gets in the function <code id="P7000497027000000000000000041192" data-uri="chapter03.xhtml#P7000497027000000000000000041192" class="pcalibre1 calibre1 pcalibre2">echo</code>, which simply reads a line from standard input and echos it back to standard output.</p>
<p id="P7000497027000000000000000041193" data-uri="chapter03.xhtml#P7000497027000000000000000041193" class="pcalibre8 pcalibre1 pcalibre2">The problem with gets is that it has no way to determine whether sufficient space has been allocated to hold the entire string. In our <code id="P7000497027000000000000000041194" data-uri="chapter03.xhtml#P7000497027000000000000000041194" class="pcalibre1 calibre1 pcalibre2">echo</code> example, we have purposely made the buffer very smallâjust eight characters long. Any string longer than seven characters will cause an out-of-bounds write.</p>
<p id="P7000497027000000000000000041195" data-uri="chapter03.xhtml#P7000497027000000000000000041195" class="pcalibre8 pcalibre1 pcalibre2">By examining the assembly code generated by <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>for <code id="P7000497027000000000000000041196" data-uri="chapter03.xhtml#P7000497027000000000000000041196" class="pcalibre1 calibre1 pcalibre2">echo</code>, we can infer how the stack is organized:</p>
<pre id="P7000497027000000000000000041197" data-uri="chapter03.xhtml#P7000497027000000000000000041197" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041198" data-uri="chapter03.xhtml#P7000497027000000000000000041198" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">void echo()</i>
1	echo:
2	subq	$24, %rsp	<i class="pcalibre17 pcalibre2 pcalibre1">Allocate 24 bytes on stack</i>
3	movq	%rsp, %rdi	<i class="pcalibre17 pcalibre2 pcalibre1">Compute buf as %rsp</i>
4	call	gets		<i class="pcalibre17 pcalibre2 pcalibre1">Call gets</i>
5	movq	%rsp, %rdi	<i class="pcalibre17 pcalibre2 pcalibre1">Compute buf as %rsp</i>
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002F5D" title="282" data-uri="chapter03.xhtml#P7000497027000000000000000002F5D" epub:type="pagebreak"></span>6	call	puts		<i class="pcalibre17 pcalibre2 pcalibre1">Call puts</i>
7	addq	$24, %rsp	<i class="pcalibre17 pcalibre2 pcalibre1">Deallocate stack space</i>
8	ret			<i class="pcalibre17 pcalibre2 pcalibre1">Return</i>
</code></pre>
<p id="P7000497027000000000000000041199" data-uri="chapter03.xhtml#P7000497027000000000000000041199" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000002F48"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.40</span></a> illustrates the stack organization during the execution of <code id="P700049702700000000000000004119A" data-uri="chapter03.xhtml#P700049702700000000000000004119A" class="pcalibre1 calibre1 pcalibre2">echo</code>. The program allocates 24 bytes on the stack by subtracting 24 from the stack pointer (line 2). Character <code id="P700049702700000000000000004119B" data-uri="chapter03.xhtml#P700049702700000000000000004119B" class="pcalibre1 calibre1 pcalibre2">buf</code> is positioned at the top of the stack, as can be seen by the fact that <code id="P700049702700000000000000004119C" data-uri="chapter03.xhtml#P700049702700000000000000004119C" class="pcalibre1 calibre1 pcalibre2">%rsp</code> is copied to <code id="P700049702700000000000000004119D" data-uri="chapter03.xhtml#P700049702700000000000000004119D" class="pcalibre1 calibre1 pcalibre2">%rdi</code> to be used as the argument to the calls to both gets and <code id="P700049702700000000000000004119E" data-uri="chapter03.xhtml#P700049702700000000000000004119E" class="pcalibre1 calibre1 pcalibre2">puts</code>. The 16 bytes between <code id="P700049702700000000000000004119F" data-uri="chapter03.xhtml#P700049702700000000000000004119F" class="pcalibre1 calibre1 pcalibre2">buf</code> and the stored return pointer are not used. As long as the user types at most seven characters, the string returned by gets (including the terminating null) will fit within the space allocated for <code id="P70004970270000000000000000411A0" data-uri="chapter03.xhtml#P70004970270000000000000000411A0" class="pcalibre1 calibre1 pcalibre2">buf</code>. A longer string, however, will cause gets to overwrite some of the information stored on the stack. As the string gets longer, the following information will get corrupted:</p>
<table id="P70004970270000000000000000411A1" data-uri="chapter03.xhtml#P70004970270000000000000000411A1" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P70004970270000000000000000411A2" data-uri="chapter03.xhtml#P70004970270000000000000000411A2" class="pcalibre1 pcalibre2 calibre5">Characters typed</th>
<th id="P70004970270000000000000000411A3" data-uri="chapter03.xhtml#P70004970270000000000000000411A3" class="pcalibre1 pcalibre2 calibre5">Additional corrupted state</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000411A4" data-uri="chapter03.xhtml#P70004970270000000000000000411A4" class="pcalibre1 pcalibre2 calibre7">0â7</td>
<td id="P70004970270000000000000000411A5" data-uri="chapter03.xhtml#P70004970270000000000000000411A5" class="pcalibre1 pcalibre2 calibre7">None</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000411A6" data-uri="chapter03.xhtml#P70004970270000000000000000411A6" class="pcalibre1 pcalibre2 calibre7">9â23</td>
<td id="P70004970270000000000000000411A7" data-uri="chapter03.xhtml#P70004970270000000000000000411A7" class="pcalibre1 pcalibre2 calibre7">Unused stack space</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000411A8" data-uri="chapter03.xhtml#P70004970270000000000000000411A8" class="pcalibre1 pcalibre2 calibre7">24â31</td>
<td id="P70004970270000000000000000411A9" data-uri="chapter03.xhtml#P70004970270000000000000000411A9" class="pcalibre1 pcalibre2 calibre7">Return address</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000411AA" data-uri="chapter03.xhtml#P70004970270000000000000000411AA" class="pcalibre1 pcalibre2 calibre7">32+</td>
<td id="P70004970270000000000000000411AB" data-uri="chapter03.xhtml#P70004970270000000000000000411AB" class="pcalibre1 pcalibre2 calibre7">Saved state in caller</td>
</tr>
</tbody>
</table>
<p id="P70004970270000000000000000411AC" data-uri="chapter03.xhtml#P70004970270000000000000000411AC" class="pcalibre8 pcalibre1 pcalibre2">No serious consequence occurs for strings of up to 23 characters, but beyond that, the value of the return pointer, and possibly additional saved state, will be corrupted. If the stored value of the return address is corrupted, then the <code id="P70004970270000000000000000411AD" data-uri="chapter03.xhtml#P70004970270000000000000000411AD" class="pcalibre1 calibre1 pcalibre2">ret</code> instruction (line 8) will cause the program to jump to a totally unexpected location. None of these behaviors would seem possible based on the C code. The impact of out-of-bounds writing to memory by functions such as <code id="P70004970270000000000000000411AE" data-uri="chapter03.xhtml#P70004970270000000000000000411AE" class="pcalibre1 calibre1 pcalibre2">gets</code> can only be understood by studying the program at the machine-code level.</p>
<p id="P70004970270000000000000000411AF" data-uri="chapter03.xhtml#P70004970270000000000000000411AF" class="pcalibre8 pcalibre1 pcalibre2">Our code for <code id="P70004970270000000000000000411B0" data-uri="chapter03.xhtml#P70004970270000000000000000411B0" class="pcalibre1 calibre1 pcalibre2">echo</code> is simple but sloppy. A better version involves using the function <code id="P70004970270000000000000000411B1" data-uri="chapter03.xhtml#P70004970270000000000000000411B1" class="pcalibre1 calibre1 pcalibre2">fgets</code>, which includes as an argument a count on the maximum number of bytes to read. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000032E1.xhtml#P70004970270000000000000000033FE"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.71</span></a> asks you to write an echo function that can handle an input string of arbitrary length. In general, using <code id="P70004970270000000000000000411B2" data-uri="chapter03.xhtml#P70004970270000000000000000411B2" class="pcalibre1 calibre1 pcalibre2">gets</code> or any function that can overflow storage is considered a bad programming practice. Unfortunately, a number of commonly used library functions, including <code id="P70004970270000000000000000411B3" data-uri="chapter03.xhtml#P70004970270000000000000000411B3" class="pcalibre1 calibre1 pcalibre2">strcpy, strcat</code>, and <code id="P70004970270000000000000000411B4" data-uri="chapter03.xhtml#P70004970270000000000000000411B4" class="pcalibre1 calibre1 pcalibre2">sprintf</code>, have the property that they can generate a byte sequence without being given any indication of the size of the destination buffer <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B466">[97]</a>. Such conditions can lead to vulnerabilities to buffer overflow.</p>
<section id="P7000497027000000000000000002F7A" data-uri="chapter03.xhtml#P7000497027000000000000000002F7A" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000411B5" data-uri="chapter03.xhtml#P70004970270000000000000000411B5" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.46 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003928">346</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000411B6" data-uri="chapter03.xhtml#P70004970270000000000000000411B6">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000411B7" data-uri="chapter03.xhtml#P70004970270000000000000000411B7">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000411B8" data-uri="chapter03.xhtml#P70004970270000000000000000411B8"><p id="P70004970270000000000000000411B9" data-uri="chapter03.xhtml#P70004970270000000000000000411B9" class="pcalibre1 pcalibre2 pcalibre10"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000002F87"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.41</span></a> shows a (low-quality) implementation of a function that reads a line from standard input, copies the string to newly allocated storage, and returns a pointer to the result.</p>
<p id="P70004970270000000000000000411BA" data-uri="chapter03.xhtml#P70004970270000000000000000411BA" class="pcalibre1 pcalibre2 pcalibre10">Consider the following scenario. Procedure <code id="P70004970270000000000000000411BB" data-uri="chapter03.xhtml#P70004970270000000000000000411BB" class="pcalibre1 calibre1 pcalibre2">get_line</code> is called with the return address equal to <code id="P70004970270000000000000000411BC" data-uri="chapter03.xhtml#P70004970270000000000000000411BC" class="pcalibre1 calibre1 pcalibre2">0x400776</code> and register <code id="P70004970270000000000000000411BD" data-uri="chapter03.xhtml#P70004970270000000000000000411BD" class="pcalibre1 calibre1 pcalibre2">%rbx</code> equal to <code id="P70004970270000000000000000411BE" data-uri="chapter03.xhtml#P70004970270000000000000000411BE" class="pcalibre1 calibre1 pcalibre2">0x0123456789ABCDEF</code>. You type in the string</p>
<pre id="P70004970270000000000000000411BF" data-uri="chapter03.xhtml#P70004970270000000000000000411BF" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000411C0" data-uri="chapter03.xhtml#P70004970270000000000000000411C0" class="calibre3 pcalibre1 pcalibre2">
0123456789012345678901234
</code></pre>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002F87" data-uri="chapter03.xhtml#P7000497027000000000000000002F87">
<p id="P70004970270000000000000000411C1" data-uri="chapter03.xhtml#P70004970270000000000000000411C1" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000002F89" title="283" data-uri="chapter03.xhtml#P7000497027000000000000000002F89" epub:type="pagebreak"></span>(a) C code</p>
<pre id="P70004970270000000000000000411C2" data-uri="chapter03.xhtml#P70004970270000000000000000411C2" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000411C3" data-uri="chapter03.xhtml#P70004970270000000000000000411C3" class="calibre3 pcalibre1 pcalibre2">
/* This is very low-quality code.
	It is intended to illustrate bad programming practices.
	See Practice <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000002F7A"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">3.46</span></a>. */
char *get_line()
{
	char buf[4];
	char *result;
	gets(buf);
	result = malloc(strlen(buf));
	strcpy(result, buf);
	return result;
}
</code></pre>
<p id="P70004970270000000000000000411C4" data-uri="chapter03.xhtml#P70004970270000000000000000411C4" class="pcalibre1 pcalibre2 pcalibre10">(b) Disassembly up through call to gets</p>
<pre id="P70004970270000000000000000411C5" data-uri="chapter03.xhtml#P70004970270000000000000000411C5" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000411C6" data-uri="chapter03.xhtml#P70004970270000000000000000411C6" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">char *get_line()</i>
1	0000000000400720 &lt;get_line&gt;:
2	400720:	53			push	%rbx
3	400721:	48 83 ec 10		sub	$0x10,%rsp
	<i class="pcalibre17 pcalibre2 pcalibre1">Diagram stack at this point</i>
4	400725:	48 89 e7		mov	%rsp,%rdi
5	400728:	e8 73 ff ff ff		callq	4006a0 &lt;gets&gt;
<i class="pcalibre17 pcalibre2 pcalibre1">Modify diagram to show stack contents at this point</i>
</code></pre>
<figcaption id="P70004970270000000000000000411C7" data-uri="chapter03.xhtml#P70004970270000000000000000411C7" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000411C8" data-uri="chapter03.xhtml#P70004970270000000000000000411C8" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.41 </span>C and disassembled code for Practice <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000002F7A"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">3.46</span></a>.</h1></header></figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000411C9" data-uri="chapter03.xhtml#P70004970270000000000000000411C9">The program terminates with a segmentation fault. You run <span class="pcalibre1 pcalibre29 pcalibre2">gdb </span>and determine that the error occurs during the execution of the <code id="P70004970270000000000000000411CA" data-uri="chapter03.xhtml#P70004970270000000000000000411CA" class="pcalibre1 calibre1 pcalibre2">ret</code> instruction of <code id="P70004970270000000000000000411CB" data-uri="chapter03.xhtml#P70004970270000000000000000411CB" class="pcalibre1 calibre1 pcalibre2">get_line.</code></p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000411CC" data-uri="chapter03.xhtml#P70004970270000000000000000411CC">
<li id="P70004970270000000000000000411CD" data-uri="chapter03.xhtml#P70004970270000000000000000411CD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000411CE" data-uri="chapter03.xhtml#P70004970270000000000000000411CE" class="pcalibre1 pcalibre2 pcalibre10">Fill in the diagram that follows, indicating as much as you can about the stack just after executing the instruction at line 3 in the disassembly. Label the quantities stored on the stack (e.g., "Return address") on the right, and their hexadecimal values (if known) within the box. Each box represents 8 bytes. Indicate the position of <code id="P70004970270000000000000000411CF" data-uri="chapter03.xhtml#P70004970270000000000000000411CF" class="pcalibre1 calibre1 pcalibre2">%rsp</code>. Recall that the ASCII codes for characters 0â9 are <code id="P70004970270000000000000000411D0" data-uri="chapter03.xhtml#P70004970270000000000000000411D0" class="pcalibre1 calibre1 pcalibre2">0x30â0x39.</code></p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002F99" data-uri="chapter03.xhtml#P7000497027000000000000000002F99">
<img alt="A diagram shows a stack with four black sections below a Return address section on top, containing 00 00 00 00 00 40 00 76." id="P70004970270000000000000000411D1" data-uri="P700049702700000000000000000B6C2" src="../images/p283-1.png" class="pcalibre136 pcalibre1 pcalibre2"/>
</figure>
</li>
<li id="P70004970270000000000000000411D2" data-uri="chapter03.xhtml#P70004970270000000000000000411D2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000411D3" data-uri="chapter03.xhtml#P70004970270000000000000000411D3" class="pcalibre1 pcalibre2 pcalibre10">Modify your diagram to show the effect of the call to <code id="P70004970270000000000000000411D4" data-uri="chapter03.xhtml#P70004970270000000000000000411D4" class="pcalibre1 calibre1 pcalibre2">gets</code> (line 5).</p></li>
<li id="P70004970270000000000000000411D5" data-uri="chapter03.xhtml#P70004970270000000000000000411D5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000411D6" data-uri="chapter03.xhtml#P70004970270000000000000000411D6" class="pcalibre1 pcalibre2 pcalibre10">To what address does the program attempt to return?</p></li>
<li id="P70004970270000000000000000411D7" data-uri="chapter03.xhtml#P70004970270000000000000000411D7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000411D8" data-uri="chapter03.xhtml#P70004970270000000000000000411D8" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002FA2" title="284" data-uri="chapter03.xhtml#P7000497027000000000000000002FA2" epub:type="pagebreak"></span>What register(s) have corrupted value(s) when <code id="P70004970270000000000000000411D9" data-uri="chapter03.xhtml#P70004970270000000000000000411D9" class="pcalibre1 calibre1 pcalibre2">get_line</code> returns?</p></li>
<li id="P70004970270000000000000000411DA" data-uri="chapter03.xhtml#P70004970270000000000000000411DA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000411DB" data-uri="chapter03.xhtml#P70004970270000000000000000411DB" class="pcalibre1 pcalibre2 pcalibre10">Besides the potential for buffer overflow, what two other things are wrong with the code for <code id="P70004970270000000000000000411DC" data-uri="chapter03.xhtml#P70004970270000000000000000411DC" class="pcalibre1 calibre1 pcalibre2">get_line?</code></p></li>
</ol>
</div></li></ol>
</section>
<p id="P70004970270000000000000000411DD" data-uri="chapter03.xhtml#P70004970270000000000000000411DD" class="pcalibre8 pcalibre1 pcalibre2">A more pernicious use of buffer overflow is to get a program to perform a function that it would otherwise be unwilling to do. This is one of the most common methods to attack the security of a system over a computer network. Typically, the program is fed with a string that contains the byte encoding of some executable code, called the <i class="pcalibre17 pcalibre2 pcalibre1">exploit code</i>, plus some extra bytes that overwrite the return address with a pointer to the exploit code. The effect of executing the <code id="P70004970270000000000000000411DE" data-uri="chapter03.xhtml#P70004970270000000000000000411DE" class="pcalibre1 calibre1 pcalibre2">ret</code> instruction is then to jump to the exploit code.</p>
<p id="P70004970270000000000000000411DF" data-uri="chapter03.xhtml#P70004970270000000000000000411DF" class="pcalibre8 pcalibre1 pcalibre2">In one form of attack, the exploit code then uses a system call to start up a shell program, providing the attacker with a range of operating system functions. In another form, the exploit code performs some otherwise unauthorized task, repairs the damage to the stack, and then executes <code id="P70004970270000000000000000411E0" data-uri="chapter03.xhtml#P70004970270000000000000000411E0" class="pcalibre1 calibre1 pcalibre2">ret</code> a second time, causing an (apparently) normal return to the caller.</p>
<p id="P70004970270000000000000000411E1" data-uri="chapter03.xhtml#P70004970270000000000000000411E1" class="pcalibre8 pcalibre1 pcalibre2">As an example, the famous Internet worm of November 1988 used four different ways to gain access to many of the computers across the Internet. One was a buffer overflow attack on the finger daemon <code id="P70004970270000000000000000411E2" data-uri="chapter03.xhtml#P70004970270000000000000000411E2" class="pcalibre1 calibre1 pcalibre2">fingerd</code>, which serves requests by the <span class="pcalibre1 pcalibre29 pcalibre2">finger </span>command. By invoking <span class="pcalibre1 pcalibre29 pcalibre2">finger </span>with an appropriate string, the worm could make the daemon at a remote site have a buffer overflow and execute code that gave the worm access to the remote system. Once the worm gained access to a system, it would replicate itself and consume virtually all of the machine's computing resources. As a consequence, hundreds of machines were effectively paralyzed until security experts could determine how to eliminate the worm. The author of the worm was caught and prosecuted. He was sentenced to 3 years probation, 400 hours of community service, and a $10,500 fine. Even to this day, however, people continue to find security leaks in systems that leave them vulnerable to buffer overflow attacks. This highlights the need for careful programming. Any interface to the external environment should be made "bulletproof" so that no behavior by an external agent can cause the system to misbehave.</p>
</section>
<section id="P7000497027000000000000000002FAD" data-uri="chapter03.xhtml#P7000497027000000000000000002FAD" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000411E3" data-uri="chapter03.xhtml#P70004970270000000000000000411E3" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.10.4 </span>Thwarting Buffer Overflow Attacks</h1></header>
<p id="P70004970270000000000000000411E4" data-uri="chapter03.xhtml#P70004970270000000000000000411E4" class="pcalibre8 pcalibre1 pcalibre2">Buffer overflow attacks have become so pervasive and have caused so many problems with computer systems that modern compilers and operating systems have implemented mechanisms to make it more difficult to mount these attacks and to limit the ways by which an intruder can seize control of a system via a buffer overflow attack. In this section, we will present mechanisms that are provided by recent versions of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>for Linux.</p>
<section id="P7000497027000000000000000002FB0" data-uri="chapter03.xhtml#P7000497027000000000000000002FB0" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000411E5" data-uri="chapter03.xhtml#P70004970270000000000000000411E5" epub:type="title">Stack Randomization</h1></header>
<p id="P70004970270000000000000000411E6" data-uri="chapter03.xhtml#P70004970270000000000000000411E6" class="pcalibre8 pcalibre1 pcalibre2">In order to insert exploit code into a system, the attacker needs to inject both the code as well as a pointer to this code as part of the attack string. Generating</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000002FB3" data-uri="chapter03.xhtml#P7000497027000000000000000002FB3"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P70004970270000000000000000411E7" data-uri="chapter03.xhtml#P70004970270000000000000000411E7" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002FB5" title="285" data-uri="chapter03.xhtml#P7000497027000000000000000002FB5" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Worms and viruses</h1></header>
<p id="P70004970270000000000000000411E8" data-uri="chapter03.xhtml#P70004970270000000000000000411E8" class="pcalibre1 pcalibre2 pcalibre10">Both worms and viruses are pieces of code that attempt to spread themselves among computers. As described by Spafford <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B476">[105],</a> a <i class="pcalibre17 pcalibre2 pcalibre1">worm</i> is a program that can run by itself and can propagate a fully working version of itself to other machines. A <i class="pcalibre17 pcalibre2 pcalibre1">virus</i> is a piece of code that adds itself to other programs, including operating systems. It cannot run independently. In the popular press, the term "virus" is used to refer to a variety of different strategies for spreading attacking code among systems, and so you will hear people saying "virus" for what more properly should be called a "worm."</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000411E9" data-uri="chapter03.xhtml#P70004970270000000000000000411E9">this pointer requires knowing the stack address where the string will be located. Historically, the stack addresses for a program were highly predictable. For all systems running the same combination of program and operating system version, the stack locations were fairly stable across many machines. So, for example, if an attacker could determine the stack addresses used by a common Web server, it could devise an attack that would work on many machines. Using infectious disease as an analogy, many systems were vulnerable to the exact same strain of a virus, a phenomenon often referred to as a <i class="pcalibre17 pcalibre2 pcalibre1">security monoculture</i> <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B464">[96]</a>.</p>
<p id="P70004970270000000000000000411EA" data-uri="chapter03.xhtml#P70004970270000000000000000411EA" class="pcalibre8 pcalibre1 pcalibre2">The idea of <i class="pcalibre17 pcalibre2 pcalibre1">stack randomization</i> is to make the position of the stack vary from one run of a program to another. Thus, even if many machines are running identical code, they would all be using different stack addresses. This is implemented by allocating a random amount of space between 0 and <var class="pcalibre17 pcalibre2 pcalibre1">n</var> bytes on the stack at the start of a program, for example, by using the allocation function <code id="P70004970270000000000000000411EB" data-uri="chapter03.xhtml#P70004970270000000000000000411EB" class="pcalibre1 calibre1 pcalibre2">alloca</code>, which allocates space for a specified number of bytes on the stack. This allocated space is not used by the program, but it causes all subsequent stack locations to vary from one execution of a program to another. The allocation range <var class="pcalibre17 pcalibre2 pcalibre1">n</var> needs to be large enough to get sufficient variations in the stack addresses, yet small enough that it does not waste too much space in the program.</p>
<p id="P70004970270000000000000000411EC" data-uri="chapter03.xhtml#P70004970270000000000000000411EC" class="pcalibre8 pcalibre1 pcalibre2">The following code shows a simple way to determine a "typical" stack address:</p>
<pre id="P70004970270000000000000000411ED" data-uri="chapter03.xhtml#P70004970270000000000000000411ED" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000411EE" data-uri="chapter03.xhtml#P70004970270000000000000000411EE" class="calibre3 pcalibre1 pcalibre2">
int main(){
	long local;
	printf("local at %p\n", &amp;local);
	return 0;
}
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000411EF" data-uri="chapter03.xhtml#P70004970270000000000000000411EF">This code simply prints the address of a local variable in the main function. Running the code 10,000 times on a Linux machine in 32-bit mode, the addresses ranged from <code id="P70004970270000000000000000411F0" data-uri="chapter03.xhtml#P70004970270000000000000000411F0" class="pcalibre1 calibre1 pcalibre2">0xff7fc59c</code> to <code id="P70004970270000000000000000411F1" data-uri="chapter03.xhtml#P70004970270000000000000000411F1" class="pcalibre1 calibre1 pcalibre2">0xffffd09c</code>, a range of around 2<sup class="pcalibre1 pcalibre2 pcalibre85">23</sup>. Running in 64-bit mode on the newer machine, the addresses ranged from <code id="P70004970270000000000000000411F2" data-uri="chapter03.xhtml#P70004970270000000000000000411F2" class="pcalibre1 calibre1 pcalibre2">0x7fff0001b698</code> to <code id="P70004970270000000000000000411F3" data-uri="chapter03.xhtml#P70004970270000000000000000411F3" class="pcalibre1 calibre1 pcalibre2">0x7ffffffaa4a8</code>, a range of nearly 2<sup class="pcalibre1 pcalibre2 pcalibre85">32</sup>.</p>
<p id="P70004970270000000000000000411F4" data-uri="chapter03.xhtml#P70004970270000000000000000411F4" class="pcalibre8 pcalibre1 pcalibre2">Stack randomization has become standard practice in Linux systems. It is one of a larger class of techniques known as <i class="pcalibre17 pcalibre2 pcalibre1">address-space layout randomization</i>, or ASLR <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B46A">[99]</a>. With ASLR, different parts of the program, including program code, library code, stack, global variables, and heap data, are loaded into different <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002FC3" title="286" data-uri="chapter03.xhtml#P7000497027000000000000000002FC3" epub:type="pagebreak"></span>regions of memory each time a program is run. That means that a program running on one machine will have very different address mappings than the same program running on other machines. This can thwart some forms of attack.</p>
<p id="P70004970270000000000000000411F5" data-uri="chapter03.xhtml#P70004970270000000000000000411F5" class="pcalibre8 pcalibre1 pcalibre2">Overall, however, a persistent attacker can overcome randomization by brute force, repeatedly attempting attacks with different addresses. A common trick is to include a long sequence of <code id="P70004970270000000000000000411F6" data-uri="chapter03.xhtml#P70004970270000000000000000411F6" class="pcalibre1 calibre1 pcalibre2">nop</code> (pronounced "no op," short for "no operation") instructions before the actual exploit code. Executing this instruction has no effect, other than incrementing the program counter to the next instruction. As long as the attacker can guess an address somewhere within this sequence, the program will run through the sequence and then hit the exploit code. The common term for this sequence is a "nop sled" <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B466">[97]</a>, expressing the idea that the program "slides" through the sequence. If we set up a 256-byte nop sled, then the randomization over <var class="pcalibre17 pcalibre2 pcalibre1">n</var> = 2<sup class="pcalibre1 pcalibre2 pcalibre85">23</sup> can be cracked by enumerating 2<sup class="pcalibre1 pcalibre2 pcalibre85">15</sup> = 32,768 starting addresses, which is entirely feasible for a determined attacker. For the 64-bit case, trying to enumerate 2<sup class="pcalibre1 pcalibre2 pcalibre85">24</sup> = 16,777,216 is a bit more daunting. We can see that stack randomization and other aspects of ASLR can increase the effort required to successfully attack a system, and therefore greatly reduce the rate at which a virus or worm can spread, but it cannot provide a complete safeguard.</p>
<section id="P7000497027000000000000000002FC6" data-uri="chapter03.xhtml#P7000497027000000000000000002FC6" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P70004970270000000000000000411F7" data-uri="chapter03.xhtml#P70004970270000000000000000411F7" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.47 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003968">347</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000411F8" data-uri="chapter03.xhtml#P70004970270000000000000000411F8">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000411F9" data-uri="chapter03.xhtml#P70004970270000000000000000411F9">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000411FA" data-uri="chapter03.xhtml#P70004970270000000000000000411FA"><p id="P70004970270000000000000000411FB" data-uri="chapter03.xhtml#P70004970270000000000000000411FB" class="pcalibre1 pcalibre2 pcalibre10">Running our stack-checking code 10,000 times on a system running Linux version 2.6.16, we obtained addresses ranging from a minimum of <code id="P70004970270000000000000000411FC" data-uri="chapter03.xhtml#P70004970270000000000000000411FC" class="pcalibre1 calibre1 pcalibre2">0xffffb754</code> to a maximum of <code id="P70004970270000000000000000411FD" data-uri="chapter03.xhtml#P70004970270000000000000000411FD" class="pcalibre1 calibre1 pcalibre2">0xffffd754</code>.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000411FE" data-uri="chapter03.xhtml#P70004970270000000000000000411FE">
<li id="P70004970270000000000000000411FF" data-uri="chapter03.xhtml#P70004970270000000000000000411FF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041200" data-uri="chapter03.xhtml#P7000497027000000000000000041200" class="pcalibre1 pcalibre2 pcalibre10">What is the approximate range of addresses?</p></li>
<li id="P7000497027000000000000000041201" data-uri="chapter03.xhtml#P7000497027000000000000000041201" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041202" data-uri="chapter03.xhtml#P7000497027000000000000000041202" class="pcalibre1 pcalibre2 pcalibre10">If we attempted a buffer overrun with a 128-byte nop sled, about how many attempts would it take to test all starting addresses?</p></li>
</ol>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000002FD3" data-uri="chapter03.xhtml#P7000497027000000000000000002FD3" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041203" data-uri="chapter03.xhtml#P7000497027000000000000000041203" epub:type="title">Stack Corruption Detection</h1></header>
<p id="P7000497027000000000000000041204" data-uri="chapter03.xhtml#P7000497027000000000000000041204" class="pcalibre8 pcalibre1 pcalibre2">A second line of defense is to be able to detect when a stack has been corrupted. We saw in the example of the echo function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000002F48"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.40</span></a>) that the corruption typically occurs when the program overruns the bounds of a local buffer. In C, there is no reliable way to prevent writing beyond the bounds of an array. Instead, the program can attempt to detect when such a write has occurred before it can have any harmful effects.</p>
<p id="P7000497027000000000000000041205" data-uri="chapter03.xhtml#P7000497027000000000000000041205" class="pcalibre8 pcalibre1 pcalibre2">Recent versions of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>incorporate a mechanism known as a <i class="pcalibre17 pcalibre2 pcalibre1">stack protector</i> into the generated code to detect buffer overruns. The idea is to store a special <i class="pcalibre17 pcalibre2 pcalibre1">canary</i> value<a class="pcalibre1 pcalibre2 pcalibre56 pcalibre16 pcalibre14 pcalibre15" id="r__P7000497027000000000000000003A70" epub:type="noteref" href="#P7000497027000000000000000003A70"><sup class="pcalibre1 pcalibre2 calibre8">4</sup></a> in the stack frame between any local buffer and the rest of the stack state, as illustrated in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000002FD7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.42</span></a> <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3D5">[26,</a> <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B466">97]</a>. This canary value, also referred to as a <i class="pcalibre17 pcalibre2 pcalibre1">guard value</i>, is generated randomly each time the program runs, and so there is no</p><aside class="pcalibre2 pcalibre32 pcalibre57" id="P7000497027000000000000000003A70" data-uri="chapter03.xhtml#P7000497027000000000000000003A70" epub:type="footnote"><p class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre58 pcalibre2"><a href="#r__P7000497027000000000000000003A70" class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13">4. </a></span>The term "canary" refers to the historic use of these birds to detect the presence of dangerous gases in coal mines.</p></aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000002FD7" data-uri="chapter03.xhtml#P7000497027000000000000000002FD7">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002FD8" title="287" data-uri="chapter03.xhtml#P7000497027000000000000000002FD8" epub:type="pagebreak"></span>
<img alt="A diagram illustrates a stack organization for echo function with stack protector enabled." id="P7000497027000000000000000041206" data-uri="P700049702700000000000000000B6C3" src="../images/p287-1.png" class="pcalibre1 pcalibre2 calibre25"/>
<figcaption id="P7000497027000000000000000041207" data-uri="chapter03.xhtml#P7000497027000000000000000041207" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041208" data-uri="chapter03.xhtml#P7000497027000000000000000041208" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.42 </span>Stack organization for <code id="P7000497027000000000000000041209" data-uri="chapter03.xhtml#P7000497027000000000000000041209" class="pcalibre1 calibre1 pcalibre2">echo</code> function with stack protector enabled.</h1></header><div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004120A" data-uri="chapter03.xhtml#P700049702700000000000000004120A"><p id="P700049702700000000000000004120B" data-uri="chapter03.xhtml#P700049702700000000000000004120B" class="pcalibre1 pcalibre2 pcalibre10">A special "canary" value is positioned between array <code id="P700049702700000000000000004120C" data-uri="chapter03.xhtml#P700049702700000000000000004120C" class="pcalibre1 calibre1 pcalibre2">buf</code> and the saved state. The code checks the canary value to determine whether or not the stack state has been corrupted.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000214E4" data-uri="chapter03.xhtml#P70004970270000000000000000214E4">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P700049702700000000000000004120D" data-uri="chapter03.xhtml#P700049702700000000000000004120D" class="pcalibre8 pcalibre1 pcalibre2">A diagram has two parts, from bottom to top:</p>
<p id="P700049702700000000000000004120E" data-uri="chapter03.xhtml#P700049702700000000000000004120E" class="pcalibre8 pcalibre1 pcalibre2">Stack frame for echo with buf = %rsp at the bottom containing [7][6][5][4][3][2][1][0] and a section above containing Canary</p>
<p id="P700049702700000000000000004120F" data-uri="chapter03.xhtml#P700049702700000000000000004120F" class="pcalibre1 pcalibre2 pcalibre10">Stack frame for caller with %rsp+24 on bottom containing Return address</p>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041210" data-uri="chapter03.xhtml#P7000497027000000000000000041210">easy way for an attacker to determine what it is. Before restoring the register state and returning from the function, the program checks if the canary has been altered by some operation of this function or one that it has called. If so, the program aborts with an error.</p>
<p id="P7000497027000000000000000041211" data-uri="chapter03.xhtml#P7000497027000000000000000041211" class="pcalibre8 pcalibre1 pcalibre2">Recent versions of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>try to determine whether a function is vulnerable to a stack overflow and insert this type of overflow detection automatically. In fact, for our earlier demonstration of stack overflow, we had to give the command-line option <code id="P7000497027000000000000000041212" data-uri="chapter03.xhtml#P7000497027000000000000000041212" class="pcalibre1 calibre1 pcalibre2">-fno-stack-protector</code> to prevent <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>from inserting this code. Compiling the function <code id="P7000497027000000000000000041213" data-uri="chapter03.xhtml#P7000497027000000000000000041213" class="pcalibre1 calibre1 pcalibre2">echo</code> without this option, and hence with the stack protector enabled, gives the following assembly code:</p>
<pre id="P7000497027000000000000000041214" data-uri="chapter03.xhtml#P7000497027000000000000000041214" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041215" data-uri="chapter03.xhtml#P7000497027000000000000000041215" class="calibre3 pcalibre1 pcalibre2">
<i class="pcalibre17 pcalibre2 pcalibre1">void echo()</i>
1	echo:
2	subq	$24, %rsp	<i class="pcalibre17 pcalibre2 pcalibre1">Allocate 24 bytes on stack</i>
3	movq	%fs:40, %rax	<i class="pcalibre17 pcalibre2 pcalibre1">Retrieve canary</i>
4	movq	%rax, 8(%rsp)	<i class="pcalibre17 pcalibre2 pcalibre1">Store on stack</i>
5	xorl	%eax, %eax	<i class="pcalibre17 pcalibre2 pcalibre1">Zero out register</i>
6	movq	%rsp, %rdi	<i class="pcalibre17 pcalibre2 pcalibre1">Compute buf as %rsp</i>
7	call	gets		<i class="pcalibre17 pcalibre2 pcalibre1">Call gets</i>
8	movq	%rsp, %rdi	<i class="pcalibre17 pcalibre2 pcalibre1">Compute buf as %rsp</i>
9	call	puts		<i class="pcalibre17 pcalibre2 pcalibre1">Call puts</i>
10	movq	8(%rsp), %rax	<i class="pcalibre17 pcalibre2 pcalibre1">Retrieve canary</i>
11	xorq	%fs:40, %rax	<i class="pcalibre17 pcalibre2 pcalibre1">Compare to stored value</i>
12	je	.L9		<i class="pcalibre17 pcalibre2 pcalibre1">If =, goto</i> ok
13	call	__stack_chk_fail <i class="pcalibre17 pcalibre2 pcalibre1">Stack corrupted!</i>
14	.L9:		     <b class="pcalibre1 pcalibre2 pcalibre12">ok:</b>
15	addq	$24, %rsp	<i class="pcalibre17 pcalibre2 pcalibre1">Deallocate stack space</i>
16	ret
</code></pre>
<p id="P7000497027000000000000000041216" data-uri="chapter03.xhtml#P7000497027000000000000000041216" class="pcalibre8 pcalibre1 pcalibre2">We see that this version of the function retrieves a value from memory (line 3) and stores it on the stack at offset 8 from <code id="P7000497027000000000000000041217" data-uri="chapter03.xhtml#P7000497027000000000000000041217" class="pcalibre1 calibre1 pcalibre2">%rsp</code>, just beyond the region allocated for <code id="P7000497027000000000000000041218" data-uri="chapter03.xhtml#P7000497027000000000000000041218" class="pcalibre1 calibre1 pcalibre2">buf</code>. The instruction argument <code id="P7000497027000000000000000041219" data-uri="chapter03.xhtml#P7000497027000000000000000041219" class="pcalibre1 calibre1 pcalibre2">%fs:40</code> is an indication that the canary value is read from memory using <i class="pcalibre17 pcalibre2 pcalibre1">segmented addressing</i>, an addressing mechanism that dates <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002FEA" title="288" data-uri="chapter03.xhtml#P7000497027000000000000000002FEA" epub:type="pagebreak"></span>back to the 80286 and is seldom found in programs running on modern systems. By storing the canary in a special segment, it can be marked as "read only," so that an attacker cannot overwrite the stored canary value. Before restoring the register state and returning, the function compares the value stored at the stack location with the canary value (via the <code id="P700049702700000000000000004121A" data-uri="chapter03.xhtml#P700049702700000000000000004121A" class="pcalibre1 calibre1 pcalibre2">xorq</code> instruction on line 11). If the two are identical, the <code id="P700049702700000000000000004121B" data-uri="chapter03.xhtml#P700049702700000000000000004121B" class="pcalibre1 calibre1 pcalibre2">xorq</code> instruction will yield zero, and the function will complete in the normal fashion. A nonzero value indicates that the canary on the stack has been modified, and so the code will call an error routine.</p>
<p id="P700049702700000000000000004121C" data-uri="chapter03.xhtml#P700049702700000000000000004121C" class="pcalibre8 pcalibre1 pcalibre2">Stack protection does a good job of preventing a buffer overflow attack from corrupting state stored on the program stack. It incurs only a small performance penalty, especially because <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>only inserts it when there is a local buffer of type <code id="P700049702700000000000000004121D" data-uri="chapter03.xhtml#P700049702700000000000000004121D" class="pcalibre1 calibre1 pcalibre2">char</code> in the function. Of course, there are other ways to corrupt the state of an executing program, but reducing the vulnerability of the stack thwarts many common attack strategies.</p>
<section id="P7000497027000000000000000002FEF" data-uri="chapter03.xhtml#P7000497027000000000000000002FEF" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P700049702700000000000000004121E" data-uri="chapter03.xhtml#P700049702700000000000000004121E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.48 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003968">347</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004121F" data-uri="chapter03.xhtml#P700049702700000000000000004121F">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041220" data-uri="chapter03.xhtml#P7000497027000000000000000041220">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041221" data-uri="chapter03.xhtml#P7000497027000000000000000041221"><p id="P7000497027000000000000000041222" data-uri="chapter03.xhtml#P7000497027000000000000000041222" class="pcalibre1 pcalibre2 pcalibre10">The functions <code id="P7000497027000000000000000041223" data-uri="chapter03.xhtml#P7000497027000000000000000041223" class="pcalibre1 calibre1 pcalibre2">intlen, len</code>, and <code id="P7000497027000000000000000041224" data-uri="chapter03.xhtml#P7000497027000000000000000041224" class="pcalibre1 calibre1 pcalibre2">iptoa</code> provide a very convoluted way to compute the number of decimal digits required to represent an integer. We will use this as a way to study some aspects of the <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>stack protector facility.</p>
<pre id="P7000497027000000000000000041225" data-uri="chapter03.xhtml#P7000497027000000000000000041225" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041226" data-uri="chapter03.xhtml#P7000497027000000000000000041226" class="calibre3 pcalibre1 pcalibre2">
int len(char *s) {
	return strlen(s);
}
void iptoa(char *s, long *p) {
	long val = *p;
	sprintf(s, "%ld", val);
}
int intlen(long x) {
	long v;
	char buf[12];
	v = x;
	iptoa(buf, &amp;v);
	return len(buf);
}
</code></pre>
<p id="P7000497027000000000000000041227" data-uri="chapter03.xhtml#P7000497027000000000000000041227" class="pcalibre1 pcalibre2 pcalibre10">The following show portions of the code for <code id="P7000497027000000000000000041228" data-uri="chapter03.xhtml#P7000497027000000000000000041228" class="pcalibre1 calibre1 pcalibre2">intlen</code>, compiled both with and without stack protector:</p>
<p id="P7000497027000000000000000041229" data-uri="chapter03.xhtml#P7000497027000000000000000041229" class="pcalibre1 pcalibre2 pcalibre10">(a) Without protector</p>
<pre id="P700049702700000000000000004122A" data-uri="chapter03.xhtml#P700049702700000000000000004122A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004122B" data-uri="chapter03.xhtml#P700049702700000000000000004122B" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">int intlen(long x)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi</i>
1	intlen:
2	subq	$40, %rsp
3	movq	%rdi, 24(%rsp)
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000002FFE" title="289" data-uri="chapter03.xhtml#P7000497027000000000000000002FFE" epub:type="pagebreak"></span>4	leaq	24(%rsp), %rsi
5	movq	%rsp, %rdi
6	call	iptoa
</code></pre>
<p id="P700049702700000000000000004122C" data-uri="chapter03.xhtml#P700049702700000000000000004122C" class="pcalibre1 pcalibre2 pcalibre10">(b) With protector</p>
<pre id="P700049702700000000000000004122D" data-uri="chapter03.xhtml#P700049702700000000000000004122D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004122E" data-uri="chapter03.xhtml#P700049702700000000000000004122E" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">int intlen(long x)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi</i>
1	intlen:
2	subq	$56, %rsp
3	movq	%fs:40, %rax
4	movq	%rax, 40(%rsp)
5	xorl	%eax, %eax
6	movq	%rdi, 8(%rsp)
7	leaq	8(%rsp), %rsi
8	leaq	16(%rsp), %rdi
9	call	iptoa
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P700049702700000000000000004122F" data-uri="chapter03.xhtml#P700049702700000000000000004122F">
<li id="P7000497027000000000000000041230" data-uri="chapter03.xhtml#P7000497027000000000000000041230" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041231" data-uri="chapter03.xhtml#P7000497027000000000000000041231" class="pcalibre1 pcalibre2 pcalibre10">For both versions: What are the positions in the stack frame for <code id="P7000497027000000000000000041232" data-uri="chapter03.xhtml#P7000497027000000000000000041232" class="pcalibre1 calibre1 pcalibre2">buf, v</code>, and (when present) the canary value?</p></li>
<li id="P7000497027000000000000000041233" data-uri="chapter03.xhtml#P7000497027000000000000000041233" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041234" data-uri="chapter03.xhtml#P7000497027000000000000000041234" class="pcalibre1 pcalibre2 pcalibre10">How does the rearranged ordering of the local variables in the protected code provide greater security against a buffer overrun attack?</p></li>
</ol>
</div></li></ol></section>
</section>
<section id="P7000497027000000000000000003008" data-uri="chapter03.xhtml#P7000497027000000000000000003008" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041235" data-uri="chapter03.xhtml#P7000497027000000000000000041235" epub:type="title">Limiting Executable Code Regions</h1></header>
<p id="P7000497027000000000000000041236" data-uri="chapter03.xhtml#P7000497027000000000000000041236" class="pcalibre8 pcalibre1 pcalibre2">A final step is to eliminate the ability of an attacker to insert executable code into a system. One method is to limit which memory regions hold executable code. In typical programs, only the portion of memory holding the code generated by the compiler need be executable. The other portions can be restricted to allow just reading and writing. As we will see in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">9</span></a>, the virtual memory space is logically divided into <i class="pcalibre17 pcalibre2 pcalibre1">pages</i>, typically with 2,048 or 4,096 bytes per page. The hardware supports different forms of <i class="pcalibre17 pcalibre2 pcalibre1">memory protection</i>, indicating the forms of access allowed by both user programs and the operating system kernel. Many systems allow control over three forms of access: read (reading data from memory), write (storing data into memory), and execute (treating the memory contents as machine-level code). Historically, the x86 architecture merged the read and execute access controls into a single 1-bit flag, so that any page marked as readable was also executable. The stack had to be kept both readable and writable, and therefore the bytes on the stack were also executable. Various schemes were implemented to be able to limit some pages to being readable but not executable, but these generally introduced significant inefficiencies.</p>
<p id="P7000497027000000000000000041237" data-uri="chapter03.xhtml#P7000497027000000000000000041237" class="pcalibre8 pcalibre1 pcalibre2">More recently, AMD introduced an NX (for "no-execute") bit into the memory protection for its 64-bit processors, separating the read and execute access modes, and Intel followed suit. With this feature, the stack can be marked as being readable and writable, but not executable, and the checking of whether a page is executable is performed in hardware, with no penalty in efficiency.</p>
<p id="P7000497027000000000000000041238" data-uri="chapter03.xhtml#P7000497027000000000000000041238" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000300D" title="290" data-uri="chapter03.xhtml#P700049702700000000000000000300D" epub:type="pagebreak"></span>Some types of programs require the ability to dynamically generate and execute code. For example, "just-in-time" compilation techniques dynamically generate code for programs written in interpreted languages, such as Java, to improve execution performance. Whether or not the run-time system can restrict the executable code to just that part generated by the compiler in creating the original program depends on the language and the operating system.</p>
<p id="P7000497027000000000000000041239" data-uri="chapter03.xhtml#P7000497027000000000000000041239" class="pcalibre8 pcalibre1 pcalibre2">The techniques we have outlinedârandomization, stack protection, and limiting which portions of memory can hold executable codeâare three of the most common mechanisms used to minimize the vulnerability of programs to buffer overflow attacks. They all have the properties that they require no special effort on the part of the programmer and incur very little or no performance penalty. Each separately reduces the level of vulnerability, and in combination they become even more effective. Unfortunately, there are still ways to attack computers <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B44D">[85,</a> <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B466">97]</a>, and so worms and viruses continue to compromise the integrity of many machines.</p>
</section>
</section>
<section id="P700049702700000000000000000300F" data-uri="chapter03.xhtml#P700049702700000000000000000300F" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004123A" data-uri="chapter03.xhtml#P700049702700000000000000004123A" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.10.5 </span>Supporting Variable-Size Stack Frames</h1></header>
<p id="P700049702700000000000000004123B" data-uri="chapter03.xhtml#P700049702700000000000000004123B" class="pcalibre8 pcalibre1 pcalibre2">We have examined the machine-level code for a variety of functions so far, but they all have the property that the compiler can determine in advance the amount of space that must be allocated for their stack frames. Some functions, however, require a variable amount of local storage. This can occur, for example, when the function calls <code id="P700049702700000000000000004123C" data-uri="chapter03.xhtml#P700049702700000000000000004123C" class="pcalibre1 calibre1 pcalibre2">alloca</code>, a standard library function that can allocate an arbitrary number of bytes of storage on the stack. It can also occur when the code declares a local array of variable size.</p>
<p id="P700049702700000000000000004123D" data-uri="chapter03.xhtml#P700049702700000000000000004123D" class="pcalibre8 pcalibre1 pcalibre2">Although the information presented in this section should rightfully be considered an aspect of how procedures are implemented, we have deferred the presentation to this point, since it requires an understanding of arrays and alignment.</p>
<p id="P700049702700000000000000004123E" data-uri="chapter03.xhtml#P700049702700000000000000004123E" class="pcalibre8 pcalibre1 pcalibre2">The code of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003022"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.43(a)</span></a> gives an example of a function containing a variable-size array. The function declares local array <code id="P700049702700000000000000004123F" data-uri="chapter03.xhtml#P700049702700000000000000004123F" class="pcalibre1 calibre1 pcalibre2">p</code> of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> pointers, where <var class="pcalibre17 pcalibre2 pcalibre1">n</var> is given by the first argument. This requires allocating 8<var class="pcalibre17 pcalibre2 pcalibre1">n</var> bytes on the stack, where the value of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> may vary from one call of the function to another. The compiler therefore cannot determine how much space it must allocate for the function's stack frame. In addition, the program generates a reference to the address of local variable <code id="P7000497027000000000000000041240" data-uri="chapter03.xhtml#P7000497027000000000000000041240" class="pcalibre1 calibre1 pcalibre2">i</code>, and so this variable must also be stored on the stack. During execution, the program must be able to access both local variable <code id="P7000497027000000000000000041241" data-uri="chapter03.xhtml#P7000497027000000000000000041241" class="pcalibre1 calibre1 pcalibre2">i</code> and the elements of array <code id="P7000497027000000000000000041242" data-uri="chapter03.xhtml#P7000497027000000000000000041242" class="pcalibre1 calibre1 pcalibre2">p</code>. On returning, the function must deallocate the stack frame and set the stack pointer to the position of the stored return address.</p>
<p id="P7000497027000000000000000041243" data-uri="chapter03.xhtml#P7000497027000000000000000041243" class="pcalibre8 pcalibre1 pcalibre2">To manage a variable-size stack frame, x86-64 code uses register <code id="P7000497027000000000000000041244" data-uri="chapter03.xhtml#P7000497027000000000000000041244" class="pcalibre1 calibre1 pcalibre2">%rbp</code> to serve as a <i class="pcalibre17 pcalibre2 pcalibre1">frame pointer</i> (sometimes referred to as a <i class="pcalibre17 pcalibre2 pcalibre1">base pointer</i>, and hence the letters <code id="P7000497027000000000000000041245" data-uri="chapter03.xhtml#P7000497027000000000000000041245" class="pcalibre1 calibre1 pcalibre2">bp</code> in <code id="P7000497027000000000000000041246" data-uri="chapter03.xhtml#P7000497027000000000000000041246" class="pcalibre1 calibre1 pcalibre2">%rbp</code>). When using a frame pointer, the stack frame is organized as shown for the case of function <code id="P7000497027000000000000000041247" data-uri="chapter03.xhtml#P7000497027000000000000000041247" class="pcalibre1 calibre1 pcalibre2">vframe</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000302E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.44</span></a>. We see that the code must save the previous version of <code id="P7000497027000000000000000041248" data-uri="chapter03.xhtml#P7000497027000000000000000041248" class="pcalibre1 calibre1 pcalibre2">%rbp</code> on the stack, since it is a callee-saved register. It then keeps <code id="P7000497027000000000000000041249" data-uri="chapter03.xhtml#P7000497027000000000000000041249" class="pcalibre1 calibre1 pcalibre2">%rbp</code> pointing to this position throughout the execution of the function, and it references fixed-length local variables, such as <code id="P700049702700000000000000004124A" data-uri="chapter03.xhtml#P700049702700000000000000004124A" class="pcalibre1 calibre1 pcalibre2">i</code>, at offsets relative to <code id="P700049702700000000000000004124B" data-uri="chapter03.xhtml#P700049702700000000000000004124B" class="pcalibre1 calibre1 pcalibre2">%rbp.</code></p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003022" data-uri="chapter03.xhtml#P7000497027000000000000000003022">
<p id="P700049702700000000000000004124C" data-uri="chapter03.xhtml#P700049702700000000000000004124C" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000003024" title="291" data-uri="chapter03.xhtml#P7000497027000000000000000003024" epub:type="pagebreak"></span>(a) C code</p>
<pre id="P700049702700000000000000004124D" data-uri="chapter03.xhtml#P700049702700000000000000004124D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004124E" data-uri="chapter03.xhtml#P700049702700000000000000004124E" class="calibre3 pcalibre1 pcalibre2">
long vframe(long n, long idx, long *q) {
	long i;
	long *p[n];
	p[0] = &amp;i;
	for (i = 1; i &lt; n; i++)
	  p[i] = q;
	return *p[idx];
}
</code></pre>
<p id="P700049702700000000000000004124F" data-uri="chapter03.xhtml#P700049702700000000000000004124F" class="pcalibre8 pcalibre1 pcalibre2">(b) Portions of generated assembly code</p>
<pre id="P7000497027000000000000000041250" data-uri="chapter03.xhtml#P7000497027000000000000000041250" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041251" data-uri="chapter03.xhtml#P7000497027000000000000000041251" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long vframe(long n, long idx, long *q)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">n in %rdi, idx in %rsi, q in %rdx</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">Only portions of code shown</i>
1	vframe:
2	pushq	%rbp			<i class="pcalibre17 pcalibre2 pcalibre1">Save old %rbp</i>
3	movq	%rsp, %rbp		<i class="pcalibre17 pcalibre2 pcalibre1">Set frame pointer</i>
4	subq	$16, %rsp		<i class="pcalibre17 pcalibre2 pcalibre1">Allocate space for i (%rsp = s</i><sub class="pcalibre1 pcalibre2 pcalibre122">1</sub>)
5	leaq	22(,%rdi,8), %rax
6	andq	$-16, %rax
7	subq	%rax, %rsp		<i class="pcalibre17 pcalibre2 pcalibre1">Allocate space for array p (%rsp = s</i><sub class="pcalibre1 pcalibre2 pcalibre122">2</sub>)
8	leaq	7(%rsp), %rax
9	shrq	$3, %rax
10	leaq	0(,%rax,8), %r8		<i class="pcalibre17 pcalibre2 pcalibre1">Set %r8 to &amp;p[0]</i>
11	movq	%r8, %rcx		<i class="pcalibre17 pcalibre2 pcalibre1">Set %rcx to &amp;p[0] (%rcx = p)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">...</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">Code for initialization loop</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">i in %rax and on stack, n in %rdi, p in %rcx, q in %rdx</i>
12	.L3:			      <b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
13	movq	%rdx, (%rcx,%rax,8)	<i class="pcalibre17 pcalibre2 pcalibre1">Set p[i] to q</i>
14	addq	$1, %rax		<i class="pcalibre17 pcalibre2 pcalibre1">Increment i</i>
15	movq	%rax, -8(%rbp)		<i class="pcalibre17 pcalibre2 pcalibre1">Store on stack</i>
16	.L2:
17	movq	-8(%rbp), %rax		<i class="pcalibre17 pcalibre2 pcalibre1">Retrieve i from stack</i>
18	cmpq	%rdi, %rax		<i class="pcalibre17 pcalibre2 pcalibre1">Compare i:n</i>
19	jl	.L3			<i class="pcalibre17 pcalibre2 pcalibre1">If &lt;, goto</i> loop
	<i class="pcalibre17 pcalibre2 pcalibre1">...</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">Code for function exit</i>
20	leave				<i class="pcalibre17 pcalibre2 pcalibre1">Restore %rbp and %rsp</i>
21	ret				<i class="pcalibre17 pcalibre2 pcalibre1">Return</i>
</code></pre>
<figcaption id="P7000497027000000000000000041252" data-uri="chapter03.xhtml#P7000497027000000000000000041252" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041253" data-uri="chapter03.xhtml#P7000497027000000000000000041253" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">3.43 </span>Function requiring the use of a frame pointer.</h1></header><div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000041254" data-uri="chapter03.xhtml#P7000497027000000000000000041254"><p id="P7000497027000000000000000041255" data-uri="chapter03.xhtml#P7000497027000000000000000041255" class="pcalibre1 pcalibre2 pcalibre10">The variable-size array implies that the size of the stack frame cannot be determined at compile time.</p></div></figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000302E" data-uri="chapter03.xhtml#P700049702700000000000000000302E">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000302F" title="292" data-uri="chapter03.xhtml#P700049702700000000000000000302F" epub:type="pagebreak"></span>
<img alt="A diagram illustrates a stack frame for function vframe." id="P7000497027000000000000000041256" data-uri="P700049702700000000000000000B6C4" src="../images/p292-1.png" class="pcalibre1 pcalibre2 calibre26"/>
<figcaption id="P7000497027000000000000000041257" data-uri="chapter03.xhtml#P7000497027000000000000000041257" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041258" data-uri="chapter03.xhtml#P7000497027000000000000000041258" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.44 </span>Stack frame structure for function <code id="P7000497027000000000000000041259" data-uri="chapter03.xhtml#P7000497027000000000000000041259" class="pcalibre1 calibre1 pcalibre2">vframe</code>.</h1></header><div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004125A" data-uri="chapter03.xhtml#P700049702700000000000000004125A"><p id="P700049702700000000000000004125B" data-uri="chapter03.xhtml#P700049702700000000000000004125B" class="pcalibre1 pcalibre2 pcalibre10">The function uses register <code id="P700049702700000000000000004125C" data-uri="chapter03.xhtml#P700049702700000000000000004125C" class="pcalibre1 calibre1 pcalibre2">%rbp</code> as a frame pointer. The annotations along the right-hand side are in reference to Practice <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003055"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">3.49</span></a>.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000021535" data-uri="chapter03.xhtml#P7000497027000000000000000021535">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P700049702700000000000000004125D" data-uri="chapter03.xhtml#P700049702700000000000000004125D" class="pcalibre8 pcalibre1 pcalibre2">The sections of the stack are summarized below from bottom to top:</p>
<ul class="pcalibre1 pcalibre2 pcalibre126" id="P700049702700000000000000004125E" data-uri="chapter03.xhtml#P700049702700000000000000004125E">
<li id="P700049702700000000000000004125F" data-uri="chapter03.xhtml#P700049702700000000000000004125F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041260" data-uri="chapter03.xhtml#P7000497027000000000000000041260" class="pcalibre1 pcalibre2 pcalibre40">e2 from s2 (Stack point %rsp) at the bottom to p.</p></li>
<li id="P7000497027000000000000000041261" data-uri="chapter03.xhtml#P7000497027000000000000000041261" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041262" data-uri="chapter03.xhtml#P7000497027000000000000000041262" class="pcalibre1 pcalibre2 pcalibre40">8n bytes containing p</p></li>
<li id="P7000497027000000000000000041263" data-uri="chapter03.xhtml#P7000497027000000000000000041263" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041264" data-uri="chapter03.xhtml#P7000497027000000000000000041264" class="pcalibre1 pcalibre2 pcalibre40">e1 to s1, numbered negative 16</p></li>
<li id="P7000497027000000000000000041265" data-uri="chapter03.xhtml#P7000497027000000000000000041265" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041266" data-uri="chapter03.xhtml#P7000497027000000000000000041266" class="pcalibre1 pcalibre2 pcalibre40">from negative 16 to negative 8 containing (Unused)</p></li>
<li id="P7000497027000000000000000041267" data-uri="chapter03.xhtml#P7000497027000000000000000041267" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041268" data-uri="chapter03.xhtml#P7000497027000000000000000041268" class="pcalibre1 pcalibre2 pcalibre40">from negative 8 to 0 (frame pointer %rbp) containing i</p></li>
<li id="P7000497027000000000000000041269" data-uri="chapter03.xhtml#P7000497027000000000000000041269" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004126A" data-uri="chapter03.xhtml#P700049702700000000000000004126A" class="pcalibre1 pcalibre2 pcalibre40">from 0 to 8 containing Saved %rbp</p></li>
<li id="P700049702700000000000000004126B" data-uri="chapter03.xhtml#P700049702700000000000000004126B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004126C" data-uri="chapter03.xhtml#P700049702700000000000000004126C" class="pcalibre1 pcalibre2 pcalibre40">above 8 containing Return address</p></li>
</ul>
</details>
</figcaption>
</figure>
<p id="P700049702700000000000000004126D" data-uri="chapter03.xhtml#P700049702700000000000000004126D" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003022"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.43(b)</span></a> shows portions of the code <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates for function <code id="P700049702700000000000000004126E" data-uri="chapter03.xhtml#P700049702700000000000000004126E" class="pcalibre1 calibre1 pcalibre2">vframe</code>. At the beginning of the function, we see code that sets up the stack frame and allocates space for array <code id="P700049702700000000000000004126F" data-uri="chapter03.xhtml#P700049702700000000000000004126F" class="pcalibre1 calibre1 pcalibre2">p</code>. The code starts by pushing the current value of <code id="P7000497027000000000000000041270" data-uri="chapter03.xhtml#P7000497027000000000000000041270" class="pcalibre1 calibre1 pcalibre2">%rbp</code> onto the stack and setting <code id="P7000497027000000000000000041271" data-uri="chapter03.xhtml#P7000497027000000000000000041271" class="pcalibre1 calibre1 pcalibre2">%rbp</code> to point to this stack position (lines 2â3). Next, it allocates 16 bytes on the stack, the first 8 of which are used to store local variable <code id="P7000497027000000000000000041272" data-uri="chapter03.xhtml#P7000497027000000000000000041272" class="pcalibre1 calibre1 pcalibre2">i</code>, and the second 8 of which are unused. Then it allocates space for array <code id="P7000497027000000000000000041273" data-uri="chapter03.xhtml#P7000497027000000000000000041273" class="pcalibre1 calibre1 pcalibre2">p</code> (lines 5â11). The details of how much space it allocates and where it positions <code id="P7000497027000000000000000041274" data-uri="chapter03.xhtml#P7000497027000000000000000041274" class="pcalibre1 calibre1 pcalibre2">p</code> within this space are explored in Practice <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003055"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.49</span></a>. Suffice it to say that by the time the program reaches line 11, it has (1) allocated at least 8<var class="pcalibre17 pcalibre2 pcalibre1">n</var> bytes on the stack and (2) positioned array <code id="P7000497027000000000000000041275" data-uri="chapter03.xhtml#P7000497027000000000000000041275" class="pcalibre1 calibre1 pcalibre2">p</code> within the allocated region such that at least 8<var class="pcalibre17 pcalibre2 pcalibre1">n</var> bytes are available for its use.</p>
<p id="P7000497027000000000000000041276" data-uri="chapter03.xhtml#P7000497027000000000000000041276" class="pcalibre8 pcalibre1 pcalibre2">The code for the initialization loop shows examples of how local variables <code id="P7000497027000000000000000041277" data-uri="chapter03.xhtml#P7000497027000000000000000041277" class="pcalibre1 calibre1 pcalibre2">i</code> and <code id="P7000497027000000000000000041278" data-uri="chapter03.xhtml#P7000497027000000000000000041278" class="pcalibre1 calibre1 pcalibre2">p</code> are referenced. Line 13 shows array element <code id="P7000497027000000000000000041279" data-uri="chapter03.xhtml#P7000497027000000000000000041279" class="pcalibre1 calibre1 pcalibre2">p[i]</code> being set to <code id="P700049702700000000000000004127A" data-uri="chapter03.xhtml#P700049702700000000000000004127A" class="pcalibre1 calibre1 pcalibre2">q</code>. This instruction uses the value in register <code id="P700049702700000000000000004127B" data-uri="chapter03.xhtml#P700049702700000000000000004127B" class="pcalibre1 calibre1 pcalibre2">%rcx</code> as the address for the start of <code id="P700049702700000000000000004127C" data-uri="chapter03.xhtml#P700049702700000000000000004127C" class="pcalibre1 calibre1 pcalibre2">p</code>. We can see instances where local variable <code id="P700049702700000000000000004127D" data-uri="chapter03.xhtml#P700049702700000000000000004127D" class="pcalibre1 calibre1 pcalibre2">i</code> is updated (line 15) and read (line 17). The address of <code id="P700049702700000000000000004127E" data-uri="chapter03.xhtml#P700049702700000000000000004127E" class="pcalibre1 calibre1 pcalibre2">i</code> is given by reference <code id="P700049702700000000000000004127F" data-uri="chapter03.xhtml#P700049702700000000000000004127F" class="pcalibre1 calibre1 pcalibre2">-8(%rbp)</code>âthat is, at offset -8 relative to the frame pointer.</p>
<p id="P7000497027000000000000000041280" data-uri="chapter03.xhtml#P7000497027000000000000000041280" class="pcalibre8 pcalibre1 pcalibre2">At the end of the function, the frame pointer is restored to its previous value using the <code id="P7000497027000000000000000041281" data-uri="chapter03.xhtml#P7000497027000000000000000041281" class="pcalibre1 calibre1 pcalibre2">leave</code> instruction (line 20). This instruction takes no arguments. It is equivalent to executing the following two instructions:</p>
<pre id="P7000497027000000000000000041282" data-uri="chapter03.xhtml#P7000497027000000000000000041282" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041283" data-uri="chapter03.xhtml#P7000497027000000000000000041283" class="calibre3 pcalibre1 pcalibre2">
movq %rbp, %rsp		<i class="pcalibre17 pcalibre2 pcalibre1">Set stack pointer to beginning of frame</i>
popq %rbp		<i class="pcalibre17 pcalibre2 pcalibre1">Restore saved %rbp and set stack ptr to end of caller's frame</i>
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041284" data-uri="chapter03.xhtml#P7000497027000000000000000041284">That is, the stack pointer is first set to the position of the saved value of <code id="P7000497027000000000000000041285" data-uri="chapter03.xhtml#P7000497027000000000000000041285" class="pcalibre1 calibre1 pcalibre2">%rbp</code>, and then this value is popped from the stack into <code id="P7000497027000000000000000041286" data-uri="chapter03.xhtml#P7000497027000000000000000041286" class="pcalibre1 calibre1 pcalibre2">%rbp</code>. This instruction combination has the effect of deallocating the entire stack frame.</p>
<p id="P7000497027000000000000000041287" data-uri="chapter03.xhtml#P7000497027000000000000000041287" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003052" title="293" data-uri="chapter03.xhtml#P7000497027000000000000000003052" epub:type="pagebreak"></span>In earlier versions of x86 code, the frame pointer was used with every function call. With x86-64 code, it is used only in cases where the stack frame may be of variable size, as is the case for function <code id="P7000497027000000000000000041288" data-uri="chapter03.xhtml#P7000497027000000000000000041288" class="pcalibre1 calibre1 pcalibre2">vframe</code>. Historically, most compilers used frame pointers when generating IA32 code. Recent versions of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>have dropped this convention. Observe that it is acceptable to mix code that uses frame pointers with code that does not, as long as all functions treat <code id="P7000497027000000000000000041289" data-uri="chapter03.xhtml#P7000497027000000000000000041289" class="pcalibre1 calibre1 pcalibre2">%rbp</code> as a callee-saved register.</p>
<section id="P7000497027000000000000000003055" data-uri="chapter03.xhtml#P7000497027000000000000000003055" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004128A" data-uri="chapter03.xhtml#P700049702700000000000000004128A" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.49 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003968">347</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004128B" data-uri="chapter03.xhtml#P700049702700000000000000004128B">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004128C" data-uri="chapter03.xhtml#P700049702700000000000000004128C">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004128D" data-uri="chapter03.xhtml#P700049702700000000000000004128D"><p id="P700049702700000000000000004128E" data-uri="chapter03.xhtml#P700049702700000000000000004128E" class="pcalibre1 pcalibre2 pcalibre10">In this problem, we will explore the logic behind the code in lines 5â11 of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003022"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.43(b)</span></a>, where space is allocated for variable-size array p. As the annotations of the code indicate, let us let <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub> denote the address of the stack pointer after executing the <code id="P700049702700000000000000004128F" data-uri="chapter03.xhtml#P700049702700000000000000004128F" class="pcalibre1 calibre1 pcalibre2">subq</code> instruction of line 4. This instruction allocates the space for local variable i. Let <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub> denote the value of the stack pointer after executing the <code id="P7000497027000000000000000041290" data-uri="chapter03.xhtml#P7000497027000000000000000041290" class="pcalibre1 calibre1 pcalibre2">subq</code> instruction of line 7. This instruction allocates the storage for local array <code id="P7000497027000000000000000041291" data-uri="chapter03.xhtml#P7000497027000000000000000041291" class="pcalibre1 calibre1 pcalibre2">p</code>. Finally, let <var class="pcalibre17 pcalibre2 pcalibre1">p</var> denote the value assigned to registers <code id="P7000497027000000000000000041292" data-uri="chapter03.xhtml#P7000497027000000000000000041292" class="pcalibre1 calibre1 pcalibre2">%r8</code> and <code id="P7000497027000000000000000041293" data-uri="chapter03.xhtml#P7000497027000000000000000041293" class="pcalibre1 calibre1 pcalibre2">%rcx</code> in the instructions of lines 10â11. Both of these registers are used to reference array <code id="P7000497027000000000000000041294" data-uri="chapter03.xhtml#P7000497027000000000000000041294" class="pcalibre1 calibre1 pcalibre2">p</code>.</p>
<p id="P7000497027000000000000000041295" data-uri="chapter03.xhtml#P7000497027000000000000000041295" class="pcalibre1 pcalibre2 pcalibre10">The right-hand side of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000302E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.44</span></a> diagrams the positions of the locations indicated by <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, and <var class="pcalibre17 pcalibre2 pcalibre1">p</var>. It also shows that there may be an offset of <var class="pcalibre17 pcalibre2 pcalibre1">e</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub> bytes between the values of <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub> and <var class="pcalibre17 pcalibre2 pcalibre1">p</var>. This space will not be used. There may also be an offset of <var class="pcalibre17 pcalibre2 pcalibre1">e</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub> bytes between the end of array <code id="P7000497027000000000000000041296" data-uri="chapter03.xhtml#P7000497027000000000000000041296" class="pcalibre1 calibre1 pcalibre2">p</code> and the position indicated by <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000041297" data-uri="chapter03.xhtml#P7000497027000000000000000041297">
<li id="P7000497027000000000000000041298" data-uri="chapter03.xhtml#P7000497027000000000000000041298" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041299" data-uri="chapter03.xhtml#P7000497027000000000000000041299" class="pcalibre1 pcalibre2 pcalibre10">Explain, in mathematical terms, the logic in the computation of <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub> on lines 5â7. <i class="pcalibre17 pcalibre2 pcalibre1">Hint:</i> Think about the bit-level representation of â16 and its effect in the <code id="P700049702700000000000000004129A" data-uri="chapter03.xhtml#P700049702700000000000000004129A" class="pcalibre1 calibre1 pcalibre2">andq</code> instruction of line 6.</p></li>
<li id="P700049702700000000000000004129B" data-uri="chapter03.xhtml#P700049702700000000000000004129B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004129C" data-uri="chapter03.xhtml#P700049702700000000000000004129C" class="pcalibre1 pcalibre2 pcalibre10">Explain, in mathematical terms, the logic in the computation of <var class="pcalibre17 pcalibre2 pcalibre1">p</var> on lines 8â10. <i class="pcalibre17 pcalibre2 pcalibre1">Hint:</i> You may want to refer to the discussion on division by powers of 2 in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000000CB3_split_001.xhtml#P7000497027000000000000000000FF6"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">2.3.7</span></a>.</p></li>
<li id="P700049702700000000000000004129D" data-uri="chapter03.xhtml#P700049702700000000000000004129D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004129E" data-uri="chapter03.xhtml#P700049702700000000000000004129E" class="pcalibre1 pcalibre2 pcalibre10">For the following values of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> and <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, trace the execution of the code to determine what the resulting values would be for <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">p</var>, <var class="pcalibre17 pcalibre2 pcalibre1">e</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, and <var class="pcalibre17 pcalibre2 pcalibre1">e</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>.</p>
<table id="P700049702700000000000000004129F" data-uri="chapter03.xhtml#P700049702700000000000000004129F" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P70004970270000000000000000412A0" data-uri="chapter03.xhtml#P70004970270000000000000000412A0" class="pcalibre1 pcalibre2 calibre5"><var class="pcalibre17 pcalibre2 pcalibre1">n</var></th>
<th id="P70004970270000000000000000412A1" data-uri="chapter03.xhtml#P70004970270000000000000000412A1" class="pcalibre1 pcalibre2 calibre5"><var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></th>
<th id="P70004970270000000000000000412A2" data-uri="chapter03.xhtml#P70004970270000000000000000412A2" class="pcalibre1 pcalibre2 calibre5"><var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></th>
<th id="P70004970270000000000000000412A3" data-uri="chapter03.xhtml#P70004970270000000000000000412A3" class="pcalibre1 pcalibre2 calibre5"><var class="pcalibre17 pcalibre2 pcalibre1">p</var></th>
<th id="P70004970270000000000000000412A4" data-uri="chapter03.xhtml#P70004970270000000000000000412A4" class="pcalibre1 pcalibre2 calibre5"><var class="pcalibre17 pcalibre2 pcalibre1">e</var><sub class="pcalibre97 pcalibre2 pcalibre1">1</sub></th>
<th id="P70004970270000000000000000412A5" data-uri="chapter03.xhtml#P70004970270000000000000000412A5" class="pcalibre1 pcalibre2 calibre5"><var class="pcalibre17 pcalibre2 pcalibre1">e</var><sub class="pcalibre97 pcalibre2 pcalibre1">2</sub></th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000412A6" data-uri="chapter03.xhtml#P70004970270000000000000000412A6" class="pcalibre1 pcalibre2 calibre7">5</td>
<td id="P70004970270000000000000000412A7" data-uri="chapter03.xhtml#P70004970270000000000000000412A7" class="pcalibre1 pcalibre2 calibre7">2,065</td>
<td id="P70004970270000000000000000412A8" data-uri="chapter03.xhtml#P70004970270000000000000000412A8" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P70004970270000000000000000412A9" data-uri="chapter03.xhtml#P70004970270000000000000000412A9" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P70004970270000000000000000412AA" data-uri="chapter03.xhtml#P70004970270000000000000000412AA" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P70004970270000000000000000412AB" data-uri="chapter03.xhtml#P70004970270000000000000000412AB" class="pcalibre1 pcalibre2 calibre7">__________</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000412AC" data-uri="chapter03.xhtml#P70004970270000000000000000412AC" class="pcalibre1 pcalibre2 calibre7">6</td>
<td id="P70004970270000000000000000412AD" data-uri="chapter03.xhtml#P70004970270000000000000000412AD" class="pcalibre1 pcalibre2 calibre7">2,064</td>
<td id="P70004970270000000000000000412AE" data-uri="chapter03.xhtml#P70004970270000000000000000412AE" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P70004970270000000000000000412AF" data-uri="chapter03.xhtml#P70004970270000000000000000412AF" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P70004970270000000000000000412B0" data-uri="chapter03.xhtml#P70004970270000000000000000412B0" class="pcalibre1 pcalibre2 calibre7">__________</td>
<td id="P70004970270000000000000000412B1" data-uri="chapter03.xhtml#P70004970270000000000000000412B1" class="pcalibre1 pcalibre2 calibre7">__________</td>
</tr>
</tbody>
</table></li>
<li id="P70004970270000000000000000412B2" data-uri="chapter03.xhtml#P70004970270000000000000000412B2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000412B3" data-uri="chapter03.xhtml#P70004970270000000000000000412B3" class="pcalibre1 pcalibre2 pcalibre10">What alignment properties does this code guarantee for the values of <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub> and <var class="pcalibre17 pcalibre2 pcalibre1">p</var>?</p></li>
</ol></div></li></ol>
</section>
</section>
</section></body></html>
