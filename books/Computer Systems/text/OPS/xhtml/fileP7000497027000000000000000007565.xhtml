<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>9.10 Garbage Collection</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000007565" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000046075" data-uri="chapter09.xhtml#P7000497027000000000000000046075" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.10 </span>Garbage Collection</h1></header>
<p id="P7000497027000000000000000046076" data-uri="chapter09.xhtml#P7000497027000000000000000046076" class="pcalibre8 pcalibre1 pcalibre2">With an explicit allocator such as the C <code id="P7000497027000000000000000046077" data-uri="chapter09.xhtml#P7000497027000000000000000046077" class="pcalibre1 calibre1 pcalibre2">malloc</code> package, an application allocates and frees heap blocks by making calls to <code id="P7000497027000000000000000046078" data-uri="chapter09.xhtml#P7000497027000000000000000046078" class="pcalibre1 calibre1 pcalibre2">malloc</code> and <code id="P7000497027000000000000000046079" data-uri="chapter09.xhtml#P7000497027000000000000000046079" class="pcalibre1 calibre1 pcalibre2">free</code>. It is the application's responsibility to free any allocated blocks that it no longer needs.</p>
<p id="P700049702700000000000000004607A" data-uri="chapter09.xhtml#P700049702700000000000000004607A" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000756C" title="866" data-uri="chapter09.xhtml#P700049702700000000000000000756C" epub:type="pagebreak"></span>Failing to free allocated blocks is a common programming error. For example, consider the following C function that allocates a block of temporary storage as part of its processing:</p>
<pre id="P700049702700000000000000004607B" data-uri="chapter09.xhtml#P700049702700000000000000004607B" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004607C" data-uri="chapter09.xhtml#P700049702700000000000000004607C" class="calibre3 pcalibre1 pcalibre2">
1	void garbage()
2	{
3		int *p = (int *)Malloc(15213);
4	
5		return; /* Array p is garbage at this point */
6	}
</code></pre>
<p id="P700049702700000000000000004607D" data-uri="chapter09.xhtml#P700049702700000000000000004607D" class="pcalibre8 pcalibre1 pcalibre2">Since <code id="P700049702700000000000000004607E" data-uri="chapter09.xhtml#P700049702700000000000000004607E" class="pcalibre1 calibre1 pcalibre2">p</code> is no longer needed by the program, it should have been freed before garbage returned. Unfortunately, the programmer has forgotten to free the block. It remains allocated for the lifetime of the program, needlessly occupying heap space that could be used to satisfy subsequent allocation requests.</p>
<p id="P700049702700000000000000004607F" data-uri="chapter09.xhtml#P700049702700000000000000004607F" class="pcalibre8 pcalibre1 pcalibre2">A <i class="pcalibre17 pcalibre2 pcalibre1">garbage collector</i> is a dynamic storage allocator that automatically frees allocated blocks that are no longer needed by the program. Such blocks are known as <i class="pcalibre17 pcalibre2 pcalibre1">garbage</i> (hence the term "garbage collector"). The process of automatically reclaiming heap storage is known as <i class="pcalibre17 pcalibre2 pcalibre1">garbage collection.</i> In a system that supports garbage collection, applications explicitly allocate heap blocks but never explicitly free them. In the context of a C program, the application calls <code id="P7000497027000000000000000046080" data-uri="chapter09.xhtml#P7000497027000000000000000046080" class="pcalibre1 calibre1 pcalibre2">malloc</code> but never calls <code id="P7000497027000000000000000046081" data-uri="chapter09.xhtml#P7000497027000000000000000046081" class="pcalibre1 calibre1 pcalibre2">free</code>. Instead, the garbage collector periodically identifies the garbage blocks and makes the appropriate calls to <code id="P7000497027000000000000000046082" data-uri="chapter09.xhtml#P7000497027000000000000000046082" class="pcalibre1 calibre1 pcalibre2">free</code> to place those blocks back on the free list.</p>
<p id="P7000497027000000000000000046083" data-uri="chapter09.xhtml#P7000497027000000000000000046083" class="pcalibre8 pcalibre1 pcalibre2">Garbage collection dates back to Lisp systems developed by John McCarthy at MIT in the early 1960s. It is an important part of modern language systems such as Java, ML, Perl, and Mathematica, and it remains an active and important area of research. The literature describes an amazing number of approaches for garbage collection. We will limit our discussion to McCarthy's original <i class="pcalibre17 pcalibre2 pcalibre1">Mark&amp;Sweep</i> algorithm, which is interesting because it can be built on top of an existing <code id="P7000497027000000000000000046084" data-uri="chapter09.xhtml#P7000497027000000000000000046084" class="pcalibre1 calibre1 pcalibre2">malloc</code> package to provide garbage collection for C and C++ programs.</p>
<section id="P7000497027000000000000000007577" data-uri="chapter09.xhtml#P7000497027000000000000000007577" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046085" data-uri="chapter09.xhtml#P7000497027000000000000000046085" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.10.1 </span>Garbage Collector Basics</h1></header>
<p id="P7000497027000000000000000046086" data-uri="chapter09.xhtml#P7000497027000000000000000046086" class="pcalibre8 pcalibre1 pcalibre2">A garbage collector views memory as a directed <i class="pcalibre17 pcalibre2 pcalibre1">reachability graph</i> of the form shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000757B"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.49</span></a>. The nodes of the graph are partitioned into a set of <i class="pcalibre17 pcalibre2 pcalibre1">root nodes</i> and a set of <i class="pcalibre17 pcalibre2 pcalibre1">heap nodes.</i> Each heap node corresponds to an allocated block in the heap. A directed edge <var class="pcalibre17 pcalibre2 pcalibre1">p</var>â†’ <var class="pcalibre17 pcalibre2 pcalibre1">q</var> means that some location in block <var class="pcalibre17 pcalibre2 pcalibre1">p</var> points to some location in block <i class="pcalibre17 pcalibre2 pcalibre1">q.</i> Root nodes correspond to locations not in the heap that contain pointers into the heap. These locations can be registers, variables on the stack, or global variables in the read/write data area of virtual memory.</p>
<p id="P7000497027000000000000000046087" data-uri="chapter09.xhtml#P7000497027000000000000000046087" class="pcalibre8 pcalibre1 pcalibre2">We say that a node <var class="pcalibre17 pcalibre2 pcalibre1">p</var> is <i class="pcalibre17 pcalibre2 pcalibre1">reachable</i> if there exists a directed path from any root node to <i class="pcalibre17 pcalibre2 pcalibre1">p.</i> At any point in time, the unreachable nodes correspond to garbage that can never be used again by the application. The role of a garbage collector is to maintain some representation of the reachability graph and periodically reclaim the unreachable nodes by freeing them and returning them to the free list.</p>
<figure id="P700049702700000000000000000757B" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P700049702700000000000000000757B">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000757C" title="867" data-uri="chapter09.xhtml#P700049702700000000000000000757C" epub:type="pagebreak"></span>
<img alt="A directed graph has arrows from three reachable root nodes to reachable heap nodes below: one branching to two reachable nodes; one above a circle of three unreachable (garbage) nodes; and one to a reachable node beside an unreachable." id="P7000497027000000000000000046088" data-uri="P700049702700000000000000000B7A7" src="../images/p867-1.png" class="calibre80 pcalibre1 pcalibre2"/>
<figcaption id="P7000497027000000000000000046089" data-uri="chapter09.xhtml#P7000497027000000000000000046089" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004608A" data-uri="chapter09.xhtml#P700049702700000000000000004608A" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.49 </span>A garbage collector's view of memory as a directed graph.</h1></header></figcaption>
</figure>
<figure id="P7000497027000000000000000007580" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P7000497027000000000000000007580">
<img alt="A diagram shows an interaction with a C application program and malloc() within a dynamic storage allocator, within which a conservative garbage collector interacts with malloc() and free()." id="P700049702700000000000000004608B" data-uri="P700049702700000000000000000B7A8" src="../images/p867-2.png" class="pcalibre1 pcalibre2 pcalibre287"/>
<figcaption id="P700049702700000000000000004608C" data-uri="chapter09.xhtml#P700049702700000000000000004608C" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004608D" data-uri="chapter09.xhtml#P700049702700000000000000004608D" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.50 </span>Integrating a conservative garbage collector and a C <code id="P700049702700000000000000004608E" data-uri="chapter09.xhtml#P700049702700000000000000004608E" class="pcalibre1 calibre1 pcalibre2">malloc</code> package.</h1></header></figcaption>
</figure>
<p id="P700049702700000000000000004608F" data-uri="chapter09.xhtml#P700049702700000000000000004608F" class="pcalibre8 pcalibre1 pcalibre2">Garbage collectors for languages like ML and Java, which exert tight control over how applications create and use pointers, can maintain an exact representation of the reachability graph and thus can reclaim all garbage. However, collectors for languages like C and C++ cannot in general maintain exact representations of the reachability graph. Such collectors are known as <i class="pcalibre17 pcalibre2 pcalibre1">conservative garbage collectors.</i> They are conservative in the sense that each reachable block is correctly identified as reachable, while some unreachable nodes might be incorrectly identified as reachable.</p>
<p id="P7000497027000000000000000046090" data-uri="chapter09.xhtml#P7000497027000000000000000046090" class="pcalibre8 pcalibre1 pcalibre2">Collectors can provide their service on demand, or they can run as separate threads in parallel with the application, continuously updating the reachability graph and reclaiming garbage. For example, consider how we might incorporate a conservative collector for C programs into an existing <code id="P7000497027000000000000000046091" data-uri="chapter09.xhtml#P7000497027000000000000000046091" class="pcalibre1 calibre1 pcalibre2">malloc</code> package, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007580"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.50</span></a>.</p>
<p id="P7000497027000000000000000046092" data-uri="chapter09.xhtml#P7000497027000000000000000046092" class="pcalibre8 pcalibre1 pcalibre2">The application calls <code id="P7000497027000000000000000046093" data-uri="chapter09.xhtml#P7000497027000000000000000046093" class="pcalibre1 calibre1 pcalibre2">malloc</code> in the usual manner whenever it needs heap space. If <code id="P7000497027000000000000000046094" data-uri="chapter09.xhtml#P7000497027000000000000000046094" class="pcalibre1 calibre1 pcalibre2">malloc</code> is unable to find a free block that fits, then it calls the garbage collector in hopes of reclaiming some garbage to the free list. The collector identifies the garbage blocks and returns them to the heap by calling the <code id="P7000497027000000000000000046095" data-uri="chapter09.xhtml#P7000497027000000000000000046095" class="pcalibre1 calibre1 pcalibre2">free</code> function. The key idea is that the collector calls free instead of the application. When the call to the collector returns, <code id="P7000497027000000000000000046096" data-uri="chapter09.xhtml#P7000497027000000000000000046096" class="pcalibre1 calibre1 pcalibre2">malloc</code> tries again to find a free block that fits. If that fails, then it can ask the operating system for additional memory. Eventually, <code id="P7000497027000000000000000046097" data-uri="chapter09.xhtml#P7000497027000000000000000046097" class="pcalibre1 calibre1 pcalibre2">malloc</code> returns a pointer to the requested block (if successful) or the NULL pointer (if unsuccessful).</p>
</section>
<section id="P700049702700000000000000000758E" data-uri="chapter09.xhtml#P700049702700000000000000000758E" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000046098" data-uri="chapter09.xhtml#P7000497027000000000000000046098" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.10.2 </span>Mark&amp;Sweep Garbage Collectors</h1></header>
<p id="P7000497027000000000000000046099" data-uri="chapter09.xhtml#P7000497027000000000000000046099" class="pcalibre8 pcalibre1 pcalibre2">A Mark&amp;Sweep garbage collector consists of a <i class="pcalibre17 pcalibre2 pcalibre1">mark phase</i>, which marks all reachable and allocated descendants of the root nodes, followed by a <i class="pcalibre17 pcalibre2 pcalibre1">sweep phase</i>, which frees each unmarked allocated block. Typically, one of the spare low-order bits in the block header is used to indicate whether a block is marked or not.</p>
<figure id="P7000497027000000000000000007591" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P7000497027000000000000000007591">
<p id="P700049702700000000000000004609A" data-uri="chapter09.xhtml#P700049702700000000000000004609A" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007593" title="868" data-uri="chapter09.xhtml#P7000497027000000000000000007593" epub:type="pagebreak"></span>(a) <code id="P700049702700000000000000004609B" data-uri="chapter09.xhtml#P700049702700000000000000004609B" class="pcalibre1 calibre1 pcalibre2">mark</code> function</p>
<pre id="P700049702700000000000000004609C" data-uri="chapter09.xhtml#P700049702700000000000000004609C" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004609D" data-uri="chapter09.xhtml#P700049702700000000000000004609D" class="calibre3 pcalibre1 pcalibre2">
void mark (ptr p) {
	if ((b = isPtr(p)) == NULL)
		return;
	if (blockMarked(b))
		return;
	markBlock(b);
	len = length(b);
	for (i=0; i &lt; len; i++)
		mark(b[i]);
	return;
}
</code></pre>
<p id="P700049702700000000000000004609E" data-uri="chapter09.xhtml#P700049702700000000000000004609E" class="pcalibre8 pcalibre1 pcalibre2">(b) <code id="P700049702700000000000000004609F" data-uri="chapter09.xhtml#P700049702700000000000000004609F" class="pcalibre1 calibre1 pcalibre2">sweep</code> function</p>
<pre id="P70004970270000000000000000460A0" data-uri="chapter09.xhtml#P70004970270000000000000000460A0" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000460A1" data-uri="chapter09.xhtml#P70004970270000000000000000460A1" class="calibre3 pcalibre1 pcalibre2">
void sweep(ptr b, ptr end) {
	while (b &lt; end) {
		if (blockMarked(b))
			unmarkBlock(b);
		else if (blockAllocated(b))
			free(b);
		b = nextBlock(b);
	}
	return;
}
</code></pre>
<figcaption id="P70004970270000000000000000460A2" data-uri="chapter09.xhtml#P70004970270000000000000000460A2" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000460A3" data-uri="chapter09.xhtml#P70004970270000000000000000460A3" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.51 </span>Pseudocode for the <code id="P70004970270000000000000000460A4" data-uri="chapter09.xhtml#P70004970270000000000000000460A4" class="pcalibre1 calibre1 pcalibre2">mark</code> and <code id="P70004970270000000000000000460A5" data-uri="chapter09.xhtml#P70004970270000000000000000460A5" class="pcalibre1 calibre1 pcalibre2">sweep</code> functions.</h1></header></figcaption>
</figure>
<p id="P70004970270000000000000000460A6" data-uri="chapter09.xhtml#P70004970270000000000000000460A6" class="pcalibre8 pcalibre1 pcalibre2">Our description of Mark&amp;Sweep will assume the following functions, where <code id="P70004970270000000000000000460A7" data-uri="chapter09.xhtml#P70004970270000000000000000460A7" class="pcalibre1 calibre1 pcalibre2">ptr</code> is defined as <code id="P70004970270000000000000000460A8" data-uri="chapter09.xhtml#P70004970270000000000000000460A8" class="pcalibre1 calibre1 pcalibre2">typedef void *ptr</code>:</p>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P70004970270000000000000000460A9" data-uri="chapter09.xhtml#P70004970270000000000000000460A9">
<li id="P70004970270000000000000000460AA" data-uri="chapter09.xhtml#P70004970270000000000000000460AA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000460AB" data-uri="chapter09.xhtml#P70004970270000000000000000460AB" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><code id="P70004970270000000000000000460AC" data-uri="chapter09.xhtml#P70004970270000000000000000460AC" class="pcalibre1 calibre1 pcalibre2">ptr isPtr (ptr p).</code> </span>If <code id="P70004970270000000000000000460AD" data-uri="chapter09.xhtml#P70004970270000000000000000460AD" class="pcalibre1 calibre1 pcalibre2">p</code> points to some word in an allocated block, it returns a pointer <code id="P70004970270000000000000000460AE" data-uri="chapter09.xhtml#P70004970270000000000000000460AE" class="pcalibre1 calibre1 pcalibre2">b</code> to the beginning of that block. Returns NULL otherwise.</p></li>
<li id="P70004970270000000000000000460AF" data-uri="chapter09.xhtml#P70004970270000000000000000460AF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000460B0" data-uri="chapter09.xhtml#P70004970270000000000000000460B0" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><code id="P70004970270000000000000000460B1" data-uri="chapter09.xhtml#P70004970270000000000000000460B1" class="pcalibre1 calibre1 pcalibre2">int blockMarked(ptr b)</code>. </span>Returns true if block <code id="P70004970270000000000000000460B2" data-uri="chapter09.xhtml#P70004970270000000000000000460B2" class="pcalibre1 calibre1 pcalibre2">b</code> is already marked.</p></li>
<li id="P70004970270000000000000000460B3" data-uri="chapter09.xhtml#P70004970270000000000000000460B3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000460B4" data-uri="chapter09.xhtml#P70004970270000000000000000460B4" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><code id="P70004970270000000000000000460B5" data-uri="chapter09.xhtml#P70004970270000000000000000460B5" class="pcalibre1 calibre1 pcalibre2">int blockAllocated(ptr b)</code>. </span>Returns true if block <code id="P70004970270000000000000000460B6" data-uri="chapter09.xhtml#P70004970270000000000000000460B6" class="pcalibre1 calibre1 pcalibre2">b</code> is allocated.</p></li>
<li id="P70004970270000000000000000460B7" data-uri="chapter09.xhtml#P70004970270000000000000000460B7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000460B8" data-uri="chapter09.xhtml#P70004970270000000000000000460B8" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><code id="P70004970270000000000000000460B9" data-uri="chapter09.xhtml#P70004970270000000000000000460B9" class="pcalibre1 calibre1 pcalibre2">void markBlock(ptr b)</code>. </span>Marks block <code id="P70004970270000000000000000460BA" data-uri="chapter09.xhtml#P70004970270000000000000000460BA" class="pcalibre1 calibre1 pcalibre2">b</code>.</p></li>
<li id="P70004970270000000000000000460BB" data-uri="chapter09.xhtml#P70004970270000000000000000460BB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000460BC" data-uri="chapter09.xhtml#P70004970270000000000000000460BC" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><code id="P70004970270000000000000000460BD" data-uri="chapter09.xhtml#P70004970270000000000000000460BD" class="pcalibre1 calibre1 pcalibre2">int length (ptr b)</code>. </span>Returns the length in words (excluding the header) of block <code id="P70004970270000000000000000460BE" data-uri="chapter09.xhtml#P70004970270000000000000000460BE" class="pcalibre1 calibre1 pcalibre2">b</code>.</p></li>
<li id="P70004970270000000000000000460BF" data-uri="chapter09.xhtml#P70004970270000000000000000460BF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000460C0" data-uri="chapter09.xhtml#P70004970270000000000000000460C0" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><code id="P70004970270000000000000000460C1" data-uri="chapter09.xhtml#P70004970270000000000000000460C1" class="pcalibre1 calibre1 pcalibre2">void unmarkBlock (ptr b)</code>. </span>Changes the status of block <code id="P70004970270000000000000000460C2" data-uri="chapter09.xhtml#P70004970270000000000000000460C2" class="pcalibre1 calibre1 pcalibre2">b</code> from marked to unmarked.</p></li>
<li id="P70004970270000000000000000460C3" data-uri="chapter09.xhtml#P70004970270000000000000000460C3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000460C4" data-uri="chapter09.xhtml#P70004970270000000000000000460C4" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41"><code id="P70004970270000000000000000460C5" data-uri="chapter09.xhtml#P70004970270000000000000000460C5" class="pcalibre1 calibre1 pcalibre2">ptr nextBlock(ptr b)</code>. </span>Returns the successor of block <var class="pcalibre17 pcalibre2 pcalibre1">b</var> in the heap.</p></li>
</ul>
<p id="P70004970270000000000000000460C6" data-uri="chapter09.xhtml#P70004970270000000000000000460C6" class="pcalibre8 pcalibre1 pcalibre2">The mark phase calls the mark function shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007591"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.51(a)</span></a> once for each root node. The <code id="P70004970270000000000000000460C7" data-uri="chapter09.xhtml#P70004970270000000000000000460C7" class="pcalibre1 calibre1 pcalibre2">mark</code> function returns immediately if <code id="P70004970270000000000000000460C8" data-uri="chapter09.xhtml#P70004970270000000000000000460C8" class="pcalibre1 calibre1 pcalibre2">p</code> does not point to an allocated and unmarked heap block. Otherwise, it marks the block and calls itself recursively on each word in block. Each call to the <code id="P70004970270000000000000000460C9" data-uri="chapter09.xhtml#P70004970270000000000000000460C9" class="pcalibre1 calibre1 pcalibre2">mark</code> function marks any unmarked and reachable descendants of some root node. At the end of the mark phase, any allocated block that is not marked is guaranteed to be unreachable and, hence, garbage that can be reclaimed in the sweep phase.</p>
<p id="P70004970270000000000000000460CA" data-uri="chapter09.xhtml#P70004970270000000000000000460CA" class="pcalibre8 pcalibre1 pcalibre2">The sweep phase is a single call to the sweep function shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007591"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.51(b)</span></a>. The <code id="P70004970270000000000000000460CB" data-uri="chapter09.xhtml#P70004970270000000000000000460CB" class="pcalibre1 calibre1 pcalibre2">sweep</code> function iterates over each block in the heap, freeing any unmarked allocated blocks (i.e., garbage) that it encounters.</p>
<p id="P70004970270000000000000000460CC" data-uri="chapter09.xhtml#P70004970270000000000000000460CC" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000075C6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.52</span></a> shows a graphical interpretation of Mark&amp;Sweep for a small heap. Block boundaries are indicated by heavy lines. Each square corresponds to a word of memory. Each block has a one-word header, which is either marked or unmarked.</p>
<figure id="P70004970270000000000000000075C6" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000075C6">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000075C7" title="869" data-uri="chapter09.xhtml#P70004970270000000000000000075C7" epub:type="pagebreak"></span>
<img alt="A diagram illustrates mark&amp;sweep." id="P70004970270000000000000000460CD" data-uri="P700049702700000000000000000B7A9" src="../images/p869-1.png" class="pcalibre288 pcalibre1 pcalibre2"/>
<figcaption id="P70004970270000000000000000460CE" data-uri="chapter09.xhtml#P70004970270000000000000000460CE" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000460CF" data-uri="chapter09.xhtml#P70004970270000000000000000460CF" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.52 </span>Mark&amp;Sweep example.</h1></header><div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000460D0" data-uri="chapter09.xhtml#P70004970270000000000000000460D0"><p id="P70004970270000000000000000460D1" data-uri="chapter09.xhtml#P70004970270000000000000000460D1" class="pcalibre1 pcalibre2 pcalibre10">Note that the arrows in this example denote memory references, not free list pointers.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P700049702700000000000000002642B" data-uri="chapter09.xhtml#P700049702700000000000000002642B">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000460D2" data-uri="chapter09.xhtml#P70004970270000000000000000460D2" class="pcalibre8 pcalibre1 pcalibre2">A diagram of a mark&amp;sweep example has three rows of 16 blocks each, with arrows and labels summarized below.</p>
<ul id="P70004970270000000000000000460D3" data-uri="chapter09.xhtml#P70004970270000000000000000460D3" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000460D4" data-uri="chapter09.xhtml#P70004970270000000000000000460D4" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000460D5" data-uri="chapter09.xhtml#P70004970270000000000000000460D5" class="pcalibre1 pcalibre2 pcalibre10">Before mark: unmarked block headers 1 through 4 are separated by blank blocks, followed by the root block. Unmarked block header 5 is second from the root, followed by three blank blocks and unmarked block header 6. Arrows point from root to the end of block 3; from block before block 4 to end of block 1; from block after root to end of block 6</p></li>
<li id="P70004970270000000000000000460D6" data-uri="chapter09.xhtml#P70004970270000000000000000460D6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000460D7" data-uri="chapter09.xhtml#P70004970270000000000000000460D7" class="pcalibre1 pcalibre2 pcalibre10">After mark: blocks 1, 3, 4, and 6 are now marked block headers</p></li>
<li id="P70004970270000000000000000460D8" data-uri="chapter09.xhtml#P70004970270000000000000000460D8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000460D9" data-uri="chapter09.xhtml#P70004970270000000000000000460D9" class="pcalibre1 pcalibre2 pcalibre10">After sweep: the third and fourth blocks, as well as marked blocks 5 to 6 are now free unmarked block headers.</p></li>
</ul>
</details>
</figcaption>
</figure>
<figure id="P70004970270000000000000000075CD" class="pcalibre2 pcalibre32 pcalibre35" data-uri="chapter09.xhtml#P70004970270000000000000000075CD">
<img alt="A diagram shows an allocated block header followed by the remainder of the block. The allocated block header contains size, left and right, with an arrow from left labeled &lt; and an arrow from right labeled &gt;." id="P70004970270000000000000000460DA" data-uri="P700049702700000000000000000B7AA" src="../images/p869-2.png" class="pcalibre289 pcalibre2 pcalibre1"/>
<figcaption id="P70004970270000000000000000460DB" data-uri="chapter09.xhtml#P70004970270000000000000000460DB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000460DC" data-uri="chapter09.xhtml#P70004970270000000000000000460DC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">9.53 </span>Left and right pointers in a balanced tree of allocated blocks.</h1></header></figcaption>
</figure>
<p id="P70004970270000000000000000460DD" data-uri="chapter09.xhtml#P70004970270000000000000000460DD" class="pcalibre8 pcalibre1 pcalibre2">Initially, the heap in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000075C6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.52</span></a> consists of six allocated blocks, each of which is unmarked. Block 3 contains a pointer to block 1. Block 4 contains pointers to blocks 3 and 6. The root points to block 4. After the mark phase, blocks 1,3,4, and 6 are marked because they are reachable from the root. Blocks 2 and 5 are unmarked because they are unreachable. After the sweep phase, the two unreachable blocks are reclaimed to the free list.</p>
</section>
<section id="P70004970270000000000000000075D2" data-uri="chapter09.xhtml#P70004970270000000000000000075D2" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000460DE" data-uri="chapter09.xhtml#P70004970270000000000000000460DE" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.10.3 </span>Conservative Mark&amp;Sweep for C Programs</h1></header>
<p id="P70004970270000000000000000460DF" data-uri="chapter09.xhtml#P70004970270000000000000000460DF" class="pcalibre8 pcalibre1 pcalibre2">Mark&amp;Sweep is an appropriate approach for garbage collecting C programs because it works in place without moving any blocks. However, the C language poses some interesting challenges for the implementation of the <code id="P70004970270000000000000000460E0" data-uri="chapter09.xhtml#P70004970270000000000000000460E0" class="pcalibre1 calibre1 pcalibre2">isPtr</code> function.</p>
<p id="P70004970270000000000000000460E1" data-uri="chapter09.xhtml#P70004970270000000000000000460E1" class="pcalibre8 pcalibre1 pcalibre2">First, C does not tag memory locations with any type information. Thus, there is no obvious way for <code id="P70004970270000000000000000460E2" data-uri="chapter09.xhtml#P70004970270000000000000000460E2" class="pcalibre1 calibre1 pcalibre2">isPtr</code> to determine if its input parameter <code id="P70004970270000000000000000460E3" data-uri="chapter09.xhtml#P70004970270000000000000000460E3" class="pcalibre1 calibre1 pcalibre2">p</code> is a pointer or not. Second, even if we were to know that <code id="P70004970270000000000000000460E4" data-uri="chapter09.xhtml#P70004970270000000000000000460E4" class="pcalibre1 calibre1 pcalibre2">p</code> was a pointer, there would be no obvious way for <code id="P70004970270000000000000000460E5" data-uri="chapter09.xhtml#P70004970270000000000000000460E5" class="pcalibre1 calibre1 pcalibre2">isPtr</code> to determine whether <code id="P70004970270000000000000000460E6" data-uri="chapter09.xhtml#P70004970270000000000000000460E6" class="pcalibre1 calibre1 pcalibre2">p</code> points to some location in the payload of an allocated block.</p>
<p id="P70004970270000000000000000460E7" data-uri="chapter09.xhtml#P70004970270000000000000000460E7" class="pcalibre8 pcalibre1 pcalibre2">One solution to the latter problem is to maintain the set of allocated blocks as a balanced binary tree that maintains the invariant that all blocks in the left subtree are located at smaller addresses and all blocks in the right subtree are located in larger addresses. As shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000075CD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.53</span></a>, this requires two additional fields (<code id="P70004970270000000000000000460E8" data-uri="chapter09.xhtml#P70004970270000000000000000460E8" class="pcalibre1 calibre1 pcalibre2">left</code> and <code id="P70004970270000000000000000460E9" data-uri="chapter09.xhtml#P70004970270000000000000000460E9" class="pcalibre1 calibre1 pcalibre2">right</code>) in the header of each allocated block. Each field points to the header of some allocated block. The <code id="P70004970270000000000000000460EA" data-uri="chapter09.xhtml#P70004970270000000000000000460EA" class="pcalibre1 calibre1 pcalibre2">isPtr (ptr p)</code> function uses the tree to perform a binary search of the allocated blocks. At each step, it relies on the size field in the block header to determine if <code id="P70004970270000000000000000460EB" data-uri="chapter09.xhtml#P70004970270000000000000000460EB" class="pcalibre1 calibre1 pcalibre2">p</code> falls within the extent of the block.</p>
<p id="P70004970270000000000000000460EC" data-uri="chapter09.xhtml#P70004970270000000000000000460EC" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000075E2" title="870" data-uri="chapter09.xhtml#P70004970270000000000000000075E2" epub:type="pagebreak"></span>The balanced tree approach is correct in the sense that it is guaranteed to mark all of the nodes that are reachable from the roots. This is a necessary guarantee, as application users would certainly not appreciate having their allocated blocks prematurely returned to the free list. However, it is conservative in the sense that it may incorrectly mark blocks that are actually unreachable, and thus it may fail to free some garbage. While this does not affect the correctness of application programs, it can result in unnecessary external fragmentation.</p>
<p id="P70004970270000000000000000460ED" data-uri="chapter09.xhtml#P70004970270000000000000000460ED" class="pcalibre8 pcalibre1 pcalibre2">The fundamental reason that Mark&amp;Sweep collectors for C programs must be conservative is that the C language does not tag memory locations with type information. Thus, scalars like <code id="P70004970270000000000000000460EE" data-uri="chapter09.xhtml#P70004970270000000000000000460EE" class="pcalibre1 calibre1 pcalibre2">ints</code> or <code id="P70004970270000000000000000460EF" data-uri="chapter09.xhtml#P70004970270000000000000000460EF" class="pcalibre1 calibre1 pcalibre2">floats</code> can masquerade as pointers. For example, suppose that some reachable allocated block contains an <code id="P70004970270000000000000000460F0" data-uri="chapter09.xhtml#P70004970270000000000000000460F0" class="pcalibre1 calibre1 pcalibre2">int</code> in its payload whose value happens to correspond to an address in the payload of some other allocated block <i class="pcalibre17 pcalibre2 pcalibre1">b.</i> There is no way for the collector to infer that the data is really an <code id="P70004970270000000000000000460F1" data-uri="chapter09.xhtml#P70004970270000000000000000460F1" class="pcalibre1 calibre1 pcalibre2">int</code> and not a pointer. Therefore, the allocator must conservatively mark block <var class="pcalibre17 pcalibre2 pcalibre1">b</var> as reachable, when in fact it might not be.</p>
</section>
</section></body></html>
