<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>11.6 Putting It Together: The Tiny Web Server</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000007F64" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000046AA2" data-uri="chapter11.xhtml#P7000497027000000000000000046AA2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">11.6 </span>Putting It Together: The T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>Web Server</h1></header>
<p id="P7000497027000000000000000046AA3" data-uri="chapter11.xhtml#P7000497027000000000000000046AA3" class="pcalibre8 pcalibre1 pcalibre2">We conclude our discussion of network programming by developing a small but functioning Web server called T<span class="pcalibre1 pcalibre29 pcalibre2">iny</span>. T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>is an interesting program. It combines many of the ideas that we have learned about, such as process control, Unix I/O, the sockets interface, and HTTP, in only 250 lines of code. While it lacks the functionality, robustness, and security of a real server, it is powerful enough to serve both static and dynamic content to real Web browsers. We encourage you to study it and implement it yourself. It is quite exciting (even for the authors!) to point a real browser at your own server and watch it display a complicated Web page with text and graphics.</p>
<section id="P7000497027000000000000000007F67" data-uri="chapter11.xhtml#P7000497027000000000000000007F67" class="pcalibre1 pcalibre2 pcalibre3">
<section id="P7000497027000000000000000007F68" data-uri="chapter11.xhtml#P7000497027000000000000000007F68" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046AA4" data-uri="chapter11.xhtml#P7000497027000000000000000046AA4" epub:type="title">The T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span><code id="P7000497027000000000000000046AA5" data-uri="chapter11.xhtml#P7000497027000000000000000046AA5" class="pcalibre1 pcalibre2 calibre16">main</code> Routine</h1></header>
<p id="P7000497027000000000000000046AA6" data-uri="chapter11.xhtml#P7000497027000000000000000046AA6" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007F74"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.29</span></a> shows T<span class="pcalibre1 pcalibre29 pcalibre2">iny's </span>main routine. T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>is an iterative server that listens for connection requests on the port that is passed in the command line. After opening a listening socket by calling the <code id="P7000497027000000000000000046AA7" data-uri="chapter11.xhtml#P7000497027000000000000000046AA7" class="pcalibre1 calibre1 pcalibre2">open_listenfd</code> function, T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>executes the typical infinite server loop, repeatedly accepting a connection request (line 32), performing a transaction (line 36), and closing its end of the connection (line 37).</p>
</section>
<section id="P7000497027000000000000000007F6D" data-uri="chapter11.xhtml#P7000497027000000000000000007F6D" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046AA8" data-uri="chapter11.xhtml#P7000497027000000000000000046AA8" epub:type="title">The <code id="P7000497027000000000000000046AA9" data-uri="chapter11.xhtml#P7000497027000000000000000046AA9" class="pcalibre1 pcalibre2 calibre16">doit</code> Function</h1></header>
<p id="P7000497027000000000000000046AAA" data-uri="chapter11.xhtml#P7000497027000000000000000046AAA" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046AAB" data-uri="chapter11.xhtml#P7000497027000000000000000046AAB" class="pcalibre1 calibre1 pcalibre2">doit</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007F7A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.30</span></a> handles one HTTP transaction. First, we read and parse the request line (lines 11−14). Notice that we are using the <code id="P7000497027000000000000000046AAC" data-uri="chapter11.xhtml#P7000497027000000000000000046AAC" class="pcalibre1 calibre1 pcalibre2">rio_readlineb</code> function from Figure <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007975.xhtml#P70004970270000000000000000079F7"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">10.8</span></a> to read the request line.</p>
<p id="P7000497027000000000000000046AAD" data-uri="chapter11.xhtml#P7000497027000000000000000046AAD" class="pcalibre8 pcalibre1 pcalibre2">T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>supports only the GET method. If the client requests another method (such as POST), we send it an error message and return to the main routine</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007F74" data-uri="chapter11.xhtml#P7000497027000000000000000007F74">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007F75" title="957" data-uri="chapter11.xhtml#P7000497027000000000000000007F75" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046AAE" data-uri="chapter11.xhtml#P7000497027000000000000000046AAE" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046AAF" data-uri="chapter11.xhtml#P7000497027000000000000000046AAF" class="calibre3 pcalibre1 pcalibre2">
1	/*
2	* tiny.c - A simple, iterative HTTP/1.0 Web server that uses the
3	* GET method to serve static and dynamic content
4	*/
5	#include "csapp.h"
6	
7	void doit(int fd);
8	void read_requesthdrs(rio_t *rp);
9	int parse_uri(char *uri, char *filename, char *cgiargs);
10	void serve_static(int fd, char *filename, int filesize);
11	void get_filetype(char *filename, char *filetype);
12	void serve_dynamic(int fd, char *filename, char *cgiargs);
13	void clienterror(int fd, char *cause, char *errnum,
14	char *shortmsg, char *longmsg);
15	
16	int main(int argc, char **argv)
17	{
18	int listenfd, connfd;
19	char hostname[MAXLINE], port[MAXLINE];
20	socklen_t clientlen;
21	struct sockaddr_storage clientaddr;
22	
23	/* Check command-line args */
24	if (argc != 2) {
25	fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
26	exit(1);
27	}
28	
29	listenfd = Open_listenfd(argv[1]);
30	while (1) {
31	clientlen = sizeof(clientaddr);
32	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
33	Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE,
34	port, MAXLINE, 0);
35	printf("Accepted connection from (%s, %s)\n", hostname, port);
36	doit(connfd);
37	Close(connfd);
38	}
39	}
</code></pre>
<figcaption id="P7000497027000000000000000046AB0" data-uri="chapter11.xhtml#P7000497027000000000000000046AB0" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046AB1" data-uri="chapter11.xhtml#P7000497027000000000000000046AB1" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.29 </span>The T<span class="pcalibre1 pcalibre2 pcalibre84">iny </span>Web server.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007F7A" data-uri="chapter11.xhtml#P7000497027000000000000000007F7A">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007F7B" title="958" data-uri="chapter11.xhtml#P7000497027000000000000000007F7B" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046AB2" data-uri="chapter11.xhtml#P7000497027000000000000000046AB2" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046AB3" data-uri="chapter11.xhtml#P7000497027000000000000000046AB3" class="calibre3 pcalibre1 pcalibre2">
1	void doit(int fd)
2	{
3	int is_static;
4	struct stat sbuf;
5	char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
6	char filename[MAXLINE], cgiargs[MAXLINE];
7	rio_t rio;
8
9	/* Read request line and headers */
10	Rio_readinitb(&amp;rio, fd);
11	Rio_readlineb(&amp;rio, buf, MAXLINE);
12	printf("Request headers:\n");
13	printf("%s", buf);
14	sscanf(buf, "%s %s %s", method, uri, version);
15	if (strcasecmp(method, "GET")) {
16	clienterror(fd, method, "501", "Not implemented",
17	"Tiny does not implement this method");
18	return;
19	}
20	read_requesthdrs(&amp;rio);
21	
22	/* Parse URI from GET request */
23	is_static = parse_uri(uri, filename, cgiargs);
24	if (stat(filename, &amp;sbuf) &lt; 0) {
25	clienterror(fd, filename, "404", "Not found",
26	"Tiny couldn't find this file");
27	return;
28	}
29	
30	if (is_static) { /* Serve static content */
31	if (!(S_ISREG(sbuf.st_mode))	|	| !(S_IRUSR &amp; sbuf.st_mode)) {
32	clienterror(fd, filename, "403", "Forbidden",
33	"Tiny couldn't read the file");
34	return;
35	}
36	serve_static(fd, filename, sbuf.st_size);
37	}
38	else { /* Serve dynamic content */
39	if (!(S_ISREG(sbuf.st_mode))	|	| !(S_IXUSR &amp; sbuf.st_mode)) {
40	clienterror(fd, filename, "403", "Forbidden",
41	"Tiny couldn't run the CGI program");
42	return;
43	}
44	serve_dynamic(fd, filename, cgiargs);
45	}
46	}
</code></pre>
<figcaption id="P7000497027000000000000000046AB4" data-uri="chapter11.xhtml#P7000497027000000000000000046AB4" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046AB5" data-uri="chapter11.xhtml#P7000497027000000000000000046AB5" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.30 </span><code id="P7000497027000000000000000046AB6" data-uri="chapter11.xhtml#P7000497027000000000000000046AB6" class="pcalibre1 calibre1 pcalibre2">T<span class="pcalibre1 pcalibre2 pcalibre84">iny </span>doit</code> handles one HTTP transaction.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046AB7" data-uri="chapter11.xhtml#P7000497027000000000000000046AB7"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007F82" title="959" data-uri="chapter11.xhtml#P7000497027000000000000000007F82" epub:type="pagebreak"></span>(lines 15−19), which then closes the connection and awaits the next connection request. Otherwise, we read and (as we shall see) ignore any request headers (line 20).</p>
<p id="P7000497027000000000000000046AB8" data-uri="chapter11.xhtml#P7000497027000000000000000046AB8" class="pcalibre8 pcalibre1 pcalibre2">Next, we parse the URI into a filename and a possibly empty CGI argument string, and we set a flag that indicates whether the request is for static or dynamic content (line 23). If the file does not exist on disk, we immediately send an error message to the client and return.</p>
<p id="P7000497027000000000000000046AB9" data-uri="chapter11.xhtml#P7000497027000000000000000046AB9" class="pcalibre8 pcalibre1 pcalibre2">Finally, if the request is for static content, we verify that the file is a regular file and that we have read permission (line 31). If so, we serve the static content (line 36) to the client. Similarly, if the request is for dynamic content, we verify that the file is executable (line 39), and, if so, we go ahead and serve the dynamic content (line 44).</p>
</section>
<section id="P7000497027000000000000000007F85" data-uri="chapter11.xhtml#P7000497027000000000000000007F85" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046ABA" data-uri="chapter11.xhtml#P7000497027000000000000000046ABA" epub:type="title">The <code id="P7000497027000000000000000046ABB" data-uri="chapter11.xhtml#P7000497027000000000000000046ABB" class="pcalibre1 pcalibre2 calibre16">clienterror</code> Function</h1></header>
<p id="P7000497027000000000000000046ABC" data-uri="chapter11.xhtml#P7000497027000000000000000046ABC" class="pcalibre8 pcalibre1 pcalibre2">T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>lacks many of the error-handling features of a real server. However, it does check for some obvious errors and reports them to the client. The <code id="P7000497027000000000000000046ABD" data-uri="chapter11.xhtml#P7000497027000000000000000046ABD" class="pcalibre1 calibre1 pcalibre2">clienterror</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007F8A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.31</span></a> sends an HTTP response to the client with the appropriate</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007F8A" data-uri="chapter11.xhtml#P7000497027000000000000000007F8A">
<pre id="P7000497027000000000000000046ABE" data-uri="chapter11.xhtml#P7000497027000000000000000046ABE" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046ABF" data-uri="chapter11.xhtml#P7000497027000000000000000046ABF" class="calibre3 pcalibre1 pcalibre2">
1	void clienterror(int fd, char *cause, char *errnum,
2			char *shortmsg, char *longmsg)
3	{
4		char buf[MAXLINE], body[MAXBUF];
5	
6		/* Build the HTTP response body */
7		sprintf(body, "&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;");
8		sprintf(body, "%s&lt;body bgcolor=""ffffff""&gt;\r\n", body);
9		sprintf(body, "%s%s: %s\r\n", body, errnum, shortmsg);
10		sprintf(body, "%s&lt;p&gt;%s: %s\r\n", body, longmsg, cause);
11		sprintf(body, "%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n", body);
12	
13		/* Print the HTTP response */
14		sprintf(buf, "HTTP/1.0 %s %s\r\n", errnum, shortmsg);
15		Rio_writen(fd, buf, strlen(buf));
16		sprintf(buf, "Content-type: text/html\r\n");
17		Rio_writen(fd, buf, strlen(buf));
18		sprintf(buf, "Content-length: %d\r\n\r\n", (int)strlen(body));
19		Rio_writen(fd, buf, strlen(buf));
20		Rio_writen(fd, body, strlen(body));
21	}
</code></pre>
<figcaption id="P7000497027000000000000000046AC0" data-uri="chapter11.xhtml#P7000497027000000000000000046AC0" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046AC1" data-uri="chapter11.xhtml#P7000497027000000000000000046AC1" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.31 </span><code id="P7000497027000000000000000046AC2" data-uri="chapter11.xhtml#P7000497027000000000000000046AC2" class="pcalibre1 calibre1 pcalibre2">T<span class="pcalibre1 pcalibre2 pcalibre84">iny </span>clienterror</code> sends an error message to the client.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007F90" data-uri="chapter11.xhtml#P7000497027000000000000000007F90">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007F91" title="960" data-uri="chapter11.xhtml#P7000497027000000000000000007F91" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046AC3" data-uri="chapter11.xhtml#P7000497027000000000000000046AC3" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046AC4" data-uri="chapter11.xhtml#P7000497027000000000000000046AC4" class="calibre3 pcalibre1 pcalibre2">
1	void read_requesthdrs(rio_t *rp)
2	{
3		char buf[MAXLINE];
4
5		Rio_readlineb(rp, buf, MAXLINE);
6		while(strcmp(buf, "\r\n")) {
7			Rio_readlineb(rp, buf, MAXLINE);
8			printf("%s", buf);
9		}
10		return;
11	}
</code></pre>
<figcaption id="P7000497027000000000000000046AC5" data-uri="chapter11.xhtml#P7000497027000000000000000046AC5" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046AC6" data-uri="chapter11.xhtml#P7000497027000000000000000046AC6" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.32 </span><code id="P7000497027000000000000000046AC7" data-uri="chapter11.xhtml#P7000497027000000000000000046AC7" class="pcalibre1 calibre1 pcalibre2">T<span class="pcalibre1 pcalibre2 pcalibre84">iny </span>read_requesthdrs</code> reads and ignores request headers.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000046AC8" data-uri="chapter11.xhtml#P7000497027000000000000000046AC8"><p id="P7000497027000000000000000046AC9" data-uri="chapter11.xhtml#P7000497027000000000000000046AC9" class="pcalibre1 pcalibre2 pcalibre10"></p></div></figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046ACA" data-uri="chapter11.xhtml#P7000497027000000000000000046ACA">status code and status message in the response line, along with an HTML file in the response body that explains the error to the browser's user.</p>
<p id="P7000497027000000000000000046ACB" data-uri="chapter11.xhtml#P7000497027000000000000000046ACB" class="pcalibre8 pcalibre1 pcalibre2">Recall that an HTML response should indicate the size and type of the content in the body. Thus, we have opted to build the HTML content as a single string so that we can easily determine its size. Also, notice that we are using the robust <code id="P7000497027000000000000000046ACC" data-uri="chapter11.xhtml#P7000497027000000000000000046ACC" class="pcalibre1 calibre1 pcalibre2">rio_writen</code> function from <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007975.xhtml#P70004970270000000000000000079BE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">10.4</span></a> for all output.</p>
</section>
<section id="P7000497027000000000000000007F9C" data-uri="chapter11.xhtml#P7000497027000000000000000007F9C" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046ACD" data-uri="chapter11.xhtml#P7000497027000000000000000046ACD" epub:type="title">The <code id="P7000497027000000000000000046ACE" data-uri="chapter11.xhtml#P7000497027000000000000000046ACE" class="pcalibre1 pcalibre2 calibre16">read_requesthdrs</code> Function</h1></header>
<p id="P7000497027000000000000000046ACF" data-uri="chapter11.xhtml#P7000497027000000000000000046ACF" class="pcalibre8 pcalibre1 pcalibre2">T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>does not use any of the information in the request headers. It simply reads and ignores them by calling the <code id="P7000497027000000000000000046AD0" data-uri="chapter11.xhtml#P7000497027000000000000000046AD0" class="pcalibre1 calibre1 pcalibre2">read_requesthdrs</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007F90"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.32</span></a>. Notice that the empty text line that terminates the request headers consists of a carriage return and line feed pair, which we check for in line 6.</p>
</section>
<section id="P7000497027000000000000000007FA1" data-uri="chapter11.xhtml#P7000497027000000000000000007FA1" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046AD1" data-uri="chapter11.xhtml#P7000497027000000000000000046AD1" epub:type="title">The <code id="P7000497027000000000000000046AD2" data-uri="chapter11.xhtml#P7000497027000000000000000046AD2" class="pcalibre1 pcalibre2 calibre16">parse_uri</code> Function</h1></header>
<p id="P7000497027000000000000000046AD3" data-uri="chapter11.xhtml#P7000497027000000000000000046AD3" class="pcalibre8 pcalibre1 pcalibre2">T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>assumes that the home directory for static content is its current directory and that the home directory for executables is <code id="P7000497027000000000000000046AD4" data-uri="chapter11.xhtml#P7000497027000000000000000046AD4" class="pcalibre1 calibre1 pcalibre2">./cgi-bin</code>. Any URI that contains the string <code id="P7000497027000000000000000046AD5" data-uri="chapter11.xhtml#P7000497027000000000000000046AD5" class="pcalibre1 calibre1 pcalibre2">cgi-bin</code> is assumed to denote a request for dynamic content. The default filename is <code id="P7000497027000000000000000046AD6" data-uri="chapter11.xhtml#P7000497027000000000000000046AD6" class="pcalibre1 calibre1 pcalibre2">./home.html</code>.</p>
<p id="P7000497027000000000000000046AD7" data-uri="chapter11.xhtml#P7000497027000000000000000046AD7" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046AD8" data-uri="chapter11.xhtml#P7000497027000000000000000046AD8" class="pcalibre1 calibre1 pcalibre2">parse_uri</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007FAB"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.33</span></a> implements these policies. It parses the URI into a filename and an optional CGI argument string. If the request is for static content (line 5), we clear the CGI argument string (line 6) and then convert the URI into a relative Linux pathname such as <code id="P7000497027000000000000000046AD9" data-uri="chapter11.xhtml#P7000497027000000000000000046AD9" class="pcalibre1 calibre1 pcalibre2">./index.html</code> (lines 7−8). If the URI ends with a `/' character (line 9), then we append the default filename (line 10). On the other hand, if the request is for dynamic content (line 13), we extract any CGI arguments (lines 14−20) and convert the remaining portion of the URI to a relative Linux filename (lines 21−22).</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007FAB" data-uri="chapter11.xhtml#P7000497027000000000000000007FAB">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007FAC" title="961" data-uri="chapter11.xhtml#P7000497027000000000000000007FAC" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046ADA" data-uri="chapter11.xhtml#P7000497027000000000000000046ADA" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046ADB" data-uri="chapter11.xhtml#P7000497027000000000000000046ADB" class="calibre3 pcalibre1 pcalibre2">
1	int parse_uri(char *uri, char *filename, char *cgiargs)
2	{
3		char *ptr;
4	
5		if (!strstr(uri, "cgi-bin")) { /* Static content */
6			strcpy(cgiargs, "");
7			strcpy(filename, ".");
8			strcat(filename, uri);
9			if (uri[strlen(uri)-1] == `/')
10				strcat(filename, "home.html");
11			return 1;
12		}
13		else { /* Dynamic content */
14			ptr = index(uri, `?');
15			if (ptr) {
16				strcpy(cgiargs, ptr+1);
17				*ptr = `\0';
18			}
19			else
20				strcpy(cgiargs, "");
21			strcpy(filename, ".");
22			strcat(filename, uri);
23			return 0;
24		}
25	}
</code></pre>
<figcaption id="P7000497027000000000000000046ADC" data-uri="chapter11.xhtml#P7000497027000000000000000046ADC" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046ADD" data-uri="chapter11.xhtml#P7000497027000000000000000046ADD" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.33 </span>T<span class="pcalibre1 pcalibre2 pcalibre84">iny </span>parse_uri parses an HTTP URI.</h1></header>
</figcaption>
</figure>
</section>
<section id="P7000497027000000000000000007FB1" data-uri="chapter11.xhtml#P7000497027000000000000000007FB1" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046ADE" data-uri="chapter11.xhtml#P7000497027000000000000000046ADE" epub:type="title">The <code id="P7000497027000000000000000046ADF" data-uri="chapter11.xhtml#P7000497027000000000000000046ADF" class="pcalibre1 pcalibre2 calibre16">serve_static</code> Function</h1></header>
<p id="P7000497027000000000000000046AE0" data-uri="chapter11.xhtml#P7000497027000000000000000046AE0" class="pcalibre8 pcalibre1 pcalibre2">T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>serves five common types of static content: HTML files, unformatted text files, and images encoded in GIF, PNG, and JPEG formats.</p>
<p id="P7000497027000000000000000046AE1" data-uri="chapter11.xhtml#P7000497027000000000000000046AE1" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046AE2" data-uri="chapter11.xhtml#P7000497027000000000000000046AE2" class="pcalibre1 calibre1 pcalibre2">serve_static</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007FBD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.34</span></a> sends an HTTP response whose body contains the contents of a local file. First, we determine the file type by inspecting the suffix in the filename (line 7) and then send the response line and response headers to the client (lines 8−13). Notice that a blank line terminates the headers.</p>
<p id="P7000497027000000000000000046AE3" data-uri="chapter11.xhtml#P7000497027000000000000000046AE3" class="pcalibre8 pcalibre1 pcalibre2">Next, we send the response body by copying the contents of the requested file to the connected descriptor <code id="P7000497027000000000000000046AE4" data-uri="chapter11.xhtml#P7000497027000000000000000046AE4" class="pcalibre1 calibre1 pcalibre2">fd</code>. The code here is somewhat subtle and needs to be studied carefully. Line 18 opens <code id="P7000497027000000000000000046AE5" data-uri="chapter11.xhtml#P7000497027000000000000000046AE5" class="pcalibre1 calibre1 pcalibre2">filename</code> for reading and gets its descriptor. In line 19, the Linux <code id="P7000497027000000000000000046AE6" data-uri="chapter11.xhtml#P7000497027000000000000000046AE6" class="pcalibre1 calibre1 pcalibre2">mmap</code> function maps the requested file to a virtual memory area. Recall from our discussion of <code id="P7000497027000000000000000046AE7" data-uri="chapter11.xhtml#P7000497027000000000000000046AE7" class="pcalibre1 calibre1 pcalibre2">mmap</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000072B5.xhtml#P70004970270000000000000000072B5"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">9.8</span></a> that the call to <code id="P7000497027000000000000000046AE8" data-uri="chapter11.xhtml#P7000497027000000000000000046AE8" class="pcalibre1 calibre1 pcalibre2">mmap</code> maps the</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007FBD" data-uri="chapter11.xhtml#P7000497027000000000000000007FBD">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007FBE" title="962" data-uri="chapter11.xhtml#P7000497027000000000000000007FBE" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046AE9" data-uri="chapter11.xhtml#P7000497027000000000000000046AE9" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046AEA" data-uri="chapter11.xhtml#P7000497027000000000000000046AEA" class="calibre3 pcalibre1 pcalibre2">
1	void serve_static(int fd, char *filename, int filesize)
2	{
3		int srcfd;
4		char *srcp, filetype[MAXLINE], buf[MAXBUF];
5	
6		/* Send response headers to client */
7		get_filetype(filename, filetype);
8		sprintf(buf, "HTTP/1.0 200 OK\r\n");
9		sprintf(buf, "%sServer: Tiny Web Server\r\n", buf);
10		sprintf(buf, "%sConnection: close\r\n", buf);
11		sprintf(buf, "%sContent-length: %d\r\n", buf, filesize);
12		sprintf(buf, "%sContent-type: %s\r\n\r\n", buf, filetype);
13		Rio_writen(fd, buf, strlen(buf));
14		printf("Response headers:\n");
15		printf("%s", buf);
16	
17		/* Send response body to client */
18		srcfd = Open(filename, O_RDONLY, 0);
19		srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);
20		Close(srcfd);
21		Rio_writen(fd, srcp, filesize);
22		Munmap(srcp, filesize);
23	}
24	
25	/*
26	* get_filetype - Derive file type from filename
27	*/
28	void get_filetype(char *filename, char *filetype)
29	{
30		if (strstr(filename, ".html"))
31			strcpy(filetype, "text/html");
32		else if (strstr(filename, ".gif"))
33			strcpy(filetype, "image/gif");
34		else if (strstr(filename, ".png"))
35			strcpy(filetype, "image/png");
36		else if (strstr(filename, ".jpg"))
37			strcpy(filetype, "image/jpeg");
38		else
39			strcpy(filetype, "text/plain");
40	}
</code></pre>
<figcaption id="P7000497027000000000000000046AEB" data-uri="chapter11.xhtml#P7000497027000000000000000046AEB" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046AEC" data-uri="chapter11.xhtml#P7000497027000000000000000046AEC" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.34 </span>T<span class="pcalibre1 pcalibre2 pcalibre84">iny </span>serve_static serves static content to a client.</h1></header>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046AED" data-uri="chapter11.xhtml#P7000497027000000000000000046AED"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007FC4" title="963" data-uri="chapter11.xhtml#P7000497027000000000000000007FC4" epub:type="pagebreak"></span>first <code id="P7000497027000000000000000046AEE" data-uri="chapter11.xhtml#P7000497027000000000000000046AEE" class="pcalibre1 calibre1 pcalibre2">filesize</code> bytes of file <code id="P7000497027000000000000000046AEF" data-uri="chapter11.xhtml#P7000497027000000000000000046AEF" class="pcalibre1 calibre1 pcalibre2">srcfd</code> to a private read-only area of virtual memory that starts at address <code id="P7000497027000000000000000046AF0" data-uri="chapter11.xhtml#P7000497027000000000000000046AF0" class="pcalibre1 calibre1 pcalibre2">srcp</code>.</p>
<p id="P7000497027000000000000000046AF1" data-uri="chapter11.xhtml#P7000497027000000000000000046AF1" class="pcalibre8 pcalibre1 pcalibre2">Once we have mapped the file to memory, we no longer need its descriptor, so we close the file (line 20). Failing to do this would introduce a potentially fatal memory leak. Line 21 performs the actual transfer of the file to the client. The <code id="P7000497027000000000000000046AF2" data-uri="chapter11.xhtml#P7000497027000000000000000046AF2" class="pcalibre1 calibre1 pcalibre2">rio_writen</code> function copies the <code id="P7000497027000000000000000046AF3" data-uri="chapter11.xhtml#P7000497027000000000000000046AF3" class="pcalibre1 calibre1 pcalibre2">filesize</code> bytes starting at location <code id="P7000497027000000000000000046AF4" data-uri="chapter11.xhtml#P7000497027000000000000000046AF4" class="pcalibre1 calibre1 pcalibre2">srcp</code> (which of course is mapped to the requested file) to the client's connected descriptor. Finally, line 22 frees the mapped virtual memory area. This is important to avoid a potentially fatal memory leak.</p>
</section>
<section id="P7000497027000000000000000007FCC" data-uri="chapter11.xhtml#P7000497027000000000000000007FCC" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000046AF5" data-uri="chapter11.xhtml#P7000497027000000000000000046AF5" epub:type="title">The <code id="P7000497027000000000000000046AF6" data-uri="chapter11.xhtml#P7000497027000000000000000046AF6" class="pcalibre1 pcalibre2 calibre16">serve_dynamic</code> Function</h1></header>
<p id="P7000497027000000000000000046AF7" data-uri="chapter11.xhtml#P7000497027000000000000000046AF7" class="pcalibre8 pcalibre1 pcalibre2">T<span class="pcalibre1 pcalibre29 pcalibre2">iny </span>serves any type of dynamic content by forking a child process and then running a CGI program in the context of the child.</p>
<p id="P7000497027000000000000000046AF8" data-uri="chapter11.xhtml#P7000497027000000000000000046AF8" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000046AF9" data-uri="chapter11.xhtml#P7000497027000000000000000046AF9" class="pcalibre1 calibre1 pcalibre2">serve_dynamic</code> function in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000007FD4"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.35</span></a> begins by sending a response line indicating success to the client, along with an informational <code id="P7000497027000000000000000046AFA" data-uri="chapter11.xhtml#P7000497027000000000000000046AFA" class="pcalibre1 calibre1 pcalibre2">Server</code> header. The CGI program is responsible for sending the rest of the response. Notice that this is not as robust as we might wish, since it doesn't allow for the possibility that the CGI program might encounter some error.</p>
<p id="P7000497027000000000000000046AFB" data-uri="chapter11.xhtml#P7000497027000000000000000046AFB" class="pcalibre8 pcalibre1 pcalibre2">After sending the first part of the response, we fork a new child process (line 11). The child initializes the QUERY_STRING environment variable with the CGI arguments from the request URI (line 13). Notice that a real server would</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000007FD4" data-uri="chapter11.xhtml#P7000497027000000000000000007FD4">
<pre id="P7000497027000000000000000046AFC" data-uri="chapter11.xhtml#P7000497027000000000000000046AFC" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000046AFD" data-uri="chapter11.xhtml#P7000497027000000000000000046AFD" class="calibre3 pcalibre1 pcalibre2">
1	void serve_dynamic(int fd, char *filename, char *cgiargs)
2	{
3		char buf[MAXLINE], *emptylist[] = { NULL };
4	
5		/* Return first part of HTTP response */
6		sprintf(buf, "HTTP/1.0 200 OK\r\n");
7		Rio_writen(fd, buf, strlen(buf));
8		sprintf(buf, "Server: Tiny Web Server\r\n");
9		Rio_writen(fd, buf, strlen(buf));
10	
11		if (Fork() == 0) { /* Child */
12			/* Real server would set all CGI vars here */
13			setenv("QUERY_STRING", cgiargs, 1);
14			Dup2(fd, STDOUT_FILENO); /* Redirect stdout to client */
15			Execve(filename, emptylist, environ); /* Run CGI program */
16		}
17		Wait(NULL); /* Parent waits for and reaps child */
18	}
</code></pre>
<figcaption id="P7000497027000000000000000046AFE" data-uri="chapter11.xhtml#P7000497027000000000000000046AFE" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000046AFF" data-uri="chapter11.xhtml#P7000497027000000000000000046AFF" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">11.35 </span>T<span class="pcalibre1 pcalibre2 pcalibre84">iny </span>serve_dynamic serves dynamic content to a client.</h1></header>
</figcaption>
</figure>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000007FD9" data-uri="chapter11.xhtml#P7000497027000000000000000007FD9"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000046B00" data-uri="chapter11.xhtml#P7000497027000000000000000046B00" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000007FDB" title="964" data-uri="chapter11.xhtml#P7000497027000000000000000007FDB" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Dealing with prematurely closed connections</h1></header>
<p id="P7000497027000000000000000046B01" data-uri="chapter11.xhtml#P7000497027000000000000000046B01" class="pcalibre1 pcalibre2 pcalibre10">Although the basic functions of a Web server are quite simple, we don't want to give you the false impression that writing a real Web server is easy. Building a robust Web server that runs for extended periods without crashing is a difficult task that requires a deeper understanding of Linux systems programming than we've learned here. For example, if a server writes to a connection that has already been closed by the client (say, because you clicked the "Stop" button on your browser), then the first such write returns normally, but the second write causes the delivery of a SIGPIPE signal whose default behavior is to terminate the process. If the SIGPIPE signal is caught or ignored, then the second write operation returns −1 with <code id="P7000497027000000000000000046B02" data-uri="chapter11.xhtml#P7000497027000000000000000046B02" class="pcalibre1 calibre1 pcalibre2">errno</code> set to EPIPE. The <code id="P7000497027000000000000000046B03" data-uri="chapter11.xhtml#P7000497027000000000000000046B03" class="pcalibre1 calibre1 pcalibre2">strerr</code> and <code id="P7000497027000000000000000046B04" data-uri="chapter11.xhtml#P7000497027000000000000000046B04" class="pcalibre1 calibre1 pcalibre2">perror</code> functions report the EPIPE error as a "Broken pipe," a nonintuitive message that has confused generations of students. The bottom line is that a robust server must catch these SIGPIPE signals and check <code id="P7000497027000000000000000046B05" data-uri="chapter11.xhtml#P7000497027000000000000000046B05" class="pcalibre1 calibre1 pcalibre2">write</code> function calls for EPIPE errors.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000046B06" data-uri="chapter11.xhtml#P7000497027000000000000000046B06">set the other CGI environment variables here as well. For brevity, we have omitted this step.</p>
<p id="P7000497027000000000000000046B07" data-uri="chapter11.xhtml#P7000497027000000000000000046B07" class="pcalibre8 pcalibre1 pcalibre2">Next, the child redirects the child's standard output to the connected file descriptor (line 14) and then loads and runs the CGI program (line 15). Since the CGI program runs in the context of the child, it has access to the same open files and environment variables that existed before the call to the <code id="P7000497027000000000000000046B08" data-uri="chapter11.xhtml#P7000497027000000000000000046B08" class="pcalibre1 calibre1 pcalibre2">execve</code> function. Thus, everything that the CGI program writes to standard output goes directly to the client process, without any intervention from the parent process. Meanwhile, the parent blocks in a call to <code id="P7000497027000000000000000046B09" data-uri="chapter11.xhtml#P7000497027000000000000000046B09" class="pcalibre1 calibre1 pcalibre2">wait</code>, waiting to reap the child when it terminates (line 17).</p>
</section>
</section>
</section></body></html>
