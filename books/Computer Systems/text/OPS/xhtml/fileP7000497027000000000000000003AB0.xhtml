<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>4.1 The Y86-64 Instruction Set Architecture</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000003AB0" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000041C67" data-uri="chapter04.xhtml#P7000497027000000000000000041C67" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.1 </span>The Y86-64 Instruction Set Architecture</h1></header>
<p id="P7000497027000000000000000041C68" data-uri="chapter04.xhtml#P7000497027000000000000000041C68" class="pcalibre8 pcalibre1 pcalibre2">Defining an instruction set architecture, such as Y86-64, includes defining the different components of its state, the set of instructions and their encodings, a set of programming conventions, and the handling of exceptional events.</p>
<section id="P7000497027000000000000000003AB3" data-uri="chapter04.xhtml#P7000497027000000000000000003AB3" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041C69" data-uri="chapter04.xhtml#P7000497027000000000000000041C69" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.1.1 </span>Programmer-Visible State</h1></header>
<p id="P7000497027000000000000000041C6A" data-uri="chapter04.xhtml#P7000497027000000000000000041C6A" class="pcalibre8 pcalibre1 pcalibre2">As <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ABC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.1</span></a> illustrates, each instruction in a Y86-64 program can read and modify some part of the processor state. This is referred to as the <i class="pcalibre17 pcalibre2 pcalibre1">programmer-visible</i> state, where the "programmer" in this case is either someone writing programs in assembly code or a compiler generating machine-level code. We will see in our processor implementations that we do not need to represent and organize this state in exactly the manner implied by the ISA, as long as we can make sure that machine-level programs appear to have access to the programmer-visible state. The state for Y86-64 is similar to that for x86-64. There are 15 <i class="pcalibre17 pcalibre2 pcalibre1">program registers:</i> <code id="P7000497027000000000000000041C6B" data-uri="chapter04.xhtml#P7000497027000000000000000041C6B" class="pcalibre1 calibre1 pcalibre2">%rax, %rcx, %rdx, %rbx, %rsp, %rbp, %rsi, %rdi, and %r8</code> through <code id="P7000497027000000000000000041C6C" data-uri="chapter04.xhtml#P7000497027000000000000000041C6C" class="pcalibre1 calibre1 pcalibre2">%r14.</code> (We omit the x86-64 register <code id="P7000497027000000000000000041C6D" data-uri="chapter04.xhtml#P7000497027000000000000000041C6D" class="pcalibre1 calibre1 pcalibre2">%r</code> 15 to simplify the instruction encoding.) Each of these stores a 64-bit word. Register <code id="P7000497027000000000000000041C6E" data-uri="chapter04.xhtml#P7000497027000000000000000041C6E" class="pcalibre1 calibre1 pcalibre2">%rsp</code> is used as a stack pointer by the push, pop, call, and return instructions. Otherwise, the registers have no fixed meanings or values. There are three single-bit <i class="pcalibre17 pcalibre2 pcalibre1">condition codes</i>, <code id="P7000497027000000000000000041C6F" data-uri="chapter04.xhtml#P7000497027000000000000000041C6F" class="pcalibre1 calibre1 pcalibre2">ZF, SF</code>, and <code id="P7000497027000000000000000041C70" data-uri="chapter04.xhtml#P7000497027000000000000000041C70" class="pcalibre1 calibre1 pcalibre2">OF</code>, storing information</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003ABC" data-uri="chapter04.xhtml#P7000497027000000000000000003ABC">
<img alt="A diagram shows fields for the Y86-64 programmer-visible state." id="P7000497027000000000000000041C71" data-uri="P700049702700000000000000000B6C9" src="../images/p355-1.png" class="pcalibre1 calibre28 pcalibre2"/>
<figcaption id="P7000497027000000000000000041C72" data-uri="chapter04.xhtml#P7000497027000000000000000041C72" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041C73" data-uri="chapter04.xhtml#P7000497027000000000000000041C73" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.1 </span>Y86-64 programmer-visible state.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041C74" data-uri="chapter04.xhtml#P7000497027000000000000000041C74"><p id="P7000497027000000000000000041C75" data-uri="chapter04.xhtml#P7000497027000000000000000041C75" class="pcalibre1 pcalibre2 pcalibre10">As with x86-64, programs for Y86-64 access and modify the program registers, the condition codes, the program counter (PC), and the memory. The status code indicates whether the program is running normally or some special event has occurred.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000021F56" data-uri="chapter04.xhtml#P7000497027000000000000000021F56">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000041C76" data-uri="chapter04.xhtml#P7000497027000000000000000041C76" class="pcalibre8 pcalibre1 pcalibre2">The five fields are summarized below.</p>
<ul id="P7000497027000000000000000041C77" data-uri="chapter04.xhtml#P7000497027000000000000000041C77" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000041C78" data-uri="chapter04.xhtml#P7000497027000000000000000041C78" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041C79" data-uri="chapter04.xhtml#P7000497027000000000000000041C79" class="pcalibre1 pcalibre2 pcalibre10">RF: Program registers: %rax, %rcx, %rdx, %rbx, %rsp, %rbp, %rsi, %rdi, %r8, %r9, %r10, %r11, %r12, %r13, %r14</p></li>
<li id="P7000497027000000000000000041C7A" data-uri="chapter04.xhtml#P7000497027000000000000000041C7A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041C7B" data-uri="chapter04.xhtml#P7000497027000000000000000041C7B" class="pcalibre1 pcalibre2 pcalibre10">CC: condition codes: ZF, SF, OF</p></li>
<li id="P7000497027000000000000000041C7C" data-uri="chapter04.xhtml#P7000497027000000000000000041C7C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041C7D" data-uri="chapter04.xhtml#P7000497027000000000000000041C7D" class="pcalibre1 pcalibre2 pcalibre10">Stat: Program status (blank)</p></li>
<li id="P7000497027000000000000000041C7E" data-uri="chapter04.xhtml#P7000497027000000000000000041C7E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041C7F" data-uri="chapter04.xhtml#P7000497027000000000000000041C7F" class="pcalibre1 pcalibre2 pcalibre10">PC (blank)</p></li>
<li id="P7000497027000000000000000041C80" data-uri="chapter04.xhtml#P7000497027000000000000000041C80" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041C81" data-uri="chapter04.xhtml#P7000497027000000000000000041C81" class="pcalibre1 pcalibre2 pcalibre10">DMEM: Memory (blank)</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041C82" data-uri="chapter04.xhtml#P7000497027000000000000000041C82"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003AC3" title="356" data-uri="chapter04.xhtml#P7000497027000000000000000003AC3" epub:type="pagebreak"></span>about the effect of the most recent arithmetic or logical instruction. The program counter (PC) holds the address of the instruction currently being executed.</p>
<p id="P7000497027000000000000000041C83" data-uri="chapter04.xhtml#P7000497027000000000000000041C83" class="pcalibre8 pcalibre1 pcalibre2">The <i class="pcalibre17 pcalibre2 pcalibre1">memory</i> is conceptually a large array of bytes, holding both program and data. Y86-64 programs reference memory locations using <i class="pcalibre17 pcalibre2 pcalibre1">virtual addresses.</i> A combination of hardware and operating system software translates these into the actual, or <i class="pcalibre17 pcalibre2 pcalibre1">physical</i>, addresses indicating where the values are actually stored in memory. We will study virtual memory in more detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">9</span></a>. For now, we can think of the virtual memory system as providing Y86-64 programs with an image of a monolithic byte array.</p>
<p id="P7000497027000000000000000041C84" data-uri="chapter04.xhtml#P7000497027000000000000000041C84" class="pcalibre8 pcalibre1 pcalibre2">A final part of the program state is a status code Stat, indicating the overall state of program execution. It will indicate either normal operation or that some sort of <i class="pcalibre17 pcalibre2 pcalibre1">exception</i> has occurred, such as when an instruction attempts to read from an invalid memory address. The possible status codes and the handling of exceptions is described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003BB9"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">4.1.4</span></a>.</p>
</section>
<section id="P7000497027000000000000000003AC6" data-uri="chapter04.xhtml#P7000497027000000000000000003AC6" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041C85" data-uri="chapter04.xhtml#P7000497027000000000000000041C85" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.1.2 </span>Y86-64 Instructions</h1></header>
<p id="P7000497027000000000000000041C86" data-uri="chapter04.xhtml#P7000497027000000000000000041C86" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ADE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.2</span></a> gives a concise description of the individual instructions in the Y86-64 ISA. We use this instruction set as a target for our processor implementations. The set of Y86-64 instructions is largely a subset of the x86-64 instruction set. It includes only 8-byte integer operations, has fewer addressing modes, and includes a smaller set of operations. Since we only use 8-byte data, we can refer to these as "words" without any ambiguity. In this figure, we show the assembly-code representation of the instructions on the left and the byte encodings on the right. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003B10"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.3</span></a> shows further details of some of the instructions. The assembly-code format is similar to the ATT format for x86-64.</p>
<p id="P7000497027000000000000000041C87" data-uri="chapter04.xhtml#P7000497027000000000000000041C87" class="pcalibre8 pcalibre1 pcalibre2">Here are some details about the Y86-64 instructions.</p>
<ul id="P7000497027000000000000000041C88" data-uri="chapter04.xhtml#P7000497027000000000000000041C88" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000041C89" data-uri="chapter04.xhtml#P7000497027000000000000000041C89" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041C8A" data-uri="chapter04.xhtml#P7000497027000000000000000041C8A" class="pcalibre1 pcalibre2 pcalibre10">The x86-64 <code id="P7000497027000000000000000041C8B" data-uri="chapter04.xhtml#P7000497027000000000000000041C8B" class="pcalibre1 calibre1 pcalibre2">movq</code> instruction is split into four different instructions: <code id="P7000497027000000000000000041C8C" data-uri="chapter04.xhtml#P7000497027000000000000000041C8C" class="pcalibre1 calibre1 pcalibre2">irmovq, rrmovq, mrmovq</code>, and <code id="P7000497027000000000000000041C8D" data-uri="chapter04.xhtml#P7000497027000000000000000041C8D" class="pcalibre1 calibre1 pcalibre2">rmmovq</code>, explicitly indicating the form of the source and destination. The source is either immediate (<code id="P7000497027000000000000000041C8E" data-uri="chapter04.xhtml#P7000497027000000000000000041C8E" class="pcalibre1 calibre1 pcalibre2">i</code>), register (<code id="P7000497027000000000000000041C8F" data-uri="chapter04.xhtml#P7000497027000000000000000041C8F" class="pcalibre1 calibre1 pcalibre2">r</code>), or memory (<code id="P7000497027000000000000000041C90" data-uri="chapter04.xhtml#P7000497027000000000000000041C90" class="pcalibre1 calibre1 pcalibre2">m</code>). It is designated by the first character in the instruction name. The destination is either register (<code id="P7000497027000000000000000041C91" data-uri="chapter04.xhtml#P7000497027000000000000000041C91" class="pcalibre1 calibre1 pcalibre2">r</code>) or memory (<code id="P7000497027000000000000000041C92" data-uri="chapter04.xhtml#P7000497027000000000000000041C92" class="pcalibre1 calibre1 pcalibre2">m</code>). It is designated by the second character in the instruction name. Explicitly identifying the four types of data transfer will prove helpful when we decide how to implement them.</p>
<p id="P7000497027000000000000000041C93" data-uri="chapter04.xhtml#P7000497027000000000000000041C93" class="pcalibre1 pcalibre2 pcalibre63">The memory references for the two memory movement instructions have a simple base and displacement format. We do not support the second index register or any scaling of a register's value in the address computation.</p>
<p id="P7000497027000000000000000041C94" data-uri="chapter04.xhtml#P7000497027000000000000000041C94" class="pcalibre1 pcalibre2 pcalibre63">As with x86-64, we do not allow direct transfers from one memory location to another. In addition, we do not allow a transfer of immediate data to memory.</p></li>
<li id="P7000497027000000000000000041C95" data-uri="chapter04.xhtml#P7000497027000000000000000041C95" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041C96" data-uri="chapter04.xhtml#P7000497027000000000000000041C96" class="pcalibre1 pcalibre2 pcalibre10">There are four integer operation instructions, shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ADE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.2</span></a> as <code id="P7000497027000000000000000041C97" data-uri="chapter04.xhtml#P7000497027000000000000000041C97" class="pcalibre1 calibre1 pcalibre2">OPq.</code> These are <code id="P7000497027000000000000000041C98" data-uri="chapter04.xhtml#P7000497027000000000000000041C98" class="pcalibre1 calibre1 pcalibre2">addq, subq, andq</code>, and <code id="P7000497027000000000000000041C99" data-uri="chapter04.xhtml#P7000497027000000000000000041C99" class="pcalibre1 calibre1 pcalibre2">xorq</code>. They operate only on register data, whereas x86-64 also allows operations on memory data. These instructions set the three condition codes <code id="P7000497027000000000000000041C9A" data-uri="chapter04.xhtml#P7000497027000000000000000041C9A" class="pcalibre1 calibre1 pcalibre2">ZF, SF</code>, and <code id="P7000497027000000000000000041C9B" data-uri="chapter04.xhtml#P7000497027000000000000000041C9B" class="pcalibre1 calibre1 pcalibre2">OF</code> (zero, sign, and overflow).</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003ADE" data-uri="chapter04.xhtml#P7000497027000000000000000003ADE">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003ADF" title="357" data-uri="chapter04.xhtml#P7000497027000000000000000003ADF" epub:type="pagebreak"></span><img alt="A diagram shows instruction sets." id="P7000497027000000000000000041C9C" data-uri="P700049702700000000000000000B6CA" src="../images/p357-1.png" class="pcalibre1 pcalibre2 pcalibre139"/>
<figcaption id="P7000497027000000000000000041C9D" data-uri="chapter04.xhtml#P7000497027000000000000000041C9D" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041C9E" data-uri="chapter04.xhtml#P7000497027000000000000000041C9E" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.2 </span>Y86-64 instruction set.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041C9F" data-uri="chapter04.xhtml#P7000497027000000000000000041C9F"><p id="P7000497027000000000000000041CA0" data-uri="chapter04.xhtml#P7000497027000000000000000041CA0" class="pcalibre1 pcalibre2 pcalibre10">Instruction encodings range between 1 and 10 bytes. An instruction consists of a 1-byte instruction specifier, possibly a 1 -byte register specifier, and possibly an 8-byte constant word. Field <code id="P7000497027000000000000000041CA1" data-uri="chapter04.xhtml#P7000497027000000000000000041CA1" class="pcalibre1 calibre1 pcalibre2">fn</code> specifies a particular integer operation (<code id="P7000497027000000000000000041CA2" data-uri="chapter04.xhtml#P7000497027000000000000000041CA2" class="pcalibre1 calibre1 pcalibre2">OPq</code>), data movement condition (<code id="P7000497027000000000000000041CA3" data-uri="chapter04.xhtml#P7000497027000000000000000041CA3" class="pcalibre1 calibre1 pcalibre2">cmovXX</code>), or branch condition (<code id="P7000497027000000000000000041CA4" data-uri="chapter04.xhtml#P7000497027000000000000000041CA4" class="pcalibre1 calibre1 pcalibre2">jXX</code>). All numeric values are shown in hexadecimal.</p><p id="P7000497027000000000000000041CA5" data-uri="chapter04.xhtml#P7000497027000000000000000041CA5" class="pcalibre1 pcalibre2 pcalibre63">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000021F86" data-uri="chapter04.xhtml#P7000497027000000000000000021F86">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000041CA6" data-uri="chapter04.xhtml#P7000497027000000000000000041CA6" class="pcalibre1 pcalibre2 pcalibre10">A diagram shows instruction sets, as summarized below.</p>
<ul id="P7000497027000000000000000041CA7" data-uri="chapter04.xhtml#P7000497027000000000000000041CA7" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000041CA8" data-uri="chapter04.xhtml#P7000497027000000000000000041CA8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CA9" data-uri="chapter04.xhtml#P7000497027000000000000000041CA9" class="pcalibre1 pcalibre2 pcalibre10">Halt: 1 byte containing 0 and 0</p></li>
<li id="P7000497027000000000000000041CAA" data-uri="chapter04.xhtml#P7000497027000000000000000041CAA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CAB" data-uri="chapter04.xhtml#P7000497027000000000000000041CAB" class="pcalibre1 pcalibre2 pcalibre10">Nop: 1 byte containing 1 and 0</p></li>
<li id="P7000497027000000000000000041CAC" data-uri="chapter04.xhtml#P7000497027000000000000000041CAC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CAD" data-uri="chapter04.xhtml#P7000497027000000000000000041CAD" class="pcalibre1 pcalibre2 pcalibre10">Rrmovq rA, rB: 2 bytes containing 2 and 0 in the first and rA and rB in the second</p></li>
<li id="P7000497027000000000000000041CAE" data-uri="chapter04.xhtml#P7000497027000000000000000041CAE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CAF" data-uri="chapter04.xhtml#P7000497027000000000000000041CAF" class="pcalibre1 pcalibre2 pcalibre10">Irmovq V, rB: 10 bytes containing 3 and 0 in the first, F and rB in the second, and V in the last 8 bytes</p></li>
<li id="P7000497027000000000000000041CB0" data-uri="chapter04.xhtml#P7000497027000000000000000041CB0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CB1" data-uri="chapter04.xhtml#P7000497027000000000000000041CB1" class="pcalibre1 pcalibre2 pcalibre10">Rmmovq rA, D(rB): 10 bytes containing 4 and 0 in the first, rA and rB in the second, and D in the last 8</p></li>
<li id="P7000497027000000000000000041CB2" data-uri="chapter04.xhtml#P7000497027000000000000000041CB2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CB3" data-uri="chapter04.xhtml#P7000497027000000000000000041CB3" class="pcalibre1 pcalibre2 pcalibre10">Nrmovq D(rB), rA: 10 bytes containing 5 and 0 in the first, rA and rB in the second, and D in the last 8</p></li>
<li id="P7000497027000000000000000041CB4" data-uri="chapter04.xhtml#P7000497027000000000000000041CB4" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CB5" data-uri="chapter04.xhtml#P7000497027000000000000000041CB5" class="pcalibre1 pcalibre2 pcalibre10">0Pq rA, rB: 2 bytes containing 6 and fn in the first and rA and rB in the second</p></li>
<li id="P7000497027000000000000000041CB6" data-uri="chapter04.xhtml#P7000497027000000000000000041CB6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CB7" data-uri="chapter04.xhtml#P7000497027000000000000000041CB7" class="pcalibre1 pcalibre2 pcalibre10">jXX Dest: 9 bytes containing 7 and fn in the first and Dest in the last 8</p></li>
<li id="P7000497027000000000000000041CB8" data-uri="chapter04.xhtml#P7000497027000000000000000041CB8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CB9" data-uri="chapter04.xhtml#P7000497027000000000000000041CB9" class="pcalibre1 pcalibre2 pcalibre10">cmovXX rA, rB: 2 bytes containing 2 and fn in the first and rA and rB in the second</p></li>
<li id="P7000497027000000000000000041CBA" data-uri="chapter04.xhtml#P7000497027000000000000000041CBA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CBB" data-uri="chapter04.xhtml#P7000497027000000000000000041CBB" class="pcalibre1 pcalibre2 pcalibre10">call Dest: 9 bytes containing 8 and 0 in the first and Dest in the last 8</p></li>
<li id="P7000497027000000000000000041CBC" data-uri="chapter04.xhtml#P7000497027000000000000000041CBC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CBD" data-uri="chapter04.xhtml#P7000497027000000000000000041CBD" class="pcalibre1 pcalibre2 pcalibre10">ret: 1 byte containing 9 and 0</p></li>
<li id="P7000497027000000000000000041CBE" data-uri="chapter04.xhtml#P7000497027000000000000000041CBE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CBF" data-uri="chapter04.xhtml#P7000497027000000000000000041CBF" class="pcalibre1 pcalibre2 pcalibre10">pushq rA: 2 bytes containing A and 0 in the first and rA and F in the second</p></li>
<li id="P7000497027000000000000000041CC0" data-uri="chapter04.xhtml#P7000497027000000000000000041CC0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CC1" data-uri="chapter04.xhtml#P7000497027000000000000000041CC1" class="pcalibre1 pcalibre2 pcalibre10">popq rA: 2 bytes containing B and 0 in the first and rA and F in the second</p></li>
</ul>
</details>
</figcaption>
</figure>
</li>
<li id="P7000497027000000000000000041CC2" data-uri="chapter04.xhtml#P7000497027000000000000000041CC2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CC3" data-uri="chapter04.xhtml#P7000497027000000000000000041CC3" class="pcalibre1 pcalibre2 pcalibre10">The seven jump instructions (shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ADE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.2</span></a> as <code id="P7000497027000000000000000041CC4" data-uri="chapter04.xhtml#P7000497027000000000000000041CC4" class="pcalibre1 calibre1 pcalibre2">jXX</code>) are <code id="P7000497027000000000000000041CC5" data-uri="chapter04.xhtml#P7000497027000000000000000041CC5" class="pcalibre1 calibre1 pcalibre2">jmp, jle, jl, je, jne, jge</code>, and <code id="P7000497027000000000000000041CC6" data-uri="chapter04.xhtml#P7000497027000000000000000041CC6" class="pcalibre1 calibre1 pcalibre2">jg</code>. Branches are taken according to the type of branch and the settings of the condition codes. The branch conditions are the same as with x86-64 (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_000.xhtml#P700049702700000000000000000244F"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.15</span></a>).</p></li>
<li id="P7000497027000000000000000041CC7" data-uri="chapter04.xhtml#P7000497027000000000000000041CC7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CC8" data-uri="chapter04.xhtml#P7000497027000000000000000041CC8" class="pcalibre1 pcalibre2 pcalibre10">There are six conditional move instructions (shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ADE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.2</span></a> as <code id="P7000497027000000000000000041CC9" data-uri="chapter04.xhtml#P7000497027000000000000000041CC9" class="pcalibre1 calibre1 pcalibre2">cmovXX): cmovle, cmovl, cmove, cmovne, cmovge</code>, and <code id="P7000497027000000000000000041CCA" data-uri="chapter04.xhtml#P7000497027000000000000000041CCA" class="pcalibre1 calibre1 pcalibre2">cmovg</code>. These have the same format as the register-register move instruction <code id="P7000497027000000000000000041CCB" data-uri="chapter04.xhtml#P7000497027000000000000000041CCB" class="pcalibre1 calibre1 pcalibre2">rrmovq</code>, but the destination register is updated only if the condition codes satisfy the required constraints.</p></li>
<li id="P7000497027000000000000000041CCC" data-uri="chapter04.xhtml#P7000497027000000000000000041CCC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CCD" data-uri="chapter04.xhtml#P7000497027000000000000000041CCD" class="pcalibre1 pcalibre2 pcalibre10">The call instruction pushes the return address on the stack and jumps to the destination address. The <code id="P7000497027000000000000000041CCE" data-uri="chapter04.xhtml#P7000497027000000000000000041CCE" class="pcalibre1 calibre1 pcalibre2">ret</code> instruction returns from such a call.</p></li>
<li id="P7000497027000000000000000041CCF" data-uri="chapter04.xhtml#P7000497027000000000000000041CCF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CD0" data-uri="chapter04.xhtml#P7000497027000000000000000041CD0" class="pcalibre1 pcalibre2 pcalibre10">The <code id="P7000497027000000000000000041CD1" data-uri="chapter04.xhtml#P7000497027000000000000000041CD1" class="pcalibre1 calibre1 pcalibre2">pushq</code> and <code id="P7000497027000000000000000041CD2" data-uri="chapter04.xhtml#P7000497027000000000000000041CD2" class="pcalibre1 calibre1 pcalibre2">popq</code> instructions implement push and pop, just as they do in x86-64.</p></li>
<li id="P7000497027000000000000000041CD3" data-uri="chapter04.xhtml#P7000497027000000000000000041CD3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CD4" data-uri="chapter04.xhtml#P7000497027000000000000000041CD4" class="pcalibre1 pcalibre2 pcalibre10">The <code id="P7000497027000000000000000041CD5" data-uri="chapter04.xhtml#P7000497027000000000000000041CD5" class="pcalibre1 calibre1 pcalibre2">halt</code> instruction stops instruction execution. x86-64 has a comparable instruction, called <code id="P7000497027000000000000000041CD6" data-uri="chapter04.xhtml#P7000497027000000000000000041CD6" class="pcalibre1 calibre1 pcalibre2">hlt</code>. x86-64 application programs are not permitted to use <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003AFE" title="358" data-uri="chapter04.xhtml#P7000497027000000000000000003AFE" epub:type="pagebreak"></span>this instruction, since it causes the entire system to suspend operation. For Y86-64, executing the <code id="P7000497027000000000000000041CD7" data-uri="chapter04.xhtml#P7000497027000000000000000041CD7" class="pcalibre1 calibre1 pcalibre2">halt</code> instruction causes the processor to stop, with the status code set to <code id="P7000497027000000000000000041CD8" data-uri="chapter04.xhtml#P7000497027000000000000000041CD8" class="pcalibre1 calibre1 pcalibre2">HLT</code>. (See <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003BB9"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">4.1.4</span></a>.)</p>
</li>
</ul>
</section>

<section id="P7000497027000000000000000003B01" data-uri="chapter04.xhtml#P7000497027000000000000000003B01" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041CD9" data-uri="chapter04.xhtml#P7000497027000000000000000041CD9" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.1.3 </span>Instruction Encoding</h1></header>
<p id="P7000497027000000000000000041CDA" data-uri="chapter04.xhtml#P7000497027000000000000000041CDA" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ADE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.2</span></a> also shows the byte-level encoding of the instructions. Each instruction requires between 1 and 10 bytes, depending on which fields are required. Every instruction has an initial byte identifying the instruction type. This byte is split into two 4-bit parts: the high-order, or <i class="pcalibre17 pcalibre2 pcalibre1">code</i>, part, and the low-order, or <i class="pcalibre17 pcalibre2 pcalibre1">function</i>, part. As can be seen in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ADE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.2</span></a>, code values range from <code id="P7000497027000000000000000041CDB" data-uri="chapter04.xhtml#P7000497027000000000000000041CDB" class="pcalibre1 calibre1 pcalibre2">0</code> to <code id="P7000497027000000000000000041CDC" data-uri="chapter04.xhtml#P7000497027000000000000000041CDC" class="pcalibre1 calibre1 pcalibre2">0xB</code>. The function values are significant only for the cases where a group of related instructions share a common code. These are given in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003B10"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.3</span></a>, showing the specific encodings of the integer operation, branch, and conditional move instructions. Observe that <code id="P7000497027000000000000000041CDD" data-uri="chapter04.xhtml#P7000497027000000000000000041CDD" class="pcalibre1 calibre1 pcalibre2">rrmovq</code> has the same instruction code as the conditional moves. It can be viewed as an "unconditional move" just as the <code id="P7000497027000000000000000041CDE" data-uri="chapter04.xhtml#P7000497027000000000000000041CDE" class="pcalibre1 calibre1 pcalibre2">jmp</code> instruction is an unconditional jump, both having function code <code id="P7000497027000000000000000041CDF" data-uri="chapter04.xhtml#P7000497027000000000000000041CDF" class="pcalibre1 calibre1 pcalibre2">0</code>.</p>
<p id="P7000497027000000000000000041CE0" data-uri="chapter04.xhtml#P7000497027000000000000000041CE0" class="pcalibre8 pcalibre1 pcalibre2">As shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003B18"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.4</span></a>, each of the 15 program registers has an associated <i class="pcalibre17 pcalibre2 pcalibre1">register identifier</i> (ID) ranging from <code id="P7000497027000000000000000041CE1" data-uri="chapter04.xhtml#P7000497027000000000000000041CE1" class="pcalibre1 calibre1 pcalibre2">0</code> to <code id="P7000497027000000000000000041CE2" data-uri="chapter04.xhtml#P7000497027000000000000000041CE2" class="pcalibre1 calibre1 pcalibre2">0xE</code>. The numbering of registers in Y86-64 matches what is used in x86-64. The program registers are stored within the CPU in a <i class="pcalibre17 pcalibre2 pcalibre1">register file</i>, a small random access memory where the register IDs serve as addresses. ID value <code id="P7000497027000000000000000041CE3" data-uri="chapter04.xhtml#P7000497027000000000000000041CE3" class="pcalibre1 calibre1 pcalibre2">0xF</code> is used in the instruction encodings and within our hardware designs when we need to indicate that no register should be accessed.</p>
<p id="P7000497027000000000000000041CE4" data-uri="chapter04.xhtml#P7000497027000000000000000041CE4" class="pcalibre8 pcalibre1 pcalibre2">Some instructions are just 1 byte long, but those that require operands have longer encodings. First, there can be an additional <i class="pcalibre17 pcalibre2 pcalibre1">register specifier byte</i>, specifying either one or two registers. These register fields are called rA and rB in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ADE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.2</span></a>. As the assembly-code versions of the instructions show, they can specify the registers used for data sources and destinations, as well as the base register used in an address computation, depending on the instruction type. Instructions that have no register operands, such as branches and call, do not have a register specifier byte. Those that require just one register operand (<code id="P7000497027000000000000000041CE5" data-uri="chapter04.xhtml#P7000497027000000000000000041CE5" class="pcalibre1 calibre1 pcalibre2">irmovq, pushq</code>, and <code id="P7000497027000000000000000041CE6" data-uri="chapter04.xhtml#P7000497027000000000000000041CE6" class="pcalibre1 calibre1 pcalibre2">popq</code>) have</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003B10" data-uri="chapter04.xhtml#P7000497027000000000000000003B10">
<img alt="A diagram shows instructions sets of operations, branches, and moves." id="P7000497027000000000000000041CE7" data-uri="P700049702700000000000000000B6CB" src="../images/p358-1.png" class="pcalibre1 pcalibre2 pcalibre140"/>
<figcaption id="P7000497027000000000000000041CE8" data-uri="chapter04.xhtml#P7000497027000000000000000041CE8" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041CE9" data-uri="chapter04.xhtml#P7000497027000000000000000041CE9" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.3 </span>Function codes for Y86-64 instruction set.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041CEA" data-uri="chapter04.xhtml#P7000497027000000000000000041CEA"><p id="P7000497027000000000000000041CEB" data-uri="chapter04.xhtml#P7000497027000000000000000041CEB" class="pcalibre1 pcalibre2 pcalibre10">The code specifies a particular integer operation, branch condition, or data transfer condition. These instructions are shown as <code id="P7000497027000000000000000041CEC" data-uri="chapter04.xhtml#P7000497027000000000000000041CEC" class="pcalibre1 calibre1 pcalibre2">0Pq, jXX</code>, and <code id="P7000497027000000000000000041CED" data-uri="chapter04.xhtml#P7000497027000000000000000041CED" class="pcalibre1 calibre1 pcalibre2">cmovXX</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ADE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.2</span></a>.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000021FCF" data-uri="chapter04.xhtml#P7000497027000000000000000021FCF">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000041CEE" data-uri="chapter04.xhtml#P7000497027000000000000000041CEE" class="pcalibre8 pcalibre1 pcalibre2">A diagram shows sets of instructions, as summarized below.</p>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P7000497027000000000000000041CEF" data-uri="chapter04.xhtml#P7000497027000000000000000041CEF">
<li id="P7000497027000000000000000041CF0" data-uri="chapter04.xhtml#P7000497027000000000000000041CF0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CF1" data-uri="chapter04.xhtml#P7000497027000000000000000041CF1" class="pcalibre1 pcalibre2 pcalibre10">Operations:</p>
<ul id="P7000497027000000000000000041CF2" data-uri="chapter04.xhtml#P7000497027000000000000000041CF2" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000041CF3" data-uri="chapter04.xhtml#P7000497027000000000000000041CF3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CF4" data-uri="chapter04.xhtml#P7000497027000000000000000041CF4" class="pcalibre1 pcalibre2 pcalibre10">Addq: 6 0</p></li>
<li id="P7000497027000000000000000041CF5" data-uri="chapter04.xhtml#P7000497027000000000000000041CF5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CF6" data-uri="chapter04.xhtml#P7000497027000000000000000041CF6" class="pcalibre1 pcalibre2 pcalibre10">Aubq: 6 1</p></li>
<li id="P7000497027000000000000000041CF7" data-uri="chapter04.xhtml#P7000497027000000000000000041CF7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CF8" data-uri="chapter04.xhtml#P7000497027000000000000000041CF8" class="pcalibre1 pcalibre2 pcalibre10">Andq: 6 2</p></li>
<li id="P7000497027000000000000000041CF9" data-uri="chapter04.xhtml#P7000497027000000000000000041CF9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CFA" data-uri="chapter04.xhtml#P7000497027000000000000000041CFA" class="pcalibre1 pcalibre2 pcalibre10">Xorq: 6 3</p></li>
</ul></li>
<li id="P7000497027000000000000000041CFB" data-uri="chapter04.xhtml#P7000497027000000000000000041CFB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CFC" data-uri="chapter04.xhtml#P7000497027000000000000000041CFC" class="pcalibre1 pcalibre2 pcalibre10">Branches:</p>
<ul id="P7000497027000000000000000041CFD" data-uri="chapter04.xhtml#P7000497027000000000000000041CFD" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000041CFE" data-uri="chapter04.xhtml#P7000497027000000000000000041CFE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041CFF" data-uri="chapter04.xhtml#P7000497027000000000000000041CFF" class="pcalibre1 pcalibre2 pcalibre10">Jmp: 7 0</p></li>
<li id="P7000497027000000000000000041D00" data-uri="chapter04.xhtml#P7000497027000000000000000041D00" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D01" data-uri="chapter04.xhtml#P7000497027000000000000000041D01" class="pcalibre1 pcalibre2 pcalibre10">Jle: 7 1</p></li>
<li id="P7000497027000000000000000041D02" data-uri="chapter04.xhtml#P7000497027000000000000000041D02" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D03" data-uri="chapter04.xhtml#P7000497027000000000000000041D03" class="pcalibre1 pcalibre2 pcalibre10">Jl: 7 2</p></li>
<li id="P7000497027000000000000000041D04" data-uri="chapter04.xhtml#P7000497027000000000000000041D04" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D05" data-uri="chapter04.xhtml#P7000497027000000000000000041D05" class="pcalibre1 pcalibre2 pcalibre10">Je: 7 3</p></li>
<li id="P7000497027000000000000000041D06" data-uri="chapter04.xhtml#P7000497027000000000000000041D06" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D07" data-uri="chapter04.xhtml#P7000497027000000000000000041D07" class="pcalibre1 pcalibre2 pcalibre10">Jne: 7 4</p></li>
<li id="P7000497027000000000000000041D08" data-uri="chapter04.xhtml#P7000497027000000000000000041D08" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D09" data-uri="chapter04.xhtml#P7000497027000000000000000041D09" class="pcalibre1 pcalibre2 pcalibre10">Jge: 7 5</p></li>
<li id="P7000497027000000000000000041D0A" data-uri="chapter04.xhtml#P7000497027000000000000000041D0A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D0B" data-uri="chapter04.xhtml#P7000497027000000000000000041D0B" class="pcalibre1 pcalibre2 pcalibre10">Jg: 7 6</p></li>
</ul></li>
<li id="P7000497027000000000000000041D0C" data-uri="chapter04.xhtml#P7000497027000000000000000041D0C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D0D" data-uri="chapter04.xhtml#P7000497027000000000000000041D0D" class="pcalibre1 pcalibre2 pcalibre10">Moves:</p>
<ul id="P7000497027000000000000000041D0E" data-uri="chapter04.xhtml#P7000497027000000000000000041D0E" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P7000497027000000000000000041D0F" data-uri="chapter04.xhtml#P7000497027000000000000000041D0F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D10" data-uri="chapter04.xhtml#P7000497027000000000000000041D10" class="pcalibre1 pcalibre2 pcalibre10">Rrmovq: 2 0</p></li>
<li id="P7000497027000000000000000041D11" data-uri="chapter04.xhtml#P7000497027000000000000000041D11" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D12" data-uri="chapter04.xhtml#P7000497027000000000000000041D12" class="pcalibre1 pcalibre2 pcalibre10">Cmovle: 2 1</p></li>
<li id="P7000497027000000000000000041D13" data-uri="chapter04.xhtml#P7000497027000000000000000041D13" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D14" data-uri="chapter04.xhtml#P7000497027000000000000000041D14" class="pcalibre1 pcalibre2 pcalibre10">Cmovl: 2 2</p></li>
<li id="P7000497027000000000000000041D15" data-uri="chapter04.xhtml#P7000497027000000000000000041D15" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D16" data-uri="chapter04.xhtml#P7000497027000000000000000041D16" class="pcalibre1 pcalibre2 pcalibre10">Cmove: 2 3</p></li>
<li id="P7000497027000000000000000041D17" data-uri="chapter04.xhtml#P7000497027000000000000000041D17" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D18" data-uri="chapter04.xhtml#P7000497027000000000000000041D18" class="pcalibre1 pcalibre2 pcalibre10">Cmovne: 2 4</p></li>
<li id="P7000497027000000000000000041D19" data-uri="chapter04.xhtml#P7000497027000000000000000041D19" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D1A" data-uri="chapter04.xhtml#P7000497027000000000000000041D1A" class="pcalibre1 pcalibre2 pcalibre10">Cmovge: 2 5</p></li>
<li id="P7000497027000000000000000041D1B" data-uri="chapter04.xhtml#P7000497027000000000000000041D1B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041D1C" data-uri="chapter04.xhtml#P7000497027000000000000000041D1C" class="pcalibre1 pcalibre2 pcalibre10">Cmovg: 2 6</p></li>
</ul></li>
</ol>
</details>
</figcaption>
</figure>


<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003B18" data-uri="chapter04.xhtml#P7000497027000000000000000003B18">
<table id="P7000497027000000000000000041D1D" data-uri="chapter04.xhtml#P7000497027000000000000000041D1D" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000041D1E" data-uri="chapter04.xhtml#P7000497027000000000000000041D1E" class="pcalibre1 pcalibre2 calibre5"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000003B1B" title="359" data-uri="chapter04.xhtml#P7000497027000000000000000003B1B" epub:type="pagebreak"></span>Number	</th><th id="P7000497027000000000000000041D1F" data-uri="chapter04.xhtml#P7000497027000000000000000041D1F" class="pcalibre1 pcalibre2 calibre5">Register name	</th><th id="P7000497027000000000000000041D20" data-uri="chapter04.xhtml#P7000497027000000000000000041D20" class="pcalibre1 pcalibre2 calibre5">Number	</th><th id="P7000497027000000000000000041D21" data-uri="chapter04.xhtml#P7000497027000000000000000041D21" class="pcalibre1 pcalibre2 calibre5">Register name</th></tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041D22" data-uri="chapter04.xhtml#P7000497027000000000000000041D22" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D23" data-uri="chapter04.xhtml#P7000497027000000000000000041D23" class="calibre3 pcalibre1 pcalibre2">0</code></td><td id="P7000497027000000000000000041D24" data-uri="chapter04.xhtml#P7000497027000000000000000041D24" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D25" data-uri="chapter04.xhtml#P7000497027000000000000000041D25" class="calibre3 pcalibre1 pcalibre2">	%rax</code></td><td id="P7000497027000000000000000041D26" data-uri="chapter04.xhtml#P7000497027000000000000000041D26" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D27" data-uri="chapter04.xhtml#P7000497027000000000000000041D27" class="calibre3 pcalibre1 pcalibre2">	8</code></td><td id="P7000497027000000000000000041D28" data-uri="chapter04.xhtml#P7000497027000000000000000041D28" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D29" data-uri="chapter04.xhtml#P7000497027000000000000000041D29" class="calibre3 pcalibre1 pcalibre2">	%r8</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041D2A" data-uri="chapter04.xhtml#P7000497027000000000000000041D2A" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D2B" data-uri="chapter04.xhtml#P7000497027000000000000000041D2B" class="calibre3 pcalibre1 pcalibre2">1</code></td><td id="P7000497027000000000000000041D2C" data-uri="chapter04.xhtml#P7000497027000000000000000041D2C" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D2D" data-uri="chapter04.xhtml#P7000497027000000000000000041D2D" class="calibre3 pcalibre1 pcalibre2">	%rcx</code></td><td id="P7000497027000000000000000041D2E" data-uri="chapter04.xhtml#P7000497027000000000000000041D2E" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D2F" data-uri="chapter04.xhtml#P7000497027000000000000000041D2F" class="calibre3 pcalibre1 pcalibre2">	9</code></td><td id="P7000497027000000000000000041D30" data-uri="chapter04.xhtml#P7000497027000000000000000041D30" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D31" data-uri="chapter04.xhtml#P7000497027000000000000000041D31" class="calibre3 pcalibre1 pcalibre2">	%r9</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041D32" data-uri="chapter04.xhtml#P7000497027000000000000000041D32" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D33" data-uri="chapter04.xhtml#P7000497027000000000000000041D33" class="calibre3 pcalibre1 pcalibre2">2</code></td><td id="P7000497027000000000000000041D34" data-uri="chapter04.xhtml#P7000497027000000000000000041D34" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D35" data-uri="chapter04.xhtml#P7000497027000000000000000041D35" class="calibre3 pcalibre1 pcalibre2">	%rdx</code></td><td id="P7000497027000000000000000041D36" data-uri="chapter04.xhtml#P7000497027000000000000000041D36" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D37" data-uri="chapter04.xhtml#P7000497027000000000000000041D37" class="calibre3 pcalibre1 pcalibre2">	A</code></td><td id="P7000497027000000000000000041D38" data-uri="chapter04.xhtml#P7000497027000000000000000041D38" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D39" data-uri="chapter04.xhtml#P7000497027000000000000000041D39" class="calibre3 pcalibre1 pcalibre2">	%r10</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041D3A" data-uri="chapter04.xhtml#P7000497027000000000000000041D3A" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D3B" data-uri="chapter04.xhtml#P7000497027000000000000000041D3B" class="calibre3 pcalibre1 pcalibre2">3</code></td><td id="P7000497027000000000000000041D3C" data-uri="chapter04.xhtml#P7000497027000000000000000041D3C" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D3D" data-uri="chapter04.xhtml#P7000497027000000000000000041D3D" class="calibre3 pcalibre1 pcalibre2">	%rbx</code></td><td id="P7000497027000000000000000041D3E" data-uri="chapter04.xhtml#P7000497027000000000000000041D3E" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D3F" data-uri="chapter04.xhtml#P7000497027000000000000000041D3F" class="calibre3 pcalibre1 pcalibre2">	B</code></td><td id="P7000497027000000000000000041D40" data-uri="chapter04.xhtml#P7000497027000000000000000041D40" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D41" data-uri="chapter04.xhtml#P7000497027000000000000000041D41" class="calibre3 pcalibre1 pcalibre2">	%r11</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041D42" data-uri="chapter04.xhtml#P7000497027000000000000000041D42" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D43" data-uri="chapter04.xhtml#P7000497027000000000000000041D43" class="calibre3 pcalibre1 pcalibre2">4</code></td><td id="P7000497027000000000000000041D44" data-uri="chapter04.xhtml#P7000497027000000000000000041D44" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D45" data-uri="chapter04.xhtml#P7000497027000000000000000041D45" class="calibre3 pcalibre1 pcalibre2">	%rsp</code></td><td id="P7000497027000000000000000041D46" data-uri="chapter04.xhtml#P7000497027000000000000000041D46" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D47" data-uri="chapter04.xhtml#P7000497027000000000000000041D47" class="calibre3 pcalibre1 pcalibre2">	C</code></td><td id="P7000497027000000000000000041D48" data-uri="chapter04.xhtml#P7000497027000000000000000041D48" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D49" data-uri="chapter04.xhtml#P7000497027000000000000000041D49" class="calibre3 pcalibre1 pcalibre2">	%.r12</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041D4A" data-uri="chapter04.xhtml#P7000497027000000000000000041D4A" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D4B" data-uri="chapter04.xhtml#P7000497027000000000000000041D4B" class="calibre3 pcalibre1 pcalibre2">5</code></td><td id="P7000497027000000000000000041D4C" data-uri="chapter04.xhtml#P7000497027000000000000000041D4C" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D4D" data-uri="chapter04.xhtml#P7000497027000000000000000041D4D" class="calibre3 pcalibre1 pcalibre2">	%rbp</code></td><td id="P7000497027000000000000000041D4E" data-uri="chapter04.xhtml#P7000497027000000000000000041D4E" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D4F" data-uri="chapter04.xhtml#P7000497027000000000000000041D4F" class="calibre3 pcalibre1 pcalibre2">	D</code></td><td id="P7000497027000000000000000041D50" data-uri="chapter04.xhtml#P7000497027000000000000000041D50" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D51" data-uri="chapter04.xhtml#P7000497027000000000000000041D51" class="calibre3 pcalibre1 pcalibre2">	%r13</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041D52" data-uri="chapter04.xhtml#P7000497027000000000000000041D52" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D53" data-uri="chapter04.xhtml#P7000497027000000000000000041D53" class="calibre3 pcalibre1 pcalibre2">6</code></td><td id="P7000497027000000000000000041D54" data-uri="chapter04.xhtml#P7000497027000000000000000041D54" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D55" data-uri="chapter04.xhtml#P7000497027000000000000000041D55" class="calibre3 pcalibre1 pcalibre2">	%rsi</code></td><td id="P7000497027000000000000000041D56" data-uri="chapter04.xhtml#P7000497027000000000000000041D56" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D57" data-uri="chapter04.xhtml#P7000497027000000000000000041D57" class="calibre3 pcalibre1 pcalibre2">	E</code></td><td id="P7000497027000000000000000041D58" data-uri="chapter04.xhtml#P7000497027000000000000000041D58" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D59" data-uri="chapter04.xhtml#P7000497027000000000000000041D59" class="calibre3 pcalibre1 pcalibre2">	%r14</code></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041D5A" data-uri="chapter04.xhtml#P7000497027000000000000000041D5A" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D5B" data-uri="chapter04.xhtml#P7000497027000000000000000041D5B" class="calibre3 pcalibre1 pcalibre2">7</code></td><td id="P7000497027000000000000000041D5C" data-uri="chapter04.xhtml#P7000497027000000000000000041D5C" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D5D" data-uri="chapter04.xhtml#P7000497027000000000000000041D5D" class="calibre3 pcalibre1 pcalibre2">	%rdi</code></td><td id="P7000497027000000000000000041D5E" data-uri="chapter04.xhtml#P7000497027000000000000000041D5E" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041D5F" data-uri="chapter04.xhtml#P7000497027000000000000000041D5F" class="calibre3 pcalibre1 pcalibre2">	F</code></td><td id="P7000497027000000000000000041D60" data-uri="chapter04.xhtml#P7000497027000000000000000041D60" class="pcalibre1 pcalibre2 calibre7">No register</td></tr>
</tbody>
</table>

<figcaption id="P7000497027000000000000000041D61" data-uri="chapter04.xhtml#P7000497027000000000000000041D61" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041D62" data-uri="chapter04.xhtml#P7000497027000000000000000041D62" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.4 </span>Y86-64 program register identifiers.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000041D63" data-uri="chapter04.xhtml#P7000497027000000000000000041D63"><p id="P7000497027000000000000000041D64" data-uri="chapter04.xhtml#P7000497027000000000000000041D64" class="pcalibre1 pcalibre2 pcalibre10">Each of the 1 5 program registers has an associated identifier (ID) ranging from <code id="P7000497027000000000000000041D65" data-uri="chapter04.xhtml#P7000497027000000000000000041D65" class="pcalibre1 calibre1 pcalibre2">0</code> to <code id="P7000497027000000000000000041D66" data-uri="chapter04.xhtml#P7000497027000000000000000041D66" class="pcalibre1 calibre1 pcalibre2">0xE</code>. ID <code id="P7000497027000000000000000041D67" data-uri="chapter04.xhtml#P7000497027000000000000000041D67" class="pcalibre1 calibre1 pcalibre2">0xF</code> in a register field of an instruction indicates the absence of a register operand.</p></div>
</figcaption>
</figure>

<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041D68" data-uri="chapter04.xhtml#P7000497027000000000000000041D68">the other register specifier set to value <code id="P7000497027000000000000000041D69" data-uri="chapter04.xhtml#P7000497027000000000000000041D69" class="pcalibre1 calibre1 pcalibre2">0xF</code>. This convention will prove useful in our processor implementation.</p>
<p id="P7000497027000000000000000041D6A" data-uri="chapter04.xhtml#P7000497027000000000000000041D6A" class="pcalibre8 pcalibre1 pcalibre2">Some instructions require an additional 8-byte <i class="pcalibre17 pcalibre2 pcalibre1">constant word.</i> This word can serve as the immediate data for <code id="P7000497027000000000000000041D6B" data-uri="chapter04.xhtml#P7000497027000000000000000041D6B" class="pcalibre1 calibre1 pcalibre2">irmovq</code>, the displacement for <code id="P7000497027000000000000000041D6C" data-uri="chapter04.xhtml#P7000497027000000000000000041D6C" class="pcalibre1 calibre1 pcalibre2">rmmovq</code> and <code id="P7000497027000000000000000041D6D" data-uri="chapter04.xhtml#P7000497027000000000000000041D6D" class="pcalibre1 calibre1 pcalibre2">mrmovq</code> address specifiers, and the destination of branches and calls. Note that branch and call destinations are given as absolute addresses, rather than using the PC-relative addressing seen in x86-64. Processors use PC-relative addressing to give more compact encodings of branch instructions and to allow code to be shifted from one part of memory to another without the need to update all of the branch target addresses. Since we are more concerned with simplicity in our presentation, we use absolute addressing. As with x86-64, all integers have a little-endian encoding. When the instruction is written in disassembled form, these bytes appear in reverse order.</p>
<p id="P7000497027000000000000000041D6E" data-uri="chapter04.xhtml#P7000497027000000000000000041D6E" class="pcalibre8 pcalibre1 pcalibre2">As an example, let us generate the byte encoding of the instruction <code id="P7000497027000000000000000041D6F" data-uri="chapter04.xhtml#P7000497027000000000000000041D6F" class="pcalibre1 calibre1 pcalibre2">rmmovq %rsp, 0x123456789abcd(%rdx)</code> in hexadecimal. From <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ADE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.2</span></a>, we can see that <code id="P7000497027000000000000000041D70" data-uri="chapter04.xhtml#P7000497027000000000000000041D70" class="pcalibre1 calibre1 pcalibre2">rmmovq</code> has initial byte 40. We can also see that source register <code id="P7000497027000000000000000041D71" data-uri="chapter04.xhtml#P7000497027000000000000000041D71" class="pcalibre1 calibre1 pcalibre2">%rsp</code> should be encoded in the rA field, and base register <code id="P7000497027000000000000000041D72" data-uri="chapter04.xhtml#P7000497027000000000000000041D72" class="pcalibre1 calibre1 pcalibre2">%rdx</code> should be encoded in the rB field. Using the register numbers in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003B18"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.4</span></a>, we get a register specifier byte of 42. Finally, the displacement is encoded in the 8-byte constant word. We first pad <code id="P7000497027000000000000000041D73" data-uri="chapter04.xhtml#P7000497027000000000000000041D73" class="pcalibre1 calibre1 pcalibre2">0x123456789abcd</code> with leading zeros to fill out 8 bytes, giving a byte sequence of <code id="P7000497027000000000000000041D74" data-uri="chapter04.xhtml#P7000497027000000000000000041D74" class="pcalibre1 calibre1 pcalibre2">00 0123 45 67 89 ab cd</code>. We write this in byte-reversed order as <code id="P7000497027000000000000000041D75" data-uri="chapter04.xhtml#P7000497027000000000000000041D75" class="pcalibre1 calibre1 pcalibre2">cd ab 89 67 45 23 01 00</code>. Combining these, we get an instruction encoding of <code id="P7000497027000000000000000041D76" data-uri="chapter04.xhtml#P7000497027000000000000000041D76" class="pcalibre1 calibre1 pcalibre2">4042cdab896745230100.</code></p>
<p id="P7000497027000000000000000041D77" data-uri="chapter04.xhtml#P7000497027000000000000000041D77" class="pcalibre8 pcalibre1 pcalibre2">One important property of any instruction set is that the byte encodings must have a unique interpretation. An arbitrary sequence of bytes either encodes a unique instruction sequence or is not a legal byte sequence. This property holds for Y86-64, because every instruction has a unique combination of code and function in its initial byte, and given this byte, we can determine the length and meaning of any additional bytes. This property ensures that a processor can execute an object-code program without any ambiguity about the meaning of the code. Even if the code is embedded within other bytes in the program, we can readily determine</p>

<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000003B75" data-uri="chapter04.xhtml#P7000497027000000000000000003B75"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000041D78" data-uri="chapter04.xhtml#P7000497027000000000000000041D78" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003B77" title="360" data-uri="chapter04.xhtml#P7000497027000000000000000003B77" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Comparing x86-64 to Y86-64 instruction encodings</h1></header>
<p id="P7000497027000000000000000041D79" data-uri="chapter04.xhtml#P7000497027000000000000000041D79" class="pcalibre1 pcalibre2 pcalibre10">Compared with the instruction encodings
 used in x86-64, the encoding of Y86-64 is much simpler but also less compact. The register fields occur only in fixed positions in all Y86-64 instructions, whereas they are packed into various positions in the different x86-64 instructions. An x86-64 instruction can encode constant values in 1, 2, 4, or 8 bytes, whereas Y86-64 always requires 8 bytes.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041D7A" data-uri="chapter04.xhtml#P7000497027000000000000000041D7A">the instruction sequence as long as we start from the first byte in the sequence. On the other hand, if we do not know the starting position of a code sequence, we cannot reliably determine how to split the sequence into individual instructions. This causes problems for disassemblers and other tools that attempt to extract machine-level programs directly from object-code byte sequences.</p>
<section id="P7000497027000000000000000003B7A" data-uri="chapter04.xhtml#P7000497027000000000000000003B7A" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041D7B" data-uri="chapter04.xhtml#P7000497027000000000000000041D7B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.1 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000045E1.xhtml#P7000497027000000000000000004690">480</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041D7C" data-uri="chapter04.xhtml#P7000497027000000000000000041D7C">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041D7D" data-uri="chapter04.xhtml#P7000497027000000000000000041D7D">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041D7E" data-uri="chapter04.xhtml#P7000497027000000000000000041D7E"><p id="P7000497027000000000000000041D7F" data-uri="chapter04.xhtml#P7000497027000000000000000041D7F" class="pcalibre1 pcalibre2 pcalibre10">Determine the byte encoding of the Y86-64 instruction sequence that follows. The line <code id="P7000497027000000000000000041D80" data-uri="chapter04.xhtml#P7000497027000000000000000041D80" class="pcalibre1 calibre1 pcalibre2">.pos 0x100</code> indicates that the starting address of the object code should be <code id="P7000497027000000000000000041D81" data-uri="chapter04.xhtml#P7000497027000000000000000041D81" class="pcalibre1 calibre1 pcalibre2">0x100.</code></p></div>
<pre id="P7000497027000000000000000041D82" data-uri="chapter04.xhtml#P7000497027000000000000000041D82" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041D83" data-uri="chapter04.xhtml#P7000497027000000000000000041D83" class="calibre3 pcalibre1 pcalibre2">.pos 0x100 # Start code at address 0x100
	irmovq $15,%rbx
	rrmovq %rbx,%rcx
loop:
	rmmovq %rcx,-3(%rbx)
	addq %rbx, 7,rcx
	jmp loop
</code>
</pre>
</li>
</ol>
</section>
<section id="P7000497027000000000000000003B84" data-uri="chapter04.xhtml#P7000497027000000000000000003B84" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041D84" data-uri="chapter04.xhtml#P7000497027000000000000000041D84" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.2 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046B3">481</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041D85" data-uri="chapter04.xhtml#P7000497027000000000000000041D85">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041D86" data-uri="chapter04.xhtml#P7000497027000000000000000041D86">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041D87" data-uri="chapter04.xhtml#P7000497027000000000000000041D87"><p id="P7000497027000000000000000041D88" data-uri="chapter04.xhtml#P7000497027000000000000000041D88" class="pcalibre1 pcalibre2 pcalibre10">For each byte sequence listed, determine the Y86-64 instruction sequence it encodes. If there is some invalid byte in the sequence, show the instruction sequence up to that point and indicate where the invalid value occurs. For each sequence, we show the starting address, then a colon, and then the byte sequence.</p>
<p id="P7000497027000000000000000041D89" data-uri="chapter04.xhtml#P7000497027000000000000000041D89" class="pcalibre1 pcalibre2 pcalibre10">A. <code id="P7000497027000000000000000041D8A" data-uri="chapter04.xhtml#P7000497027000000000000000041D8A" class="pcalibre1 calibre1 pcalibre2">0x100: 30f3fcffffffffffffff40630008000000000000</code></p>
<p id="P7000497027000000000000000041D8B" data-uri="chapter04.xhtml#P7000497027000000000000000041D8B" class="pcalibre1 pcalibre2 pcalibre10">B. <code id="P7000497027000000000000000041D8C" data-uri="chapter04.xhtml#P7000497027000000000000000041D8C" class="pcalibre1 calibre1 pcalibre2">0x200: a06f800c020000000000000030f30a00000000000000</code></p>
<p id="P7000497027000000000000000041D8D" data-uri="chapter04.xhtml#P7000497027000000000000000041D8D" class="pcalibre1 pcalibre2 pcalibre10">C. <code id="P7000497027000000000000000041D8E" data-uri="chapter04.xhtml#P7000497027000000000000000041D8E" class="pcalibre1 calibre1 pcalibre2">0x300: 5054070000000000000010f0b01f</code></p>
<p id="P7000497027000000000000000041D8F" data-uri="chapter04.xhtml#P7000497027000000000000000041D8F" class="pcalibre1 pcalibre2 pcalibre10">D. <code id="P7000497027000000000000000041D90" data-uri="chapter04.xhtml#P7000497027000000000000000041D90" class="pcalibre1 calibre1 pcalibre2">0x400: 611373000400000000000000</code></p>
<p id="P7000497027000000000000000041D91" data-uri="chapter04.xhtml#P7000497027000000000000000041D91" class="pcalibre1 pcalibre2 pcalibre10">E. <code id="P7000497027000000000000000041D92" data-uri="chapter04.xhtml#P7000497027000000000000000041D92" class="pcalibre1 calibre1 pcalibre2">0x500: 6362a0f0</code></p>
</div>
</li>
</ol>
</section>

<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000003B94" data-uri="chapter04.xhtml#P7000497027000000000000000003B94"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000041D93" data-uri="chapter04.xhtml#P7000497027000000000000000041D93" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003B96" title="361" data-uri="chapter04.xhtml#P7000497027000000000000000003B96" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>RISC and CISC instruction sets</h1></header>
<p id="P7000497027000000000000000041D94" data-uri="chapter04.xhtml#P7000497027000000000000000041D94" class="pcalibre1 pcalibre2 pcalibre40">x86-64 is sometimes labeled as a "complex instruction set computer" (CISCpronounced "sisk"), and is deemed to be the opposite of ISAs that are classified as "reduced instruction set computers" (RISCpronounced "risk"). Historically, CISC machines came first, having evolved from the earliest computers. By the early 1980s, instruction sets for mainframe and minicomputers had grown quite large, as machine designers incorporated new instructions to support high-level tasks, such as manipulating circular buffers, performing decimal arithmetic, and evaluating polynomials. The first microprocessors appeared in the early 1970s and had limited instruction sets, because the integrated-circuit technology then posed severe constraints on what could be implemented on a single chip. Microprocessors evolved quickly and, by the early 1980s, were following the same path of increasing instruction set complexity that had been the case for mainframes and minicomputers. The x86 family took this path, evolving into IA32, and more recently into x86-64. The x86 line continues to evolve as new classes of instructions are added based on the needs of emerging applications.</p>
<p id="P7000497027000000000000000041D95" data-uri="chapter04.xhtml#P7000497027000000000000000041D95" class="pcalibre1 pcalibre2 pcalibre40">The RISC design philosophy developed in the early 1980s as an alternative to these trends. A group of hardware and compiler experts at IBM, strongly influenced by the ideas of IBM researcher John Cocke, recognized that they could generate efficient code for a much simpler form of instruction set. In fact, many of the high-level instructions that were being added to instruction sets were very difficult to generate with a compiler and were seldom used. A simpler instruction set could be implemented with much less hardware and could be organized in an efficient pipeline structure, similar to those described later in this chapter. IBM did not commercialize this idea until many years later, when it developed the Power and PowerPC ISAs.</p>
<p id="P7000497027000000000000000041D96" data-uri="chapter04.xhtml#P7000497027000000000000000041D96" class="pcalibre1 pcalibre2 pcalibre40">The RISC concept was further developed by Professors David Patterson, of the University of California at Berkeley, and John Hennessy, of Stanford University. Patterson gave the name RISC to this new class of machines, and CISC to the existing class, since there had previously been no need to have a special designation for a nearly universal form of instruction set.</p>
<p id="P7000497027000000000000000041D97" data-uri="chapter04.xhtml#P7000497027000000000000000041D97" class="pcalibre1 pcalibre2 pcalibre40">When comparing CISC with the original RISC instruction sets, we find the following general characteristics:</p>


<table id="P7000497027000000000000000041D98" data-uri="chapter04.xhtml#P7000497027000000000000000041D98" class="pcalibre1 pcalibre2 pcalibre43">

<thead class="pcalibre44 pcalibre2 pcalibre1"><tr class="pcalibre45 pcalibre1 pcalibre2"><th id="P7000497027000000000000000041D99" data-uri="chapter04.xhtml#P7000497027000000000000000041D99" class="pcalibre1 pcalibre2 calibre5">CISC	</th><th id="P7000497027000000000000000041D9A" data-uri="chapter04.xhtml#P7000497027000000000000000041D9A" class="pcalibre1 pcalibre2 calibre5">Early RISC</th></tr></thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041D9B" data-uri="chapter04.xhtml#P7000497027000000000000000041D9B" class="pcalibre1 pcalibre2 calibre7">A large number of instructions. The Intel document describing the complete set of instructions <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B408">[51]</a> is over 1,200 pages long.</td>
<td id="P7000497027000000000000000041D9C" data-uri="chapter04.xhtml#P7000497027000000000000000041D9C" class="pcalibre1 pcalibre2 calibre7">Many fewer instructionstypically less than 100.</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041D9D" data-uri="chapter04.xhtml#P7000497027000000000000000041D9D" class="pcalibre1 pcalibre2 calibre7">Some instructions with long execution times. These include instructions that copy an entire block from one part of memory to another and others that copy multiple registers to and from memory.</td>
<td id="P7000497027000000000000000041D9E" data-uri="chapter04.xhtml#P7000497027000000000000000041D9E" class="pcalibre1 pcalibre2 calibre7">No instruction with a long execution time. Some early RISC machines did not even have an integer multiply instruction, requiring compilers to implement multiplication as a sequence of additions.</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041D9F" data-uri="chapter04.xhtml#P7000497027000000000000000041D9F" class="pcalibre1 pcalibre2 calibre7">Variable-size encodings. x86-64 instructions can range from 1 to 15 bytes.</td>
<td id="P7000497027000000000000000041DA0" data-uri="chapter04.xhtml#P7000497027000000000000000041DA0" class="pcalibre1 pcalibre2 calibre7">Fixed-length encodings. Typically all instructions are encoded as 4 bytes.</td></tr>

<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041DA1" data-uri="chapter04.xhtml#P7000497027000000000000000041DA1" class="pcalibre1 pcalibre2 calibre7"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003BA5" title="362" data-uri="chapter04.xhtml#P7000497027000000000000000003BA5" epub:type="pagebreak"></span>Multiple formats for specifying operands. In x86-64, a memory operand specifier can have many different combinations of displacement, base and index registers, and scale factors.</td>
<td id="P7000497027000000000000000041DA2" data-uri="chapter04.xhtml#P7000497027000000000000000041DA2" class="pcalibre1 pcalibre2 calibre7">Simple addressing formats. Typically just base and displacement addressing.</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041DA3" data-uri="chapter04.xhtml#P7000497027000000000000000041DA3" class="pcalibre1 pcalibre2 calibre7">Arithmetic and logical operations can be applied to both memory and register operands.</td>
<td id="P7000497027000000000000000041DA4" data-uri="chapter04.xhtml#P7000497027000000000000000041DA4" class="pcalibre1 pcalibre2 calibre7">Arithmetic and logical operations only use register operands. Memory referencing is only allowed by <i class="pcalibre17 pcalibre2 pcalibre1">load</i> instructions, reading from memory into a register, and <i class="pcalibre17 pcalibre2 pcalibre1">store</i> instructions, writing from a register to memory. This convention is referred to as a <i class="pcalibre17 pcalibre2 pcalibre1">load/store architecture.</i></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041DA5" data-uri="chapter04.xhtml#P7000497027000000000000000041DA5" class="pcalibre1 pcalibre2 calibre7">Implementation artifacts hidden from machine-level programs. The ISA provides a clean abstraction between programs and how they get executed.</td>
<td id="P7000497027000000000000000041DA6" data-uri="chapter04.xhtml#P7000497027000000000000000041DA6" class="pcalibre1 pcalibre2 calibre7">Implementation artifacts exposed to machine-level programs. Some RISC machines prohibit particular instruction sequences and have jumps that do not take effect until the following instruction is executed. The compiler is given the task of optimizing performance within these constraints.</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041DA7" data-uri="chapter04.xhtml#P7000497027000000000000000041DA7" class="pcalibre1 pcalibre2 calibre7">Condition codes. Special flags are set as a side effect of instructions and then used for conditional branch testing.</td>
<td id="P7000497027000000000000000041DA8" data-uri="chapter04.xhtml#P7000497027000000000000000041DA8" class="pcalibre1 pcalibre2 calibre7">No condition codes. Instead, explicit test instructions store the test results in normal registers for use in conditional evaluation.</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000041DA9" data-uri="chapter04.xhtml#P7000497027000000000000000041DA9" class="pcalibre1 pcalibre2 calibre7">Stack-intensive procedure linkage. The stack is used for procedure arguments and return addresses.</td>
<td id="P7000497027000000000000000041DAA" data-uri="chapter04.xhtml#P7000497027000000000000000041DAA" class="pcalibre1 pcalibre2 calibre7">Register-intensive procedure linkage. Registers are used for procedure arguments and return addresses. Some procedures can thereby avoid any memory references. Typically, the processor has many more (up to 32) registers.</td></tr>
</tbody>
</table>

<p id="P7000497027000000000000000041DAB" data-uri="chapter04.xhtml#P7000497027000000000000000041DAB" class="pcalibre1 pcalibre2 pcalibre10">The Y86-64 instruction set includes attributes of both CISC and RISC instruction sets. On the CISC side, it has condition codes and variable-length instructions, and it uses the stack to store return addresses. On the RISC side, it uses a load/store architecture and a regular instruction encoding, and it passes procedure arguments through registers. It can be viewed as taking a CISC instruction set (x86) and simplifying it by applying some of the principles of RISC.</p>
</aside>

<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000003BB0" data-uri="chapter04.xhtml#P7000497027000000000000000003BB0"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000041DAC" data-uri="chapter04.xhtml#P7000497027000000000000000041DAC" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003BB2" title="363" data-uri="chapter04.xhtml#P7000497027000000000000000003BB2" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>The RISC versus CISC controversy</h1></header>
<p id="P7000497027000000000000000041DAD" data-uri="chapter04.xhtml#P7000497027000000000000000041DAD" class="pcalibre1 pcalibre2 pcalibre40">Through the 1980s, battles raged in the computer architecture community regarding the merits of RISC versus CISC instruction sets. Proponents of RISC claimed they could get more computing power for a given amount of hardware through a combination of streamlined instruction set design, advanced compiler technology, and pipelined processor implementation. CISC proponents countered that fewer CISC instructions were required to perform a given task, and so their machines could achieve higher overall performance.</p>
<p id="P7000497027000000000000000041DAE" data-uri="chapter04.xhtml#P7000497027000000000000000041DAE" class="pcalibre1 pcalibre2 pcalibre40">Major companies introduced RISC processor lines, including Sun Microsystems (SPARC), IBM and Motorola (PowerPC), and Digital Equipment Corporation (Alpha). A British company, Acorn Computers Ltd., developed its own architecture, ARM (originally an acronym for "Acorn RISC machine"), which has become widely used in embedded applications, such as cell phones.</p>
<p id="P7000497027000000000000000041DAF" data-uri="chapter04.xhtml#P7000497027000000000000000041DAF" class="pcalibre1 pcalibre2 pcalibre40">In the early 1990s, the debate diminished as it became clear that neither RISC nor CISC in their purest forms were better than designs that incorporated the best ideas of both. RISC machines evolved and introduced more instructions, many of which take multiple cycles to execute. RISC machines today have hundreds of instructions in their repertoire, hardly fitting the name "reduced instruction set machine." The idea of exposing implementation artifacts to machine-level programs proved to be shortsighted. As new processor models were developed using more advanced hardware structures, many of these artifacts became irrelevant, but they still remained part of the instruction set. Still, the core of RISC design is an instruction set that is well suited to execution on a pipelined machine.</p>
<p id="P7000497027000000000000000041DB0" data-uri="chapter04.xhtml#P7000497027000000000000000041DB0" class="pcalibre1 pcalibre2 pcalibre40">More recent CISC machines also take advantage of high-performance pipeline structures. As we will discuss in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004B6C"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">5.7</span></a>, they fetch the CISC instructions and dynamically translate them into a sequence of simpler, RISC-like operations. For example, an instruction that adds a register to memory is translated into three operations: one to read the original memory value, one to perform the addition, and a third to write the sum to memory. Since the dynamic translation can generally be performed well in advance of the actual instruction execution, the processor can sustain a very high execution rate.</p>
<p id="P7000497027000000000000000041DB1" data-uri="chapter04.xhtml#P7000497027000000000000000041DB1" class="pcalibre1 pcalibre2 pcalibre40">Marketing issues, apart from technological ones, have also played a major role in determining the success of different instruction sets. By maintaining compatibility with its existing processors, Intel with x86 made it easy to keep moving from one generation of processor to the next. As integrated-circuit technology improved, Intel and other x86 processor manufacturers could overcome the inefficiencies created by the original 8086 instruction set design, using RISC techniques to produce performance comparable to the best RISC machines. As we saw in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001E06.xhtml#P7000497027000000000000000001E06"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.1</span></a>, the evolution of IA32 into x86-64 provided an opportunity to incorporate several features of RISC into the x86 family. In the areas of desktop, laptop, and server-based computing, x86 has achieved near total domination.</p>
<p id="P7000497027000000000000000041DB2" data-uri="chapter04.xhtml#P7000497027000000000000000041DB2" class="pcalibre1 pcalibre2 pcalibre10">RISC processors have done very well in the market for <i class="pcalibre17 pcalibre2 pcalibre1">embedded processors</i>, controlling such systems as cellular telephones, automobile brakes, and Internet appliances. In these applications, saving on cost and power is more important than maintaining backward compatibility. In terms of the number of processors sold, this is a very large and growing market.</p>
</aside>
</section>
<section id="P7000497027000000000000000003BB9" data-uri="chapter04.xhtml#P7000497027000000000000000003BB9" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041DB3" data-uri="chapter04.xhtml#P7000497027000000000000000041DB3" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.1.4 </span>Y86-64 Exceptions</h1></header>
<p id="P7000497027000000000000000041DB4" data-uri="chapter04.xhtml#P7000497027000000000000000041DB4" class="pcalibre8 pcalibre1 pcalibre2">The programmer-visible state for Y86-64 (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003ABC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.1</span></a>) includes a status code Stat describing the overall state of the executing program. The possible values for this code are shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003BBD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.5</span></a>. Code value 1, named <code id="P7000497027000000000000000041DB5" data-uri="chapter04.xhtml#P7000497027000000000000000041DB5" class="pcalibre1 calibre1 pcalibre2">AOK</code>, indicates that the program</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003BBD" data-uri="chapter04.xhtml#P7000497027000000000000000003BBD">
<table id="P7000497027000000000000000041DB6" data-uri="chapter04.xhtml#P7000497027000000000000000041DB6" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2"><th id="P7000497027000000000000000041DB7" data-uri="chapter04.xhtml#P7000497027000000000000000041DB7" class="pcalibre1 pcalibre2 calibre5"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000003BC0" title="364" data-uri="chapter04.xhtml#P7000497027000000000000000003BC0" epub:type="pagebreak"></span>Value</th>
<th id="P7000497027000000000000000041DB8" data-uri="chapter04.xhtml#P7000497027000000000000000041DB8" class="pcalibre1 pcalibre2 calibre5">Name</th>
<th id="P7000497027000000000000000041DB9" data-uri="chapter04.xhtml#P7000497027000000000000000041DB9" class="pcalibre1 pcalibre2 calibre5">Meaning</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041DBA" data-uri="chapter04.xhtml#P7000497027000000000000000041DBA" class="pcalibre1 pcalibre2 calibre7">1</td><td id="P7000497027000000000000000041DBB" data-uri="chapter04.xhtml#P7000497027000000000000000041DBB" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041DBC" data-uri="chapter04.xhtml#P7000497027000000000000000041DBC" class="calibre3 pcalibre1 pcalibre2">AOK</code></td><td id="P7000497027000000000000000041DBD" data-uri="chapter04.xhtml#P7000497027000000000000000041DBD" class="pcalibre1 pcalibre2 calibre7">Normal operation</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041DBE" data-uri="chapter04.xhtml#P7000497027000000000000000041DBE" class="pcalibre1 pcalibre2 calibre7">2</td><td id="P7000497027000000000000000041DBF" data-uri="chapter04.xhtml#P7000497027000000000000000041DBF" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041DC0" data-uri="chapter04.xhtml#P7000497027000000000000000041DC0" class="calibre3 pcalibre1 pcalibre2">HLT</code></td><td id="P7000497027000000000000000041DC1" data-uri="chapter04.xhtml#P7000497027000000000000000041DC1" class="pcalibre1 pcalibre2 calibre7">halt instruction encountered</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041DC2" data-uri="chapter04.xhtml#P7000497027000000000000000041DC2" class="pcalibre1 pcalibre2 calibre7">3</td><td id="P7000497027000000000000000041DC3" data-uri="chapter04.xhtml#P7000497027000000000000000041DC3" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041DC4" data-uri="chapter04.xhtml#P7000497027000000000000000041DC4" class="calibre3 pcalibre1 pcalibre2">ADR</code></td><td id="P7000497027000000000000000041DC5" data-uri="chapter04.xhtml#P7000497027000000000000000041DC5" class="pcalibre1 pcalibre2 calibre7">Invalid address encountered</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000041DC6" data-uri="chapter04.xhtml#P7000497027000000000000000041DC6" class="pcalibre1 pcalibre2 calibre7">4</td><td id="P7000497027000000000000000041DC7" data-uri="chapter04.xhtml#P7000497027000000000000000041DC7" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000041DC8" data-uri="chapter04.xhtml#P7000497027000000000000000041DC8" class="calibre3 pcalibre1 pcalibre2">INS</code></td><td id="P7000497027000000000000000041DC9" data-uri="chapter04.xhtml#P7000497027000000000000000041DC9" class="pcalibre1 pcalibre2 calibre7">Invalid instruction encountered</td></tr>
</tbody>
</table>
<figcaption id="P7000497027000000000000000041DCA" data-uri="chapter04.xhtml#P7000497027000000000000000041DCA" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041DCB" data-uri="chapter04.xhtml#P7000497027000000000000000041DCB" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.5 </span>Y86-64 status codes.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000041DCC" data-uri="chapter04.xhtml#P7000497027000000000000000041DCC"><p id="P7000497027000000000000000041DCD" data-uri="chapter04.xhtml#P7000497027000000000000000041DCD" class="pcalibre1 pcalibre2 pcalibre10">In our design, the processor halts for any code other than <code id="P7000497027000000000000000041DCE" data-uri="chapter04.xhtml#P7000497027000000000000000041DCE" class="pcalibre1 calibre1 pcalibre2">AOK</code>.</p></div>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041DCF" data-uri="chapter04.xhtml#P7000497027000000000000000041DCF">is executing normally, while the other codes indicate that some type of <i class="pcalibre17 pcalibre2 pcalibre1">exception</i> has occurred. Code 2, named <code id="P7000497027000000000000000041DD0" data-uri="chapter04.xhtml#P7000497027000000000000000041DD0" class="pcalibre1 calibre1 pcalibre2">HL</code>T, indicates that the processor has executed a <code id="P7000497027000000000000000041DD1" data-uri="chapter04.xhtml#P7000497027000000000000000041DD1" class="pcalibre1 calibre1 pcalibre2">halt</code> instruction. Code 3, named <code id="P7000497027000000000000000041DD2" data-uri="chapter04.xhtml#P7000497027000000000000000041DD2" class="pcalibre1 calibre1 pcalibre2">ADR</code>, indicates that the processor attempted to read from or write to an invalid memory address, either while fetching an instruction or while reading or writing data. We limit the maximum address (the exact limit varies by implementation), and any access to an address beyond this limit will trigger an <code id="P7000497027000000000000000041DD3" data-uri="chapter04.xhtml#P7000497027000000000000000041DD3" class="pcalibre1 calibre1 pcalibre2">ADR</code> exception. Code 4, named <code id="P7000497027000000000000000041DD4" data-uri="chapter04.xhtml#P7000497027000000000000000041DD4" class="pcalibre1 calibre1 pcalibre2">INS</code>, indicates that an invalid instruction code has been encountered.</p>
<p id="P7000497027000000000000000041DD5" data-uri="chapter04.xhtml#P7000497027000000000000000041DD5" class="pcalibre8 pcalibre1 pcalibre2">For Y86-64, we will simply have the processor stop executing instructions when it encounters any of the exceptions listed. In a more complete design, the processor would typically invoke an <i class="pcalibre17 pcalibre2 pcalibre1">exception handler</i>, a procedure designated to handle the specific type of exception encountered. As described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">8</span></a>, exception handlers can be configured to have different effects, such as aborting the program or invoking a user-defined <i class="pcalibre17 pcalibre2 pcalibre1">signal handler.</i></p>
</section>
<section id="P7000497027000000000000000003BDF" data-uri="chapter04.xhtml#P7000497027000000000000000003BDF" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041DD6" data-uri="chapter04.xhtml#P7000497027000000000000000041DD6" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.1.5 </span>Y86-64 Programs</h1></header>
<p id="P7000497027000000000000000041DD7" data-uri="chapter04.xhtml#P7000497027000000000000000041DD7" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003BE8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.6</span></a> shows x86-64 and Y86-64 assembly code for the following C function:</p>
<pre id="P7000497027000000000000000041DD8" data-uri="chapter04.xhtml#P7000497027000000000000000041DD8" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000041DD9" data-uri="chapter04.xhtml#P7000497027000000000000000041DD9" class="calibre3 pcalibre1 pcalibre2">1	long sum(long *start, long count)
2	{
3	long sum = 0;
4	while (count) {
5	sum += *start;
6	start ++;
7	count--;
8	&gt;
9	return sum;
10	}
</code></pre>
<p id="P7000497027000000000000000041DDA" data-uri="chapter04.xhtml#P7000497027000000000000000041DDA" class="pcalibre8 pcalibre1 pcalibre2">The x86-64 code was generated by the <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>compiler. The Y86-64 code is similar, but with the following differences:</p>
<ul id="P7000497027000000000000000041DDB" data-uri="chapter04.xhtml#P7000497027000000000000000041DDB" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000041DDC" data-uri="chapter04.xhtml#P7000497027000000000000000041DDC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041DDD" data-uri="chapter04.xhtml#P7000497027000000000000000041DDD" class="pcalibre1 pcalibre2 pcalibre10">The Y86-64 code loads constants into registers (lines 2-3), since it cannot use immediate data in arithmetic instructions.</p>


<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003BE8" data-uri="chapter04.xhtml#P7000497027000000000000000003BE8">
<p id="P7000497027000000000000000041DDE" data-uri="chapter04.xhtml#P7000497027000000000000000041DDE" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000003BEA" title="365" data-uri="chapter04.xhtml#P7000497027000000000000000003BEA" epub:type="pagebreak"></span>x86-64 code</p>
<pre id="P7000497027000000000000000041DDF" data-uri="chapter04.xhtml#P7000497027000000000000000041DDF" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000041DE0" data-uri="chapter04.xhtml#P7000497027000000000000000041DE0" class="calibre3 pcalibre1 pcalibre2">	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">long sum(long * start, long count)
	start in %rdi, count in %rsi</i></b>
1	sum:
2	movl	$0, %eax	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">sum = 0</i></b>
3	jmp	.L2		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Goto test</i></b>
4	.L3:		    <b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
5	addq	(%rdi), %rax	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Add *start to sum</i></b>
6	addq $8, %rdi		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">start ++</i></b>
7	subq	$1, %rsi	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">count</i>--</b>
8	.L2:		    <b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">test:</i></b>
9	testq	%rsi, %rsi	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Test sum</i></b>
10	jne	.L3		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">If ! = 0, goto</i> loop</b>
11	rep;	ret		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Return</i></b></code></pre>
<p id="P7000497027000000000000000041DE1" data-uri="chapter04.xhtml#P7000497027000000000000000041DE1" class="pcalibre1 pcalibre2 pcalibre10">Y86-64 code</p>
<pre id="P7000497027000000000000000041DE2" data-uri="chapter04.xhtml#P7000497027000000000000000041DE2" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041DE3" data-uri="chapter04.xhtml#P7000497027000000000000000041DE3" class="calibre3 pcalibre1 pcalibre2">	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">long sum(long * start, long count)
	start in %rdi, count in %rsi</i></b>
1	sum:
2	irmovq	$8,% r8		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Constant 8</i></b>
3	irmovq	$1,%r9		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Constant 1</i></b>
4	xorq	%rax,%rax	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">sum = 0</i></b>
5	andq	%rsi,%rsi	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Set CC</i></b>
6	jmp	test		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Go to test</i></b>
7	loop:
8	mrmovq	(%rdi),%r10	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Get *start</i></b>
9	addq %r10,%rax		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Add to sum</i></b>
10	addq	%r8,%rdi	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">start++</i></b>
11	subq	%r9,%rsi	<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">count--. Set CC</i></b>
12	test:
13	jne	loop		<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Stop when 0</i></b>
14	ret			<b class="pcalibre1 pcalibre2 pcalibre12"><i class="pcalibre17 pcalibre2 pcalibre1">Return</i></b>
</code>
</pre>
<figcaption id="P7000497027000000000000000041DE4" data-uri="chapter04.xhtml#P7000497027000000000000000041DE4" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041DE5" data-uri="chapter04.xhtml#P7000497027000000000000000041DE5" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.6 </span>Comparison of Y86-64 and x86-64 assembly programs.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000041DE6" data-uri="chapter04.xhtml#P7000497027000000000000000041DE6"><p id="P7000497027000000000000000041DE7" data-uri="chapter04.xhtml#P7000497027000000000000000041DE7" class="pcalibre1 pcalibre2 pcalibre10">The sum function computes the sum of an integer array. The Y86-64 code follows the same general pattern as the x86-64 code.</p></div></figcaption>
</figure>

</li>
<li id="P7000497027000000000000000041DE8" data-uri="chapter04.xhtml#P7000497027000000000000000041DE8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041DE9" data-uri="chapter04.xhtml#P7000497027000000000000000041DE9" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003BF6" title="366" data-uri="chapter04.xhtml#P7000497027000000000000000003BF6" epub:type="pagebreak"></span>The Y86-64 code requires two instructions (lines 8-9) to read a value from memory and add it to a register, whereas the x86-64 code can do this with a single <code id="P7000497027000000000000000041DEA" data-uri="chapter04.xhtml#P7000497027000000000000000041DEA" class="pcalibre1 calibre1 pcalibre2">addq</code> instruction (line 5).</p></li>
<li id="P7000497027000000000000000041DEB" data-uri="chapter04.xhtml#P7000497027000000000000000041DEB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041DEC" data-uri="chapter04.xhtml#P7000497027000000000000000041DEC" class="pcalibre1 pcalibre2 pcalibre10">Our hand-coded Y86-64 implementation takes advantage of the property that the <code id="P7000497027000000000000000041DED" data-uri="chapter04.xhtml#P7000497027000000000000000041DED" class="pcalibre1 calibre1 pcalibre2">subq</code> instruction (line 11) also sets the condition codes, and so the <code id="P7000497027000000000000000041DEE" data-uri="chapter04.xhtml#P7000497027000000000000000041DEE" class="pcalibre1 calibre1 pcalibre2">testq</code> instruction of the <span class="pcalibre1 pcalibre29 pcalibre2">gcc</span>-generated code (line 9) is not required. For this to work, though, the Y86-64 code must set the condition codes prior to entering the loop with an <code id="P7000497027000000000000000041DEF" data-uri="chapter04.xhtml#P7000497027000000000000000041DEF" class="pcalibre1 calibre1 pcalibre2">andq</code> instruction (line 5).</p></li>
</ul>
<p id="P7000497027000000000000000041DF0" data-uri="chapter04.xhtml#P7000497027000000000000000041DF0" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003C09"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.7</span></a> shows an example of a complete program file written in Y86-64 assembly code. The program contains both data and instructions. Directives indicate where to place code or data and how to align it. The program specifies issues such as stack placement, data initialization, program initialization, and program termination.</p>
<p id="P7000497027000000000000000041DF1" data-uri="chapter04.xhtml#P7000497027000000000000000041DF1" class="pcalibre8 pcalibre1 pcalibre2">In this program, words beginning with `.' are <i class="pcalibre17 pcalibre2 pcalibre1">assembler directives</i> telling the assembler to adjust the address at which it is generating code or to insert some words of data. The directive .<code id="P7000497027000000000000000041DF2" data-uri="chapter04.xhtml#P7000497027000000000000000041DF2" class="pcalibre1 calibre1 pcalibre2">pos 0</code> (line 2) indicates that the assembler should begin generating code starting at address 0. This is the starting address for all Y86-64 programs. The next instruction (line 3) initializes the stack pointer. We can see that the label stack is declared at the end of the program (line 40), to indicate address <code id="P7000497027000000000000000041DF3" data-uri="chapter04.xhtml#P7000497027000000000000000041DF3" class="pcalibre1 calibre1 pcalibre2">0x200</code> using a <code id="P7000497027000000000000000041DF4" data-uri="chapter04.xhtml#P7000497027000000000000000041DF4" class="pcalibre1 calibre1 pcalibre2">.pos</code> directive (line 39). Our stack will therefore start at this address and grow toward lower addresses. We must ensure that the stack does not grow so large that it overwrites the code or other program data.</p>
<p id="P7000497027000000000000000041DF5" data-uri="chapter04.xhtml#P7000497027000000000000000041DF5" class="pcalibre8 pcalibre1 pcalibre2">Lines 8 to 13 of the program declare an array of four words, having the values</p>
<pre id="P7000497027000000000000000041DF6" data-uri="chapter04.xhtml#P7000497027000000000000000041DF6" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000041DF7" data-uri="chapter04.xhtml#P7000497027000000000000000041DF7" class="calibre3 pcalibre1 pcalibre2">0x000d000d000d000d, 0x00c000c000c000c0,
0x0b000b000b000b00, 0xa000a000a000a000
</code>
</pre>
<p id="P7000497027000000000000000041DF8" data-uri="chapter04.xhtml#P7000497027000000000000000041DF8" class="pcalibre8 pcalibre1 pcalibre2">The label array denotes the start of this array, and is aligned on an 8-byte boundary (using the .align directive). Lines 16 to 19 show a "main" procedure that calls the function sum on the four-word array and then halts.</p>
<p id="P7000497027000000000000000041DF9" data-uri="chapter04.xhtml#P7000497027000000000000000041DF9" class="pcalibre8 pcalibre1 pcalibre2">As this example shows, since our only tool for creating Y86-64 code is an assembler, the programmer must perform tasks we ordinarily delegate to the compiler, linker, and run-time system. Fortunately, we only do this for small programs, for which simple mechanisms suffice.</p>
<p id="P7000497027000000000000000041DFA" data-uri="chapter04.xhtml#P7000497027000000000000000041DFA" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003C11"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.8</span></a> shows the result of assembling the code shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003C09"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.7</span></a> by an assembler we call <span class="pcalibre1 pcalibre29 pcalibre2">yas. </span>The assembler output is in ASCII format to make it more readable. On lines of the assembly file that contain instructions or data, the object code contains an address, followed by the values of between 1 and 10 bytes.</p>
<p id="P7000497027000000000000000041DFB" data-uri="chapter04.xhtml#P7000497027000000000000000041DFB" class="pcalibre8 pcalibre1 pcalibre2">We have implemented an <i class="pcalibre17 pcalibre2 pcalibre1">instruction set simulator</i> we call <span class="pcalibre1 pcalibre29 pcalibre2">yis</span>, the purpose of which is to model the execution of a Y86-64 machine-code program without attempting to model the behavior of any specific processor implementation. This form of simulation is useful for debugging programs before actual hardware is available, and for checking the result of either simulating the hardware or running</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003C09" data-uri="chapter04.xhtml#P7000497027000000000000000003C09">
<pre id="P7000497027000000000000000041DFC" data-uri="chapter04.xhtml#P7000497027000000000000000041DFC" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000041DFD" data-uri="chapter04.xhtml#P7000497027000000000000000041DFD" class="calibre3 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000003C0C" title="367" data-uri="chapter04.xhtml#P7000497027000000000000000003C0C" epub:type="pagebreak"></span>1	# Execution begins at address 0
2	    .pos 0
3	    irmovq stack, %rsp	# Set up stack pointer
4	    call main		# Execute main program
5	    halt		# Terminate program
6	
7	# Array of 4 elements
8	    .align 8
9	array :
10	    .quad 0x000d000d000d
11	    .quad 0x00c000c000c0
12	    .quad 0x0b000b000b00
13	    .quad 0xa000a000a000
14	
15	main:
16	    irmovq array,%rdi
17	    irmovq $4,%rsi
18	    call sum		# sum(array, 4)
19	    ret
20	
21	# long sum(long *start, long count)
22	# start in %rdi, count in %rsi
23	sum:
24	    irmovq $8,%r8	# Constant 8
25	    irmovq $1,%r9	# Constant 1
26	    xorq %rax/Zrax	# sum = 0
27	    andq %rsi,%rsi	# Set CC
28	    jmp test		# Goto test
29	loop :
30	    mrmovq (%rdi),%r10	# Get *start
31	    addq %r10,%rax	# Add to sum
32	    addq %r8,%rdi	# start++
33	    subq %r9,%rsi	# count--. Set CC
34	test:
35	    jne loop		# Stop when 0
36	    ret			# Return
37	
38	# Stack starts here and grows to lower addresses
39	    .pos 0x200
40	stack:
</code>
</pre>
<figcaption id="P7000497027000000000000000041DFE" data-uri="chapter04.xhtml#P7000497027000000000000000041DFE" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041DFF" data-uri="chapter04.xhtml#P7000497027000000000000000041DFF" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.7 </span>Sample program written in Y86-64 assembly code.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000041E00" data-uri="chapter04.xhtml#P7000497027000000000000000041E00"><p id="P7000497027000000000000000041E01" data-uri="chapter04.xhtml#P7000497027000000000000000041E01" class="pcalibre8 pcalibre1 pcalibre2">The sum function is called to compute the sum of a four-element array.</p><p id="P7000497027000000000000000041E02" data-uri="chapter04.xhtml#P7000497027000000000000000041E02" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
</figcaption>
</figure>


<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003C11" data-uri="chapter04.xhtml#P7000497027000000000000000003C11">

<pre id="P7000497027000000000000000041E03" data-uri="chapter04.xhtml#P7000497027000000000000000041E03" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041E04" data-uri="chapter04.xhtml#P7000497027000000000000000041E04" class="calibre3 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000003C14" title="368" data-uri="chapter04.xhtml#P7000497027000000000000000003C14" epub:type="pagebreak"></span>					| # Execution begins at address 0
0x000:					| .pos 0
0x000: 30f40002000000000000		| irmovq stack, %rsp # Set up stack pointer
0x00a: 803800000000000000		| call main # Execute main program
0x013: 00				| halt # Terminate program
					| # Array of 4 elements
0x018:					| .align 8
0x018:					| array:
0x018: 0d000d000d000000			| .quad 0x000d000d000d
0x020: c000c000c0000000			| .quad 0x00c000c000c0
0x028: 000b000b000b0000			| .quad 0x0b000b000b00
0x030: 00a000a000a00000			| .quad 0xa000a000a000
0x038:					| main:
0x038: 30f71800000000000000		| irmovq array,%rdi
0x042: 30f60400000000000000		| irmovq $4,%rsi
0x04c: 805600000000000000		| call sum # sum(array, 4)
0x055: 90				| ret
					| # long sum(long *start, long count)
					| # start in %rdi, count in %rsi
0x056 :					| sum :
0x056: 30f80800000000000000		| irmovq $8,%r8 # Constant 8
0x060: 30f90100000000000000		| irmovq $l,%r9 # Constant 1
0x06a: 6300				| xorq %rax,7,rax # sum = 0
0x06c: 6266				| andq %rsi, %rsi # Set CC
0x06e: 708700000000000000		| jmp test # Goto test
0x077:					| loop:
0x077: 50a70000000000000000		| mrmovq (%rdi),%10 # Get *start
0x081: 60a0				| addq %r10,%rax # Add to sum
0x083: 6087				| addq %r8,%rdi # start++
0x085: 6196				| subq %r9,%rsi # count--. Set CC
0x087:					| test:
0x087: 747700000000000000		| jne loop # Stop when 0
0x090: 90				| ret # Return
					| # Stack starts here and grows to lower addresses
0x200:					| .pos 0x200
0x200:					| stack:
</code>
</pre>
<figcaption id="P7000497027000000000000000041E05" data-uri="chapter04.xhtml#P7000497027000000000000000041E05" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041E06" data-uri="chapter04.xhtml#P7000497027000000000000000041E06" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.8 </span>Output of <span class="pcalibre1 pcalibre2 pcalibre84">yas </span>assembler.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000041E07" data-uri="chapter04.xhtml#P7000497027000000000000000041E07"><p id="P7000497027000000000000000041E08" data-uri="chapter04.xhtml#P7000497027000000000000000041E08" class="pcalibre8 pcalibre1 pcalibre2">Each line includes a hexadecimal address and between 1 and 10 bytes of object code.</p><p id="P7000497027000000000000000041E09" data-uri="chapter04.xhtml#P7000497027000000000000000041E09" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
</figcaption>
</figure>

<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000041E0A" data-uri="chapter04.xhtml#P7000497027000000000000000041E0A"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003C1A" title="369" data-uri="chapter04.xhtml#P7000497027000000000000000003C1A" epub:type="pagebreak"></span>the program on the hardware itself. Running on our sample object code, <span class="pcalibre1 pcalibre29 pcalibre2">yis </span>generates the following output:</p>
<pre id="P7000497027000000000000000041E0B" data-uri="chapter04.xhtml#P7000497027000000000000000041E0B" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041E0C" data-uri="chapter04.xhtml#P7000497027000000000000000041E0C" class="calibre3 pcalibre1 pcalibre2">Stopped in 34 steps at PC = 0x13. Status `HLT', CC Z=l S=0 0=0
Changes to registers:
%rax:	0x0000000000000000	0x0000abcdabcdabcd
%rsp:	0x0000000000000000	0x0000000000000200
%rdi:	0x0000000000000000	0x0000000000000038
%r8:	0x0000000000000000	0x0000000000000008
%r9:	0x0000000000000000	0x0000000000000001
%r10:	0x0000000000000000	0x0000a000a000a000
Changes to memory:
0x0lf0:	0x0000000000000000	0x0000000000000055
0x01f8:	0x0000000000000000	0x0000000000000013
</code>
</pre>
<p id="P7000497027000000000000000041E0D" data-uri="chapter04.xhtml#P7000497027000000000000000041E0D" class="pcalibre8 pcalibre1 pcalibre2">The first line of the simulation output summarizes the execution and the resulting values of the PC and program status. In printing register and memory values, it only prints out words that change during simulation, either in registers or in memory. The original values (here they are all zero) are shown on the left, and the final values are shown on the right. We can see in this output that register <code id="P7000497027000000000000000041E0E" data-uri="chapter04.xhtml#P7000497027000000000000000041E0E" class="pcalibre1 calibre1 pcalibre2">%rax</code> contains <code id="P7000497027000000000000000041E0F" data-uri="chapter04.xhtml#P7000497027000000000000000041E0F" class="pcalibre1 calibre1 pcalibre2">0xabcdabcdabcdabcd</code>, the sum of the 4-element array passed to procedure sum. In addition, we can see that the stack, which starts at address <code id="P7000497027000000000000000041E10" data-uri="chapter04.xhtml#P7000497027000000000000000041E10" class="pcalibre1 calibre1 pcalibre2">0x200</code> and grows toward lower addresses, has been used, causing changes to words of memory at addresses <code id="P7000497027000000000000000041E11" data-uri="chapter04.xhtml#P7000497027000000000000000041E11" class="pcalibre1 calibre1 pcalibre2">0x1f0-0x1f8</code>. The maximum address for executable code is <code id="P7000497027000000000000000041E12" data-uri="chapter04.xhtml#P7000497027000000000000000041E12" class="pcalibre1 calibre1 pcalibre2">0x090</code>, and so the pushing and popping of values on the stack did not corrupt the executable code.</p>
<section id="P7000497027000000000000000003C23" data-uri="chapter04.xhtml#P7000497027000000000000000003C23" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041E13" data-uri="chapter04.xhtml#P7000497027000000000000000041E13" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.3 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046D8">482</a>)</h1></header>
<p id="P7000497027000000000000000041E14" data-uri="chapter04.xhtml#P7000497027000000000000000041E14" class="pcalibre8 pcalibre1 pcalibre2">One common pattern in machine-level programs is to add a constant value to a register. With the Y86-64 instructions presented thus far, this requires first using an <code id="P7000497027000000000000000041E15" data-uri="chapter04.xhtml#P7000497027000000000000000041E15" class="pcalibre1 calibre1 pcalibre2">irmovq</code> instruction to set a register to the constant, and then an <code id="P7000497027000000000000000041E16" data-uri="chapter04.xhtml#P7000497027000000000000000041E16" class="pcalibre1 calibre1 pcalibre2">addq</code> instruction to add this value to the destination register. Suppose we want to add a new instruction <code id="P7000497027000000000000000041E17" data-uri="chapter04.xhtml#P7000497027000000000000000041E17" class="pcalibre1 calibre1 pcalibre2">iaddq</code> with the following format:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003C29" data-uri="chapter04.xhtml#P7000497027000000000000000003C29">
<img alt="A diagram illustrates the 10-byte instructions for iaddq V, rB with C and 0 in the first byte, F and rB in the second, and V in the last 8 bytes." id="P7000497027000000000000000041E18" data-uri="P700049702700000000000000000B6CC" src="../images/p369-1.png" class="pcalibre1 pcalibre2 pcalibre142"/>
</figure>
<p id="P7000497027000000000000000041E19" data-uri="chapter04.xhtml#P7000497027000000000000000041E19" class="pcalibre8 pcalibre1 pcalibre2">This instruction adds the constant value V to register rB.</p>
<p id="P7000497027000000000000000041E1A" data-uri="chapter04.xhtml#P7000497027000000000000000041E1A" class="pcalibre8 pcalibre1 pcalibre2">Rewrite the Y86-64 <code id="P7000497027000000000000000041E1B" data-uri="chapter04.xhtml#P7000497027000000000000000041E1B" class="pcalibre1 calibre1 pcalibre2">sum</code> function of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003BE8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.6</span></a> to make use of the <code id="P7000497027000000000000000041E1C" data-uri="chapter04.xhtml#P7000497027000000000000000041E1C" class="pcalibre1 calibre1 pcalibre2">iaddq</code> instruction. In the original version, we dedicated registers <code id="P7000497027000000000000000041E1D" data-uri="chapter04.xhtml#P7000497027000000000000000041E1D" class="pcalibre1 calibre1 pcalibre2">%r8</code> and <code id="P7000497027000000000000000041E1E" data-uri="chapter04.xhtml#P7000497027000000000000000041E1E" class="pcalibre1 calibre1 pcalibre2">%r9</code> to hold constant values. Now, we can avoid using those registers altogether.</p>

</section>
<section id="P7000497027000000000000000003C31" data-uri="chapter04.xhtml#P7000497027000000000000000003C31" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041E1F" data-uri="chapter04.xhtml#P7000497027000000000000000041E1F" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003C33" title="370" data-uri="chapter04.xhtml#P7000497027000000000000000003C33" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.4 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046D8">482</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041E20" data-uri="chapter04.xhtml#P7000497027000000000000000041E20">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041E21" data-uri="chapter04.xhtml#P7000497027000000000000000041E21">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041E22" data-uri="chapter04.xhtml#P7000497027000000000000000041E22"><p id="P7000497027000000000000000041E23" data-uri="chapter04.xhtml#P7000497027000000000000000041E23" class="pcalibre1 pcalibre2 pcalibre10">Write Y86-64 code to implement a recursive sum function <code id="P7000497027000000000000000041E24" data-uri="chapter04.xhtml#P7000497027000000000000000041E24" class="pcalibre1 calibre1 pcalibre2">rsum</code>, based on the following C code:</p>
<pre id="P7000497027000000000000000041E25" data-uri="chapter04.xhtml#P7000497027000000000000000041E25" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041E26" data-uri="chapter04.xhtml#P7000497027000000000000000041E26" class="calibre3 pcalibre1 pcalibre2">long rsum(long *start, long count)
{
if (count &lt;= 0)
	return 0;
return *start + rsum(start+l, count-1);
}
</code></pre>
<p id="P7000497027000000000000000041E27" data-uri="chapter04.xhtml#P7000497027000000000000000041E27" class="pcalibre1 pcalibre2 pcalibre10">Use the same argument passing and register saving conventions as x86-64 code does. You might find it helpful to compile the C code on an x86-64 machine and then translate the instructions to Y86-64.</p>
</div>
</li>
</ol>
</section>
<section id="P7000497027000000000000000003C3C" data-uri="chapter04.xhtml#P7000497027000000000000000003C3C" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041E28" data-uri="chapter04.xhtml#P7000497027000000000000000041E28" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.5 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046E7">483</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041E29" data-uri="chapter04.xhtml#P7000497027000000000000000041E29">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041E2A" data-uri="chapter04.xhtml#P7000497027000000000000000041E2A">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041E2B" data-uri="chapter04.xhtml#P7000497027000000000000000041E2B"><p id="P7000497027000000000000000041E2C" data-uri="chapter04.xhtml#P7000497027000000000000000041E2C" class="pcalibre1 pcalibre2 pcalibre10">Modify the Y86-64 code for the sum function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003BE8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.6</span></a>) to implement a function <code id="P7000497027000000000000000041E2D" data-uri="chapter04.xhtml#P7000497027000000000000000041E2D" class="pcalibre1 calibre1 pcalibre2">absSum</code> that computes the sum of absolute values of an array. Use a <i class="pcalibre17 pcalibre2 pcalibre1">conditional jump</i> instruction within your inner loop.</p></div></li></ol>
</section>
<section id="P7000497027000000000000000003C43" data-uri="chapter04.xhtml#P7000497027000000000000000003C43" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041E2E" data-uri="chapter04.xhtml#P7000497027000000000000000041E2E" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.6 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046E7">483</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041E2F" data-uri="chapter04.xhtml#P7000497027000000000000000041E2F">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041E30" data-uri="chapter04.xhtml#P7000497027000000000000000041E30">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041E31" data-uri="chapter04.xhtml#P7000497027000000000000000041E31"><p id="P7000497027000000000000000041E32" data-uri="chapter04.xhtml#P7000497027000000000000000041E32" class="pcalibre1 pcalibre2 pcalibre10">Modify the Y86-64 code for the <code id="P7000497027000000000000000041E33" data-uri="chapter04.xhtml#P7000497027000000000000000041E33" class="pcalibre1 calibre1 pcalibre2">sum</code> function (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003BE8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.6</span></a>) to implement a function <code id="P7000497027000000000000000041E34" data-uri="chapter04.xhtml#P7000497027000000000000000041E34" class="pcalibre1 calibre1 pcalibre2">absSum</code> that computes the sum of absolute values of an array. Use a <i class="pcalibre17 pcalibre2 pcalibre1">conditional move</i> instruction within your inner loop.</p></div>
</li>
</ol>
</section>
</section>
<section id="P7000497027000000000000000003C4B" data-uri="chapter04.xhtml#P7000497027000000000000000003C4B" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041E35" data-uri="chapter04.xhtml#P7000497027000000000000000041E35" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.1.6 </span>Some Y86-64 Instruction Details</h1></header>
<p id="P7000497027000000000000000041E36" data-uri="chapter04.xhtml#P7000497027000000000000000041E36" class="pcalibre8 pcalibre1 pcalibre2">Most Y86-64 instructions transform the program state in a straightforward manner, and so defining the intended effect of each instruction is not difficult. Two unusual instruction combinations, however, require special attention.</p>
<p id="P7000497027000000000000000041E37" data-uri="chapter04.xhtml#P7000497027000000000000000041E37" class="pcalibre8 pcalibre1 pcalibre2">The <code id="P7000497027000000000000000041E38" data-uri="chapter04.xhtml#P7000497027000000000000000041E38" class="pcalibre1 calibre1 pcalibre2">pushq</code> instruction both decrements the stack pointer by 8 and writes a register value to memory. It is therefore not totally clear what the processor should do when executing the instruction <code id="P7000497027000000000000000041E39" data-uri="chapter04.xhtml#P7000497027000000000000000041E39" class="pcalibre1 calibre1 pcalibre2">pushq %rsp</code>, since the register being pushed is being changed by the same instruction. Two different conventions are possible: (1) push the original value of <code id="P7000497027000000000000000041E3A" data-uri="chapter04.xhtml#P7000497027000000000000000041E3A" class="pcalibre1 calibre1 pcalibre2">%rsp</code>, or (2) push the decremented value of <code id="P7000497027000000000000000041E3B" data-uri="chapter04.xhtml#P7000497027000000000000000041E3B" class="pcalibre1 calibre1 pcalibre2">%rsp</code>.</p>
<p id="P7000497027000000000000000041E3C" data-uri="chapter04.xhtml#P7000497027000000000000000041E3C" class="pcalibre8 pcalibre1 pcalibre2">For the Y86-64 processor, let us adopt the same convention as is used with x86-64, as determined in the following problem.</p>
<section id="P7000497027000000000000000003C54" data-uri="chapter04.xhtml#P7000497027000000000000000003C54" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041E3D" data-uri="chapter04.xhtml#P7000497027000000000000000041E3D" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.7 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046F2">484</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041E3E" data-uri="chapter04.xhtml#P7000497027000000000000000041E3E">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041E3F" data-uri="chapter04.xhtml#P7000497027000000000000000041E3F">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041E40" data-uri="chapter04.xhtml#P7000497027000000000000000041E40"><p id="P7000497027000000000000000041E41" data-uri="chapter04.xhtml#P7000497027000000000000000041E41" class="pcalibre1 pcalibre2 pcalibre10">Let us determine the behavior of the instruction <code id="P7000497027000000000000000041E42" data-uri="chapter04.xhtml#P7000497027000000000000000041E42" class="pcalibre1 calibre1 pcalibre2">pushq %rsp</code> for an x86-64 processor. We could try reading the Intel documentation on this instruction, but a <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003C5B" title="371" data-uri="chapter04.xhtml#P7000497027000000000000000003C5B" epub:type="pagebreak"></span>simpler approach is to conduct an experiment on an actual machine. The C compiler would not normally generate this instruction, so we must use hand-generated assembly code for this task. Here is a test function we have written (Web Aside <span class="pcalibre1 pcalibre29 pcalibre2">asm:easm </span>on page 178 describes how to write programs that combine C code with handwritten assembly code):</p>
<pre id="P7000497027000000000000000041E43" data-uri="chapter04.xhtml#P7000497027000000000000000041E43" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041E44" data-uri="chapter04.xhtml#P7000497027000000000000000041E44" class="calibre3 pcalibre1 pcalibre2">1	.text
2	.globl pushtest
3	pushtest:
4	movq	%rsp, %rax	<i class="pcalibre17 pcalibre2 pcalibre1">Copy stack pointer</i>
5	pushq	%rsp	<i class="pcalibre17 pcalibre2 pcalibre1">Push stack pointer</i>
6	Popd	%rdx	<i class="pcalibre17 pcalibre2 pcalibre1">Pop it back</i>
7	subq %rdx, %rax	<i class="pcalibre17 pcalibre2 pcalibre1">Return 0 or 4</i>
8	ret
</code></pre>
<p id="P7000497027000000000000000041E45" data-uri="chapter04.xhtml#P7000497027000000000000000041E45" class="pcalibre1 pcalibre2 pcalibre10">In our experiments, we find that function <code id="P7000497027000000000000000041E46" data-uri="chapter04.xhtml#P7000497027000000000000000041E46" class="pcalibre1 calibre1 pcalibre2">pushtest</code> always returns 0. What does this imply about the behavior of the instruction <code id="P7000497027000000000000000041E47" data-uri="chapter04.xhtml#P7000497027000000000000000041E47" class="pcalibre1 calibre1 pcalibre2">pushq %rsp</code> under x86-64?</p></div></li></ol>
</section>
<p id="P7000497027000000000000000041E48" data-uri="chapter04.xhtml#P7000497027000000000000000041E48" class="pcalibre8 pcalibre1 pcalibre2">A similar ambiguity occurs for the instruction <code id="P7000497027000000000000000041E49" data-uri="chapter04.xhtml#P7000497027000000000000000041E49" class="pcalibre1 calibre1 pcalibre2">popq %rsp</code>. It could either set <code id="P7000497027000000000000000041E4A" data-uri="chapter04.xhtml#P7000497027000000000000000041E4A" class="pcalibre1 calibre1 pcalibre2">%rsp</code> to the value read from memory or to the incremented stack pointer. As with <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003C54"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.7</span></a>, let us run an experiment to determine how an x86-64 machine would handle this instruction, and then design our Y86-64 machine to follow the same convention.</p>
<section id="P7000497027000000000000000003C64" data-uri="chapter04.xhtml#P7000497027000000000000000003C64" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000041E4B" data-uri="chapter04.xhtml#P7000497027000000000000000041E4B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.8 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046F2">484</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041E4C" data-uri="chapter04.xhtml#P7000497027000000000000000041E4C">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041E4D" data-uri="chapter04.xhtml#P7000497027000000000000000041E4D">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041E4E" data-uri="chapter04.xhtml#P7000497027000000000000000041E4E"><p id="P7000497027000000000000000041E4F" data-uri="chapter04.xhtml#P7000497027000000000000000041E4F" class="pcalibre1 pcalibre2 pcalibre10">The following assembly-code function lets us determine the behavior of the instruction <code id="P7000497027000000000000000041E50" data-uri="chapter04.xhtml#P7000497027000000000000000041E50" class="pcalibre1 calibre1 pcalibre2">popq %rsp</code> for x86-64:</p>
<pre id="P7000497027000000000000000041E51" data-uri="chapter04.xhtml#P7000497027000000000000000041E51" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041E52" data-uri="chapter04.xhtml#P7000497027000000000000000041E52" class="calibre3 pcalibre1 pcalibre2">1	.text
2	.globl poptest
3	poptest:
4	movq	%rsp, %rdi	<i class="pcalibre17 pcalibre2 pcalibre1">Save stack pointer</i>
5	pushq	$0xabcd	<i class="pcalibre17 pcalibre2 pcalibre1">Push test value</i>
6	popq	%rsp	<i class="pcalibre17 pcalibre2 pcalibre1">Pop to stack pointer</i>
7	movq	%rsp, %rax	<i class="pcalibre17 pcalibre2 pcalibre1">Set popped value as return value</i>
8	movq	%rdi, %rsp	<i class="pcalibre17 pcalibre2 pcalibre1">Restore stack pointer</i>
9	ret
</code></pre>
<p id="P7000497027000000000000000041E53" data-uri="chapter04.xhtml#P7000497027000000000000000041E53" class="pcalibre1 pcalibre2 pcalibre10">We find this function always returns <code id="P7000497027000000000000000041E54" data-uri="chapter04.xhtml#P7000497027000000000000000041E54" class="pcalibre1 calibre1 pcalibre2">0xabcd</code>. What does this imply about the behavior of <code id="P7000497027000000000000000041E55" data-uri="chapter04.xhtml#P7000497027000000000000000041E55" class="pcalibre1 calibre1 pcalibre2">popq%rsp?</code> What other Y86-64 instruction would have the exact same behavior?</p></div></li></ol>
</section>

<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000003C70" data-uri="chapter04.xhtml#P7000497027000000000000000003C70"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000041E56" data-uri="chapter04.xhtml#P7000497027000000000000000041E56" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003C72" title="372" data-uri="chapter04.xhtml#P7000497027000000000000000003C72" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Getting the details right: Inconsistencies across x86 models</h1></header>
<p id="P7000497027000000000000000041E57" data-uri="chapter04.xhtml#P7000497027000000000000000041E57" class="pcalibre1 pcalibre2 pcalibre40"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003C54"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problems </span><span class="pcalibre1 pcalibre21 pcalibre2">4.7</span></a> and <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003C64"><span class="pcalibre1 pcalibre21 pcalibre2">4.8</span></a> are designed to help us devise a consistent set of conventions for instructions that push or pop the stack pointer. There seems to be little reason why one would want to perform either of these operations, and so a natural question to ask is, "Why worry about such picky details?"</p>
<p id="P7000497027000000000000000041E58" data-uri="chapter04.xhtml#P7000497027000000000000000041E58" class="pcalibre1 pcalibre2 pcalibre40">Several useful lessons can be learned about the importance of consistency from the following excerpt from the Intel documentation of the <span class="pcalibre1 pcalibre29 pcalibre2">push </span>instruction <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B408">[51]</a>:</p>
<div class="pcalibre1 pcalibre2 pcalibre90" id="P7000497027000000000000000041E59" data-uri="chapter04.xhtml#P7000497027000000000000000041E59">
<blockquote class="pcalibre88 pcalibre87 pcalibre91" id="P7000497027000000000000000041E5A" data-uri="chapter04.xhtml#P7000497027000000000000000041E5A"><p id="P7000497027000000000000000041E5B" data-uri="chapter04.xhtml#P7000497027000000000000000041E5B" class="pcalibre1 pcalibre2 pcalibre40">For IA-32 processors from the Intel 286 on, the PUSH ESP instruction pushes the value of the ESP register as it existed before the instruction was executed. (This is also true for Intel 64 architecture, real-address and virtual-8086 modes of IA-32 architecture.) For the Intel(r) 8086 processor, the PUSH SP instruction pushes the new value of the SP register (that is the value after it has been decremented by 2).</p>
</blockquote>
<div class="pcalibre1 pcalibre2 pcalibre92" id="P7000497027000000000000000041E5C" data-uri="chapter04.xhtml#P7000497027000000000000000041E5C"><p id="P7000497027000000000000000041E5D" data-uri="chapter04.xhtml#P7000497027000000000000000041E5D" class="pcalibre1 pcalibre2 calibre15">(PUSH ESP instruction. Intel Corporation. 50.)</p></div>
</div>
<p id="P7000497027000000000000000041E5E" data-uri="chapter04.xhtml#P7000497027000000000000000041E5E" class="pcalibre1 pcalibre2 pcalibre40">Although the exact details of this note may be difficult to follow, we can see that it states that, depending on what mode an x86 processor operates under, it will do different things when instructed to push the stack pointer register. Some modes push the original value, while others push the decremented value. (Interestingly, there is no corresponding ambiguity about popping to the stack pointer register.) There are two drawbacks to this inconsistency:</p>
<ul id="P7000497027000000000000000041E5F" data-uri="chapter04.xhtml#P7000497027000000000000000041E5F" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000041E60" data-uri="chapter04.xhtml#P7000497027000000000000000041E60" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041E61" data-uri="chapter04.xhtml#P7000497027000000000000000041E61" class="pcalibre1 pcalibre2 pcalibre10">It decreases code portability. Programs may have different behavior depending on the processor mode. Although the particular instruction is not at all common, even the potential for incompatibility can have serious consequences.</p></li>
<li id="P7000497027000000000000000041E62" data-uri="chapter04.xhtml#P7000497027000000000000000041E62" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041E63" data-uri="chapter04.xhtml#P7000497027000000000000000041E63" class="pcalibre1 pcalibre2 pcalibre10">It complicates the documentation. As we see here, a special note is required to try to clarify the differences. The documentation for x86 is already complex enough without special cases such as this one.</p></li>
</ul>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000041E64" data-uri="chapter04.xhtml#P7000497027000000000000000041E64">We conclude, therefore, that working out details in advance and striving for complete consistency can save a lot of trouble in the long run.</p>
</aside>
</section>
</section></body></html>
