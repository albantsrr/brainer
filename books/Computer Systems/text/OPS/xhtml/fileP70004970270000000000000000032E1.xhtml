<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>Homework Problems </title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P70004970270000000000000000032E1" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000004151F" data-uri="chapter03.xhtml#P700049702700000000000000004151F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Homework Problems </span></h1></header>
<section id="P70004970270000000000000000032E3" data-uri="chapter03.xhtml#P70004970270000000000000000032E3" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041520" data-uri="chapter03.xhtml#P7000497027000000000000000041520" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.58 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041521" data-uri="chapter03.xhtml#P7000497027000000000000000041521">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041522" data-uri="chapter03.xhtml#P7000497027000000000000000041522">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041523" data-uri="chapter03.xhtml#P7000497027000000000000000041523"><p id="P7000497027000000000000000041524" data-uri="chapter03.xhtml#P7000497027000000000000000041524" class="pcalibre1 pcalibre2 pcalibre10">For a function with prototype</p>
<pre id="P7000497027000000000000000041525" data-uri="chapter03.xhtml#P7000497027000000000000000041525" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041526" data-uri="chapter03.xhtml#P7000497027000000000000000041526" class="calibre3 pcalibre1 pcalibre2">
long decode2(long x, long y, long z);
</code></pre>
<p id="P7000497027000000000000000041527" data-uri="chapter03.xhtml#P7000497027000000000000000041527" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the following assembly code:</p>
<pre id="P7000497027000000000000000041528" data-uri="chapter03.xhtml#P7000497027000000000000000041528" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041529" data-uri="chapter03.xhtml#P7000497027000000000000000041529" class="calibre3 pcalibre1 pcalibre2">
1	decode2:	
2	subq	%rdx, %rsi
3	imulq	%rsi, %rdi
4	movq	%rsi, %rax
5	salq	$63, %rax
6	sarq	$63, %rax
7	xorq	%rdi, %rax
8	ret	
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P700049702700000000000000004152A" data-uri="chapter03.xhtml#P700049702700000000000000004152A">Parameters <code id="P700049702700000000000000004152B" data-uri="chapter03.xhtml#P700049702700000000000000004152B" class="pcalibre1 calibre1 pcalibre2">x, y</code>, and <code id="P700049702700000000000000004152C" data-uri="chapter03.xhtml#P700049702700000000000000004152C" class="pcalibre1 calibre1 pcalibre2">z</code> are passed in registers <code id="P700049702700000000000000004152D" data-uri="chapter03.xhtml#P700049702700000000000000004152D" class="pcalibre1 calibre1 pcalibre2">%rdi, %rsi</code>, and <code id="P700049702700000000000000004152E" data-uri="chapter03.xhtml#P700049702700000000000000004152E" class="pcalibre1 calibre1 pcalibre2">%rdx</code>. The code stores the return value in register <code id="P700049702700000000000000004152F" data-uri="chapter03.xhtml#P700049702700000000000000004152F" class="pcalibre1 calibre1 pcalibre2">%rax</code>.</p>
<p id="P7000497027000000000000000041530" data-uri="chapter03.xhtml#P7000497027000000000000000041530" class="pcalibre1 pcalibre2 pcalibre10">Write C code for <code id="P7000497027000000000000000041531" data-uri="chapter03.xhtml#P7000497027000000000000000041531" class="pcalibre1 calibre1 pcalibre2">decode2</code> that will have an effect equivalent to the assembly code shown.</p>
</div></li></ol>
</section>
<section id="P70004970270000000000000000032F6" data-uri="chapter03.xhtml#P70004970270000000000000000032F6" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041532" data-uri="chapter03.xhtml#P7000497027000000000000000041532" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.59 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041533" data-uri="chapter03.xhtml#P7000497027000000000000000041533">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041534" data-uri="chapter03.xhtml#P7000497027000000000000000041534">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041535" data-uri="chapter03.xhtml#P7000497027000000000000000041535"><p id="P7000497027000000000000000041536" data-uri="chapter03.xhtml#P7000497027000000000000000041536" class="pcalibre1 pcalibre2 pcalibre10">The following code computes the 128-bit product of two 64-bit signed values <var class="pcalibre17 pcalibre2 pcalibre1">x</var> and <var class="pcalibre17 pcalibre2 pcalibre1">y</var> and stores the result in memory:</p>
<pre id="P7000497027000000000000000041537" data-uri="chapter03.xhtml#P7000497027000000000000000041537" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041538" data-uri="chapter03.xhtml#P7000497027000000000000000041538" class="calibre3 pcalibre1 pcalibre2">
1	typedef __int128 int128_t;
2	
3	void store_prod(int128_t *dest, int64_t x, int64_t y) {
4	*dest = x * (int128_t) y;
5	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000041539" data-uri="chapter03.xhtml#P7000497027000000000000000041539"><span class="pcalibre1 pcalibre29 pcalibre2">Gcc </span>generates the following assembly code implementing the computation:</p>
<pre id="P700049702700000000000000004153A" data-uri="chapter03.xhtml#P700049702700000000000000004153A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004153B" data-uri="chapter03.xhtml#P700049702700000000000000004153B" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003301" title="312" data-uri="chapter03.xhtml#P7000497027000000000000000003301" epub:type="pagebreak"></span>1	store_prod:
2	movq	%rdx, %rax
3	cqto	
4	movq	%rsi, %rcx
5	sarq	$63, %rcx
6	imulq	%rax, %rcx
7	imulq	%rsi, %rdx
8	addq	%rdx, %rcx
9	mulq	%rsi
1	addq	%rcx, %rdx
1	movq	%rax, (%rdi)
1	movq	%rdx, 8(%rdi)
1	ret	
</code></pre>
<p id="P700049702700000000000000004153C" data-uri="chapter03.xhtml#P700049702700000000000000004153C" class="pcalibre1 pcalibre2 pcalibre10">This code uses three multiplications for the multiprecision arithmetic required to implement 128-bit arithmetic on a 64-bit machine. Describe the algorithm used to compute the product, and annotate the assembly code to show how it realizes your algorithm. <i class="pcalibre17 pcalibre2 pcalibre1">Hint:</i> When extending arguments of <var class="pcalibre17 pcalibre2 pcalibre1">x</var> and <var class="pcalibre17 pcalibre2 pcalibre1">y</var> to 128 bits, they can be rewritten as <var class="pcalibre17 pcalibre2 pcalibre1">x</var> = 2<sup class="pcalibre1 pcalibre2 pcalibre85">64</sup> · <i class="pcalibre17 pcalibre2 pcalibre1">x<sub class="pcalibre1 pcalibre2 calibre14">h</sub></i> + <i class="pcalibre17 pcalibre2 pcalibre1">x<sub class="pcalibre1 pcalibre2 calibre14">l</sub></i> and <var class="pcalibre17 pcalibre2 pcalibre1">y</var> = 2<sup class="pcalibre1 pcalibre2 pcalibre85">64</sup> · <i class="pcalibre17 pcalibre2 pcalibre1">y<sub class="pcalibre1 pcalibre2 calibre14">h</sub></i> + <i class="pcalibre17 pcalibre2 pcalibre1">y<sub class="pcalibre1 pcalibre2 calibre14">l</sub></i>, where <i class="pcalibre17 pcalibre2 pcalibre1">x<sub class="pcalibre1 pcalibre2 calibre14">h</sub></i>, <i class="pcalibre17 pcalibre2 pcalibre1">x<sub class="pcalibre1 pcalibre2 calibre14">l</sub></i>, <i class="pcalibre17 pcalibre2 pcalibre1">y<sub class="pcalibre1 pcalibre2 calibre14">h</sub></i>, and <i class="pcalibre17 pcalibre2 pcalibre1">y<sub class="pcalibre1 pcalibre2 calibre14">l</sub></i> are 64-bit values. Similarly, the 128-bit product can be written as <var class="pcalibre17 pcalibre2 pcalibre1">p</var> = 2<sup class="pcalibre1 pcalibre2 pcalibre85">64</sup> · <i class="pcalibre17 pcalibre2 pcalibre1">p<sub class="pcalibre1 pcalibre2 calibre14">h</sub></i> + <i class="pcalibre17 pcalibre2 pcalibre1">p<sub class="pcalibre1 pcalibre2 calibre14">l</sub></i>, where <i class="pcalibre17 pcalibre2 pcalibre1">p<sub class="pcalibre1 pcalibre2 calibre14">h</sub></i> and <i class="pcalibre17 pcalibre2 pcalibre1">p<sub class="pcalibre1 pcalibre2 calibre14">l</sub></i> are 64-bit values. Show how the code computes the values of <i class="pcalibre17 pcalibre2 pcalibre1">p<sub class="pcalibre1 pcalibre2 calibre14">h</sub></i> and <i class="pcalibre17 pcalibre2 pcalibre1">p<sub class="pcalibre1 pcalibre2 calibre14">l</sub></i> in terms of <i class="pcalibre17 pcalibre2 pcalibre1">x<sub class="pcalibre1 pcalibre2 calibre14">h</sub></i>, <i class="pcalibre17 pcalibre2 pcalibre1">x<sub class="pcalibre1 pcalibre2 calibre14">l</sub></i>, <i class="pcalibre17 pcalibre2 pcalibre1">y<sub class="pcalibre1 pcalibre2 calibre14">h</sub></i>, and <i class="pcalibre17 pcalibre2 pcalibre1">y<sub class="pcalibre1 pcalibre2 calibre14">l</sub></i>.</p>
</div></li></ol>
</section>
<section id="P7000497027000000000000000003303" data-uri="chapter03.xhtml#P7000497027000000000000000003303" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004153D" data-uri="chapter03.xhtml#P700049702700000000000000004153D" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.60 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004153E" data-uri="chapter03.xhtml#P700049702700000000000000004153E">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004153F" data-uri="chapter03.xhtml#P700049702700000000000000004153F">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041540" data-uri="chapter03.xhtml#P7000497027000000000000000041540"><p id="P7000497027000000000000000041541" data-uri="chapter03.xhtml#P7000497027000000000000000041541" class="pcalibre1 pcalibre2 pcalibre10">Consider the following assembly code:</p>
<pre id="P7000497027000000000000000041542" data-uri="chapter03.xhtml#P7000497027000000000000000041542" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041543" data-uri="chapter03.xhtml#P7000497027000000000000000041543" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long loop(long x, int n)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi, n in %esi</i>
1	loop:
2	  movl	%esi, %ecx
3	  movl	$1, %edx
4	  movl	$0, %eax
5	  jmp	.L2
6	.L3:
7	  movq	%rdi, %r8
8	  andq	%rdx, %r8
9	  orq	%r8, %rax
10	  salq	%cl, %rdx
11	.L2:
12	  testq	%rdx, %rdx
13	  jne	.L3
14	  rep; ret
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000041544" data-uri="chapter03.xhtml#P7000497027000000000000000041544">The preceding code was generated by compiling C code that had the following overall form:</p>
<pre id="P7000497027000000000000000041545" data-uri="chapter03.xhtml#P7000497027000000000000000041545" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041546" data-uri="chapter03.xhtml#P7000497027000000000000000041546" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000330E" title="313" data-uri="chapter03.xhtml#P700049702700000000000000000330E" epub:type="pagebreak"></span>1	long loop(long x, long n)
2	{
3		long result = _____;
4		long mask;
5		for (mask = _____; mask _____; mask = _____){
6			result	|	= _____;
7	}
8	return result;
9	}
</code></pre>
<p id="P7000497027000000000000000041547" data-uri="chapter03.xhtml#P7000497027000000000000000041547" class="pcalibre1 pcalibre2 pcalibre10">Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register <code id="P7000497027000000000000000041548" data-uri="chapter03.xhtml#P7000497027000000000000000041548" class="pcalibre1 calibre1 pcalibre2">%rax</code>. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000041549" data-uri="chapter03.xhtml#P7000497027000000000000000041549">
<li id="P700049702700000000000000004154A" data-uri="chapter03.xhtml#P700049702700000000000000004154A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004154B" data-uri="chapter03.xhtml#P700049702700000000000000004154B" class="pcalibre1 pcalibre2 pcalibre10">Which registers hold program values <code id="P700049702700000000000000004154C" data-uri="chapter03.xhtml#P700049702700000000000000004154C" class="pcalibre1 calibre1 pcalibre2">x, n, result</code>, and <code id="P700049702700000000000000004154D" data-uri="chapter03.xhtml#P700049702700000000000000004154D" class="pcalibre1 calibre1 pcalibre2">mask?</code></p></li>
<li id="P700049702700000000000000004154E" data-uri="chapter03.xhtml#P700049702700000000000000004154E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004154F" data-uri="chapter03.xhtml#P700049702700000000000000004154F" class="pcalibre1 pcalibre2 pcalibre10">What are the initial values of <code id="P7000497027000000000000000041550" data-uri="chapter03.xhtml#P7000497027000000000000000041550" class="pcalibre1 calibre1 pcalibre2">result</code> and <code id="P7000497027000000000000000041551" data-uri="chapter03.xhtml#P7000497027000000000000000041551" class="pcalibre1 calibre1 pcalibre2">mask?</code></p></li>
<li id="P7000497027000000000000000041552" data-uri="chapter03.xhtml#P7000497027000000000000000041552" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041553" data-uri="chapter03.xhtml#P7000497027000000000000000041553" class="pcalibre1 pcalibre2 pcalibre10">What is the test condition for <code id="P7000497027000000000000000041554" data-uri="chapter03.xhtml#P7000497027000000000000000041554" class="pcalibre1 calibre1 pcalibre2">mask?</code></p></li>
<li id="P7000497027000000000000000041555" data-uri="chapter03.xhtml#P7000497027000000000000000041555" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041556" data-uri="chapter03.xhtml#P7000497027000000000000000041556" class="pcalibre1 pcalibre2 pcalibre10">How does <code id="P7000497027000000000000000041557" data-uri="chapter03.xhtml#P7000497027000000000000000041557" class="pcalibre1 calibre1 pcalibre2">mask</code> get updated?</p></li>
<li id="P7000497027000000000000000041558" data-uri="chapter03.xhtml#P7000497027000000000000000041558" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041559" data-uri="chapter03.xhtml#P7000497027000000000000000041559" class="pcalibre1 pcalibre2 pcalibre10">How does <code id="P700049702700000000000000004155A" data-uri="chapter03.xhtml#P700049702700000000000000004155A" class="pcalibre1 calibre1 pcalibre2">result</code> get updated?</p></li>
<li id="P700049702700000000000000004155B" data-uri="chapter03.xhtml#P700049702700000000000000004155B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004155C" data-uri="chapter03.xhtml#P700049702700000000000000004155C" class="pcalibre1 pcalibre2 pcalibre10">Fill in all the missing parts of the C code.</p></li>
</ol></div></li></ol>
</section>
<section id="P7000497027000000000000000003325" data-uri="chapter03.xhtml#P7000497027000000000000000003325" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004155D" data-uri="chapter03.xhtml#P700049702700000000000000004155D" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.61 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004155E" data-uri="chapter03.xhtml#P700049702700000000000000004155E">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004155F" data-uri="chapter03.xhtml#P700049702700000000000000004155F">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041560" data-uri="chapter03.xhtml#P7000497027000000000000000041560"><p id="P7000497027000000000000000041561" data-uri="chapter03.xhtml#P7000497027000000000000000041561" class="pcalibre1 pcalibre2 pcalibre10">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.6.6</span></a>, we examined the following code as a candidate for the use of conditional data transfer:</p>
<pre id="P7000497027000000000000000041562" data-uri="chapter03.xhtml#P7000497027000000000000000041562" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041563" data-uri="chapter03.xhtml#P7000497027000000000000000041563" class="calibre3 pcalibre1 pcalibre2">
long cread(long *xp) {
	return (xp ? *xp : 0);
}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000041564" data-uri="chapter03.xhtml#P7000497027000000000000000041564">We showed a trial implementation using a conditional move instruction but argued that it was not valid, since it could attempt to read from a null address.</p>
<p id="P7000497027000000000000000041565" data-uri="chapter03.xhtml#P7000497027000000000000000041565" class="pcalibre1 pcalibre2 pcalibre10">Write a C function <code id="P7000497027000000000000000041566" data-uri="chapter03.xhtml#P7000497027000000000000000041566" class="pcalibre1 calibre1 pcalibre2">cread_alt</code> that has the same behavior as <code id="P7000497027000000000000000041567" data-uri="chapter03.xhtml#P7000497027000000000000000041567" class="pcalibre1 calibre1 pcalibre2">cread</code>, except that it can be compiled to use conditional data transfer. When compiled, the generated code should use a conditional move instruction rather than one of the jump instructions.</p>
</div></li></ol>
</section>
<section id="P7000497027000000000000000003331" data-uri="chapter03.xhtml#P7000497027000000000000000003331" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041568" data-uri="chapter03.xhtml#P7000497027000000000000000041568" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.62 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041569" data-uri="chapter03.xhtml#P7000497027000000000000000041569">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004156A" data-uri="chapter03.xhtml#P700049702700000000000000004156A">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004156B" data-uri="chapter03.xhtml#P700049702700000000000000004156B"><p id="P700049702700000000000000004156C" data-uri="chapter03.xhtml#P700049702700000000000000004156C" class="pcalibre1 pcalibre2 pcalibre10">The code that follows shows an example of branching on an enumerated type value in a switch statement. Recall that enumerated types in C are simply a way to introduce a set of names having associated integer values. By default, the values assigned to the names count from zero upward. In our code, the actions associated with the different case labels have been omitted.</p>
<pre id="P700049702700000000000000004156D" data-uri="chapter03.xhtml#P700049702700000000000000004156D" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004156E" data-uri="chapter03.xhtml#P700049702700000000000000004156E" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003339" title="314" data-uri="chapter03.xhtml#P7000497027000000000000000003339" epub:type="pagebreak"></span>1	/* Enumerated type creates set of constants numbered 0 and upward */
2	typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t;
3	
4	long switch3(long *p1, long *p2, mode_t action)
5	{
6		long result = 0;
7		switch(action) {
8		case MODE_A: 9
10		case MODE_B:
11	
12		case MODE_C:
13	
14		case MODE_D:
15	
16		case MODE_E:
17	
18		default:
19	
20		}
21		return result;
22	}
</code></pre>
<p id="P700049702700000000000000004156F" data-uri="chapter03.xhtml#P700049702700000000000000004156F" class="pcalibre1 pcalibre2 pcalibre10">The part of the generated assembly code implementing the different actions is shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003346"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.52</span></a>. The annotations indicate the argument locations, the register values, and the case labels for the different jump destinations.</p>
<p id="P7000497027000000000000000041570" data-uri="chapter03.xhtml#P7000497027000000000000000041570" class="pcalibre1 pcalibre2 pcalibre10">Fill in the missing parts of the C code. It contained one case that fell through to another—try to reconstruct this.</p>
</div></li></ol>
</section>
<section id="P700049702700000000000000000333C" data-uri="chapter03.xhtml#P700049702700000000000000000333C" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041571" data-uri="chapter03.xhtml#P7000497027000000000000000041571" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.63 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041572" data-uri="chapter03.xhtml#P7000497027000000000000000041572">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041573" data-uri="chapter03.xhtml#P7000497027000000000000000041573">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041574" data-uri="chapter03.xhtml#P7000497027000000000000000041574"><p id="P7000497027000000000000000041575" data-uri="chapter03.xhtml#P7000497027000000000000000041575" class="pcalibre1 pcalibre2 pcalibre10">This problem will give you a chance to reverse engineer a <code id="P7000497027000000000000000041576" data-uri="chapter03.xhtml#P7000497027000000000000000041576" class="pcalibre1 calibre1 pcalibre2">switch</code> statement from disassembled machine code. In the following procedure, the body of the <code id="P7000497027000000000000000041577" data-uri="chapter03.xhtml#P7000497027000000000000000041577" class="pcalibre1 calibre1 pcalibre2">switch</code> statement has been omitted:</p>
<pre id="P7000497027000000000000000041578" data-uri="chapter03.xhtml#P7000497027000000000000000041578" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041579" data-uri="chapter03.xhtml#P7000497027000000000000000041579" class="calibre3 pcalibre1 pcalibre2">
1	long switch_prob(long x, long n) {
2		long result = x;
3		switch(n) {
4			/* Fill in code here */ 5
6		}
7		return result;
8	}
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003346" data-uri="chapter03.xhtml#P7000497027000000000000000003346">
<pre id="P700049702700000000000000004157A" data-uri="chapter03.xhtml#P700049702700000000000000004157A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004157B" data-uri="chapter03.xhtml#P700049702700000000000000004157B" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003349" title="315" data-uri="chapter03.xhtml#P7000497027000000000000000003349" epub:type="pagebreak"></span>	<i class="pcalibre17 pcalibre2 pcalibre1">p1 in %rdi, p2 in %rsi, action in %edx</i>
1	.L8:	<i class="pcalibre17 pcalibre2 pcalibre1">MODE_E</i>
2	  movl	$27, %eax
3	  ret
4	.L3:	<i class="pcalibre17 pcalibre2 pcalibre1">MODE_A</i>
5	  movq	(%rsi), %rax
6	  movq	(%rdi), %rdx
7	  movq	%rdx, (%rsi)
8	  ret
9	.L5:	<i class="pcalibre17 pcalibre2 pcalibre1">MODE_B</i>
10	  movq	(%rdi), %rax
11	  addq	(%rsi), %rax
12	  movq	%rax, (%rdi)
13	  ret
14	.L6:	<i class="pcalibre17 pcalibre2 pcalibre1">MODE_C</i>
15	  movq	$59, (%rdi)
16	  movq	(%rsi), %rax
17	  ret
18	.L7:	<i class="pcalibre17 pcalibre2 pcalibre1">MODE_D</i>
19	  movq	(%rsi), %rax
20	  movq	%rax, (%rdi)
21	  movl	$27, %eax
22	  ret
23	.L9:	<i class="pcalibre17 pcalibre2 pcalibre1">default</i>
24	  movl	$12, %eax
25	  ret
</code></pre>
<figcaption id="P700049702700000000000000004157C" data-uri="chapter03.xhtml#P700049702700000000000000004157C" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004157D" data-uri="chapter03.xhtml#P700049702700000000000000004157D" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.52 </span>Assembly code for <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003331"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">3.62</span></a>.</h1></header><div class="pcalibre1 caption pcalibre2" id="P700049702700000000000000004157E" data-uri="chapter03.xhtml#P700049702700000000000000004157E"><p id="P700049702700000000000000004157F" data-uri="chapter03.xhtml#P700049702700000000000000004157F" class="pcalibre1 pcalibre2 pcalibre10">This code implements the different branches of a switch statement.</p></div></figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000041580" data-uri="chapter03.xhtml#P7000497027000000000000000041580"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003355"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.53</span></a> shows the disassembled machine code for the procedure.</p>
<p id="P7000497027000000000000000041581" data-uri="chapter03.xhtml#P7000497027000000000000000041581" class="pcalibre1 pcalibre2 pcalibre10">The jump table resides in a different area of memory. We can see from the indirect jump on line 5 that the jump table begins at address <code id="P7000497027000000000000000041582" data-uri="chapter03.xhtml#P7000497027000000000000000041582" class="pcalibre1 calibre1 pcalibre2">0x4006f8</code>. Using the <span class="pcalibre1 pcalibre29 pcalibre2">GDB </span>debugger, we can examine the six 8-byte words of memory comprising the jump table with the command <code id="P7000497027000000000000000041583" data-uri="chapter03.xhtml#P7000497027000000000000000041583" class="pcalibre1 calibre1 pcalibre2">x/6gx 0x4006f8.</code> <span class="pcalibre1 pcalibre29 pcalibre2">GDB </span>prints the following:</p>
<pre id="P7000497027000000000000000041584" data-uri="chapter03.xhtml#P7000497027000000000000000041584" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041585" data-uri="chapter03.xhtml#P7000497027000000000000000041585" class="calibre3 pcalibre1 pcalibre2">
(gdb) <i class="pcalibre17 pcalibre2 pcalibre1">x/6gx 0x4006f8</i>
0x4006f8:	0x00000000004005a1	0x00000000004005c3
0x400708:	0x00000000004005a1	0x00000000004005aa
0x400718:	0x00000000004005b2	0x00000000004005bf
</code></pre>
<p id="P7000497027000000000000000041586" data-uri="chapter03.xhtml#P7000497027000000000000000041586" class="pcalibre1 pcalibre2 pcalibre10">Fill in the body of the switch statement with C code that will have the same behavior as the machine code.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000003355" data-uri="chapter03.xhtml#P7000497027000000000000000003355">
<pre id="P7000497027000000000000000041587" data-uri="chapter03.xhtml#P7000497027000000000000000041587" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041588" data-uri="chapter03.xhtml#P7000497027000000000000000041588" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003358" title="316" data-uri="chapter03.xhtml#P7000497027000000000000000003358" epub:type="pagebreak"></span><i class="pcalibre17 pcalibre2 pcalibre1">long switch_prob(long x, long n)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi, n in %rsi</i>
1	0000000000400590 &lt;switch_prob&gt;:
2	400590: 48 83 ee 3c	sub	$0x3c,%rsi
3	400594: 48 83 fe 05	cmp	$0x5,%rsi
4	400598: 77 29	ja	4005c3 &lt;switch_prob+0x33&gt;
5	40059a: ff 24 f5 f8 06 40 00	jmpq	*0x4006f8(,%rsi,8)
6	4005a1: 48 8d 04 fd 00 00 00	lea	0x0(,%rdi,8),%rax
7	4005a8: 00
8	4005a9: c3	retq
9	4005aa: 4889f8	mov	%rdi,%rax
10	4005ad: 48 c1 f8 03	sar	$0x3,%rax
11	4005b1: c3	retq
12	4005b2: 4889f8	mov	%rdi,%rax
13	4005b5: 48 c1 e0 04	shl	$0x4,%rax
14	4005b9: 4829f8	sub	%rdi,%rax
15	4005bc: 4889c7	mov	%rax,%rdi
16	4005bf: 48 0f af ff	imul	%rdi,%rdi
17	4005c3: 48 8d 47 4b	lea	0x4b(%rdi),%rax
18	4005c7: c3	retq
</code></pre>
<figcaption id="P7000497027000000000000000041589" data-uri="chapter03.xhtml#P7000497027000000000000000041589" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004158A" data-uri="chapter03.xhtml#P700049702700000000000000004158A" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.53 </span>Disassembled code for <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000333C"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">3.63</span></a>.</h1></header></figcaption>
</figure>
</div></li></ol>
</section>
<section id="P700049702700000000000000000335B" data-uri="chapter03.xhtml#P700049702700000000000000000335B" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004158B" data-uri="chapter03.xhtml#P700049702700000000000000004158B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.64 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004158C" data-uri="chapter03.xhtml#P700049702700000000000000004158C">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004158D" data-uri="chapter03.xhtml#P700049702700000000000000004158D">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004158E" data-uri="chapter03.xhtml#P700049702700000000000000004158E"><p id="P700049702700000000000000004158F" data-uri="chapter03.xhtml#P700049702700000000000000004158F" class="pcalibre1 pcalibre2 pcalibre10">Consider the following source code, where <var class="pcalibre17 pcalibre2 pcalibre1">R</var>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var>, and <var class="pcalibre17 pcalibre2 pcalibre1">T</var> are constants declared with <code id="P7000497027000000000000000041590" data-uri="chapter03.xhtml#P7000497027000000000000000041590" class="pcalibre1 calibre1 pcalibre2">#define</code>:</p>
<pre id="P7000497027000000000000000041591" data-uri="chapter03.xhtml#P7000497027000000000000000041591" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041592" data-uri="chapter03.xhtml#P7000497027000000000000000041592" class="calibre3 pcalibre1 pcalibre2">
1	long A[R][S][T]; 
2
3	long store_ele(long i, long j, long k, long *dest)
4	{
5		*dest = A[i][j][k];
6		return sizeof(A);
7	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000041593" data-uri="chapter03.xhtml#P7000497027000000000000000041593">In compiling this program, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the following assembly code:</p>
<pre id="P7000497027000000000000000041594" data-uri="chapter03.xhtml#P7000497027000000000000000041594" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041595" data-uri="chapter03.xhtml#P7000497027000000000000000041595" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long store_ele(long i, long j, long k, long *dest)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">i in %rdi, j in %rsi, k in %rdx, dest in %rcx</i>
1	store_ele:
2	  leaq	(%rsi,%rsi,2), %rax
3	  leaq	(%rsi,%rax,4), %rax
4	  movq	%rdi, %rsi
5	  salq	$6, %rsi
6	  addq	%rsi, %rdi
7	  addq	%rax, %rdi
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003367" title="317" data-uri="chapter03.xhtml#P7000497027000000000000000003367" epub:type="pagebreak"></span>8	  addq	%rdi, %rdx
9	  movq	A(,%rdx,8), %rax
10	  movq	%rax, (%rcx)
11	  movl	$3640, %eax
12	  ret
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000041596" data-uri="chapter03.xhtml#P7000497027000000000000000041596">
<li id="P7000497027000000000000000041597" data-uri="chapter03.xhtml#P7000497027000000000000000041597" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041598" data-uri="chapter03.xhtml#P7000497027000000000000000041598" class="pcalibre1 pcalibre2 pcalibre10">Extend <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002B19.xhtml#P7000497027000000000000000002C39"><span class="pcalibre1 pcalibre21 pcalibre2">Equation </span><span class="pcalibre1 pcalibre21 pcalibre2">3.1</span></a> from two dimensions to three to provide a formula for the location of array element <code id="P7000497027000000000000000041599" data-uri="chapter03.xhtml#P7000497027000000000000000041599" class="pcalibre1 calibre1 pcalibre2">A[i][j][k]</code>.</p></li>
<li id="P700049702700000000000000004159A" data-uri="chapter03.xhtml#P700049702700000000000000004159A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004159B" data-uri="chapter03.xhtml#P700049702700000000000000004159B" class="pcalibre1 pcalibre2 pcalibre10">Use your reverse engineering skills to determine the values of <var class="pcalibre17 pcalibre2 pcalibre1">R</var>, <var class="pcalibre17 pcalibre2 pcalibre1">S</var>, and <var class="pcalibre17 pcalibre2 pcalibre1">T</var> based on the assembly code.</p></li>
</ol></div></li></ol>
</section>
<section id="P700049702700000000000000000336E" data-uri="chapter03.xhtml#P700049702700000000000000000336E" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004159C" data-uri="chapter03.xhtml#P700049702700000000000000004159C" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.65 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004159D" data-uri="chapter03.xhtml#P700049702700000000000000004159D">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004159E" data-uri="chapter03.xhtml#P700049702700000000000000004159E">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004159F" data-uri="chapter03.xhtml#P700049702700000000000000004159F"><p id="P70004970270000000000000000415A0" data-uri="chapter03.xhtml#P70004970270000000000000000415A0" class="pcalibre1 pcalibre2 pcalibre10">The following code transposes the elements of an <var class="pcalibre17 pcalibre2 pcalibre1">M</var> × <var class="pcalibre17 pcalibre2 pcalibre1">M</var> array, where <var class="pcalibre17 pcalibre2 pcalibre1">M</var> is a constant defined by <code id="P70004970270000000000000000415A1" data-uri="chapter03.xhtml#P70004970270000000000000000415A1" class="pcalibre1 calibre1 pcalibre2">#define</code>:</p>
<pre id="P70004970270000000000000000415A2" data-uri="chapter03.xhtml#P70004970270000000000000000415A2" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000415A3" data-uri="chapter03.xhtml#P70004970270000000000000000415A3" class="calibre3 pcalibre1 pcalibre2">
1	void transpose(long A[M][M]) {
2		long i, j;
3		for (i = 0; i &lt; M; i++)
4			for (j = 0; j &lt; i; j++) {
5				long t = A[i][j];
6				A[i][j] = A[j][i];
7				A[j][i] = t;
8			}
9	}
</code></pre>
<p id="P70004970270000000000000000415A4" data-uri="chapter03.xhtml#P70004970270000000000000000415A4" class="pcalibre1 pcalibre2 pcalibre10">When compiled with optimization level –01, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the following code for the inner loop of the function:</p>
<pre id="P70004970270000000000000000415A5" data-uri="chapter03.xhtml#P70004970270000000000000000415A5" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000415A6" data-uri="chapter03.xhtml#P70004970270000000000000000415A6" class="calibre3 pcalibre1 pcalibre2">
1	.L6:
2	  movq	(%rdx), %rcx
3	  movq	(%rax), %rsi
4	  movq	%rsi, (%rdx)
5	  movq	%rcx, (%rax)
6	  addq	$8, %rdx
7	  addq	$120, %rax
8	  cmpq	%rdi, %rax
9	  jne	.L6
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000415A7" data-uri="chapter03.xhtml#P70004970270000000000000000415A7">We can see that <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>has converted the array indexing to pointer code.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000415A8" data-uri="chapter03.xhtml#P70004970270000000000000000415A8">
<li id="P70004970270000000000000000415A9" data-uri="chapter03.xhtml#P70004970270000000000000000415A9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000415AA" data-uri="chapter03.xhtml#P70004970270000000000000000415AA" class="pcalibre1 pcalibre2 pcalibre10">Which register holds a pointer to array element <code id="P70004970270000000000000000415AB" data-uri="chapter03.xhtml#P70004970270000000000000000415AB" class="pcalibre1 calibre1 pcalibre2">A[i][j]?</code></p></li>
<li id="P70004970270000000000000000415AC" data-uri="chapter03.xhtml#P70004970270000000000000000415AC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000415AD" data-uri="chapter03.xhtml#P70004970270000000000000000415AD" class="pcalibre1 pcalibre2 pcalibre10">Which register holds a pointer to array element <code id="P70004970270000000000000000415AE" data-uri="chapter03.xhtml#P70004970270000000000000000415AE" class="pcalibre1 calibre1 pcalibre2">A[j][i]?</code></p></li>
<li id="P70004970270000000000000000415AF" data-uri="chapter03.xhtml#P70004970270000000000000000415AF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000415B0" data-uri="chapter03.xhtml#P70004970270000000000000000415B0" class="pcalibre1 pcalibre2 pcalibre10">What is the value of <var class="pcalibre17 pcalibre2 pcalibre1">M</var>?</p></li>
</ol></div></li></ol>
</section>
<section id="P7000497027000000000000000003384" data-uri="chapter03.xhtml#P7000497027000000000000000003384" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000415B1" data-uri="chapter03.xhtml#P70004970270000000000000000415B1" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.66 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000415B2" data-uri="chapter03.xhtml#P70004970270000000000000000415B2">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000415B3" data-uri="chapter03.xhtml#P70004970270000000000000000415B3">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000415B4" data-uri="chapter03.xhtml#P70004970270000000000000000415B4"><p id="P70004970270000000000000000415B5" data-uri="chapter03.xhtml#P70004970270000000000000000415B5" class="pcalibre1 pcalibre2 pcalibre10">Consider the following source code, where <code id="P70004970270000000000000000415B6" data-uri="chapter03.xhtml#P70004970270000000000000000415B6" class="pcalibre1 calibre1 pcalibre2">NR</code> and <code id="P70004970270000000000000000415B7" data-uri="chapter03.xhtml#P70004970270000000000000000415B7" class="pcalibre1 calibre1 pcalibre2">NC</code> are macro expressions declared with <code id="P70004970270000000000000000415B8" data-uri="chapter03.xhtml#P70004970270000000000000000415B8" class="pcalibre1 calibre1 pcalibre2">#define</code> that compute the dimensions of array A in terms of parameter <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. This code computes the sum of the elements of column <var class="pcalibre17 pcalibre2 pcalibre1">j</var> of the array.</p>
<pre id="P70004970270000000000000000415B9" data-uri="chapter03.xhtml#P70004970270000000000000000415B9" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000415BA" data-uri="chapter03.xhtml#P70004970270000000000000000415BA" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000338F" title="318" data-uri="chapter03.xhtml#P700049702700000000000000000338F" epub:type="pagebreak"></span>1	long sum_col(long n, long A[NR(n)][NC(n)], long j) {
2		long i;
3		long result = 0;
4		for (i = 0; i &lt; NR(n); i++)
5			result += A[i][j];
6		return result;
7	}
</code></pre>
<p id="P70004970270000000000000000415BB" data-uri="chapter03.xhtml#P70004970270000000000000000415BB" class="pcalibre1 pcalibre2 pcalibre10">In compiling this program, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the following assembly code:</p>
<pre id="P70004970270000000000000000415BC" data-uri="chapter03.xhtml#P70004970270000000000000000415BC" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000415BD" data-uri="chapter03.xhtml#P70004970270000000000000000415BD" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long sum_col(long n, long A[NR(n)][NC(n)], long j)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">n in %rdi, A in %rsi, j in %rdx</i>
1	sum_col:
2	  leaq	1(,%rdi,4), %r8
3	  leaq	(%rdi,%rdi,2), %rax
4	  movq	%rax, %rdi
5	  testq	%rax, %rax
6	  jle	.L4
7	  salq	$3, %r8
8	  leaq	(%rsi,%rdx,8), %rcx
9	  movl	$0, %eax
10	  movl	$0, %edx
11	.L3:
12	  addq	(%rcx), %rax
13	  addq	$1, %rdx
14	  addq	%r8, %rcx
15	  cmpq	%rdi, %rdx
16	  jne	.L3
17	  rep;	ret
18	.L4:
19	  movl	$0, %eax
20	  ret
</code></pre>
<p id="P70004970270000000000000000415BE" data-uri="chapter03.xhtml#P70004970270000000000000000415BE" class="pcalibre1 pcalibre2 pcalibre10">Use your reverse engineering skills to determine the definitions of <code id="P70004970270000000000000000415BF" data-uri="chapter03.xhtml#P70004970270000000000000000415BF" class="pcalibre1 calibre1 pcalibre2">NR</code> and <code id="P70004970270000000000000000415C0" data-uri="chapter03.xhtml#P70004970270000000000000000415C0" class="pcalibre1 calibre1 pcalibre2">NC</code>.</p>
</div></li></ol>
</section>
<section id="P7000497027000000000000000003396" data-uri="chapter03.xhtml#P7000497027000000000000000003396" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000415C1" data-uri="chapter03.xhtml#P70004970270000000000000000415C1" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.67 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000415C2" data-uri="chapter03.xhtml#P70004970270000000000000000415C2">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000415C3" data-uri="chapter03.xhtml#P70004970270000000000000000415C3">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000415C4" data-uri="chapter03.xhtml#P70004970270000000000000000415C4"><p id="P70004970270000000000000000415C5" data-uri="chapter03.xhtml#P70004970270000000000000000415C5" class="pcalibre1 pcalibre2 pcalibre10">For this exercise, we will examine the code generated by <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>for functions that have structures as arguments and return values, and from this see how these language features are typically implemented.</p>
<p id="P70004970270000000000000000415C6" data-uri="chapter03.xhtml#P70004970270000000000000000415C6" class="pcalibre1 pcalibre2 pcalibre10">The following C code has a function process having structures as argument and return values, and a function eval that calls process:</p>
<pre id="P70004970270000000000000000415C7" data-uri="chapter03.xhtml#P70004970270000000000000000415C7" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000415C8" data-uri="chapter03.xhtml#P70004970270000000000000000415C8" class="calibre3 pcalibre1 pcalibre2">
1	typedef struct {
2		long a[2];
3		long *p;
4	} strA;
5	
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000339F" title="319" data-uri="chapter03.xhtml#P700049702700000000000000000339F" epub:type="pagebreak"></span>6	typedef struct {
7		long u[2];
8		long q;
9	} strB;
10	
11	strB process(strA s) {
12		strB r;
13		r.u[0] = s.a[1];
14		r.u[1] = s.a[0];
15		r.q = *s.p;
16		return r;
17	}
18	
19	long eval(long x, long y, long z) {
20		strA s;
21		s.a[0] = x;
22		s.a[1] = y;
23		s.p = &amp;z;
24		strB r = process(s);
25		return r.u[0] + r.u[1] + r.q;
26	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000415C9" data-uri="chapter03.xhtml#P70004970270000000000000000415C9">G<span class="pcalibre1 pcalibre29 pcalibre2">cc </span>generates the following code for these two functions:</p>
<pre id="P70004970270000000000000000415CA" data-uri="chapter03.xhtml#P70004970270000000000000000415CA" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000415CB" data-uri="chapter03.xhtml#P70004970270000000000000000415CB" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">strB process(strA s)</i>
1	process:
2	  movq	%rdi, %rax
3	  movq	24(%rsp), %rdx
4	  movq	(%rdx), %rdx
5	  movq	16(%rsp), %rcx
6	  movq	%rcx, (%rdi)
7	  movq	8(%rsp), %rcx
8	  movq	%rcx, 8(%rdi)
9	  movq	%rdx, 16(%rdi)
10	  ret
	<i class="pcalibre17 pcalibre2 pcalibre1">long eval(long x, long y, long z)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">x in %rdi, y in %rsi, z in %rdx</i>
1	eval:
2	  subq	$104, %rsp
3	  movq	%rdx, 24(%rsp)
4	  leaq	24(%rsp), %rax
5	  movq	%rdi, (%rsp)
6	  movq	%rsi, 8(%rsp)
7	  movq	%rax, 16(%rsp)
8	  leaq	64(%rsp), %rdi
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000033A3" title="320" data-uri="chapter03.xhtml#P70004970270000000000000000033A3" epub:type="pagebreak"></span>9	  call	process
10	  movq	72(%rsp), %rax
11	  addq	64(%rsp), %rax
12	  addq	80(%rsp), %rax
13	  addq	$104, %rsp
14	  ret
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000415CC" data-uri="chapter03.xhtml#P70004970270000000000000000415CC">
<li id="P70004970270000000000000000415CD" data-uri="chapter03.xhtml#P70004970270000000000000000415CD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000415CE" data-uri="chapter03.xhtml#P70004970270000000000000000415CE" class="pcalibre1 pcalibre2 pcalibre10">We can see on line 2 of function eval that it allocates 104 bytes on the stack. Diagram the stack frame for <code id="P70004970270000000000000000415CF" data-uri="chapter03.xhtml#P70004970270000000000000000415CF" class="pcalibre1 calibre1 pcalibre2">eval</code>, showing the values that it stores on the stack prior to calling <code id="P70004970270000000000000000415D0" data-uri="chapter03.xhtml#P70004970270000000000000000415D0" class="pcalibre1 calibre1 pcalibre2">process</code>.</p></li>
<li id="P70004970270000000000000000415D1" data-uri="chapter03.xhtml#P70004970270000000000000000415D1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000415D2" data-uri="chapter03.xhtml#P70004970270000000000000000415D2" class="pcalibre1 pcalibre2 pcalibre10">What value does <code id="P70004970270000000000000000415D3" data-uri="chapter03.xhtml#P70004970270000000000000000415D3" class="pcalibre1 calibre1 pcalibre2">eval</code> pass in its call to <code id="P70004970270000000000000000415D4" data-uri="chapter03.xhtml#P70004970270000000000000000415D4" class="pcalibre1 calibre1 pcalibre2">process?</code></p></li>
<li id="P70004970270000000000000000415D5" data-uri="chapter03.xhtml#P70004970270000000000000000415D5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000415D6" data-uri="chapter03.xhtml#P70004970270000000000000000415D6" class="pcalibre1 pcalibre2 pcalibre10">How does the code for <code id="P70004970270000000000000000415D7" data-uri="chapter03.xhtml#P70004970270000000000000000415D7" class="pcalibre1 calibre1 pcalibre2">process</code> access the elements of structure arguments?</p></li>
<li id="P70004970270000000000000000415D8" data-uri="chapter03.xhtml#P70004970270000000000000000415D8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000415D9" data-uri="chapter03.xhtml#P70004970270000000000000000415D9" class="pcalibre1 pcalibre2 pcalibre10">How does the code for <code id="P70004970270000000000000000415DA" data-uri="chapter03.xhtml#P70004970270000000000000000415DA" class="pcalibre1 calibre1 pcalibre2">process</code> set the fields of result structure <code id="P70004970270000000000000000415DB" data-uri="chapter03.xhtml#P70004970270000000000000000415DB" class="pcalibre1 calibre1 pcalibre2">r?</code></p></li>
<li id="P70004970270000000000000000415DC" data-uri="chapter03.xhtml#P70004970270000000000000000415DC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000415DD" data-uri="chapter03.xhtml#P70004970270000000000000000415DD" class="pcalibre1 pcalibre2 pcalibre10">Complete your diagram of the stack frame for <code id="P70004970270000000000000000415DE" data-uri="chapter03.xhtml#P70004970270000000000000000415DE" class="pcalibre1 calibre1 pcalibre2">eval</code>, showing how <code id="P70004970270000000000000000415DF" data-uri="chapter03.xhtml#P70004970270000000000000000415DF" class="pcalibre1 calibre1 pcalibre2">eval</code> accesses the elements of structure <code id="P70004970270000000000000000415E0" data-uri="chapter03.xhtml#P70004970270000000000000000415E0" class="pcalibre1 calibre1 pcalibre2">r</code> following the return from process.</p></li>
<li id="P70004970270000000000000000415E1" data-uri="chapter03.xhtml#P70004970270000000000000000415E1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000415E2" data-uri="chapter03.xhtml#P70004970270000000000000000415E2" class="pcalibre1 pcalibre2 pcalibre10">What general principles can you discern about how structure values are passed as function arguments and how they are returned as function results?</p></li>
</ol></div></li></ol>
</section>
<section id="P70004970270000000000000000033BB" data-uri="chapter03.xhtml#P70004970270000000000000000033BB" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000415E3" data-uri="chapter03.xhtml#P70004970270000000000000000415E3" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.68 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000415E4" data-uri="chapter03.xhtml#P70004970270000000000000000415E4">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000415E5" data-uri="chapter03.xhtml#P70004970270000000000000000415E5">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000415E6" data-uri="chapter03.xhtml#P70004970270000000000000000415E6"><p id="P70004970270000000000000000415E7" data-uri="chapter03.xhtml#P70004970270000000000000000415E7" class="pcalibre1 pcalibre2 pcalibre10">In the following code, <var class="pcalibre17 pcalibre2 pcalibre1">A</var> and <var class="pcalibre17 pcalibre2 pcalibre1">B</var> are constants defined with <code id="P70004970270000000000000000415E8" data-uri="chapter03.xhtml#P70004970270000000000000000415E8" class="pcalibre1 calibre1 pcalibre2">#define:</code></p>
<pre id="P70004970270000000000000000415E9" data-uri="chapter03.xhtml#P70004970270000000000000000415E9" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000415EA" data-uri="chapter03.xhtml#P70004970270000000000000000415EA" class="calibre3 pcalibre1 pcalibre2">
1	typedef struct {
2		int x[A][B]; /* Unknown constants A and B */
3		long y;
4	} str1;
5	
6	typedef struct {
7		char array[B];
8		int t;
9		short s[A];
10		long u;
11	} str2;
12	
13	void setVal(str1 *p, str2 *q) {
14		long v1 = q-&lt;t;
15		long v2 = q-&lt;u;
16		p-&lt;y = v1+v2;
17	}
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P70004970270000000000000000415EB" data-uri="chapter03.xhtml#P70004970270000000000000000415EB">G<span class="pcalibre1 pcalibre29 pcalibre2">cc </span>generates the following code for <code id="P70004970270000000000000000415EC" data-uri="chapter03.xhtml#P70004970270000000000000000415EC" class="pcalibre1 calibre1 pcalibre2">setVal:</code></p>
<pre id="P70004970270000000000000000415ED" data-uri="chapter03.xhtml#P70004970270000000000000000415ED" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000415EE" data-uri="chapter03.xhtml#P70004970270000000000000000415EE" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">void setVal(str1 *p, str2 *q) p in %rdi, q in %rsi</i>
1	setVal:
2	  movslq	8(%rsi), %rax
3	  addq	32(%rsi), %rax
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000033C8" title="321" data-uri="chapter03.xhtml#P70004970270000000000000000033C8" epub:type="pagebreak"></span>4	  movq	%rax, 184(%rdi)
5	  ret
</code></pre>
<p id="P70004970270000000000000000415EF" data-uri="chapter03.xhtml#P70004970270000000000000000415EF" class="pcalibre1 pcalibre2 pcalibre10">What are the values of <var class="pcalibre17 pcalibre2 pcalibre1">A</var> and <var class="pcalibre17 pcalibre2 pcalibre1">B</var>? (The solution is unique.)</p>
</div></li></ol>
</section>
<section id="P70004970270000000000000000033CA" data-uri="chapter03.xhtml#P70004970270000000000000000033CA" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000415F0" data-uri="chapter03.xhtml#P70004970270000000000000000415F0" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.69 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000415F1" data-uri="chapter03.xhtml#P70004970270000000000000000415F1">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000415F2" data-uri="chapter03.xhtml#P70004970270000000000000000415F2">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000415F3" data-uri="chapter03.xhtml#P70004970270000000000000000415F3"><p id="P70004970270000000000000000415F4" data-uri="chapter03.xhtml#P70004970270000000000000000415F4" class="pcalibre1 pcalibre2 pcalibre10">You are charged with maintaining a large C program, and you come across the following code:</p>
<pre id="P70004970270000000000000000415F5" data-uri="chapter03.xhtml#P70004970270000000000000000415F5" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000415F6" data-uri="chapter03.xhtml#P70004970270000000000000000415F6" class="calibre3 pcalibre1 pcalibre2">
1	typedef struct {
2		int first;
3		a_struct a[CNT];
4		int last;
5	} b_struct;
6	
7	void test(long i, b_struct *bp)
8	{
9		int n = bp-&gt;first + bp-&gt;last;
10		a_struct *ap = &amp;bp-&gt;a[i];
11		ap-&gt;x[ap-&gt;idx] = n;
12	}
</code></pre>
<p id="P70004970270000000000000000415F7" data-uri="chapter03.xhtml#P70004970270000000000000000415F7" class="pcalibre1 pcalibre2 pcalibre10">The declarations of the compile-time constant <code id="P70004970270000000000000000415F8" data-uri="chapter03.xhtml#P70004970270000000000000000415F8" class="pcalibre1 calibre1 pcalibre2">CNT</code> and the structure <code id="P70004970270000000000000000415F9" data-uri="chapter03.xhtml#P70004970270000000000000000415F9" class="pcalibre1 calibre1 pcalibre2">a_struct</code> are in a file for which you do not have the necessary access privilege. Fortunately, you have a copy of the <code id="P70004970270000000000000000415FA" data-uri="chapter03.xhtml#P70004970270000000000000000415FA" class="pcalibre1 calibre1 pcalibre2">.o</code> version of code, which you are able to disassemble with the <span class="pcalibre1 pcalibre29 pcalibre2">objdump </span>program, yielding the following disassembly:</p>
<pre id="P70004970270000000000000000415FB" data-uri="chapter03.xhtml#P70004970270000000000000000415FB" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000415FC" data-uri="chapter03.xhtml#P70004970270000000000000000415FC" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">void test(long i, b_struct *bp)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">i in %rdi, bp in %rsi</i>
1	0000000000000000 &lt;test&gt;:
2	 0: 8b 8e 20 01 00 00	mov	0x120(%rsi),%ecx
3	 6: 030e		add	(%rsi),%ecx
4	 8: 48 8d 04 bf		lea	(%rdi,%rdi,4),%rax
5	 c: 48 8d 04 c6		lea	(%rsi,%rax,8),%rax
6	 10: 48 8b 50 08	mov	0x8(%rax),%rdx
7	 14: 48 63 c9		movslq	%ecx,%rcx
8	 17: 48 89 4c d0 10	mov	%rcx,0x10(%rax,%rdx,8)
9	 1c: c3			retq
</code></pre>
<p id="P70004970270000000000000000415FD" data-uri="chapter03.xhtml#P70004970270000000000000000415FD" class="pcalibre1 pcalibre2 pcalibre10">Using your reverse engineering skills, deduce the following:</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000415FE" data-uri="chapter03.xhtml#P70004970270000000000000000415FE">
<li id="P70004970270000000000000000415FF" data-uri="chapter03.xhtml#P70004970270000000000000000415FF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041600" data-uri="chapter03.xhtml#P7000497027000000000000000041600" class="pcalibre1 pcalibre2 pcalibre10">The value of <code id="P7000497027000000000000000041601" data-uri="chapter03.xhtml#P7000497027000000000000000041601" class="pcalibre1 calibre1 pcalibre2">CNT.</code></p></li>
<li id="P7000497027000000000000000041602" data-uri="chapter03.xhtml#P7000497027000000000000000041602" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041603" data-uri="chapter03.xhtml#P7000497027000000000000000041603" class="pcalibre1 pcalibre2 pcalibre10">A complete declaration of structure <code id="P7000497027000000000000000041604" data-uri="chapter03.xhtml#P7000497027000000000000000041604" class="pcalibre1 calibre1 pcalibre2">a_struct.</code> Assume that the only fields in this structure are <code id="P7000497027000000000000000041605" data-uri="chapter03.xhtml#P7000497027000000000000000041605" class="pcalibre1 calibre1 pcalibre2">idx</code> and <code id="P7000497027000000000000000041606" data-uri="chapter03.xhtml#P7000497027000000000000000041606" class="pcalibre1 calibre1 pcalibre2">x</code>, and that both of these contain signed values.</p></li>
</ol></div></li></ol>
</section>
<section id="P70004970270000000000000000033E2" data-uri="chapter03.xhtml#P70004970270000000000000000033E2" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041607" data-uri="chapter03.xhtml#P7000497027000000000000000041607" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000033E4" title="322" data-uri="chapter03.xhtml#P70004970270000000000000000033E4" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">3.70 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041608" data-uri="chapter03.xhtml#P7000497027000000000000000041608">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041609" data-uri="chapter03.xhtml#P7000497027000000000000000041609">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004160A" data-uri="chapter03.xhtml#P700049702700000000000000004160A"><p id="P700049702700000000000000004160B" data-uri="chapter03.xhtml#P700049702700000000000000004160B" class="pcalibre1 pcalibre2 pcalibre10">Consider the following union declaration:</p>
<pre id="P700049702700000000000000004160C" data-uri="chapter03.xhtml#P700049702700000000000000004160C" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004160D" data-uri="chapter03.xhtml#P700049702700000000000000004160D" class="calibre3 pcalibre1 pcalibre2">
1	union ele {
2		struct {
3			long *p;
4			long y;
5		} e1;
6		struct {
7			long x;
8			union ele *next;
9		} e2;
10	};
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P700049702700000000000000004160E" data-uri="chapter03.xhtml#P700049702700000000000000004160E">This declaration illustrates that structures can be embedded within unions.</p>
<p id="P700049702700000000000000004160F" data-uri="chapter03.xhtml#P700049702700000000000000004160F" class="pcalibre1 pcalibre2 pcalibre10">The following function (with some expressions omitted) operates on a linked list having these unions as list elements:</p>
<pre id="P7000497027000000000000000041610" data-uri="chapter03.xhtml#P7000497027000000000000000041610" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041611" data-uri="chapter03.xhtml#P7000497027000000000000000041611" class="calibre3 pcalibre1 pcalibre2">
1	void proc (union ele *up) {
2		up-&gt; _____ = *(_____) - _____;
3	}
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000041612" data-uri="chapter03.xhtml#P7000497027000000000000000041612">
<li id="P7000497027000000000000000041613" data-uri="chapter03.xhtml#P7000497027000000000000000041613" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041614" data-uri="chapter03.xhtml#P7000497027000000000000000041614" class="pcalibre1 pcalibre2 pcalibre10">What are the offsets (in bytes) of the following fields:</p>
<pre id="P7000497027000000000000000041615" data-uri="chapter03.xhtml#P7000497027000000000000000041615" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041616" data-uri="chapter03.xhtml#P7000497027000000000000000041616" class="calibre3 pcalibre1 pcalibre2">
e1.p	_____
e1.y	_____
e2.x	_____
e2.next	_____
</code></pre></li>
<li id="P7000497027000000000000000041617" data-uri="chapter03.xhtml#P7000497027000000000000000041617" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041618" data-uri="chapter03.xhtml#P7000497027000000000000000041618" class="pcalibre1 pcalibre2 pcalibre10">How many total bytes does the structure require?</p></li>
<li id="P7000497027000000000000000041619" data-uri="chapter03.xhtml#P7000497027000000000000000041619" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004161A" data-uri="chapter03.xhtml#P700049702700000000000000004161A" class="pcalibre1 pcalibre2 pcalibre10">The compiler generates the following assembly code for <code id="P700049702700000000000000004161B" data-uri="chapter03.xhtml#P700049702700000000000000004161B" class="pcalibre1 calibre1 pcalibre2">proc:</code></p>
<pre id="P700049702700000000000000004161C" data-uri="chapter03.xhtml#P700049702700000000000000004161C" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004161D" data-uri="chapter03.xhtml#P700049702700000000000000004161D" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">void proc (union ele *up) up in %rdi</i>
1	proc:
2	movq	8(%rdi), %rax
3	movq	(%rax), %rdx
4	movq	(%rdx), %rdx
5	subq	8(%rax), %rdx
6	movq	%rdx, (%rdi)
7	ret
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P700049702700000000000000004161E" data-uri="chapter03.xhtml#P700049702700000000000000004161E">On the basis of this information, fill in the missing expressions in the code for <code id="P700049702700000000000000004161F" data-uri="chapter03.xhtml#P700049702700000000000000004161F" class="pcalibre1 calibre1 pcalibre2">proc.</code> <i class="pcalibre17 pcalibre2 pcalibre1">Hint:</i> Some union references can have ambiguous interpretations. These ambiguities get resolved as you see where the references lead. There <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000033FD" title="323" data-uri="chapter03.xhtml#P70004970270000000000000000033FD" epub:type="pagebreak"></span>is only one answer that does not perform any casting and does not violate any type constraints.</p></li>
</ol></div></li></ol>
</section>
<section id="P70004970270000000000000000033FE" data-uri="chapter03.xhtml#P70004970270000000000000000033FE" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041620" data-uri="chapter03.xhtml#P7000497027000000000000000041620" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.71 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041621" data-uri="chapter03.xhtml#P7000497027000000000000000041621">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041622" data-uri="chapter03.xhtml#P7000497027000000000000000041622">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041623" data-uri="chapter03.xhtml#P7000497027000000000000000041623"><p id="P7000497027000000000000000041624" data-uri="chapter03.xhtml#P7000497027000000000000000041624" class="pcalibre1 pcalibre2 pcalibre10">Write a function <code id="P7000497027000000000000000041625" data-uri="chapter03.xhtml#P7000497027000000000000000041625" class="pcalibre1 calibre1 pcalibre2">good_echo</code> that reads a line from standard input and writes it to standard output. Your implementation should work for an input line of arbitrary length. You may use the library function <code id="P7000497027000000000000000041626" data-uri="chapter03.xhtml#P7000497027000000000000000041626" class="pcalibre1 calibre1 pcalibre2">fgets</code>, but you must make sure your function works correctly even when the input line requires more space than you have allocated for your buffer. Your code should also check for error conditions and return when one is encountered. Refer to the definitions of the standard I/O functions for documentation <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3FC">[45,</a> <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41C">61]</a>.</p></div></li></ol>
</section>
<section id="P7000497027000000000000000003406" data-uri="chapter03.xhtml#P7000497027000000000000000003406" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041627" data-uri="chapter03.xhtml#P7000497027000000000000000041627" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.72 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041628" data-uri="chapter03.xhtml#P7000497027000000000000000041628">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041629" data-uri="chapter03.xhtml#P7000497027000000000000000041629">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004162A" data-uri="chapter03.xhtml#P700049702700000000000000004162A"><p id="P700049702700000000000000004162B" data-uri="chapter03.xhtml#P700049702700000000000000004162B" class="pcalibre1 pcalibre2 pcalibre10"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000340F"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.54(a)</span></a> shows the code for a function that is similar to function <code id="P700049702700000000000000004162C" data-uri="chapter03.xhtml#P700049702700000000000000004162C" class="pcalibre1 calibre1 pcalibre2">vfunct</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002E6D.xhtml#P7000497027000000000000000003022"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.43(a)</span></a>). We used <code id="P700049702700000000000000004162D" data-uri="chapter03.xhtml#P700049702700000000000000004162D" class="pcalibre1 calibre1 pcalibre2">vfunct</code> to illustrate the use of a frame pointer in managing variable-size stack frames. The new function <code id="P700049702700000000000000004162E" data-uri="chapter03.xhtml#P700049702700000000000000004162E" class="pcalibre1 calibre1 pcalibre2">aframe</code> allocates space for local</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000340F" data-uri="chapter03.xhtml#P700049702700000000000000000340F">
<p id="P700049702700000000000000004162F" data-uri="chapter03.xhtml#P700049702700000000000000004162F" class="pcalibre1 pcalibre2 pcalibre10">(a) C code</p>
<pre id="P7000497027000000000000000041630" data-uri="chapter03.xhtml#P7000497027000000000000000041630" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041631" data-uri="chapter03.xhtml#P7000497027000000000000000041631" class="calibre3 pcalibre1 pcalibre2">
1	#include &lt;alloca.h&gt;
2	
3	long aframe(long n, long idx, long *q) {
4		long i;
5		long **p = alloca(n * sizeof(long *));
6		p[0] = &amp;i;
7		for (i = 1; i &lt; n; i++)
8			p[i] = q;
9		return *p[idx];
10 }
</code></pre>
<p id="P7000497027000000000000000041632" data-uri="chapter03.xhtml#P7000497027000000000000000041632" class="pcalibre1 pcalibre2 pcalibre10">(b) Portions of generated assembly code</p>
<pre id="P7000497027000000000000000041633" data-uri="chapter03.xhtml#P7000497027000000000000000041633" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041634" data-uri="chapter03.xhtml#P7000497027000000000000000041634" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">long aframe(long n, long idx, long *q)</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">n in %rdi, idx in %rsi, q in %rdx</i>
1	aframe:
2	pushq	%rbp
3	movq	%rsp, %rbp
4	subq	$16, %rsp <i class="pcalibre17 pcalibre2 pcalibre1">Allocate space for i (%rsp = s</i><sub class="pcalibre1 pcalibre2 pcalibre122">1</sub>)
5	leaq	30(,%rdi,8), %rax
6	andq	$-16, %rax
7	subq	%rax, %rsp <i class="pcalibre17 pcalibre2 pcalibre1">Allocate space for array p (%rsp = s</i><sub class="pcalibre1 pcalibre2 pcalibre122">2</sub>)
8	leaq	15(%rsp), %r8
9	andq	$-16, %r8 <i class="pcalibre17 pcalibre2 pcalibre1">Set %r8 to &amp;p[0]</i>
	⋮
</code></pre>
<figcaption id="P7000497027000000000000000041635" data-uri="chapter03.xhtml#P7000497027000000000000000041635" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000041636" data-uri="chapter03.xhtml#P7000497027000000000000000041636" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.54 </span>Code for <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000003406"><span class="label pcalibre1 pcalibre2">Problem </span><span class="pcalibre1 pcalibre2 pcalibre37">3.72</span></a>.</h1></header><div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000041637" data-uri="chapter03.xhtml#P7000497027000000000000000041637"><p id="P7000497027000000000000000041638" data-uri="chapter03.xhtml#P7000497027000000000000000041638" class="pcalibre1 pcalibre2 pcalibre10">This function is similar to that of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002E6D.xhtml#P7000497027000000000000000003022"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">3.43</span></a>.</p></div></figcaption>
</figure>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000041639" data-uri="chapter03.xhtml#P7000497027000000000000000041639"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000341B" title="324" data-uri="chapter03.xhtml#P700049702700000000000000000341B" epub:type="pagebreak"></span>array p by calling library function <code id="P700049702700000000000000004163A" data-uri="chapter03.xhtml#P700049702700000000000000004163A" class="pcalibre1 calibre1 pcalibre2">alloca</code>. This function is similar to the more commonly used function malloc, except that it allocates space on the run-time stack. The space is automatically deallocated when the executing procedure returns.</p>
<p id="P700049702700000000000000004163B" data-uri="chapter03.xhtml#P700049702700000000000000004163B" class="pcalibre1 pcalibre2 pcalibre10"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000340F"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.54(b)</span></a> shows the part of the assembly code that sets up the frame pointer and allocates space for local variables <code id="P700049702700000000000000004163C" data-uri="chapter03.xhtml#P700049702700000000000000004163C" class="pcalibre1 calibre1 pcalibre2">i</code> and <code id="P700049702700000000000000004163D" data-uri="chapter03.xhtml#P700049702700000000000000004163D" class="pcalibre1 calibre1 pcalibre2">p</code>. It is very similar to the corresponding code for <code id="P700049702700000000000000004163E" data-uri="chapter03.xhtml#P700049702700000000000000004163E" class="pcalibre1 calibre1 pcalibre2">vframe</code>. Let us use the same notation as in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002E6D.xhtml#P7000497027000000000000000003055"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">3.49</span></a>: The stack pointer is set to values <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub> at line 4 and <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub> at line 7. The start address of array <code id="P700049702700000000000000004163F" data-uri="chapter03.xhtml#P700049702700000000000000004163F" class="pcalibre1 calibre1 pcalibre2">p</code> is set to value <var class="pcalibre17 pcalibre2 pcalibre1">p</var> at line 9. Extra space <var class="pcalibre17 pcalibre2 pcalibre1">e</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub> may arise between <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub> and <var class="pcalibre17 pcalibre2 pcalibre1">p</var>, and extra space <var class="pcalibre17 pcalibre2 pcalibre1">e</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub> may arise between the end of array <code id="P7000497027000000000000000041640" data-uri="chapter03.xhtml#P7000497027000000000000000041640" class="pcalibre1 calibre1 pcalibre2">p</code> and <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000041641" data-uri="chapter03.xhtml#P7000497027000000000000000041641">
<li id="P7000497027000000000000000041642" data-uri="chapter03.xhtml#P7000497027000000000000000041642" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041643" data-uri="chapter03.xhtml#P7000497027000000000000000041643" class="pcalibre1 pcalibre2 pcalibre10">Explain, in mathematical terms, the logic in the computation of <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>.</p></li>
<li id="P7000497027000000000000000041644" data-uri="chapter03.xhtml#P7000497027000000000000000041644" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041645" data-uri="chapter03.xhtml#P7000497027000000000000000041645" class="pcalibre1 pcalibre2 pcalibre10">Explain, in mathematical terms, the logic in the computation of <var class="pcalibre17 pcalibre2 pcalibre1">p</var>.</p></li>
<li id="P7000497027000000000000000041646" data-uri="chapter03.xhtml#P7000497027000000000000000041646" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041647" data-uri="chapter03.xhtml#P7000497027000000000000000041647" class="pcalibre1 pcalibre2 pcalibre10">Find values of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> and <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub> that lead to minimum and maximum values of <var class="pcalibre17 pcalibre2 pcalibre1">e</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>.</p></li>
<li id="P7000497027000000000000000041648" data-uri="chapter03.xhtml#P7000497027000000000000000041648" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041649" data-uri="chapter03.xhtml#P7000497027000000000000000041649" class="pcalibre1 pcalibre2 pcalibre10">What alignment properties does this code guarantee for the values of <var class="pcalibre17 pcalibre2 pcalibre1">s</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub> and <var class="pcalibre17 pcalibre2 pcalibre1">p</var>?</p></li>
</ol></div></li></ol>
</section>
<section id="P700049702700000000000000000342C" data-uri="chapter03.xhtml#P700049702700000000000000000342C" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004164A" data-uri="chapter03.xhtml#P700049702700000000000000004164A" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.73 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004164B" data-uri="chapter03.xhtml#P700049702700000000000000004164B">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004164C" data-uri="chapter03.xhtml#P700049702700000000000000004164C">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004164D" data-uri="chapter03.xhtml#P700049702700000000000000004164D"><p id="P700049702700000000000000004164E" data-uri="chapter03.xhtml#P700049702700000000000000004164E" class="pcalibre1 pcalibre2 pcalibre10">Write a function in assembly code that matches the behavior of the function <code id="P700049702700000000000000004164F" data-uri="chapter03.xhtml#P700049702700000000000000004164F" class="pcalibre1 calibre1 pcalibre2">find_range</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000003080.xhtml#P7000497027000000000000000003294"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.51</span></a>. Your code should contain only one floating-point comparison instruction, and then it should use conditional branches to generate the correct result. Test your code on all 2<sup class="pcalibre1 pcalibre2 pcalibre85">32</sup> possible argument values. Web Aside <span class="pcalibre1 pcalibre29 pcalibre2">ASM:EASM </span>on page 178 describes how to incorporate functions written in assembly code into C programs.</p>
</div></li></ol>
</section>
<section id="P7000497027000000000000000003433" data-uri="chapter03.xhtml#P7000497027000000000000000003433" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041650" data-uri="chapter03.xhtml#P7000497027000000000000000041650" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.74 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041651" data-uri="chapter03.xhtml#P7000497027000000000000000041651">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041652" data-uri="chapter03.xhtml#P7000497027000000000000000041652">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000041653" data-uri="chapter03.xhtml#P7000497027000000000000000041653"><p id="P7000497027000000000000000041654" data-uri="chapter03.xhtml#P7000497027000000000000000041654" class="pcalibre1 pcalibre2 pcalibre10">Write a function in assembly code that matches the behavior of the function <code id="P7000497027000000000000000041655" data-uri="chapter03.xhtml#P7000497027000000000000000041655" class="pcalibre1 calibre1 pcalibre2">find_range</code> in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000003080.xhtml#P7000497027000000000000000003294"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">3.51</span></a>. Your code should contain only one floating-point comparison instruction, and then it should use conditional moves to generate the correct result. You might want to make use of the instruction <code id="P7000497027000000000000000041656" data-uri="chapter03.xhtml#P7000497027000000000000000041656" class="pcalibre1 calibre1 pcalibre2">cmovp</code> (move if even parity). Test your code on all 2<sup class="pcalibre1 pcalibre2 pcalibre85">32</sup> possible argument values. Web Aside <span class="pcalibre1 pcalibre29 pcalibre2">ASM:EASM </span>on page 178 describes how to incorporate functions written in assembly code into C programs.</p>
</div></li></ol>
</section>
<section id="P700049702700000000000000000343B" data-uri="chapter03.xhtml#P700049702700000000000000000343B" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000041657" data-uri="chapter03.xhtml#P7000497027000000000000000041657" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">3.75 </span></h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000041658" data-uri="chapter03.xhtml#P7000497027000000000000000041658">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000041659" data-uri="chapter03.xhtml#P7000497027000000000000000041659">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004165A" data-uri="chapter03.xhtml#P700049702700000000000000004165A"><p id="P700049702700000000000000004165B" data-uri="chapter03.xhtml#P700049702700000000000000004165B" class="pcalibre1 pcalibre2 pcalibre10">ISO C99 includes extensions to support complex numbers. Any floating-point type can be modified with the keyword complex. Here are some sample functions that work with complex data and that call some of the associated library functions:</p>
<pre id="P700049702700000000000000004165C" data-uri="chapter03.xhtml#P700049702700000000000000004165C" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004165D" data-uri="chapter03.xhtml#P700049702700000000000000004165D" class="calibre3 pcalibre1 pcalibre2">
1	#include &lt;complex.h&gt; 2
3	double c_imag(double complex x) {
4		return cimag(x);
5	}
6	
7	double c_real(double complex x) {
8		return creal(x);
9	}
10	
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000003443" title="325" data-uri="chapter03.xhtml#P7000497027000000000000000003443" epub:type="pagebreak"></span>11	double complex c_sub(double complex x, double complex y) {
12		return x - y;
13	}
</code></pre>
<p id="P700049702700000000000000004165E" data-uri="chapter03.xhtml#P700049702700000000000000004165E" class="pcalibre1 pcalibre2 pcalibre10">When compiled, <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>generates the following assembly code for these functions:</p>
<pre id="P700049702700000000000000004165F" data-uri="chapter03.xhtml#P700049702700000000000000004165F" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000041660" data-uri="chapter03.xhtml#P7000497027000000000000000041660" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">double c_imag(double complex x)</i>
1	c_imag:
2		movapd	%xmm1, %xmm0
3		ret

	<i class="pcalibre17 pcalibre2 pcalibre1">double c_real(double complex x)</i>
4	c_real:
5		rep; ret

	<i class="pcalibre17 pcalibre2 pcalibre1">double complex c_sub(double complex x, double complex y)</i>
6	c_sub:
7		subsd	%xmm2, %xmm0
8		subsd	%xmm3, %xmm1
9		ret
</code></pre>
<p id="P7000497027000000000000000041661" data-uri="chapter03.xhtml#P7000497027000000000000000041661" class="pcalibre1 pcalibre2 pcalibre10">Based on these examples, determine the following:</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000041662" data-uri="chapter03.xhtml#P7000497027000000000000000041662">
<li id="P7000497027000000000000000041663" data-uri="chapter03.xhtml#P7000497027000000000000000041663" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041664" data-uri="chapter03.xhtml#P7000497027000000000000000041664" class="pcalibre1 pcalibre2 pcalibre10">How are complex arguments passed to a function?</p></li>
<li id="P7000497027000000000000000041665" data-uri="chapter03.xhtml#P7000497027000000000000000041665" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000041666" data-uri="chapter03.xhtml#P7000497027000000000000000041666" class="pcalibre1 pcalibre2 pcalibre10">How are complex values returned from a function?</p></li>
</ol></div></li></ol>
</section>
</section></body></html>
