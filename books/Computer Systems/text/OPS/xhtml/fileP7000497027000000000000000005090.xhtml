<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>Homework Problems </title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000005090" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000004383F" data-uri="chapter05.xhtml#P700049702700000000000000004383F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Homework Problems </span></h1></header>
<section id="P7000497027000000000000000005092" data-uri="chapter05.xhtml#P7000497027000000000000000005092" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000043840" data-uri="chapter05.xhtml#P7000497027000000000000000043840" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.13 </span>♦♦</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043841" data-uri="chapter05.xhtml#P7000497027000000000000000043841"><p id="P7000497027000000000000000043842" data-uri="chapter05.xhtml#P7000497027000000000000000043842" class="pcalibre8 pcalibre1 pcalibre2">Suppose we wish to write a procedure that computes the inner product of two vectors u and v. An abstract version of the function has a CPE of 14−18 with x86-64 for different types of integer and floating-point data. By doing the same sort of transformations we did to transform the abstract program <code id="P7000497027000000000000000043843" data-uri="chapter05.xhtml#P7000497027000000000000000043843" class="pcalibre1 calibre1 pcalibre2">combine1</code> into the more efficient <code id="P7000497027000000000000000043844" data-uri="chapter05.xhtml#P7000497027000000000000000043844" class="pcalibre1 calibre1 pcalibre2">combine4</code>, we get the following code:</p></div>
<pre id="P7000497027000000000000000043845" data-uri="chapter05.xhtml#P7000497027000000000000000043845" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043846" data-uri="chapter05.xhtml#P7000497027000000000000000043846" class="calibre3 pcalibre1 pcalibre2">
1	/* Inner product. Accumulate in temporary */
2	void inner4(vec_ptr u, vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(u);
6		data_t *udata = get_vec_start(u);
7		data_t *vdata = get_vec_start(v);
8		data_t sum = (data_t) 0;
9	
10		for (i = 0; i &lt; length; i++) {
11			sum = sum + udata[i] * vdata[i];
12		}
13		*dest = sum;
14	}
</code></pre>
<p id="P7000497027000000000000000043847" data-uri="chapter05.xhtml#P7000497027000000000000000043847" class="pcalibre8 pcalibre1 pcalibre2">Our measurements show that this function has CPEs of 1.50 for integer data and 3.00 for floating-point data. For data type double, the x86-64 assembly code for the inner loop is as follows:</p>
<pre id="P7000497027000000000000000043848" data-uri="chapter05.xhtml#P7000497027000000000000000043848" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043849" data-uri="chapter05.xhtml#P7000497027000000000000000043849" class="calibre3 pcalibre1 pcalibre2">
	<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000509C" title="571" data-uri="chapter05.xhtml#P700049702700000000000000000509C" epub:type="pagebreak"></span><i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of inner4. data_t = double, OP = *</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">udata in %rbp, vdata in %rax, sum in %xmm0</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">i in %rcx, limit in %rbx</i>
1	.L15:					<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	 vmovsd 0(%rbp,%rcx,8), %xmml		  Get <i class="pcalibre17 pcalibre2 pcalibre1">udata[i]</i>
3	 vmulsd (%rax,%rcx,8), %xmml, %xmml	  <i class="pcalibre17 pcalibre2 pcalibre1">Multiply by vdata[i]</i>
4	 vaddsd %xmml, %xmm0, %xmm0		  <i class="pcalibre17 pcalibre2 pcalibre1">Add to sum</i>
5	 addq $1, 7,rcx				  <i class="pcalibre17 pcalibre2 pcalibre1">Increment i</i>
6	 cmpq %rbx, %rcx			  <i class="pcalibre17 pcalibre2 pcalibre1">Compare i:limit</i>
7	 jne .L15				  <i class="pcalibre17 pcalibre2 pcalibre1">If ! =, goto</i> <b class="pcalibre1 pcalibre2 pcalibre12">loop</b>
</code></pre>
<p id="P700049702700000000000000004384A" data-uri="chapter05.xhtml#P700049702700000000000000004384A" class="pcalibre8 pcalibre1 pcalibre2">Assume that the functional units have the characteristics listed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004BAA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a>.</p>
<ol class="pcalibre1 pcalibre2 pcalibre128" id="P700049702700000000000000004384B" data-uri="chapter05.xhtml#P700049702700000000000000004384B">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004384C" data-uri="chapter05.xhtml#P700049702700000000000000004384C">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004384D" data-uri="chapter05.xhtml#P700049702700000000000000004384D"><p id="P700049702700000000000000004384E" data-uri="chapter05.xhtml#P700049702700000000000000004384E" class="pcalibre1 pcalibre2 pcalibre10">Diagram how this instruction sequence would be decoded into operations and show how the data dependencies between them would create a critical path of operations, in the style of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figures </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> and <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">5.14</span></a>.</p></div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004384F" data-uri="chapter05.xhtml#P700049702700000000000000004384F">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043850" data-uri="chapter05.xhtml#P7000497027000000000000000043850"><p id="P7000497027000000000000000043851" data-uri="chapter05.xhtml#P7000497027000000000000000043851" class="pcalibre1 pcalibre2 pcalibre10">For data type double, what lower bound on the CPE is determined by the critical path?</p></div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000043852" data-uri="chapter05.xhtml#P7000497027000000000000000043852">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043853" data-uri="chapter05.xhtml#P7000497027000000000000000043853"><p id="P7000497027000000000000000043854" data-uri="chapter05.xhtml#P7000497027000000000000000043854" class="pcalibre1 pcalibre2 pcalibre10">Assuming similar instruction sequences for the integer code as well, what lower bound on the CPE is determined by the critical path for integer data?</p></div></li>
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000043855" data-uri="chapter05.xhtml#P7000497027000000000000000043855">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043856" data-uri="chapter05.xhtml#P7000497027000000000000000043856"><p id="P7000497027000000000000000043857" data-uri="chapter05.xhtml#P7000497027000000000000000043857" class="pcalibre1 pcalibre2 pcalibre10">Explain how the floating-point versions can have CPEs of 3.00, even though the multiplication operation requires 5 clock cycles.</p></div></li>
</ol>
</section>
<section id="P70004970270000000000000000050A7" data-uri="chapter05.xhtml#P70004970270000000000000000050A7" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000043858" data-uri="chapter05.xhtml#P7000497027000000000000000043858" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.14 </span>♦</h1></header>
<p id="P7000497027000000000000000043859" data-uri="chapter05.xhtml#P7000497027000000000000000043859" class="pcalibre8 pcalibre1 pcalibre2">Write a version of the inner product procedure described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005092"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> that uses 6 × 1 loop unrolling. For x86-64, our measurements of the unrolled version give a CPE of 1.07 for integer data but still 3.01 for both floating-point data.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P700049702700000000000000004385A" data-uri="chapter05.xhtml#P700049702700000000000000004385A">
<li id="P700049702700000000000000004385B" data-uri="chapter05.xhtml#P700049702700000000000000004385B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004385C" data-uri="chapter05.xhtml#P700049702700000000000000004385C" class="pcalibre1 pcalibre2 pcalibre10">Explain why any (scalar) version of an inner product procedure running on an Intel Core i7 Haswell processor cannot achieve a CPE less than 1.00.</p></li>
<li id="P700049702700000000000000004385D" data-uri="chapter05.xhtml#P700049702700000000000000004385D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004385E" data-uri="chapter05.xhtml#P700049702700000000000000004385E" class="pcalibre1 pcalibre2 pcalibre10">Explain why the performance for floating-point data did not improve with loop unrolling.</p></li>
</ol>
</section>
<section id="P70004970270000000000000000050AF" data-uri="chapter05.xhtml#P70004970270000000000000000050AF" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004385F" data-uri="chapter05.xhtml#P700049702700000000000000004385F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.15 </span>♦</h1></header>
<p id="P7000497027000000000000000043860" data-uri="chapter05.xhtml#P7000497027000000000000000043860" class="pcalibre8 pcalibre1 pcalibre2">Write a version of the inner product procedure described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005092"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> that uses 6 × 6 loop unrolling. Our measurements for this function with x86-64 give a CPE of 1.06 for integer data and 1.01 for floating-point data.</p>
<p id="P7000497027000000000000000043861" data-uri="chapter05.xhtml#P7000497027000000000000000043861" class="pcalibre8 pcalibre1 pcalibre2">What factor limits the performance to a CPE of 1.00?</p>
</section>
<section id="P70004970270000000000000000050B3" data-uri="chapter05.xhtml#P70004970270000000000000000050B3" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000043862" data-uri="chapter05.xhtml#P7000497027000000000000000043862" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.16 </span>♦</h1></header>
<p id="P7000497027000000000000000043863" data-uri="chapter05.xhtml#P7000497027000000000000000043863" class="pcalibre8 pcalibre1 pcalibre2">Write a version of the inner product procedure described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000005092"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> that uses 6 × 1<var class="pcalibre17 pcalibre2 pcalibre1">a</var> loop unrolling to enable greater parallelism. Our measurements for this function give a CPE of 1.10 for integer data and 1.05 for floating-point data.</p>
</section>
<section id="P70004970270000000000000000050B6" data-uri="chapter05.xhtml#P70004970270000000000000000050B6" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000043864" data-uri="chapter05.xhtml#P7000497027000000000000000043864" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.17 </span>♦♦</h1></header>
<p id="P7000497027000000000000000043865" data-uri="chapter05.xhtml#P7000497027000000000000000043865" class="pcalibre8 pcalibre1 pcalibre2">The library function <code id="P7000497027000000000000000043866" data-uri="chapter05.xhtml#P7000497027000000000000000043866" class="pcalibre1 calibre1 pcalibre2">memset</code> has the following prototype:</p>
<pre id="P7000497027000000000000000043867" data-uri="chapter05.xhtml#P7000497027000000000000000043867" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043868" data-uri="chapter05.xhtml#P7000497027000000000000000043868" class="calibre3 pcalibre1 pcalibre2">void *memset(void *s, int c, size_t n);</code></pre>
<p id="P7000497027000000000000000043869" data-uri="chapter05.xhtml#P7000497027000000000000000043869" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000050BD" title="572" data-uri="chapter05.xhtml#P70004970270000000000000000050BD" epub:type="pagebreak"></span>This function fills <code id="P700049702700000000000000004386A" data-uri="chapter05.xhtml#P700049702700000000000000004386A" class="pcalibre1 calibre1 pcalibre2">n</code> bytes of the memory area starting at <code id="P700049702700000000000000004386B" data-uri="chapter05.xhtml#P700049702700000000000000004386B" class="pcalibre1 calibre1 pcalibre2">s</code> with copies of the low-order byte of <code id="P700049702700000000000000004386C" data-uri="chapter05.xhtml#P700049702700000000000000004386C" class="pcalibre1 calibre1 pcalibre2">c</code>. For example, it can be used to zero out a region of memory by giving argument 0 for <code id="P700049702700000000000000004386D" data-uri="chapter05.xhtml#P700049702700000000000000004386D" class="pcalibre1 calibre1 pcalibre2">c</code>, but other values are possible.</p>
<p id="P700049702700000000000000004386E" data-uri="chapter05.xhtml#P700049702700000000000000004386E" class="pcalibre8 pcalibre1 pcalibre2">The following is a straightforward implementation of <code id="P700049702700000000000000004386F" data-uri="chapter05.xhtml#P700049702700000000000000004386F" class="pcalibre1 calibre1 pcalibre2">memset</code>:</p>
<pre id="P7000497027000000000000000043870" data-uri="chapter05.xhtml#P7000497027000000000000000043870" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043871" data-uri="chapter05.xhtml#P7000497027000000000000000043871" class="calibre3 pcalibre1 pcalibre2">
1	/* Basic implementation of memset */
2	void *basic_memset(void *s, int c, size_t n)
3	{
4		size_t cnt = 0;
5		unsigned char *schar = s;
6		while (cnt &lt; n) {
7			*schar++ = (unsigned char) c;
8			cnt++;
9		}
10		return s;
11	}
</code></pre>
<p id="P7000497027000000000000000043872" data-uri="chapter05.xhtml#P7000497027000000000000000043872" class="pcalibre8 pcalibre1 pcalibre2">Implement a more efficient version of the function by using a word of data type <code id="P7000497027000000000000000043873" data-uri="chapter05.xhtml#P7000497027000000000000000043873" class="pcalibre1 calibre1 pcalibre2">unsigned long</code> to pack eight copies of <code id="P7000497027000000000000000043874" data-uri="chapter05.xhtml#P7000497027000000000000000043874" class="pcalibre1 calibre1 pcalibre2">c</code>, and then step through the region using word-level writes. You might find it helpful to do additional loop unrolling as well. On our reference machine, we were able to reduce the CPE from 1.00 for the straightforward implementation to 0.127. That is, the program is able to write 8 bytes every clock cycle.</p>
<p id="P7000497027000000000000000043875" data-uri="chapter05.xhtml#P7000497027000000000000000043875" class="pcalibre8 pcalibre1 pcalibre2">Here are some additional guidelines. To ensure portability, let <var class="pcalibre17 pcalibre2 pcalibre1">K</var> denote the value of <code id="P7000497027000000000000000043876" data-uri="chapter05.xhtml#P7000497027000000000000000043876" class="pcalibre1 calibre1 pcalibre2">sizeof (unsigned long)</code> for the machine on which you run your program.</p>
<ul id="P7000497027000000000000000043877" data-uri="chapter05.xhtml#P7000497027000000000000000043877" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000043878" data-uri="chapter05.xhtml#P7000497027000000000000000043878" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043879" data-uri="chapter05.xhtml#P7000497027000000000000000043879" class="pcalibre1 pcalibre2 pcalibre10">You may not call any library functions.</p></li>
<li id="P700049702700000000000000004387A" data-uri="chapter05.xhtml#P700049702700000000000000004387A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004387B" data-uri="chapter05.xhtml#P700049702700000000000000004387B" class="pcalibre1 pcalibre2 pcalibre10">Your code should work for arbitrary values of <code id="P700049702700000000000000004387C" data-uri="chapter05.xhtml#P700049702700000000000000004387C" class="pcalibre1 calibre1 pcalibre2">n</code>, including when it is not a multiple of <i class="pcalibre17 pcalibre2 pcalibre1">K.</i> You can do this in a manner similar to the way we finish the last few iterations with loop unrolling.</p></li>
<li id="P700049702700000000000000004387D" data-uri="chapter05.xhtml#P700049702700000000000000004387D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004387E" data-uri="chapter05.xhtml#P700049702700000000000000004387E" class="pcalibre1 pcalibre2 pcalibre10">You should write your code so that it will compile and run correctly on any machine regardless of the value of <i class="pcalibre17 pcalibre2 pcalibre1">K.</i> Make use of the operation <code id="P700049702700000000000000004387F" data-uri="chapter05.xhtml#P700049702700000000000000004387F" class="pcalibre1 calibre1 pcalibre2">sizeof</code> to do this.</p></li>
<li id="P7000497027000000000000000043880" data-uri="chapter05.xhtml#P7000497027000000000000000043880" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043881" data-uri="chapter05.xhtml#P7000497027000000000000000043881" class="pcalibre1 pcalibre2 pcalibre10">On some machines, unaligned writes can be much slower than aligned ones. (On some non-x86 machines, they can even cause segmentation faults.) Write your code so that it starts with byte-level writes until the destination address is a multiple of <var class="pcalibre17 pcalibre2 pcalibre1">K</var>, then do word-level writes, and then (if necessary) finish with byte-level writes.</p></li>
<li id="P7000497027000000000000000043882" data-uri="chapter05.xhtml#P7000497027000000000000000043882" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043883" data-uri="chapter05.xhtml#P7000497027000000000000000043883" class="pcalibre1 pcalibre2 pcalibre10">Beware of the case where <code id="P7000497027000000000000000043884" data-uri="chapter05.xhtml#P7000497027000000000000000043884" class="pcalibre1 calibre1 pcalibre2">cnt</code> is small enough that the upper bounds on some of the loops become negative. With expressions involving the <code id="P7000497027000000000000000043885" data-uri="chapter05.xhtml#P7000497027000000000000000043885" class="pcalibre1 calibre1 pcalibre2">sizeof</code> operator, the testing may be performed with unsigned arithmetic. (See <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP700049702700000000000000000077D_split_001.xhtml#P7000497027000000000000000000C88"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">2.2.8</span></a> and <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001498.xhtml#P70004970270000000000000000015A5"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">2.72</span></a>.)</p></li>
</ul>
</section>
<section id="P70004970270000000000000000050DA" data-uri="chapter05.xhtml#P70004970270000000000000000050DA" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000043886" data-uri="chapter05.xhtml#P7000497027000000000000000043886" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.18 </span>♦♦♦</h1></header>
<p id="P7000497027000000000000000043887" data-uri="chapter05.xhtml#P7000497027000000000000000043887" class="pcalibre8 pcalibre1 pcalibre2">We considered the task of polynomial evaluation in Practice Problems 5.5 and 5.6, with both a direct evaluation and an evaluation by Horner's method. Try to write <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000050DD" title="573" data-uri="chapter05.xhtml#P70004970270000000000000000050DD" epub:type="pagebreak"></span>faster versions of the function using the optimization techniques we have explored, including loop unrolling, parallel accumulation, and reassociation. You will find many different ways of mixing together Horner's scheme and direct evaluation with these optimization techniques.</p>
<p id="P7000497027000000000000000043888" data-uri="chapter05.xhtml#P7000497027000000000000000043888" class="pcalibre8 pcalibre1 pcalibre2">Ideally, you should be able to reach a CPE close to the throughput limit of your machine. Our best version achieves a CPE of 1.07 on our reference machine.</p>
</section>
<section id="P70004970270000000000000000050DF" data-uri="chapter05.xhtml#P70004970270000000000000000050DF" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000043889" data-uri="chapter05.xhtml#P7000497027000000000000000043889" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.19 </span>♦♦♦</h1></header>
<p id="P700049702700000000000000004388A" data-uri="chapter05.xhtml#P700049702700000000000000004388A" class="pcalibre8 pcalibre1 pcalibre2">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004FEC"><span class="pcalibre1 pcalibre21 pcalibre2">Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a>, we were able to reduce the CPE for the prefix-sum computation to 3.00, limited by the latency of floating-point addition on this machine. Simple loop unrolling does not improve things.</p>
<p id="P700049702700000000000000004388B" data-uri="chapter05.xhtml#P700049702700000000000000004388B" class="pcalibre8 pcalibre1 pcalibre2">Using a combination of loop unrolling and reassociation, write code for a prefix sum that achieves a CPE less than the latency of floating-point addition on your machine. Doing this requires actually increasing the number of additions performed. For example, our version with two-way unrolling requires three additions per iteration, while our version with four-way unrolling requires five. Our best implementation achieves a CPE of 1.67 on our reference machine.</p>
<p id="P700049702700000000000000004388C" data-uri="chapter05.xhtml#P700049702700000000000000004388C" class="pcalibre8 pcalibre1 pcalibre2">Determine how the throughput and latency limits of your machine limit the minimum CPE you can achieve for the prefix-sum operation.</p>
</section>
</section></body></html>
