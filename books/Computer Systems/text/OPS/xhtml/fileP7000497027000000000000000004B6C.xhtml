<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.7 Understanding Modern Processors</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000004B6C" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P70004970270000000000000000432B9" data-uri="chapter05.xhtml#P70004970270000000000000000432B9" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.7 </span>Understanding Modern Processors</h1></header>
<p id="P70004970270000000000000000432BA" data-uri="chapter05.xhtml#P70004970270000000000000000432BA" class="pcalibre8 pcalibre1 pcalibre2">Up to this point, we have applied optimizations that did not rely on any features of the target machine. They simply reduced the overhead of procedure calls and eliminated some of the critical "optimization blockers" that cause difficulties for optimizing compilers. As we seek to push the performance further, we must consider optimizations that exploit the <i class="pcalibre17 pcalibre2 pcalibre1">microarchitecture</i> of the processor—that is, the underlying system design by which a processor executes instructions. Getting every last bit of performance requires a detailed analysis of the program as well as code generation tuned for the target processor. Nonetheless, we can apply some basic optimizations that will yield an overall performance improvement on a large class of processors. The detailed performance results we report here may not hold for other machines, but the general principles of operation and optimization apply to a wide variety of machines.</p>
<p id="P70004970270000000000000000432BB" data-uri="chapter05.xhtml#P70004970270000000000000000432BB" class="pcalibre8 pcalibre1 pcalibre2">To understand ways to improve performance, we require a basic understanding of the microarchitectures of modern processors. Due to the large number of transistors that can be integrated onto a single chip, modern microprocessors employ complex hardware that attempts to maximize program performance. One result is that their actual operation is far different from the view that is perceived by looking at machine-level programs. At the code level, it appears as if instructions are executed one at a time, where each instruction involves fetching values from registers or memory, performing an operation, and storing results back to a register or memory location. In the actual processor, a number of instructions <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004B70" title="518" data-uri="chapter05.xhtml#P7000497027000000000000000004B70" epub:type="pagebreak"></span>are evaluated simultaneously, a phenomenon referred to as <i class="pcalibre17 pcalibre2 pcalibre1">instruction-level parallelism</i>. In some designs, there can be 100 or more instructions "in flight." Elaborate mechanisms are employed to make sure the behavior of this parallel execution exactly captures the sequential semantic model required by the machine-level program. This is one of the remarkable feats of modern microprocessors: they employ complex and exotic microarchitectures, in which multiple instructions can be executed in parallel, while presenting an operational view of simple sequential instruction execution.</p>
<p id="P70004970270000000000000000432BC" data-uri="chapter05.xhtml#P70004970270000000000000000432BC" class="pcalibre8 pcalibre1 pcalibre2">Although the detailed design of a modern microprocessor is well beyond the scope of this book, having a general idea of the principles by which they operate suffices to understand how they achieve instruction-level parallelism. We will find that two different lower bounds characterize the maximum performance of a program. The <i class="pcalibre17 pcalibre2 pcalibre1">latency bound</i> is encountered when a series of operations must be performed in strict sequence, because the result of one operation is required before the next one can begin. This bound can limit program performance when the data dependencies in the code limit the ability of the processor to exploit instruction-level parallelism. The <i class="pcalibre17 pcalibre2 pcalibre1">throughput bound</i> characterizes the raw computing capacity of the processor's functional units. This bound becomes the ultimate limit on program performance.</p>
<section id="P7000497027000000000000000004B72" data-uri="chapter05.xhtml#P7000497027000000000000000004B72" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000432BD" data-uri="chapter05.xhtml#P70004970270000000000000000432BD" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.7.1 </span>Overall Operation</h1></header>
<p id="P70004970270000000000000000432BE" data-uri="chapter05.xhtml#P70004970270000000000000000432BE" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004B76"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.11</span></a> shows a very simplified view of a modern microprocessor. Our hypothetical processor design is based loosely on the structure of recent Intel processors. These processors are described in the industry as being <i class="pcalibre17 pcalibre2 pcalibre1">superscalar</i>, which means they can perform multiple operations on every clock cycle and <i class="pcalibre17 pcalibre2 pcalibre1">out of order</i>, meaning that the order in which instructions execute need not correspond to their ordering in the machine-level program. The overall design has two main parts: the <i class="pcalibre17 pcalibre2 pcalibre1">instruction control unit</i> (ICU), which is responsible for reading a sequence of instructions from memory and generating from these a set of primitive operations to perform on program data, and the <i class="pcalibre17 pcalibre2 pcalibre1">execution unit</i> (EU), which then executes these operations. Compared to the simple <i class="pcalibre17 pcalibre2 pcalibre1">in-order</i> pipeline we studied in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000003A76.xhtml#P7000497027000000000000000003A76"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">4</span></a>, out-of-order processors require far greater and more complex hardware, but they are better at achieving higher degrees of instruction-level parallelism.</p>
<p id="P70004970270000000000000000432BF" data-uri="chapter05.xhtml#P70004970270000000000000000432BF" class="pcalibre8 pcalibre1 pcalibre2">The ICU reads the instructions from an <i class="pcalibre17 pcalibre2 pcalibre1">instruction cache</i>—a special high-speed memory containing the most recently accessed instructions. In general, the ICU fetches well ahead of the currently executing instructions, so that it has enough time to decode these and send operations down to the EU. One problem, however, is that when a program hits a branch,<a class="pcalibre1 pcalibre2 pcalibre56 pcalibre16 pcalibre14 pcalibre15" id="r__P7000497027000000000000000005188" epub:type="noteref" href="#P7000497027000000000000000005188">1</a> there are two possible directions the program might go. The branch can be <i class="pcalibre17 pcalibre2 pcalibre1">taken</i>, with control passing to the branch target. Alternatively, the branch can be <i class="pcalibre17 pcalibre2 pcalibre1">not taken</i>, with control passing to the next</p><aside class="pcalibre2 pcalibre32 pcalibre57" id="P7000497027000000000000000005188" data-uri="chapter05.xhtml#P7000497027000000000000000005188" epub:type="footnote"><p class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre58 pcalibre2"><a href="#r__P7000497027000000000000000005188" class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13">1. </a></span>We use the term "branch" specifically to refer to conditional jump instructions. Other instructions that can transfer control to multiple destinations, such as procedure return and indirect jumps, provide similar challenges for the processor.</p></aside>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004B76" data-uri="chapter05.xhtml#P7000497027000000000000000004B76">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004B77" title="519" data-uri="chapter05.xhtml#P7000497027000000000000000004B77" epub:type="pagebreak"></span>
<img alt="A block diagram depicts interactions between instruction control unit and execution unit." id="P70004970270000000000000000432C0" data-uri="P700049702700000000000000000B711" src="../images/p519-1.png" class="pcalibre1 pcalibre2 pcalibre191"/>
<figcaption id="P70004970270000000000000000432C1" data-uri="chapter05.xhtml#P70004970270000000000000000432C1" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000432C2" data-uri="chapter05.xhtml#P70004970270000000000000000432C2" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.11 </span>Block diagram of an out-of-order processor.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000432C3" data-uri="chapter05.xhtml#P70004970270000000000000000432C3"><p id="P70004970270000000000000000432C4" data-uri="chapter05.xhtml#P70004970270000000000000000432C4" class="pcalibre1 pcalibre2 pcalibre10">The instruction control unit is responsible for reading instructions from memory and generating a sequence of primitive operations. The execution unit then performs the operations and indicates whether the branches were correctly predicted.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000235A4" data-uri="chapter05.xhtml#P70004970270000000000000000235A4">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000432C5" data-uri="chapter05.xhtml#P70004970270000000000000000432C5" class="pcalibre8 pcalibre1 pcalibre2">The components of the instruction control unit and execution unit are summarized below.</p>
<ul id="P70004970270000000000000000432C6" data-uri="chapter05.xhtml#P70004970270000000000000000432C6" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000432C7" data-uri="chapter05.xhtml#P70004970270000000000000000432C7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432C8" data-uri="chapter05.xhtml#P70004970270000000000000000432C8" class="pcalibre1 pcalibre2 pcalibre10">Instruction control unit: the register file, within the retirement unit, sends output to instruction decode. The instruction cache receives address from fetch control and sends instructions to instruction decode.</p></li>
<li id="P70004970270000000000000000432C9" data-uri="chapter05.xhtml#P70004970270000000000000000432C9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432CA" data-uri="chapter05.xhtml#P70004970270000000000000000432CA" class="pcalibre1 pcalibre2 pcalibre10">Execution unit: the following function units interact with operation results: branch, arithmetic operations (two), load, and store. Load and store send and receive data between the data cache.</p></li>
<li id="P70004970270000000000000000432CB" data-uri="chapter05.xhtml#P70004970270000000000000000432CB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432CC" data-uri="chapter05.xhtml#P70004970270000000000000000432CC" class="pcalibre1 pcalibre2 pcalibre10">Operations from instruction decode are sent to the function units, and are also sent back to the retirement unit. Register updates are sent from operation results to the retirement unit. From branch, prediction ok? Is sent to the retirement unit and fetch control.</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000432CD" data-uri="chapter05.xhtml#P70004970270000000000000000432CD">instruction in the instruction sequence. Modern processors employ a technique known as <i class="pcalibre17 pcalibre2 pcalibre1">branch prediction</i>, in which they guess whether or not a branch will be taken and also predict the target address for the branch. Using a technique known as <i class="pcalibre17 pcalibre2 pcalibre1">speculative execution</i>, the processor begins fetching and decoding instructions at where it predicts the branch will go, and even begins executing these operations before it has been determined whether or not the branch prediction was correct. If it later determines that the branch was predicted incorrectly, it resets the state to that at the branch point and begins fetching and executing instructions in the other direction. The block labeled "Fetch control" incorporates branch prediction to perform the task of determining which instructions to fetch.</p>
<p id="P70004970270000000000000000432CE" data-uri="chapter05.xhtml#P70004970270000000000000000432CE" class="pcalibre8 pcalibre1 pcalibre2">The <i class="pcalibre17 pcalibre2 pcalibre1">instruction decoding</i> logic takes the actual program instructions and converts them into a set of primitive <i class="pcalibre17 pcalibre2 pcalibre1">operations</i> (sometimes referred to as <i class="pcalibre17 pcalibre2 pcalibre1">micro-operations</i>). Each of these operations performs some simple computational task such as adding two numbers, reading data from memory, or writing data to memory. For machines with complex instructions, such as x86 processors, an instruction <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004B7F" title="520" data-uri="chapter05.xhtml#P7000497027000000000000000004B7F" epub:type="pagebreak"></span>can be decoded into multiple operations. The details of how instructions are decoded into sequences of operations varies between machines, and this information is considered highly proprietary. Fortunately, we can optimize our programs without knowing the low-level details of a particular machine implementation.</p>
<p id="P70004970270000000000000000432CF" data-uri="chapter05.xhtml#P70004970270000000000000000432CF" class="pcalibre8 pcalibre1 pcalibre2">In a typical x86 implementation, an instruction that only operates on registers, such as</p>
<pre id="P70004970270000000000000000432D0" data-uri="chapter05.xhtml#P70004970270000000000000000432D0" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000432D1" data-uri="chapter05.xhtml#P70004970270000000000000000432D1" class="calibre3 pcalibre1 pcalibre2">
addq %rax,%rdx
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000432D2" data-uri="chapter05.xhtml#P70004970270000000000000000432D2">is converted into a single operation. On the other hand, an instruction involving one or more memory references, such as</p>
<pre id="P70004970270000000000000000432D3" data-uri="chapter05.xhtml#P70004970270000000000000000432D3" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000432D4" data-uri="chapter05.xhtml#P70004970270000000000000000432D4" class="calibre3 pcalibre1 pcalibre2">
addq %rax,8(%rdx)
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000432D5" data-uri="chapter05.xhtml#P70004970270000000000000000432D5">yields multiple operations, separating the memory references from the arithmetic operations. This particular instruction would be decoded as three operations: one to <i class="pcalibre17 pcalibre2 pcalibre1">load</i> a value from memory into the processor, one to add the loaded value to the value in register <code id="P70004970270000000000000000432D6" data-uri="chapter05.xhtml#P70004970270000000000000000432D6" class="pcalibre1 calibre1 pcalibre2">%eax</code>, and one to <i class="pcalibre17 pcalibre2 pcalibre1">store</i> the result back to memory. The decoding splits instructions to allow a division of labor among a set of dedicated hardware units. These units can then execute the different parts of multiple instructions in parallel.</p>
<p id="P70004970270000000000000000432D7" data-uri="chapter05.xhtml#P70004970270000000000000000432D7" class="pcalibre8 pcalibre1 pcalibre2">The EU receives operations from the instruction fetch unit. Typically, it can receive a number of them on each clock cycle. These operations are dispatched to a set of <i class="pcalibre17 pcalibre2 pcalibre1">functional units</i> that perform the actual operations. These functional units are specialized to handle different types of operations.</p>
<p id="P70004970270000000000000000432D8" data-uri="chapter05.xhtml#P70004970270000000000000000432D8" class="pcalibre8 pcalibre1 pcalibre2">Reading and writing memory is implemented by the load and store units. The load unit handles operations that read data from the memory into the processor. This unit has an adder to perform address computations. Similarly, the store unit handles operations that write data from the processor to the memory. It also has an adder to perform address computations. As shown in the figure, the load and store units access memory via a <i class="pcalibre17 pcalibre2 pcalibre1">data cache</i>, a high-speed memory containing the most recently accessed data values.</p>
<p id="P70004970270000000000000000432D9" data-uri="chapter05.xhtml#P70004970270000000000000000432D9" class="pcalibre8 pcalibre1 pcalibre2">With speculative execution, the operations are evaluated, but the final results are not stored in the program registers or data memory until the processor can be certain that these instructions should actually have been executed. Branch operations are sent to the EU, not to determine where the branch should go, but rather to determine whether or not they were predicted correctly. If the prediction was incorrect, the EU will discard the results that have been computed beyond the branch point. It will also signal the branch unit that the prediction was incorrect and indicate the correct branch destination. In this case, the branch unit begins fetching at the new location. As we saw in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.6.6</span></a>, such a <i class="pcalibre17 pcalibre2 pcalibre1">misprediction</i> incurs a significant cost in performance. It takes a while before the new instructions can be fetched, decoded, and sent to the functional units.</p>
<p id="P70004970270000000000000000432DA" data-uri="chapter05.xhtml#P70004970270000000000000000432DA" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004B76"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.11</span></a> indicates that the different functional units are designed to perform different operations. Those labeled as performing "arithmetic operations" are typically specialized to perform different combinations of integer and floating-point operations. As the number of transistors that can be integrated onto a single <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004B8C" title="521" data-uri="chapter05.xhtml#P7000497027000000000000000004B8C" epub:type="pagebreak"></span>microprocessor chip has grown over time, successive models of microprocessors have increased the total number of functional units, the combinations of operations each unit can perform, and the performance of each of these units. The arithmetic units are intentionally designed to be able to perform a variety of different operations, since the required operations vary widely across different programs. For example, some programs might involve many integer operations, while others require many floating-point operations. If one functional unit were specialized to perform integer operations while another could only perform floating-point operations, then none of these programs would get the full benefit of having multiple functional units.</p>
<p id="P70004970270000000000000000432DB" data-uri="chapter05.xhtml#P70004970270000000000000000432DB" class="pcalibre8 pcalibre1 pcalibre2">For example, our Intel Core i7 Has well reference machine has eight functional units, numbered 0−7. Here is a partial list of each one's capabilities:</p>
<ol start="0" id="P70004970270000000000000000432DC" data-uri="chapter05.xhtml#P70004970270000000000000000432DC" class="pcalibre1 calibre19 pcalibre2">
<li id="P70004970270000000000000000432DD" data-uri="chapter05.xhtml#P70004970270000000000000000432DD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432DE" data-uri="chapter05.xhtml#P70004970270000000000000000432DE" class="pcalibre1 pcalibre2 pcalibre10">Integer arithmetic, floating-point multiplication, integer and floating-point division, branches</p></li>
<li id="P70004970270000000000000000432DF" data-uri="chapter05.xhtml#P70004970270000000000000000432DF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432E0" data-uri="chapter05.xhtml#P70004970270000000000000000432E0" class="pcalibre1 pcalibre2 pcalibre10">Integer arithmetic, floating-point addition, integer multiplication, floating-point multiplication</p></li>
<li id="P70004970270000000000000000432E1" data-uri="chapter05.xhtml#P70004970270000000000000000432E1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432E2" data-uri="chapter05.xhtml#P70004970270000000000000000432E2" class="pcalibre1 pcalibre2 pcalibre10">Load, address computation</p></li>
<li id="P70004970270000000000000000432E3" data-uri="chapter05.xhtml#P70004970270000000000000000432E3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432E4" data-uri="chapter05.xhtml#P70004970270000000000000000432E4" class="pcalibre1 pcalibre2 pcalibre10">Load, address computation</p></li>
<li id="P70004970270000000000000000432E5" data-uri="chapter05.xhtml#P70004970270000000000000000432E5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432E6" data-uri="chapter05.xhtml#P70004970270000000000000000432E6" class="pcalibre1 pcalibre2 pcalibre10">Store</p></li>
<li id="P70004970270000000000000000432E7" data-uri="chapter05.xhtml#P70004970270000000000000000432E7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432E8" data-uri="chapter05.xhtml#P70004970270000000000000000432E8" class="pcalibre1 pcalibre2 pcalibre10">Integer arithmetic</p></li>
<li id="P70004970270000000000000000432E9" data-uri="chapter05.xhtml#P70004970270000000000000000432E9" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432EA" data-uri="chapter05.xhtml#P70004970270000000000000000432EA" class="pcalibre1 pcalibre2 pcalibre10">Integer arithmetic, branches</p></li>
<li id="P70004970270000000000000000432EB" data-uri="chapter05.xhtml#P70004970270000000000000000432EB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000432EC" data-uri="chapter05.xhtml#P70004970270000000000000000432EC" class="pcalibre1 pcalibre2 pcalibre10">Store address computation</p></li>
</ol>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000432ED" data-uri="chapter05.xhtml#P70004970270000000000000000432ED">In the above list, "integer arithmetic" refers to basic operations, such as addition, bitwise operations, and shifting. Multiplication and division require more specialized resources. We see that a store operation requires two functional units—one to compute the store address and one to actually store the data. We will discuss the mechanics of store (and load) operations in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004F49"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a>.</p>
<p id="P70004970270000000000000000432EE" data-uri="chapter05.xhtml#P70004970270000000000000000432EE" class="pcalibre8 pcalibre1 pcalibre2">We can see that this combination of functional units has the potential to perform multiple operations of the same type simultaneously. It has four units capable of performing integer operations, two that can perform load operations, and two that can perform floating-point multiplication. We will later see the impact these resources have on the maximum performance our programs can achieve.</p>
<p id="P70004970270000000000000000432EF" data-uri="chapter05.xhtml#P70004970270000000000000000432EF" class="pcalibre8 pcalibre1 pcalibre2">Within the ICU, the <i class="pcalibre17 pcalibre2 pcalibre1">retirement unit</i> keeps track of the ongoing processing and makes sure that it obeys the sequential semantics of the machine-level program. Our figure shows a <i class="pcalibre17 pcalibre2 pcalibre1">register file</i> containing the integer, floating-point, and, more recently, SSE and AVX registers as part of the retirement unit, because this unit controls the updating of these registers. As an instruction is decoded, information about it is placed into a first-in, first-out queue. This information remains in the queue until one of two outcomes occurs. First, once the operations for the instruction have completed and any branch points leading to this instruction are confirmed as having been correctly predicted, the instruction can be <i class="pcalibre17 pcalibre2 pcalibre1">retired</i>, with any updates to the program registers being made. If some branch point leading to this instruction was mispredicted, on the other hand, the instruction will be</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000004BA2" data-uri="chapter05.xhtml#P7000497027000000000000000004BA2"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P70004970270000000000000000432F0" data-uri="chapter05.xhtml#P70004970270000000000000000432F0" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004BA4" title="522" data-uri="chapter05.xhtml#P7000497027000000000000000004BA4" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>The history of out-of-order processing</h1></header>
<p id="P70004970270000000000000000432F1" data-uri="chapter05.xhtml#P70004970270000000000000000432F1" class="pcalibre1 pcalibre2 pcalibre40">Out-of-order processing was first implemented in the Control Data Corporation 6600 processor in 1964. Instructions were processed by 10 different functional units, each of which could be operated independently. In its day, this machine, with a clock rate of 10 MHz, was considered the premium machine for scientific computing.</p>
<p id="P70004970270000000000000000432F2" data-uri="chapter05.xhtml#P70004970270000000000000000432F2" class="pcalibre1 pcalibre2 pcalibre10">IBM first implemented out-of-order processing with the IBM 360/91 processor in 1966, but just to execute the floating-point instructions. For around 25 years, out-of-order processing was considered an exotic technology, found only in machines striving for the highest possible performance, until IBM reintroduced it in the RS/6000 line of workstations in 1990. This design became the basis for the IBM/Motorola PowerPC line, with the model 601, introduced in 1993, becoming the first single-chip microprocessor to use out-of-order processing. Intel introduced out-of-order processing with its PentiumPro model in 1995, with an underlying microarchitecture similar to that of our reference machine.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000432F3" data-uri="chapter05.xhtml#P70004970270000000000000000432F3"><i class="pcalibre17 pcalibre2 pcalibre1">flushed</i>, discarding any results that may have been computed. By this means, mispredictions will not alter the program state.</p>
<p id="P70004970270000000000000000432F4" data-uri="chapter05.xhtml#P70004970270000000000000000432F4" class="pcalibre8 pcalibre1 pcalibre2">As we have described, any updates to the program registers occur only as instructions are being retired, and this takes place only after the processor can be certain that any branches leading to this instruction have been correctly predicted. To expedite the communication of results from one instruction to another, much of this information is exchanged among the execution units, shown in the figure as "Operation results." As the arrows in the figure show, the execution units can send results directly to each other. This is a more elaborate form of the data-forwarding techniques we incorporated into our simple processor design in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000041EB_split_000.xhtml#P7000497027000000000000000004251"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">4.5.5</span></a>.</p>
<p id="P70004970270000000000000000432F5" data-uri="chapter05.xhtml#P70004970270000000000000000432F5" class="pcalibre8 pcalibre1 pcalibre2">The most common mechanism for controlling the communication of operands among the execution units is called <i class="pcalibre17 pcalibre2 pcalibre1">register renaming</i>. When an instruction that updates register <var class="pcalibre17 pcalibre2 pcalibre1">r</var> is decoded, a <i class="pcalibre17 pcalibre2 pcalibre1">tag t</i> is generated giving a unique identifier to the result of the operation. An entry <i class="pcalibre17 pcalibre2 pcalibre1">(r, t)</i> is added to a table maintaining the association between program register <var class="pcalibre17 pcalibre2 pcalibre1">r</var> and tag <var class="pcalibre17 pcalibre2 pcalibre1">t</var> for an operation that will update this register. When a subsequent instruction using register <var class="pcalibre17 pcalibre2 pcalibre1">r</var> as an operand is decoded, the operation sent to the execution unit will contain <var class="pcalibre17 pcalibre2 pcalibre1">t</var> as the source for the operand value. When some execution unit completes the first operation, it generates a result <i class="pcalibre17 pcalibre2 pcalibre1">(v, t)</i>, indicating that the operation with tag <var class="pcalibre17 pcalibre2 pcalibre1">t</var> produced value <var class="pcalibre17 pcalibre2 pcalibre1">v</var>. Any operation waiting for <var class="pcalibre17 pcalibre2 pcalibre1">t</var> as a source will then use <var class="pcalibre17 pcalibre2 pcalibre1">v</var> as the source value, a form of data forwarding. By this mechanism, values can be forwarded directly from one operation to another, rather than being written to and read from the register file, enabling the second operation to begin as soon as the first has completed. The renaming table only contains entries for registers having pending write operations. When a decoded instruction requires a register <var class="pcalibre17 pcalibre2 pcalibre1">r</var>, and there is no tag associated with this register, the operand is retrieved directly from the register file. With register renaming, an entire sequence of operations can be performed speculatively, even though the registers are updated only after the processor is certain of the branch outcomes.</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004BAA" data-uri="chapter05.xhtml#P7000497027000000000000000004BAA">
<table id="P70004970270000000000000000432F6" data-uri="chapter05.xhtml#P70004970270000000000000000432F6" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P70004970270000000000000000432F7" data-uri="chapter05.xhtml#P70004970270000000000000000432F7" class="pcalibre1 pcalibre2 calibre5"/>
<th colspan="3" id="P70004970270000000000000000432F8" data-uri="chapter05.xhtml#P70004970270000000000000000432F8" class="pcalibre1 pcalibre2 calibre5"><span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000004BAE" title="523" data-uri="chapter05.xhtml#P7000497027000000000000000004BAE" epub:type="pagebreak"></span>Integer</th>
<th colspan="3" id="P70004970270000000000000000432F9" data-uri="chapter05.xhtml#P70004970270000000000000000432F9" class="pcalibre1 pcalibre2 calibre5">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P70004970270000000000000000432FA" data-uri="chapter05.xhtml#P70004970270000000000000000432FA" class="pcalibre1 pcalibre2 calibre5">Operation</th>
<th id="P70004970270000000000000000432FB" data-uri="chapter05.xhtml#P70004970270000000000000000432FB" class="pcalibre1 pcalibre2 calibre5">Latency</th>
<th id="P70004970270000000000000000432FC" data-uri="chapter05.xhtml#P70004970270000000000000000432FC" class="pcalibre1 pcalibre2 calibre5">Issue</th>
<th id="P70004970270000000000000000432FD" data-uri="chapter05.xhtml#P70004970270000000000000000432FD" class="pcalibre1 pcalibre2 calibre5">Capacity</th>
<th id="P70004970270000000000000000432FE" data-uri="chapter05.xhtml#P70004970270000000000000000432FE" class="pcalibre1 pcalibre2 calibre5">Latency</th>
<th id="P70004970270000000000000000432FF" data-uri="chapter05.xhtml#P70004970270000000000000000432FF" class="pcalibre1 pcalibre2 calibre5">Issue</th>
<th id="P7000497027000000000000000043300" data-uri="chapter05.xhtml#P7000497027000000000000000043300" class="pcalibre1 pcalibre2 calibre5">Capacity</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043301" data-uri="chapter05.xhtml#P7000497027000000000000000043301" class="pcalibre1 pcalibre2 calibre7">Addition</td>
<td id="P7000497027000000000000000043302" data-uri="chapter05.xhtml#P7000497027000000000000000043302" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P7000497027000000000000000043303" data-uri="chapter05.xhtml#P7000497027000000000000000043303" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P7000497027000000000000000043304" data-uri="chapter05.xhtml#P7000497027000000000000000043304" class="pcalibre1 pcalibre2 calibre7">4</td>
<td id="P7000497027000000000000000043305" data-uri="chapter05.xhtml#P7000497027000000000000000043305" class="pcalibre1 pcalibre2 calibre7">3</td>
<td id="P7000497027000000000000000043306" data-uri="chapter05.xhtml#P7000497027000000000000000043306" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P7000497027000000000000000043307" data-uri="chapter05.xhtml#P7000497027000000000000000043307" class="pcalibre1 pcalibre2 calibre7">1</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043308" data-uri="chapter05.xhtml#P7000497027000000000000000043308" class="pcalibre1 pcalibre2 calibre7">Multiplication</td>
<td id="P7000497027000000000000000043309" data-uri="chapter05.xhtml#P7000497027000000000000000043309" class="pcalibre1 pcalibre2 calibre7">3</td>
<td id="P700049702700000000000000004330A" data-uri="chapter05.xhtml#P700049702700000000000000004330A" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P700049702700000000000000004330B" data-uri="chapter05.xhtml#P700049702700000000000000004330B" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P700049702700000000000000004330C" data-uri="chapter05.xhtml#P700049702700000000000000004330C" class="pcalibre1 pcalibre2 calibre7">5</td>
<td id="P700049702700000000000000004330D" data-uri="chapter05.xhtml#P700049702700000000000000004330D" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P700049702700000000000000004330E" data-uri="chapter05.xhtml#P700049702700000000000000004330E" class="pcalibre1 pcalibre2 calibre7">2</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004330F" data-uri="chapter05.xhtml#P700049702700000000000000004330F" class="pcalibre1 pcalibre2 calibre7">Division</td>
<td id="P7000497027000000000000000043310" data-uri="chapter05.xhtml#P7000497027000000000000000043310" class="pcalibre1 pcalibre2 calibre7">3−30</td>
<td id="P7000497027000000000000000043311" data-uri="chapter05.xhtml#P7000497027000000000000000043311" class="pcalibre1 pcalibre2 calibre7">3−30</td>
<td id="P7000497027000000000000000043312" data-uri="chapter05.xhtml#P7000497027000000000000000043312" class="pcalibre1 pcalibre2 calibre7">1</td>
<td id="P7000497027000000000000000043313" data-uri="chapter05.xhtml#P7000497027000000000000000043313" class="pcalibre1 pcalibre2 calibre7">3−15</td>
<td id="P7000497027000000000000000043314" data-uri="chapter05.xhtml#P7000497027000000000000000043314" class="pcalibre1 pcalibre2 calibre7">3−15</td>
<td id="P7000497027000000000000000043315" data-uri="chapter05.xhtml#P7000497027000000000000000043315" class="pcalibre1 pcalibre2 calibre7">1</td>
</tr>
</tbody>
</table>
<figcaption id="P7000497027000000000000000043316" data-uri="chapter05.xhtml#P7000497027000000000000000043316" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043317" data-uri="chapter05.xhtml#P7000497027000000000000000043317" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.12 </span>Latency, issue time, and capacity characteristics of reference machine operations.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000043318" data-uri="chapter05.xhtml#P7000497027000000000000000043318"><p id="P7000497027000000000000000043319" data-uri="chapter05.xhtml#P7000497027000000000000000043319" class="pcalibre1 pcalibre2 pcalibre10">Latency indicates the total number of clock cycles required to perform the actual operations, while issue time indicates the minimum number of cycles between two independent operations. The capacity indicates how many of these operations can be issued simultaneously. The times for division depend on the data values.</p></div></figcaption></figure>
</section>
<section id="P7000497027000000000000000004BD0" data-uri="chapter05.xhtml#P7000497027000000000000000004BD0" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004331A" data-uri="chapter05.xhtml#P700049702700000000000000004331A" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.7.2 </span>Functional Unit Performance</h1></header>
<p id="P700049702700000000000000004331B" data-uri="chapter05.xhtml#P700049702700000000000000004331B" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004BAA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a> documents the performance of some of the arithmetic operations for our Intel Core i7 Haswell reference machine, determined by both measurements and by reference to Intel literature [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B404">49</a>]. These timings are typical for other processors as well. Each operation is characterized by its <i class="pcalibre17 pcalibre2 pcalibre1">latency</i>, meaning the total time required to perform the operation, the <i class="pcalibre17 pcalibre2 pcalibre1">issue time</i>, meaning the minimum number of clock cycles between two independent operations of the same type, and the <i class="pcalibre17 pcalibre2 pcalibre1">capacity</i>, indicating the number of functional units capable of performing that operation.</p>
<p id="P700049702700000000000000004331C" data-uri="chapter05.xhtml#P700049702700000000000000004331C" class="pcalibre8 pcalibre1 pcalibre2">We see that the latencies increase in going from integer to floating-point operations. We see also that the addition and multiplication operations all have issue times of 1, meaning that on each clock cycle, the processor can start a new one of these operations. This short issue time is achieved through the use of <i class="pcalibre17 pcalibre2 pcalibre1">pipelining</i>. A pipelined function unit is implemented as a series of <i class="pcalibre17 pcalibre2 pcalibre1">stages</i>, each of which performs part of the operation. For example, a typical floating-point adder contains three stages (and hence the three-cycle latency): one to process the exponent values, one to add the fractions, and one to round the result. The arithmetic operations can proceed through the stages in close succession rather than waiting for one operation to complete before the next begins. This capability can be exploited only if there are successive, logically independent operations to be performed. Functional units with issue times of 1 cycle are said to be <i class="pcalibre17 pcalibre2 pcalibre1">fully pipelined:</i> they can start a new operation every clock cycle. Operations with capacity greater than 1 arise due to the capabilities of the multiple functional units, as was described earlier for the reference machine.</p>
<p id="P700049702700000000000000004331D" data-uri="chapter05.xhtml#P700049702700000000000000004331D" class="pcalibre8 pcalibre1 pcalibre2">We see also that the divider (used for integer and floating-point division, as well as floating-point square root) is not pipelined—its issue time equals its latency. What this means is that the divider must perform a complete division before it can begin anew one. We also see that the latencies and issue times for division are given as ranges, because some combinations of dividend and divisor require more steps than others. The long latency and issue times of division make it a comparatively costly operation.</p>
<p id="P700049702700000000000000004331E" data-uri="chapter05.xhtml#P700049702700000000000000004331E" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004BD6" title="524" data-uri="chapter05.xhtml#P7000497027000000000000000004BD6" epub:type="pagebreak"></span>A more common way of expressing issue time is to specify the maximum <i class="pcalibre17 pcalibre2 pcalibre1">throughput</i> of the unit, defined as the reciprocal of the issue time. A fully pipelined functional unit has a maximum throughput of 1 operation per clock cycle, while units with higher issue times have lower maximum throughput. Having multiple functional units can increase throughput even further. For an operation with capacity <var class="pcalibre17 pcalibre2 pcalibre1">C</var> and issue time <var class="pcalibre17 pcalibre2 pcalibre1">I</var>, the processor can potentially achieve a throughput of <i class="pcalibre17 pcalibre2 pcalibre1">C/I</i> operations per clock cycle. For example, our reference machine is capable of performing floating-point multiplication operations at a rate of 2 per clock cycle. We will see how this capability can be exploited to increase program performance.</p>
<p id="P700049702700000000000000004331F" data-uri="chapter05.xhtml#P700049702700000000000000004331F" class="pcalibre8 pcalibre1 pcalibre2">Circuit designers can create functional units with wide ranges of performance characteristics. Creating a unit with short latency or with pipelining requires more hardware, especially for more complex functions such as multiplication and floating-point operations. Since there is only a limited amount of space for these units on the microprocessor chip, CPU designers must carefully balance the number of functional units and their individual performance to achieve optimal overall performance. They evaluate many different benchmark programs and dedicate the most resources to the most critical operations. As <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004BAA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a> indicates, integer multiplication and floating-point multiplication and addition were considered important operations in the design of the Core i7 Haswell processor, even though a significant amount of hardware is required to achieve the low latencies and high degree of pipelining shown. On the other hand, division is relatively infrequent and difficult to implement with either short latency or full pipelining.</p>
<p id="P7000497027000000000000000043320" data-uri="chapter05.xhtml#P7000497027000000000000000043320" class="pcalibre8 pcalibre1 pcalibre2">The latencies, issue times, and capacities of these arithmetic operations can affect the performance of our combining functions. We can express these effects in terms of two fundamental bounds on the CPE values:</p>
<table id="P7000497027000000000000000043321" data-uri="chapter05.xhtml#P7000497027000000000000000043321" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043322" data-uri="chapter05.xhtml#P7000497027000000000000000043322" class="pcalibre1 pcalibre2 calibre5"/>
<th colspan="2" id="P7000497027000000000000000043323" data-uri="chapter05.xhtml#P7000497027000000000000000043323" class="pcalibre1 pcalibre2 calibre5">Integer</th>
<th colspan="2" id="P7000497027000000000000000043324" data-uri="chapter05.xhtml#P7000497027000000000000000043324" class="pcalibre1 pcalibre2 calibre5">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043325" data-uri="chapter05.xhtml#P7000497027000000000000000043325" class="pcalibre1 pcalibre2 calibre5">Bound</th>
<th id="P7000497027000000000000000043326" data-uri="chapter05.xhtml#P7000497027000000000000000043326" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P7000497027000000000000000043327" data-uri="chapter05.xhtml#P7000497027000000000000000043327" class="pcalibre1 pcalibre2 calibre5">*</th>
<th id="P7000497027000000000000000043328" data-uri="chapter05.xhtml#P7000497027000000000000000043328" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P7000497027000000000000000043329" data-uri="chapter05.xhtml#P7000497027000000000000000043329" class="pcalibre1 pcalibre2 calibre5">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004332A" data-uri="chapter05.xhtml#P700049702700000000000000004332A" class="pcalibre1 pcalibre2 calibre7">Latency</td>
<td id="P700049702700000000000000004332B" data-uri="chapter05.xhtml#P700049702700000000000000004332B" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P700049702700000000000000004332C" data-uri="chapter05.xhtml#P700049702700000000000000004332C" class="pcalibre1 pcalibre2 calibre7">3.00</td>
<td id="P700049702700000000000000004332D" data-uri="chapter05.xhtml#P700049702700000000000000004332D" class="pcalibre1 pcalibre2 calibre7">3.00</td>
<td id="P700049702700000000000000004332E" data-uri="chapter05.xhtml#P700049702700000000000000004332E" class="pcalibre1 pcalibre2 calibre7">5.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004332F" data-uri="chapter05.xhtml#P700049702700000000000000004332F" class="pcalibre1 pcalibre2 calibre7">Throughput</td>
<td id="P7000497027000000000000000043330" data-uri="chapter05.xhtml#P7000497027000000000000000043330" class="pcalibre1 pcalibre2 calibre7">0.50</td>
<td id="P7000497027000000000000000043331" data-uri="chapter05.xhtml#P7000497027000000000000000043331" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P7000497027000000000000000043332" data-uri="chapter05.xhtml#P7000497027000000000000000043332" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P7000497027000000000000000043333" data-uri="chapter05.xhtml#P7000497027000000000000000043333" class="pcalibre1 pcalibre2 calibre7">0.50</td>
</tr>
</tbody>
</table>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043334" data-uri="chapter05.xhtml#P7000497027000000000000000043334">The <i class="pcalibre17 pcalibre2 pcalibre1">latency bound</i> gives a minimum value for the CPE for any function that must perform the combining operation in a strict sequence. The <i class="pcalibre17 pcalibre2 pcalibre1">throughput bound</i> gives a minimum bound for the CPE based on the maximum rate at which the functional units can produce results. For example, since there is only one integer multiplier, and it has an issue time of 1 clock cycle, the processor cannot possibly sustain a rate of more than 1 multiplication per clock cycle. On the other hand, with four functional units capable of performing integer addition, the processor can potentially sustain a rate of 4 operations per cycle. Unfortunately, the need to read elements from memory creates an additional throughput bound. The two load units limit the processor to reading at most 2 data values per clock cycle, yielding a throughput bound of 0.50. We will demonstrate the effect of both the latency and throughput bounds with different versions of the combining functions.</p>
</section>
<section id="P7000497027000000000000000004BED" data-uri="chapter05.xhtml#P7000497027000000000000000004BED" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000043335" data-uri="chapter05.xhtml#P7000497027000000000000000043335" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004BEF" title="525" data-uri="chapter05.xhtml#P7000497027000000000000000004BEF" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">5.7.3 </span>An Abstract Model of Processor Operation</h1></header>
<p id="P7000497027000000000000000043336" data-uri="chapter05.xhtml#P7000497027000000000000000043336" class="pcalibre8 pcalibre1 pcalibre2">As a tool for analyzing the performance of a machine-level program executing on a modern processor, we will use a <i class="pcalibre17 pcalibre2 pcalibre1">data-flow</i> representation of programs, a graphical notation showing how the data dependencies between the different operations constrain the order in which they are executed. These constraints then lead to <i class="pcalibre17 pcalibre2 pcalibre1">critical paths</i> in the graph, putting a lower bound on the number of clock cycles required to execute a set of machine instructions.</p>
<p id="P7000497027000000000000000043337" data-uri="chapter05.xhtml#P7000497027000000000000000043337" class="pcalibre8 pcalibre1 pcalibre2">Before proceeding with the technical details, it is instructive to examine the CPE measurements obtained for function <code id="P7000497027000000000000000043338" data-uri="chapter05.xhtml#P7000497027000000000000000043338" class="pcalibre1 calibre1 pcalibre2">combine4</code>, our fastest code up to this point:</p>
<table id="P7000497027000000000000000043339" data-uri="chapter05.xhtml#P7000497027000000000000000043339" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P700049702700000000000000004333A" data-uri="chapter05.xhtml#P700049702700000000000000004333A" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P700049702700000000000000004333B" data-uri="chapter05.xhtml#P700049702700000000000000004333B" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P700049702700000000000000004333C" data-uri="chapter05.xhtml#P700049702700000000000000004333C" class="pcalibre1 pcalibre2 calibre5"/>
<th colspan="2" id="P700049702700000000000000004333D" data-uri="chapter05.xhtml#P700049702700000000000000004333D" class="pcalibre1 pcalibre2 calibre5">Integer</th>
<th colspan="2" id="P700049702700000000000000004333E" data-uri="chapter05.xhtml#P700049702700000000000000004333E" class="pcalibre1 pcalibre2 calibre5">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P700049702700000000000000004333F" data-uri="chapter05.xhtml#P700049702700000000000000004333F" class="pcalibre1 pcalibre2 calibre5">Function</th>
<th id="P7000497027000000000000000043340" data-uri="chapter05.xhtml#P7000497027000000000000000043340" class="pcalibre1 pcalibre2 calibre5">Page</th>
<th id="P7000497027000000000000000043341" data-uri="chapter05.xhtml#P7000497027000000000000000043341" class="pcalibre1 pcalibre2 calibre5">Method</th>
<th id="P7000497027000000000000000043342" data-uri="chapter05.xhtml#P7000497027000000000000000043342" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P7000497027000000000000000043343" data-uri="chapter05.xhtml#P7000497027000000000000000043343" class="pcalibre1 pcalibre2 calibre5">*</th>
<th id="P7000497027000000000000000043344" data-uri="chapter05.xhtml#P7000497027000000000000000043344" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P7000497027000000000000000043345" data-uri="chapter05.xhtml#P7000497027000000000000000043345" class="pcalibre1 pcalibre2 calibre5">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043346" data-uri="chapter05.xhtml#P7000497027000000000000000043346" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000043347" data-uri="chapter05.xhtml#P7000497027000000000000000043347" class="calibre3 pcalibre1 pcalibre2">combine4</code></td>
<td id="P7000497027000000000000000043348" data-uri="chapter05.xhtml#P7000497027000000000000000043348" class="pcalibre1 pcalibre2 calibre7">515</td>
<td id="P7000497027000000000000000043349" data-uri="chapter05.xhtml#P7000497027000000000000000043349" class="pcalibre1 pcalibre2 calibre7">Accumulate in temporary</td>
<td id="P700049702700000000000000004334A" data-uri="chapter05.xhtml#P700049702700000000000000004334A" class="pcalibre1 pcalibre2 calibre7">1.27</td>
<td id="P700049702700000000000000004334B" data-uri="chapter05.xhtml#P700049702700000000000000004334B" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P700049702700000000000000004334C" data-uri="chapter05.xhtml#P700049702700000000000000004334C" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P700049702700000000000000004334D" data-uri="chapter05.xhtml#P700049702700000000000000004334D" class="pcalibre1 pcalibre2 calibre7">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="3" id="P700049702700000000000000004334E" data-uri="chapter05.xhtml#P700049702700000000000000004334E" class="pcalibre1 pcalibre2 calibre7">Latency bound</td>
<td id="P700049702700000000000000004334F" data-uri="chapter05.xhtml#P700049702700000000000000004334F" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P7000497027000000000000000043350" data-uri="chapter05.xhtml#P7000497027000000000000000043350" class="pcalibre1 pcalibre2 calibre7">3.00</td>
<td id="P7000497027000000000000000043351" data-uri="chapter05.xhtml#P7000497027000000000000000043351" class="pcalibre1 pcalibre2 calibre7">3.00</td>
<td id="P7000497027000000000000000043352" data-uri="chapter05.xhtml#P7000497027000000000000000043352" class="pcalibre1 pcalibre2 calibre7">5.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="3" id="P7000497027000000000000000043353" data-uri="chapter05.xhtml#P7000497027000000000000000043353" class="pcalibre1 pcalibre2 calibre7">Throughput bound</td>
<td id="P7000497027000000000000000043354" data-uri="chapter05.xhtml#P7000497027000000000000000043354" class="pcalibre1 pcalibre2 calibre7">0.50</td>
<td id="P7000497027000000000000000043355" data-uri="chapter05.xhtml#P7000497027000000000000000043355" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P7000497027000000000000000043356" data-uri="chapter05.xhtml#P7000497027000000000000000043356" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P7000497027000000000000000043357" data-uri="chapter05.xhtml#P7000497027000000000000000043357" class="pcalibre1 pcalibre2 calibre7">0.50</td>
</tr>
</tbody>
</table>
<p id="P7000497027000000000000000043358" data-uri="chapter05.xhtml#P7000497027000000000000000043358" class="pcalibre8 pcalibre1 pcalibre2">We can see that these measurements match the latency bound for the processor, except for the case of integer addition. This is not a coincidence—it indicates that the performance of these functions is dictated by the latency of the sum or product computation being performed. Computing the product or sum of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> elements requires around <i class="pcalibre17 pcalibre2 pcalibre1">L · n</i> + <var class="pcalibre17 pcalibre2 pcalibre1">K</var> clock cycles, where <var class="pcalibre17 pcalibre2 pcalibre1">L</var> is the latency of the combining operation and <var class="pcalibre17 pcalibre2 pcalibre1">K</var> represents the overhead of calling the function and initiating and terminating the loop. The CPE is therefore equal to the latency bound <var class="pcalibre17 pcalibre2 pcalibre1">L</var>.</p>
<section id="P7000497027000000000000000004C13" data-uri="chapter05.xhtml#P7000497027000000000000000004C13" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000043359" data-uri="chapter05.xhtml#P7000497027000000000000000043359" epub:type="title">From Machine-Level Code to Data-Flow Graphs</h1></header>
<p id="P700049702700000000000000004335A" data-uri="chapter05.xhtml#P700049702700000000000000004335A" class="pcalibre8 pcalibre1 pcalibre2">Our data-flow representation of programs is informal. We use it as a way to visualize how the data dependencies in a program dictate its performance. We present the data-flow notation by working with <code id="P700049702700000000000000004335B" data-uri="chapter05.xhtml#P700049702700000000000000004335B" class="pcalibre1 calibre1 pcalibre2">combine4</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004AB6.xhtml#P7000497027000000000000000004AD0"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.10</span></a>) as an example. We focus just on the computation performed by the loop, since this is the dominating factor in performance for large vectors. We consider the case of data type <code id="P700049702700000000000000004335C" data-uri="chapter05.xhtml#P700049702700000000000000004335C" class="pcalibre1 calibre1 pcalibre2">double</code> with multiplication as the combining operation. Other combinations of data type and operation yield similar code. The compiled code for this loop consists of four instructions, with registers <code id="P700049702700000000000000004335D" data-uri="chapter05.xhtml#P700049702700000000000000004335D" class="pcalibre1 calibre1 pcalibre2">%rdx</code> holding a pointer to the <var class="pcalibre17 pcalibre2 pcalibre1">i</var>th element of array data, <code id="P700049702700000000000000004335E" data-uri="chapter05.xhtml#P700049702700000000000000004335E" class="pcalibre1 calibre1 pcalibre2">%rax</code> holding a pointer to the end of the array, and <code id="P700049702700000000000000004335F" data-uri="chapter05.xhtml#P700049702700000000000000004335F" class="pcalibre1 calibre1 pcalibre2">%xmm0</code> holding the accumulated value <code id="P7000497027000000000000000043360" data-uri="chapter05.xhtml#P7000497027000000000000000043360" class="pcalibre1 calibre1 pcalibre2">acc</code>.</p>
<pre id="P7000497027000000000000000043361" data-uri="chapter05.xhtml#P7000497027000000000000000043361" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043362" data-uri="chapter05.xhtml#P7000497027000000000000000043362" class="calibre3 pcalibre1 pcalibre2">
	<i class="pcalibre17 pcalibre2 pcalibre1">Inner loop of combine4. data_t = double, OP = *</i>
	<i class="pcalibre17 pcalibre2 pcalibre1">acc in %xmm0, data+i in %rdx, data+length in %rax</i>
1	.L25:				<b class="pcalibre1 pcalibre2 pcalibre12">loop:</b>
2	  vmulsd (%rdx), %xmm0, %xmm0	  <i class="pcalibre17 pcalibre2 pcalibre1">Multiply acc by data[i]</i>
3	  addq $8, %rdx			  <i class="pcalibre17 pcalibre2 pcalibre1">Increment data+i</i>
4	  cmpq %rax, %rdx		  <i class="pcalibre17 pcalibre2 pcalibre1">Compare to data+length</i>
5	  jne .L25			  <i class="pcalibre17 pcalibre2 pcalibre1">If !=, goto</i> loop
</code></pre>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004C1E" data-uri="chapter05.xhtml#P7000497027000000000000000004C1E">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004C1F" title="526" data-uri="chapter05.xhtml#P7000497027000000000000000004C1F" epub:type="pagebreak"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for combine4." id="P7000497027000000000000000043363" data-uri="P700049702700000000000000000B712" src="../images/p526-1.png" class="pcalibre1 pcalibre2 pcalibre192"/>
<figcaption id="P7000497027000000000000000043364" data-uri="chapter05.xhtml#P7000497027000000000000000043364" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043365" data-uri="chapter05.xhtml#P7000497027000000000000000043365" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13 </span>Graphical representation of inner-loop code for <code id="P7000497027000000000000000043366" data-uri="chapter05.xhtml#P7000497027000000000000000043366" class="pcalibre1 calibre1 pcalibre2">combine4</code></h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043367" data-uri="chapter05.xhtml#P7000497027000000000000000043367"><p id="P7000497027000000000000000043368" data-uri="chapter05.xhtml#P7000497027000000000000000043368" class="pcalibre1 pcalibre2 pcalibre10">Instructions are dynamically translated into one or two operations, each of which receives values from other operations or from registers and produces values for other operations and for registers. We show the target of the final instruction as the label loop. It jumps to the first instruction shown.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000023649" data-uri="chapter05.xhtml#P7000497027000000000000000023649">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000043369" data-uri="chapter05.xhtml#P7000497027000000000000000043369" class="pcalibre8 pcalibre1 pcalibre2">A diagram has two rows of boxes, each with %rax, %rdx, and %rmm0, with output from top %rax to bottom %rax. A column of boxes includes the five operations summarized below, from top to bottom:</p>
<ul id="P700049702700000000000000004336A" data-uri="chapter05.xhtml#P700049702700000000000000004336A" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P700049702700000000000000004336B" data-uri="chapter05.xhtml#P700049702700000000000000004336B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004336C" data-uri="chapter05.xhtml#P700049702700000000000000004336C" class="pcalibre1 pcalibre2 pcalibre10">load: receives input from top %rdx; sends output to mul below</p></li>
<li id="P700049702700000000000000004336D" data-uri="chapter05.xhtml#P700049702700000000000000004336D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004336E" data-uri="chapter05.xhtml#P700049702700000000000000004336E" class="pcalibre1 pcalibre2 pcalibre10">mul: receives input from load, with the two together representing vmulsd (%rdx), %rmm0, %rmm0; receives input from top %rmm0</p></li>
<li id="P700049702700000000000000004336F" data-uri="chapter05.xhtml#P700049702700000000000000004336F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043370" data-uri="chapter05.xhtml#P7000497027000000000000000043370" class="pcalibre1 pcalibre2 pcalibre10">add (addq $8, %rdx): receives input from top %rdx and sends output to bottom %rmm0</p></li>
<li id="P7000497027000000000000000043371" data-uri="chapter05.xhtml#P7000497027000000000000000043371" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043372" data-uri="chapter05.xhtml#P7000497027000000000000000043372" class="pcalibre1 pcalibre2 pcalibre10">cmp (cmpq %rax, %rdx): receives input from add above and top %rax; sends output to jne below</p></li>
<li id="P7000497027000000000000000043373" data-uri="chapter05.xhtml#P7000497027000000000000000043373" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043374" data-uri="chapter05.xhtml#P7000497027000000000000000043374" class="pcalibre1 pcalibre2 pcalibre10">jne (jne loop); receives input from cmp above and top %rax</p></li>
</ul>
</details>
</figcaption></figure>
<p id="P7000497027000000000000000043375" data-uri="chapter05.xhtml#P7000497027000000000000000043375" class="pcalibre8 pcalibre1 pcalibre2">As <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> indicates, with our hypothetical processor design, the four instructions are expanded by the instruction decoder into a series of five <i class="pcalibre17 pcalibre2 pcalibre1">operations</i>, with the initial multiplication instruction being expanded into a load operation to read the source operand from memory, and a mul operation to perform the multiplication.</p>
<p id="P7000497027000000000000000043376" data-uri="chapter05.xhtml#P7000497027000000000000000043376" class="pcalibre8 pcalibre1 pcalibre2">As a step toward generating a data-flow graph representation of the program, the boxes and lines along the left-hand side of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> show how the registers are used and updated by the different operations, with the boxes along the top representing the register values at the beginning of the loop, and those along the bottom representing the values at the end. For example, register <code id="P7000497027000000000000000043377" data-uri="chapter05.xhtml#P7000497027000000000000000043377" class="pcalibre1 calibre1 pcalibre2">%rax</code> is only used as a source value by the <code id="P7000497027000000000000000043378" data-uri="chapter05.xhtml#P7000497027000000000000000043378" class="pcalibre1 calibre1 pcalibre2">cmp</code> operation, and so the register has the same value at the end of the loop as at the beginning. Register <code id="P7000497027000000000000000043379" data-uri="chapter05.xhtml#P7000497027000000000000000043379" class="pcalibre1 calibre1 pcalibre2">%rdx</code>, on the other hand, is both used and updated within the loop. Its initial value is used by the load and add operations; its new value is generated by the add operation, which is then used by the <code id="P700049702700000000000000004337A" data-uri="chapter05.xhtml#P700049702700000000000000004337A" class="pcalibre1 calibre1 pcalibre2">cmp</code> operation. Register <code id="P700049702700000000000000004337B" data-uri="chapter05.xhtml#P700049702700000000000000004337B" class="pcalibre1 calibre1 pcalibre2">%xmm0</code> is also updated within the loop by the mul operation, which first uses the initial value as a source value.</p>
<p id="P700049702700000000000000004337C" data-uri="chapter05.xhtml#P700049702700000000000000004337C" class="pcalibre8 pcalibre1 pcalibre2">Some of the operations in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a> produce values that do not correspond to registers. We show these as arcs between operations on the right-hand side. The load operation reads a value from memory and passes it directly to the <code id="P700049702700000000000000004337D" data-uri="chapter05.xhtml#P700049702700000000000000004337D" class="pcalibre1 calibre1 pcalibre2">mul</code> operation. Since these two operations arise from decoding a single <code id="P700049702700000000000000004337E" data-uri="chapter05.xhtml#P700049702700000000000000004337E" class="pcalibre1 calibre1 pcalibre2">vmulsd</code> instruction, there is no register associated with the intermediate value passing between them. The <code id="P700049702700000000000000004337F" data-uri="chapter05.xhtml#P700049702700000000000000004337F" class="pcalibre1 calibre1 pcalibre2">cmp</code> operation updates the condition codes, and these are then tested by the <code id="P7000497027000000000000000043380" data-uri="chapter05.xhtml#P7000497027000000000000000043380" class="pcalibre1 calibre1 pcalibre2">jne</code> operation.</p>
<p id="P7000497027000000000000000043381" data-uri="chapter05.xhtml#P7000497027000000000000000043381" class="pcalibre8 pcalibre1 pcalibre2">For a code segment forming a loop, we can classify the registers that are accessed into four categories:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004C33" data-uri="chapter05.xhtml#P7000497027000000000000000004C33">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004C34" title="527" data-uri="chapter05.xhtml#P7000497027000000000000000004C34" epub:type="pagebreak"></span>
<img alt="A diagram depicts two data-flow graphs for combine4." id="P7000497027000000000000000043382" data-uri="P700049702700000000000000000B713" src="../images/p527-1.png" class="pcalibre1 pcalibre2 pcalibre193"/>
<figcaption id="P7000497027000000000000000043383" data-uri="chapter05.xhtml#P7000497027000000000000000043383" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043384" data-uri="chapter05.xhtml#P7000497027000000000000000043384" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14 </span>Abstracting <code id="P7000497027000000000000000043385" data-uri="chapter05.xhtml#P7000497027000000000000000043385" class="pcalibre1 calibre1 pcalibre2">combine4</code> operations as a data-flow graph.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043386" data-uri="chapter05.xhtml#P7000497027000000000000000043386"><p id="P7000497027000000000000000043387" data-uri="chapter05.xhtml#P7000497027000000000000000043387" class="pcalibre1 pcalibre2 pcalibre10">We rearrange the operators of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.13</span></a> to more clearly show the data dependencies (a), and then further show only those operations that use values from one iteration to produce new values for the next (b).</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000023669" data-uri="chapter05.xhtml#P7000497027000000000000000023669">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P7000497027000000000000000043388" data-uri="chapter05.xhtml#P7000497027000000000000000043388">
<li id="P7000497027000000000000000043389" data-uri="chapter05.xhtml#P7000497027000000000000000043389" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004338A" data-uri="chapter05.xhtml#P700049702700000000000000004338A" class="pcalibre1 pcalibre2 pcalibre10">Data flows from top %rmm0 to mul to bottom %rmm0; from top %rax to cmp to jne; from top %rdx to load and add. From load, data is sent to mul and bottom %rmm0. From add, data is sent to bottom %rdx and to cmp, sent to jne.</p></li>
<li id="P700049702700000000000000004338B" data-uri="chapter05.xhtml#P700049702700000000000000004338B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004338C" data-uri="chapter05.xhtml#P700049702700000000000000004338C" class="pcalibre1 pcalibre2 pcalibre10">Operations within data[i]: data flows from top %rmm0 to mul to bottom %rmm0; from top %rdx to load and add, with load leading to mul and add leading to bottom %rdx.</p></li>
</ol>
</details>

</figcaption></figure>
<ul class="pcalibre38 pcalibre1 pcalibre2" id="P700049702700000000000000004338D" data-uri="chapter05.xhtml#P700049702700000000000000004338D">
<li id="P700049702700000000000000004338E" data-uri="chapter05.xhtml#P700049702700000000000000004338E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004338F" data-uri="chapter05.xhtml#P700049702700000000000000004338F" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Read-only. </span>These are used as source values, either as data or to compute memory addresses, but they are not modified within the loop. The only read only register for the loop in <code id="P7000497027000000000000000043390" data-uri="chapter05.xhtml#P7000497027000000000000000043390" class="pcalibre1 calibre1 pcalibre2">combine4</code> is <code id="P7000497027000000000000000043391" data-uri="chapter05.xhtml#P7000497027000000000000000043391" class="pcalibre1 calibre1 pcalibre2">%rax</code>.</p></li>
<li id="P7000497027000000000000000043392" data-uri="chapter05.xhtml#P7000497027000000000000000043392" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043393" data-uri="chapter05.xhtml#P7000497027000000000000000043393" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Write-only. </span>These are used as the destinations of data-movement operations. There are no such registers in this loop.</p></li>
<li id="P7000497027000000000000000043394" data-uri="chapter05.xhtml#P7000497027000000000000000043394" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043395" data-uri="chapter05.xhtml#P7000497027000000000000000043395" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Local. </span>These are updated and used within the loop, but there is no dependency from one iteration to another. The condition code registers are examples for this loop: they are updated by the <code id="P7000497027000000000000000043396" data-uri="chapter05.xhtml#P7000497027000000000000000043396" class="pcalibre1 calibre1 pcalibre2">cmp</code> operation and used by the <code id="P7000497027000000000000000043397" data-uri="chapter05.xhtml#P7000497027000000000000000043397" class="pcalibre1 calibre1 pcalibre2">jne</code> operation, but this dependency is contained within individual iterations.</p></li>
<li id="P7000497027000000000000000043398" data-uri="chapter05.xhtml#P7000497027000000000000000043398" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043399" data-uri="chapter05.xhtml#P7000497027000000000000000043399" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre41">Loop. </span>These are used both as source values and as destinations for the loop, with the value generated in one iteration being used in another. We can see that <code id="P700049702700000000000000004339A" data-uri="chapter05.xhtml#P700049702700000000000000004339A" class="pcalibre1 calibre1 pcalibre2">%rdx</code> and <code id="P700049702700000000000000004339B" data-uri="chapter05.xhtml#P700049702700000000000000004339B" class="pcalibre1 calibre1 pcalibre2">%xmm0</code> are loop registers for <code id="P700049702700000000000000004339C" data-uri="chapter05.xhtml#P700049702700000000000000004339C" class="pcalibre1 calibre1 pcalibre2">combine4</code>, corresponding to program values <code id="P700049702700000000000000004339D" data-uri="chapter05.xhtml#P700049702700000000000000004339D" class="pcalibre1 calibre1 pcalibre2">data+i</code> and <code id="P700049702700000000000000004339E" data-uri="chapter05.xhtml#P700049702700000000000000004339E" class="pcalibre1 calibre1 pcalibre2">acc</code>.</p></li>
</ul>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004339F" data-uri="chapter05.xhtml#P700049702700000000000000004339F">As we will see, the chains of operations between loop registers determine the performance-limiting data dependencies.</p>
<p id="P70004970270000000000000000433A0" data-uri="chapter05.xhtml#P70004970270000000000000000433A0" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14</span></a> shows further refinements of the graphical representation of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C1E"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.13</span></a>, with a goal of showing only those operations and data dependencies that affect the program execution time. We see in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14(a)</span></a> that we rearranged the operators to show more clearly the flow of data from the source registers at the top (both read-only and loop registers) and to the destination registers at the bottom (both write-only and loop registers).</p>
<p id="P70004970270000000000000000433A1" data-uri="chapter05.xhtml#P70004970270000000000000000433A1" class="pcalibre8 pcalibre1 pcalibre2">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14(a)</span></a>, we also color operators white if they are not part of some chain of dependencies between loop registers. For this example, the comparison (cmp) and branch (jne) operations do not directly affect the flow of data in the program. We assume that the instruction control unit predicts that branch will be taken, and hence the program will continue looping. The purpose of the compare and branch operations is to test the branch condition and notify the ICU if it is <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004C50" title="528" data-uri="chapter05.xhtml#P7000497027000000000000000004C50" epub:type="pagebreak"></span>not taken. We assume this checking can be done quickly enough that it does not slow down the processor.</p>
<p id="P70004970270000000000000000433A2" data-uri="chapter05.xhtml#P70004970270000000000000000433A2" class="pcalibre8 pcalibre1 pcalibre2">In <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14(b)</span></a>, we have eliminated the operators that were colored white on the left, and we have retained only the loop registers. What we have left is an abstract template showing the data dependencies that form among loop registers due to one iteration of the loop. We can see in this diagram that there are two data dependencies from one iteration to the next. Along one side, we see the dependencies between successive values of program value <code id="P70004970270000000000000000433A3" data-uri="chapter05.xhtml#P70004970270000000000000000433A3" class="pcalibre1 calibre1 pcalibre2">acc</code>, stored in register <code id="P70004970270000000000000000433A4" data-uri="chapter05.xhtml#P70004970270000000000000000433A4" class="pcalibre1 calibre1 pcalibre2">%xmm0</code>. The loop computes a new value for <code id="P70004970270000000000000000433A5" data-uri="chapter05.xhtml#P70004970270000000000000000433A5" class="pcalibre1 calibre1 pcalibre2">acc</code> by multiplying the old value by a data element, generated by the load operation. Along the other side, we see the dependencies between successive values of the pointer to the <var class="pcalibre17 pcalibre2 pcalibre1">i</var>th data element. On each iteration, the old value is used as the address for the load operation, and it is also incremented by the add operation to compute its new value.</p>
<p id="P70004970270000000000000000433A6" data-uri="chapter05.xhtml#P70004970270000000000000000433A6" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C57"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15</span></a> shows the data-flow representation of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> iterations by the inner loop of function <code id="P70004970270000000000000000433A7" data-uri="chapter05.xhtml#P70004970270000000000000000433A7" class="pcalibre1 calibre1 pcalibre2">combine4</code>. This graph was obtained by simply replicating the template shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C33"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.14(b)</span></a><var class="pcalibre17 pcalibre2 pcalibre1">n</var>times.Wecan see that the program has two chains of data</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004C57" data-uri="chapter05.xhtml#P7000497027000000000000000004C57">
<img alt="A diagram shows a critical path extending through mul operations from data[0] to data[1] to data[n minus 2] to data[n minus 1]." id="P70004970270000000000000000433A8" data-uri="P700049702700000000000000000B714" src="../images/p528-1.png" class="pcalibre194 pcalibre1 pcalibre2"/>
<figcaption id="P70004970270000000000000000433A9" data-uri="chapter05.xhtml#P70004970270000000000000000433A9" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000433AA" data-uri="chapter05.xhtml#P70004970270000000000000000433AA" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15 </span>Data-flow representation of computation by <var class="pcalibre17 pcalibre2 pcalibre1">n</var> iterations of the inner loop of <code id="P70004970270000000000000000433AB" data-uri="chapter05.xhtml#P70004970270000000000000000433AB" class="pcalibre1 calibre1 pcalibre2">combine4</code>.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000433AC" data-uri="chapter05.xhtml#P70004970270000000000000000433AC"><p id="P70004970270000000000000000433AD" data-uri="chapter05.xhtml#P70004970270000000000000000433AD" class="pcalibre1 pcalibre2 pcalibre10">The sequence of multiplication operations forms a critical path that limits program performance.</p></div></figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000433AE" data-uri="chapter05.xhtml#P70004970270000000000000000433AE"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004C5F" title="529" data-uri="chapter05.xhtml#P7000497027000000000000000004C5F" epub:type="pagebreak"></span>dependencies, corresponding to the updating of program values <code id="P70004970270000000000000000433AF" data-uri="chapter05.xhtml#P70004970270000000000000000433AF" class="pcalibre1 calibre1 pcalibre2">acc</code> and <code id="P70004970270000000000000000433B0" data-uri="chapter05.xhtml#P70004970270000000000000000433B0" class="pcalibre1 calibre1 pcalibre2">data+i</code> with operations mul and add, respectively. Given that floating-point multiplication has a latency of 5 cycles, while integer addition has a latency of 1 cycle, we can see that the chain on the left will form a <i class="pcalibre17 pcalibre2 pcalibre1">critical path</i>, requiring 5<var class="pcalibre17 pcalibre2 pcalibre1">n</var> cycles to execute. The chain on the right would require only <var class="pcalibre17 pcalibre2 pcalibre1">n</var> cycles to execute, and so it does not limit the program performance.</p>
<p id="P70004970270000000000000000433B1" data-uri="chapter05.xhtml#P70004970270000000000000000433B1" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C57"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15</span></a> demonstrates why we achieved a CPE equal to the latency bound of 5 cycles for <code id="P70004970270000000000000000433B2" data-uri="chapter05.xhtml#P70004970270000000000000000433B2" class="pcalibre1 calibre1 pcalibre2">combine4</code>, when performing floating-point multiplication. When executing the function, the floating-point multiplier becomes the limiting resource. The other operations required during the loop—manipulating and testing pointer value <code id="P70004970270000000000000000433B3" data-uri="chapter05.xhtml#P70004970270000000000000000433B3" class="pcalibre1 calibre1 pcalibre2">data+i</code> and reading data from memory—proceed in parallel with the multiplication. As each successive value of <code id="P70004970270000000000000000433B4" data-uri="chapter05.xhtml#P70004970270000000000000000433B4" class="pcalibre1 calibre1 pcalibre2">acc</code> is computed, it is fed back around to compute the next value, but this will not occur until 5 cycles later.</p>
<p id="P70004970270000000000000000433B5" data-uri="chapter05.xhtml#P70004970270000000000000000433B5" class="pcalibre8 pcalibre1 pcalibre2">The flow for other combinations of data type and operation are identical to those shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C57"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15</span></a>, but with a different data operation forming the chain of data dependencies shown on the left. For all of the cases where the operation has a latency <var class="pcalibre17 pcalibre2 pcalibre1">L</var> greater than 1, we see that the measured CPE is simply <var class="pcalibre17 pcalibre2 pcalibre1">L</var>, indicating that this chain forms the performance-limiting critical path.</p>
</section>
<section id="P7000497027000000000000000004C67" data-uri="chapter05.xhtml#P7000497027000000000000000004C67" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P70004970270000000000000000433B6" data-uri="chapter05.xhtml#P70004970270000000000000000433B6" epub:type="title">Other Performance Factors</h1></header>
<p id="P70004970270000000000000000433B7" data-uri="chapter05.xhtml#P70004970270000000000000000433B7" class="pcalibre8 pcalibre1 pcalibre2">For the case of integer addition, on the other hand, our measurements of <code id="P70004970270000000000000000433B8" data-uri="chapter05.xhtml#P70004970270000000000000000433B8" class="pcalibre1 calibre1 pcalibre2">combine4</code> show a CPE of 1.27, slower than the CPE of 1.00 we would predict based on the chains of dependencies formed along either the left- or the right-hand side of the graph of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C57"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.15</span></a>. This illustrates the principle that the critical paths in a data-flow representation provide only a <i class="pcalibre17 pcalibre2 pcalibre1">lower</i> bound on how many cycles a program will require. Other factors can also limit performance, including the total number of functional units available and the number of data values that can be passed among the functional units on any given step. For the case of integer addition as the combining operation, the data operation is sufficiently fast that the rest of the operations cannot supply data fast enough. Determining exactly why the program requires 1.27 cycles per element would require a much more detailed knowledge of the hardware design than is publicly available.</p>
<p id="P70004970270000000000000000433B9" data-uri="chapter05.xhtml#P70004970270000000000000000433B9" class="pcalibre8 pcalibre1 pcalibre2">To summarize our performance analysis of <code id="P70004970270000000000000000433BA" data-uri="chapter05.xhtml#P70004970270000000000000000433BA" class="pcalibre1 calibre1 pcalibre2">combine4</code>: our abstract data-flow representation of program operation showed that <code id="P70004970270000000000000000433BB" data-uri="chapter05.xhtml#P70004970270000000000000000433BB" class="pcalibre1 calibre1 pcalibre2">combine4</code> has a critical path of length <i class="pcalibre17 pcalibre2 pcalibre1">L · n</i> caused by the successive updating of program value <code id="P70004970270000000000000000433BC" data-uri="chapter05.xhtml#P70004970270000000000000000433BC" class="pcalibre1 calibre1 pcalibre2">acc</code>, and this path limits the CPE to at least <var class="pcalibre17 pcalibre2 pcalibre1">L</var>. This is indeed the CPE we measure for all cases except integer addition, which has a measured CPE of 1.27 rather than the CPE of 1.00 we would expect from the critical path length.</p>
<p id="P70004970270000000000000000433BD" data-uri="chapter05.xhtml#P70004970270000000000000000433BD" class="pcalibre8 pcalibre1 pcalibre2">It may seem that the latency bound forms a fundamental limit on how fast our combining operations can be performed. Our next task will be to restructure the operations to enhance instruction-level parallelism. We want to transform the program in such a way that our only limitation becomes the throughput bound, yielding CPEs below or close to 1.00.</p>

<section id="P7000497027000000000000000004C70" data-uri="chapter05.xhtml#P7000497027000000000000000004C70" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P70004970270000000000000000433BE" data-uri="chapter05.xhtml#P70004970270000000000000000433BE" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004C72" title="530" data-uri="chapter05.xhtml#P7000497027000000000000000004C72" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.5 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005127">575</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000433BF" data-uri="chapter05.xhtml#P70004970270000000000000000433BF">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000433C0" data-uri="chapter05.xhtml#P70004970270000000000000000433C0">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000433C1" data-uri="chapter05.xhtml#P70004970270000000000000000433C1"><p id="P70004970270000000000000000433C2" data-uri="chapter05.xhtml#P70004970270000000000000000433C2" class="pcalibre1 pcalibre2 pcalibre10">Supposewewishtowriteafunctiontoevaluateapolynomial, where a polynomial of degree <var class="pcalibre17 pcalibre2 pcalibre1">n</var> is defined to have a set of coefficients <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">0</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">2</sub>, . . ., <i class="pcalibre17 pcalibre2 pcalibre1">a<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i>. For a value <var class="pcalibre17 pcalibre2 pcalibre1">x</var>, we evaluate the polynomial by computing</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P70004970270000000000000000433C3" data-uri="chapter05.xhtml#P70004970270000000000000000433C3">
<m:math display="block" alttext="" data-uri="" altimg-width="183" altimg-height="17" altimg="../images/ch05-5.png"><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mi>x</m:mi><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mn>2</m:mn></m:msub><m:msup><m:mi>x</m:mi><m:mn>2</m:mn></m:msup><m:mo>+</m:mo><m:mo>…</m:mo><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mi>n</m:mi></m:msub><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup></m:mrow></m:math>
<span class="pcalibre1 pcalibre76 pcalibre2">(5.2)</span>
</div>
<p id="P70004970270000000000000000433C4" data-uri="chapter05.xhtml#P70004970270000000000000000433C4" class="pcalibre1 pcalibre2 pcalibre10">This evaluation can be implemented by the following function, having as arguments an array of coefficients a, a value <code id="P70004970270000000000000000433C5" data-uri="chapter05.xhtml#P70004970270000000000000000433C5" class="pcalibre1 calibre1 pcalibre2">x</code>, and the polynomial degree <code id="P70004970270000000000000000433C6" data-uri="chapter05.xhtml#P70004970270000000000000000433C6" class="pcalibre1 calibre1 pcalibre2">degree</code> (the value <var class="pcalibre17 pcalibre2 pcalibre1">n</var> in Equation 5.2). In this function, we compute both the successive terms of the equation and the successive powers of <var class="pcalibre17 pcalibre2 pcalibre1">x</var> within a single loop:</p>
<pre id="P70004970270000000000000000433C7" data-uri="chapter05.xhtml#P70004970270000000000000000433C7" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000433C8" data-uri="chapter05.xhtml#P70004970270000000000000000433C8" class="calibre3 pcalibre1 pcalibre2">
1	double poly(double a[], double x, long degree)
2	{
3		long i;
4		double result = a[0];
5		double xpwr = x; /* Equals x⁁i at start of loop */
6		for (i = 1; i &lt;= degree; i++) {
7			result += a[i] * xpwr;
8			xpwr = x * xpwr;
9		}
10		return result;
11	}
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000433C9" data-uri="chapter05.xhtml#P70004970270000000000000000433C9">
<li id="P70004970270000000000000000433CA" data-uri="chapter05.xhtml#P70004970270000000000000000433CA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000433CB" data-uri="chapter05.xhtml#P70004970270000000000000000433CB" class="pcalibre1 pcalibre2 pcalibre10">For degree <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, how many additions and how many multiplications does this code perform?</p></li>
<li id="P70004970270000000000000000433CC" data-uri="chapter05.xhtml#P70004970270000000000000000433CC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000433CD" data-uri="chapter05.xhtml#P70004970270000000000000000433CD" class="pcalibre1 pcalibre2 pcalibre10">On our reference machine, with arithmetic operations having the latencies shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004BAA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a>, we measure the CPE for this function to be 5.00. Explain how this CPE arises based on the data dependencies formed between iterations due to the operations implementing lines 7-8 of the function.</p></li>
</ol></div></li>
</ol>
</section>
<section id="P7000497027000000000000000004C82" data-uri="chapter05.xhtml#P7000497027000000000000000004C82" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P70004970270000000000000000433CE" data-uri="chapter05.xhtml#P70004970270000000000000000433CE" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.6 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005127">575</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P70004970270000000000000000433CF" data-uri="chapter05.xhtml#P70004970270000000000000000433CF">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P70004970270000000000000000433D0" data-uri="chapter05.xhtml#P70004970270000000000000000433D0">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000433D1" data-uri="chapter05.xhtml#P70004970270000000000000000433D1"><p id="P70004970270000000000000000433D2" data-uri="chapter05.xhtml#P70004970270000000000000000433D2" class="pcalibre1 pcalibre2 pcalibre10">Let us continue exploring ways to evaluate polynomials, as described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C70"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.5</span></a>. We can reduce the number of multiplications in evaluating a polynomial by applying <i class="pcalibre17 pcalibre2 pcalibre1">Horner's method</i>, named after British mathematician William G. Horner (1786-1837). The idea is to repeatedly factor out the powers of <var class="pcalibre17 pcalibre2 pcalibre1">x</var> to get the following evaluation:</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P70004970270000000000000000433D3" data-uri="chapter05.xhtml#P70004970270000000000000000433D3">
<m:math display="block" alttext="" data-uri="" altimg-width="280" altimg-height="13" altimg="../images/ch05-6.png"><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>+</m:mo><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mo>+</m:mo><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mn>2</m:mn></m:msub><m:mo>+</m:mo><m:mo>…</m:mo><m:mo>+</m:mo><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mi>n</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:mi>x</m:mi><m:msub><m:mi>a</m:mi><m:mi>n</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>…</m:mo></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:math>
<span class="pcalibre1 pcalibre76 pcalibre2">(5.3)</span>
</div>
<p id="P70004970270000000000000000433D4" data-uri="chapter05.xhtml#P70004970270000000000000000433D4" class="pcalibre1 pcalibre2 pcalibre10">Using Horner's method, we can implement polynomial evaluation using the following code:</p>
<pre id="P70004970270000000000000000433D5" data-uri="chapter05.xhtml#P70004970270000000000000000433D5" class="calibre2 pcalibre2 pcalibre1"><code id="P70004970270000000000000000433D6" data-uri="chapter05.xhtml#P70004970270000000000000000433D6" class="calibre3 pcalibre1 pcalibre2">
1	/* Apply Horner's method */
2	double polyh(double a[], double x, long degree)
3	{
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004C8C" title="531" data-uri="chapter05.xhtml#P7000497027000000000000000004C8C" epub:type="pagebreak"></span>4		long i;
5		double result = a[degree];
6		for (i = degree-1; i &gt;= 0; i−)
7			result = a[i] + x*result;
8		return result;
9	}
</code></pre>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P70004970270000000000000000433D7" data-uri="chapter05.xhtml#P70004970270000000000000000433D7">
<li id="P70004970270000000000000000433D8" data-uri="chapter05.xhtml#P70004970270000000000000000433D8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000433D9" data-uri="chapter05.xhtml#P70004970270000000000000000433D9" class="pcalibre1 pcalibre2 pcalibre10">For degree <var class="pcalibre17 pcalibre2 pcalibre1">n</var>, how many additions and how many multiplications does this code perform?</p></li>
<li id="P70004970270000000000000000433DA" data-uri="chapter05.xhtml#P70004970270000000000000000433DA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000433DB" data-uri="chapter05.xhtml#P70004970270000000000000000433DB" class="pcalibre1 pcalibre2 pcalibre10">On our reference machine, with the arithmetic operations having the latencies shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004BAA"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.12</span></a>, we measure the CPE for this function to be 8.00. Explain how this CPE arises based on the data dependencies formed between iterations due to the operations implementing line 7 of the function.</p></li>
<li id="P70004970270000000000000000433DC" data-uri="chapter05.xhtml#P70004970270000000000000000433DC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000433DD" data-uri="chapter05.xhtml#P70004970270000000000000000433DD" class="pcalibre1 pcalibre2 pcalibre10">Explain how the function shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004C70"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.5</span></a> can run faster, even though it requires more operations.</p></li>
</ol></div></li>
</ol>
</section>
</section>
</section>
</section></body></html>
