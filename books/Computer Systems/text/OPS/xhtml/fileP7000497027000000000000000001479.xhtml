<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>2.5 Summary </title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000001479" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000003F78B" data-uri="chapter02.xhtml#P700049702700000000000000003F78B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">2.5 </span><span class="pcalibre1 pcalibre21 pcalibre2">Summary </span></h1></header>
<p id="P700049702700000000000000003F78C" data-uri="chapter02.xhtml#P700049702700000000000000003F78C" class="pcalibre8 pcalibre1 pcalibre2">Computers encode information as bits, generally organized as sequences of bytes. Different encodings are used for representing integers, real numbers, and character strings. Different models of computers use different conventions for encoding numbers and for ordering the bytes within multi-byte data.</p>
<p id="P700049702700000000000000003F78D" data-uri="chapter02.xhtml#P700049702700000000000000003F78D" class="pcalibre8 pcalibre1 pcalibre2">The C language is designed to accommodate a wide range of different implementations in terms of word sizes and numeric encodings. Machines with 64-bit word sizes have become increasingly common, replacing the 32-bit machines that dominated the market for around 30 years. Because 64-bit machines can also run programs compiled for 32-bit machines, we have focused on the distinction between 32-and 64-bit programs, rather than machines. The advantage of 64-bit programs is that they can go beyond the 4 GB address limitation of 32-bit programs.</p>
<p id="P700049702700000000000000003F78E" data-uri="chapter02.xhtml#P700049702700000000000000003F78E" class="pcalibre8 pcalibre1 pcalibre2">Most machines encode signed numbers using a two's-complement representation and encode floating-point numbers using IEEE Standard 754. Understanding these encodings at the bit level, as well as understanding the mathematical characteristics of the arithmetic operations, is important for writing programs that operate correctly over the full range of numeric values.</p>
<p id="P700049702700000000000000003F78F" data-uri="chapter02.xhtml#P700049702700000000000000003F78F" class="pcalibre8 pcalibre1 pcalibre2">When casting between signed and unsigned integers of the same size, most C implementations follow the convention that the underlying bit pattern does not change. On a two's-complement machine, this behavior is characterized by functions <i class="pcalibre17 pcalibre2 pcalibre1">T2U<sub class="pcalibre1 pcalibre2 calibre14">w</sub></i> and <i class="pcalibre17 pcalibre2 pcalibre1">U2T<sub class="pcalibre1 pcalibre2 calibre14">w</sub></i>, for a <var class="pcalibre17 pcalibre2 pcalibre1">w</var>-bit value. The implicit casting of C gives results that many programmers do not anticipate, often leading to program bugs.</p>
<p id="P700049702700000000000000003F790" data-uri="chapter02.xhtml#P700049702700000000000000003F790" class="pcalibre8 pcalibre1 pcalibre2">Due to the finite lengths of the encodings, computer arithmetic has properties quite different from conventional integer and real arithmetic. The finite length can cause numbers to overflow, when they exceed the range of the representation. Floating-point values can also underflow, when they are so close to 0.0 that they are changed to zero.</p>
<p id="P700049702700000000000000003F791" data-uri="chapter02.xhtml#P700049702700000000000000003F791" class="pcalibre8 pcalibre1 pcalibre2">The finite integer arithmetic implemented by C, as well as most other programming languages, has some peculiar properties compared to true integer arithmetic. For example, the expression <code id="P700049702700000000000000003F792" data-uri="chapter02.xhtml#P700049702700000000000000003F792" class="pcalibre1 calibre1 pcalibre2">x*x</code> can evaluate to a negative number due to overflow. Nonetheless, both unsigned and two's-complement arithmetic satisfy many of the other properties of integer arithmetic, including associativity, commutativity, and distributivity. This allows compilers to do many optimizations. For example, in replacing the expression <code id="P700049702700000000000000003F793" data-uri="chapter02.xhtml#P700049702700000000000000003F793" class="pcalibre1 calibre1 pcalibre2">7*x</code> by <code id="P700049702700000000000000003F794" data-uri="chapter02.xhtml#P700049702700000000000000003F794" class="pcalibre1 calibre1 pcalibre2">(x&lt;&lt;3)–x</code>, we make use of the associative, commutative, and distributive properties, along with the relationship between shifting and multiplying by powers of 2.</p>
<p id="P700049702700000000000000003F795" data-uri="chapter02.xhtml#P700049702700000000000000003F795" class="pcalibre8 pcalibre1 pcalibre2">We have seen several clever ways to exploit combinations of bit-level operations and arithmetic operations. For example, we saw that with two's-complement arithmetic, <code id="P700049702700000000000000003F796" data-uri="chapter02.xhtml#P700049702700000000000000003F796" class="pcalibre1 calibre1 pcalibre2">~x+1</code> is equivalent to <code id="P700049702700000000000000003F797" data-uri="chapter02.xhtml#P700049702700000000000000003F797" class="pcalibre1 calibre1 pcalibre2">–x</code>. As another example, suppose we want a bit</p>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000001487" data-uri="chapter02.xhtml#P7000497027000000000000000001487"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P700049702700000000000000003F798" data-uri="chapter02.xhtml#P700049702700000000000000003F798" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000001489" title="127" data-uri="chapter02.xhtml#P7000497027000000000000000001489" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre2 pcalibre34">Aside </span>Ariane 5: The high cost of floating-point overflow</h1></header>
<p id="P700049702700000000000000003F799" data-uri="chapter02.xhtml#P700049702700000000000000003F799" class="pcalibre1 pcalibre2 pcalibre40">Converting large floating-point numbers to integers is a common source of programming errors. Such an error had disastrous consequences for the maiden voyage of the Ariane 5 rocket, on June 4, 1996. Just 37 seconds after liftoff, the rocket veered off its flight path, broke up, and exploded. Communication satellites valued at $500 million were on board the rocket.</p>
<p id="P700049702700000000000000003F79A" data-uri="chapter02.xhtml#P700049702700000000000000003F79A" class="pcalibre1 pcalibre2 pcalibre40">A later investigation [<a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B435">73</a>, <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3E3">33</a>] showed that the computer controlling the inertial navigation system had sent invalid data to the computer controlling the engine nozzles. Instead of sending flight control information, it had sent a diagnostic bit pattern indicating that an overflow had occurred during the conversion of a 64-bit floating-point number to a 16-bit signed integer.</p>
<p id="P700049702700000000000000003F79B" data-uri="chapter02.xhtml#P700049702700000000000000003F79B" class="pcalibre1 pcalibre2 pcalibre10">The value that overflowed measured the horizontal velocity of the rocket, which could be more than five times higher than that achieved by the earlier Ariane 4 rocket. In the design of the Ariane 4 software, they had carefully analyzed the numeric values and determined that the horizontal velocity would never overflow a 16-bit number. Unfortunately, they simply reused this part of the software in the Ariane 5 without checking the assumptions on which it had been based.</p>
</aside>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000003F79C" data-uri="chapter02.xhtml#P700049702700000000000000003F79C">pattern of the form [0, ... , 0, 1, ..., 1], consisting of <var class="pcalibre17 pcalibre2 pcalibre1">w</var> – <var class="pcalibre17 pcalibre2 pcalibre1">k</var> zeros followed by <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ones. Such bit patterns are useful for masking operations. This pattern can be generated by the C expression <code id="P700049702700000000000000003F79D" data-uri="chapter02.xhtml#P700049702700000000000000003F79D" class="pcalibre1 calibre1 pcalibre2">(1&lt;&lt;k)–1</code>, exploiting the property that the desired bit pattern has numeric value 2<sup class="pcalibre1 pcalibre2 pcalibre85"><var class="pcalibre17 pcalibre2 pcalibre1">k</var></sup> – 1. For example, the expression <code id="P700049702700000000000000003F79E" data-uri="chapter02.xhtml#P700049702700000000000000003F79E" class="pcalibre1 calibre1 pcalibre2">(1&lt;&lt;8)–1</code> will generate the bit pattern <code id="P700049702700000000000000003F79F" data-uri="chapter02.xhtml#P700049702700000000000000003F79F" class="pcalibre1 calibre1 pcalibre2">0xFF</code>.</p>
<p id="P700049702700000000000000003F7A0" data-uri="chapter02.xhtml#P700049702700000000000000003F7A0" class="pcalibre8 pcalibre1 pcalibre2">Floating-point representations approximate real numbers by encoding numbers of the form <var class="pcalibre17 pcalibre2 pcalibre1">x</var> × 2<sup class="pcalibre1 pcalibre2 pcalibre85"><var class="pcalibre17 pcalibre2 pcalibre1">y</var></sup>. IEEE Standard 754 provides for several different precisions, with the most common being single (32 bits) and double (64 bits). IEEE floating point also has representations for special values representing plus and minus infinity, as well as not-a-number.</p>
<p id="P700049702700000000000000003F7A1" data-uri="chapter02.xhtml#P700049702700000000000000003F7A1" class="pcalibre8 pcalibre1 pcalibre2">Floating-point arithmetic must be used very carefully, because it has only limited range and precision, and because it does not obey common mathematical properties such as associativity.</p>
</section></body></html>
