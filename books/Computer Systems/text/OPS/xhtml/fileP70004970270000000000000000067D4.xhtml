<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>8.2 Processes</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P70004970270000000000000000067D4" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P7000497027000000000000000044FC7" data-uri="chapter08.xhtml#P7000497027000000000000000044FC7" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000067D6" title="732" data-uri="chapter08.xhtml#P70004970270000000000000000067D6" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">8.2 </span>Processes</h1></header>
<p id="P7000497027000000000000000044FC8" data-uri="chapter08.xhtml#P7000497027000000000000000044FC8" class="pcalibre8 pcalibre1 pcalibre2">Exceptions are the basic building blocks that allow the operating system kernel to provide the notion of a <i class="pcalibre17 pcalibre2 pcalibre1">process</i>, one of the most profound and successful ideas in computer science.</p>
<p id="P7000497027000000000000000044FC9" data-uri="chapter08.xhtml#P7000497027000000000000000044FC9" class="pcalibre8 pcalibre1 pcalibre2">When we run a program on a modern system, we are presented with the illusion that our program is the only one currently running in the system. Our program appears to have exclusive use of both the processor and the memory. The processor appears to execute the instructions in our program, one after the other, without interruption. Finally, the code and data of our program appear to be the only objects in the system's memory. These illusions are provided to us by the notion of a process.</p>
<p id="P7000497027000000000000000044FCA" data-uri="chapter08.xhtml#P7000497027000000000000000044FCA" class="pcalibre8 pcalibre1 pcalibre2">The classic definition of a process is <i class="pcalibre17 pcalibre2 pcalibre1">an instance of a program in execution</i>. Each program in the system runs in the <i class="pcalibre17 pcalibre2 pcalibre1">context</i> of some process. The context consists of the state that the program needs to run correctly. This state includes the program's code and data stored in memory, its stack, the contents of its general purpose registers, its program counter, environment variables, and the set of open file descriptors.</p>
<p id="P7000497027000000000000000044FCB" data-uri="chapter08.xhtml#P7000497027000000000000000044FCB" class="pcalibre8 pcalibre1 pcalibre2">Each time a user runs a program by typing the name of an executable object file to the shell, the shell creates a new process and then runs the executable object file in the context of this new process. Application programs can also create new processes and run either their own code or other applications in the context of the new process.</p>
<p id="P7000497027000000000000000044FCC" data-uri="chapter08.xhtml#P7000497027000000000000000044FCC" class="pcalibre8 pcalibre1 pcalibre2">A detailed discussion of how operating systems implement processes is beyond our scope. Instead, we will focus on the key abstractions that a process provides to the application:</p>
<ul id="P7000497027000000000000000044FCD" data-uri="chapter08.xhtml#P7000497027000000000000000044FCD" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000044FCE" data-uri="chapter08.xhtml#P7000497027000000000000000044FCE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044FCF" data-uri="chapter08.xhtml#P7000497027000000000000000044FCF" class="pcalibre1 pcalibre2 pcalibre10">An independent logical control flow that provides the illusion that our program has exclusive use of the processor.</p></li>
<li id="P7000497027000000000000000044FD0" data-uri="chapter08.xhtml#P7000497027000000000000000044FD0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000044FD1" data-uri="chapter08.xhtml#P7000497027000000000000000044FD1" class="pcalibre1 pcalibre2 pcalibre10">A private address space that provides the illusion that our program has exclusive use of the memory system.</p></li>
</ul>
<p id="P7000497027000000000000000044FD2" data-uri="chapter08.xhtml#P7000497027000000000000000044FD2" class="pcalibre8 pcalibre1 pcalibre2">Let's look more closely at these abstractions.</p>

<section id="P70004970270000000000000000067E2" data-uri="chapter08.xhtml#P70004970270000000000000000067E2" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000044FD3" data-uri="chapter08.xhtml#P7000497027000000000000000044FD3" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.2.1  </span>Logical Control Flow</h1></header>
<p id="P7000497027000000000000000044FD4" data-uri="chapter08.xhtml#P7000497027000000000000000044FD4" class="pcalibre8 pcalibre1 pcalibre2">A process provides each program with the illusion that it has exclusive use of the processor, even though many other programs are typically running concurrently on the system. If we were to use a debugger to single-step the execution of our program, we would observe a series of program counter (PC) values that corresponded exclusively to instructions contained in our program's executable object file or in shared objects linked into our program dynamically at run time. This sequence of PC values is known as a <i class="pcalibre17 pcalibre2 pcalibre1">logical control flow</i>, or simply <i class="pcalibre17 pcalibre2 pcalibre1">logical flow</i>.</p>
<p id="P7000497027000000000000000044FD5" data-uri="chapter08.xhtml#P7000497027000000000000000044FD5" class="pcalibre8 pcalibre1 pcalibre2">Consider a system that runs three processes, as shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000067E6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.12</span></a>. The single physical control flow of the processor is partitioned into three logical flows, one for each process. Each vertical line represents a portion of the logical flow for</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000067E6" data-uri="chapter08.xhtml#P70004970270000000000000000067E6">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000067E7" title="733" data-uri="chapter08.xhtml#P70004970270000000000000000067E7" epub:type="pagebreak"></span><img alt="A diagram shows a vertical arrow representing time and vertical lines moving from Process A to Process B to Process C to Process A to Process C, over time." id="P7000497027000000000000000044FD6" data-uri="P700049702700000000000000000B768" src="../images/p733-1.png" class="pcalibre1 pcalibre2 pcalibre247"/>
<figcaption id="P7000497027000000000000000044FD7" data-uri="chapter08.xhtml#P7000497027000000000000000044FD7" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000044FD8" data-uri="chapter08.xhtml#P7000497027000000000000000044FD8" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.12 </span>Logical control flows.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000044FD9" data-uri="chapter08.xhtml#P7000497027000000000000000044FD9"><p id="P7000497027000000000000000044FDA" data-uri="chapter08.xhtml#P7000497027000000000000000044FDA" class="pcalibre1 pcalibre2 pcalibre10">Processes provide each program with the illusion that it has exclusive use of the processor. Each vertical bar represents a portion of the logical control flow for a process.</p></div>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000044FDB" data-uri="chapter08.xhtml#P7000497027000000000000000044FDB">a process. In the example, the execution of the three logical flows is interleaved. Process A runs for a while, followed by B, which runs to completion. Process C then runs for a while, followed by A, which runs to completion. Finally, C is able to run to completion.</p>
<p id="P7000497027000000000000000044FDC" data-uri="chapter08.xhtml#P7000497027000000000000000044FDC" class="pcalibre8 pcalibre1 pcalibre2">The key point in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000067E6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.12</span></a> is that processes take turns using the processor. Each process executes a portion of its flow and then is <i class="pcalibre17 pcalibre2 pcalibre1">preempted</i> (temporarily suspended) while other processes take their turns. To a program running in the context of one of these processes, it appears to have exclusive use of the processor. The only evidence to the contrary is that if we were to precisely measure the elapsed time of each instruction, we would notice that the CPU appears to periodically stall between the execution of some of the instructions in our program. However, each time the processor stalls, it subsequently resumes execution of our program without any change to the contents of the program's memory locations or registers.</p>
</section>
<section id="P70004970270000000000000000067EF" data-uri="chapter08.xhtml#P70004970270000000000000000067EF" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000044FDD" data-uri="chapter08.xhtml#P7000497027000000000000000044FDD" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.2.2  </span>Concurrent Flows</h1></header>
<p id="P7000497027000000000000000044FDE" data-uri="chapter08.xhtml#P7000497027000000000000000044FDE" class="pcalibre8 pcalibre1 pcalibre2">Logical flows take many different forms in computer systems. Exception handlers, processes, signal handlers, threads, and Java processes are all examples of logical flows.</p>
<p id="P7000497027000000000000000044FDF" data-uri="chapter08.xhtml#P7000497027000000000000000044FDF" class="pcalibre8 pcalibre1 pcalibre2">A logical flow whose execution overlaps in time with another flow is called a <i class="pcalibre17 pcalibre2 pcalibre1">concurrent flow</i>, and the two flows are said to <i class="pcalibre17 pcalibre2 pcalibre1">run concurrently</i>. More precisely, flows X and Y are concurrent with respect to each other if and only if X begins after Y begins and before Y finishes, or Y begins after X begins and before X finishes. For example, in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000067E6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.12</span></a>, processes A and B run concurrently, as do A and C. On the other hand, B and C do not run concurrently, because the last instruction of B executes before the first instruction of C.</p>
<p id="P7000497027000000000000000044FE0" data-uri="chapter08.xhtml#P7000497027000000000000000044FE0" class="pcalibre8 pcalibre1 pcalibre2">The general phenomenon of multiple flows executing concurrently is known as <i class="pcalibre17 pcalibre2 pcalibre1">concurrency</i>. The notion of a process taking turns with other processes is also known as <i class="pcalibre17 pcalibre2 pcalibre1">multitasking</i>. Each time period that a process executes a portion of its flow is called a <i class="pcalibre17 pcalibre2 pcalibre1">time slice</i>. Thus, multitasking is also referred to as <i class="pcalibre17 pcalibre2 pcalibre1">time slicing</i>. For example, in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000067E6"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.12</span></a>, the flow for process A consists of two time slices.</p>
<p id="P7000497027000000000000000044FE1" data-uri="chapter08.xhtml#P7000497027000000000000000044FE1" class="pcalibre8 pcalibre1 pcalibre2">Notice that the idea of concurrent flows is independent of the number of processor cores or computers that the flows are running on. If two flows overlap in time, then they are concurrent, even if they are running on the same processor. However, we will sometimes find it useful to identify a proper subset of concurrent <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000067F5" title="734" data-uri="chapter08.xhtml#P70004970270000000000000000067F5" epub:type="pagebreak"></span>flows known as <i class="pcalibre17 pcalibre2 pcalibre1">parallel flows</i>. If two flows are running concurrently on different processor cores or computers, then we say that they are <i class="pcalibre17 pcalibre2 pcalibre1">parallel flows</i>, that they are <i class="pcalibre17 pcalibre2 pcalibre1">running in parallel</i>, and have <i class="pcalibre17 pcalibre2 pcalibre1">parallel execution</i>.</p>

<section id="P70004970270000000000000000067F6" data-uri="chapter08.xhtml#P70004970270000000000000000067F6" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000044FE2" data-uri="chapter08.xhtml#P7000497027000000000000000044FE2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">8.1 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP7000497027000000000000000006E81.xhtml#P7000497027000000000000000006F86">795</a>)</h1></header>
<p id="P7000497027000000000000000044FE3" data-uri="chapter08.xhtml#P7000497027000000000000000044FE3" class="pcalibre8 pcalibre1 pcalibre2">Consider three processes with the following starting and ending times:</p>
<table id="P7000497027000000000000000044FE4" data-uri="chapter08.xhtml#P7000497027000000000000000044FE4" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000044FE5" data-uri="chapter08.xhtml#P7000497027000000000000000044FE5" class="pcalibre1 pcalibre2 calibre5">
Process</th><th id="P7000497027000000000000000044FE6" data-uri="chapter08.xhtml#P7000497027000000000000000044FE6" class="pcalibre1 pcalibre2 calibre5">Start time</th><th id="P7000497027000000000000000044FE7" data-uri="chapter08.xhtml#P7000497027000000000000000044FE7" class="pcalibre1 pcalibre2 calibre5">End time</th></tr></thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000044FE8" data-uri="chapter08.xhtml#P7000497027000000000000000044FE8" class="pcalibre1 pcalibre2 calibre7">A</td><td id="P7000497027000000000000000044FE9" data-uri="chapter08.xhtml#P7000497027000000000000000044FE9" class="pcalibre1 pcalibre2 calibre7">0</td><td id="P7000497027000000000000000044FEA" data-uri="chapter08.xhtml#P7000497027000000000000000044FEA" class="pcalibre1 pcalibre2 calibre7">2</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000044FEB" data-uri="chapter08.xhtml#P7000497027000000000000000044FEB" class="pcalibre1 pcalibre2 calibre7">B</td><td id="P7000497027000000000000000044FEC" data-uri="chapter08.xhtml#P7000497027000000000000000044FEC" class="pcalibre1 pcalibre2 calibre7">1</td><td id="P7000497027000000000000000044FED" data-uri="chapter08.xhtml#P7000497027000000000000000044FED" class="pcalibre1 pcalibre2 calibre7">4</td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000044FEE" data-uri="chapter08.xhtml#P7000497027000000000000000044FEE" class="pcalibre1 pcalibre2 calibre7">C</td><td id="P7000497027000000000000000044FEF" data-uri="chapter08.xhtml#P7000497027000000000000000044FEF" class="pcalibre1 pcalibre2 calibre7">3</td><td id="P7000497027000000000000000044FF0" data-uri="chapter08.xhtml#P7000497027000000000000000044FF0" class="pcalibre1 pcalibre2 calibre7">5</td></tr>
</tbody>
</table>
<p id="P7000497027000000000000000044FF1" data-uri="chapter08.xhtml#P7000497027000000000000000044FF1" class="pcalibre8 pcalibre1 pcalibre2">For each pair of processes, indicate whether they run concurrently (Y) or not (N):</p>
<table id="P7000497027000000000000000044FF2" data-uri="chapter08.xhtml#P7000497027000000000000000044FF2" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000044FF3" data-uri="chapter08.xhtml#P7000497027000000000000000044FF3" class="pcalibre1 pcalibre2 calibre5">
Process pair</th><th id="P7000497027000000000000000044FF4" data-uri="chapter08.xhtml#P7000497027000000000000000044FF4" class="pcalibre1 pcalibre2 calibre5">Concurrent?</th></tr></thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000044FF5" data-uri="chapter08.xhtml#P7000497027000000000000000044FF5" class="pcalibre1 pcalibre2 calibre7">AB</td><td id="P7000497027000000000000000044FF6" data-uri="chapter08.xhtml#P7000497027000000000000000044FF6" class="pcalibre1 pcalibre2 calibre7"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000044FF7" data-uri="chapter08.xhtml#P7000497027000000000000000044FF7" class="pcalibre1 pcalibre2 calibre7">AC</td><td id="P7000497027000000000000000044FF8" data-uri="chapter08.xhtml#P7000497027000000000000000044FF8" class="pcalibre1 pcalibre2 calibre7"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
<tr class="pcalibre45 pcalibre1 pcalibre2"><td id="P7000497027000000000000000044FF9" data-uri="chapter08.xhtml#P7000497027000000000000000044FF9" class="pcalibre1 pcalibre2 calibre7">BC</td><td id="P7000497027000000000000000044FFA" data-uri="chapter08.xhtml#P7000497027000000000000000044FFA" class="pcalibre1 pcalibre2 calibre7"><span class="pcalibre1 pcalibre94 pcalibre2">     </span></td></tr>
</tbody>
</table>
</section>
</section>

<section id="P7000497027000000000000000006810" data-uri="chapter08.xhtml#P7000497027000000000000000006810" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000044FFB" data-uri="chapter08.xhtml#P7000497027000000000000000044FFB" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.2.3  </span>Private Address Space</h1></header>
<p id="P7000497027000000000000000044FFC" data-uri="chapter08.xhtml#P7000497027000000000000000044FFC" class="pcalibre8 pcalibre1 pcalibre2">A process provides each program with the illusion that it has exclusive use of the system's address space. On a machine with <var class="pcalibre17 pcalibre2 pcalibre1">n</var>-bit addresses, the <i class="pcalibre17 pcalibre2 pcalibre1">address space</i> is the set of 2<sup class="pcalibre1 pcalibre2 pcalibre85"><var class="pcalibre17 pcalibre2 pcalibre1">n</var></sup> possible addresses, 0, 1, ... , 2<sup class="pcalibre1 pcalibre2 pcalibre85"><var class="pcalibre17 pcalibre2 pcalibre1">n</var></sup> - 1. A process provides each program with its own <i class="pcalibre17 pcalibre2 pcalibre1">private address space</i>. This space is private in the sense that a byte of memory associated with a particular address in the space cannot in general be read or written by any other process.</p>
<p id="P7000497027000000000000000044FFD" data-uri="chapter08.xhtml#P7000497027000000000000000044FFD" class="pcalibre8 pcalibre1 pcalibre2">Although the contents of the memory associated with each private address space is different in general, each such space has the same general organization. For example, <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006819"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.13</span></a> shows the organization of the address space for an x86-64 Linux process.</p>
<p id="P7000497027000000000000000044FFE" data-uri="chapter08.xhtml#P7000497027000000000000000044FFE" class="pcalibre8 pcalibre1 pcalibre2">The bottom portion of the address space is reserved for the user program, with the usual code, data, heap, and stack segments. The code segment always begins at address <code id="P7000497027000000000000000044FFF" data-uri="chapter08.xhtml#P7000497027000000000000000044FFF" class="pcalibre1 calibre1 pcalibre2">0x400000</code>. The top portion of the address space is reserved for the kernel (the memory-resident part of the operating system). This part of the address space contains the code, data, and stack that the kernel uses when it executes instructions on behalf of the process (e.g., when the application program executes a system call).</p>
</section>
<section id="P7000497027000000000000000006816" data-uri="chapter08.xhtml#P7000497027000000000000000006816" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045000" data-uri="chapter08.xhtml#P7000497027000000000000000045000" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.2.4  </span>User and Kernel Modes</h1></header>
<p id="P7000497027000000000000000045001" data-uri="chapter08.xhtml#P7000497027000000000000000045001" class="pcalibre8 pcalibre1 pcalibre2">In order for the operating system kernel to provide an airtight process abstraction, the processor must provide a mechanism that restricts the instructions that an</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000006819" data-uri="chapter08.xhtml#P7000497027000000000000000006819">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000681A" title="735" data-uri="chapter08.xhtml#P700049702700000000000000000681A" epub:type="pagebreak"></span><img alt="A diagram illustrates process address space." id="P7000497027000000000000000045002" data-uri="P700049702700000000000000000B769" src="../images/p735-1.png" class="pcalibre1 pcalibre2 pcalibre248"/>
<figcaption id="P7000497027000000000000000045003" data-uri="chapter08.xhtml#P7000497027000000000000000045003" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045004" data-uri="chapter08.xhtml#P7000497027000000000000000045004" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.13 </span>Process address space.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000025326" data-uri="chapter08.xhtml#P7000497027000000000000000025326">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045005" data-uri="chapter08.xhtml#P7000497027000000000000000045005" class="pcalibre8 pcalibre1 pcalibre2">A diagram shows a stack with sections summarized below from bottom to top.</p>
<ul id="P7000497027000000000000000045006" data-uri="chapter08.xhtml#P7000497027000000000000000045006" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000045007" data-uri="chapter08.xhtml#P7000497027000000000000000045007" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045008" data-uri="chapter08.xhtml#P7000497027000000000000000045008" class="pcalibre1 pcalibre2 pcalibre10">Gap from 0 to 0x400000</p></li>
<li id="P7000497027000000000000000045009" data-uri="chapter08.xhtml#P7000497027000000000000000045009" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004500A" data-uri="chapter08.xhtml#P700049702700000000000000004500A" class="pcalibre1 pcalibre2 pcalibre10">Loaded from the executable file:</p>
<ul id="P700049702700000000000000004500B" data-uri="chapter08.xhtml#P700049702700000000000000004500B" class="pcalibre1 pcalibre2 pcalibre69">
<li id="P700049702700000000000000004500C" data-uri="chapter08.xhtml#P700049702700000000000000004500C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004500D" data-uri="chapter08.xhtml#P700049702700000000000000004500D" class="pcalibre1 pcalibre2 pcalibre10">Read-only code segment (.init, .text, .rodata)</p></li>
<li id="P700049702700000000000000004500E" data-uri="chapter08.xhtml#P700049702700000000000000004500E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004500F" data-uri="chapter08.xhtml#P700049702700000000000000004500F" class="pcalibre1 pcalibre2 pcalibre10">Read/write segment (.data, .bss)</p></li>
</ul></li>
<li id="P7000497027000000000000000045010" data-uri="chapter08.xhtml#P7000497027000000000000000045010" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045011" data-uri="chapter08.xhtml#P7000497027000000000000000045011" class="pcalibre1 pcalibre2 pcalibre10">Run-time heap (created by malloc), to brk</p></li>
<li id="P7000497027000000000000000045012" data-uri="chapter08.xhtml#P7000497027000000000000000045012" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045013" data-uri="chapter08.xhtml#P7000497027000000000000000045013" class="pcalibre1 pcalibre2 pcalibre10">Gap</p></li>
<li id="P7000497027000000000000000045014" data-uri="chapter08.xhtml#P7000497027000000000000000045014" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045015" data-uri="chapter08.xhtml#P7000497027000000000000000045015" class="pcalibre1 pcalibre2 pcalibre10">Memory-mapped region for shared libraries</p></li>
<li id="P7000497027000000000000000045016" data-uri="chapter08.xhtml#P7000497027000000000000000045016" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045017" data-uri="chapter08.xhtml#P7000497027000000000000000045017" class="pcalibre1 pcalibre2 pcalibre10">Gap to %esp (stack pointer)</p></li>
<li id="P7000497027000000000000000045018" data-uri="chapter08.xhtml#P7000497027000000000000000045018" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045019" data-uri="chapter08.xhtml#P7000497027000000000000000045019" class="pcalibre1 pcalibre2 pcalibre10">User stack (created at run time), to 2<sup class="pcalibre1 pcalibre2 pcalibre85">48</sup> minus 1</p></li>
<li id="P700049702700000000000000004501A" data-uri="chapter08.xhtml#P700049702700000000000000004501A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004501B" data-uri="chapter08.xhtml#P700049702700000000000000004501B" class="pcalibre1 pcalibre2 pcalibre10">Kernel virtual memory (code, data, heap, stack), to memory invisible to user code</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004501C" data-uri="chapter08.xhtml#P700049702700000000000000004501C">application can execute, as well as the portions of the address space that it can access.</p>
<p id="P700049702700000000000000004501D" data-uri="chapter08.xhtml#P700049702700000000000000004501D" class="pcalibre8 pcalibre1 pcalibre2">Processors typically provide this capability with a <i class="pcalibre17 pcalibre2 pcalibre1">mode bit</i> in some control register that characterizes the privileges that the process currently enjoys. When the mode bit is set, the process is running in <i class="pcalibre17 pcalibre2 pcalibre1">kernel mode</i> (sometimes called <i class="pcalibre17 pcalibre2 pcalibre1">supervisor mode</i>). A process running in kernel mode can execute any instruction in the instruction set and access any memory location in the system.</p>
<p id="P700049702700000000000000004501E" data-uri="chapter08.xhtml#P700049702700000000000000004501E" class="pcalibre8 pcalibre1 pcalibre2">When the mode bit is not set, the process is running in <i class="pcalibre17 pcalibre2 pcalibre1">user mode</i>. A process in user mode is not allowed to execute <i class="pcalibre17 pcalibre2 pcalibre1">privileged instructions</i> that do things such as halt the processor, change the mode bit, or initiate an I/O operation. Nor is it allowed to directly reference code or data in the kernel area of the address space. Any such attempt results in a fatal protection fault. User programs must instead access kernel code and data indirectly via the system call interface.</p>
<p id="P700049702700000000000000004501F" data-uri="chapter08.xhtml#P700049702700000000000000004501F" class="pcalibre8 pcalibre1 pcalibre2">A process running application code is initially in user mode. The only way for the process to change from user mode to kernel mode is via an exception such as an interrupt, a fault, or a trapping system call. When the exception occurs, and control passes to the exception handler, the processor changes the mode from user mode to kernel mode. The handler runs in kernel mode. When it returns to the application code, the processor changes the mode from kernel mode back to user mode.</p>
<p id="P7000497027000000000000000045020" data-uri="chapter08.xhtml#P7000497027000000000000000045020" class="pcalibre8 pcalibre1 pcalibre2">Linux provides a clever mechanism, called the <code id="P7000497027000000000000000045021" data-uri="chapter08.xhtml#P7000497027000000000000000045021" class="pcalibre1 calibre1 pcalibre2">/proc</code> filesystem, that allows user mode processes to access the contents of kernel data structures. The <code id="P7000497027000000000000000045022" data-uri="chapter08.xhtml#P7000497027000000000000000045022" class="pcalibre1 calibre1 pcalibre2">/proc</code> filesystem exports the contents of many kernel data structures as a hierarchy of text <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006825" title="736" data-uri="chapter08.xhtml#P7000497027000000000000000006825" epub:type="pagebreak"></span>files that can be read by user programs. For example, you can use the <code id="P7000497027000000000000000045023" data-uri="chapter08.xhtml#P7000497027000000000000000045023" class="pcalibre1 calibre1 pcalibre2">/proc</code> filesystem to find out general system attributes such as CPU type (<code id="P7000497027000000000000000045024" data-uri="chapter08.xhtml#P7000497027000000000000000045024" class="pcalibre1 calibre1 pcalibre2">/proc/cpuinfo</code>), or the memory segments used by a particular process (<code id="P7000497027000000000000000045025" data-uri="chapter08.xhtml#P7000497027000000000000000045025" class="pcalibre1 calibre1 pcalibre2">/proc/<i class="pcalibre17 pcalibre2 pcalibre1">process-id</i>/maps</code>). The 2.6 version of the Linux kernel introduced a <code id="P7000497027000000000000000045026" data-uri="chapter08.xhtml#P7000497027000000000000000045026" class="pcalibre1 calibre1 pcalibre2">/sys</code> filesystem, which exports additional low-level information about system buses and devices.</p>
</section>
<section id="P700049702700000000000000000682A" data-uri="chapter08.xhtml#P700049702700000000000000000682A" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000045027" data-uri="chapter08.xhtml#P7000497027000000000000000045027" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">8.2.5  </span>Context Switches</h1></header>
<p id="P7000497027000000000000000045028" data-uri="chapter08.xhtml#P7000497027000000000000000045028" class="pcalibre8 pcalibre1 pcalibre2">The operating system kernel implements multitasking using a higher-level form of exceptional control flow known as a <i class="pcalibre17 pcalibre2 pcalibre1">context switch</i>. The context switch mechanism is built on top of the lower-level exception mechanism that we discussed in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000066A6.xhtml#P70004970270000000000000000066A6"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">8.1</span></a>.</p>
<p id="P7000497027000000000000000045029" data-uri="chapter08.xhtml#P7000497027000000000000000045029" class="pcalibre8 pcalibre1 pcalibre2">The kernel maintains a <i class="pcalibre17 pcalibre2 pcalibre1">context</i> for each process. The context is the state that the kernel needs to restart a preempted process. It consists of the values of objects such as the general-purpose registers, the floating-point registers, the program counter, user's stack, status registers, kernel's stack, and various kernel data structures such as a <i class="pcalibre17 pcalibre2 pcalibre1">page table</i> that characterizes the address space, a <i class="pcalibre17 pcalibre2 pcalibre1">process table</i> that contains information about the current process, and a <i class="pcalibre17 pcalibre2 pcalibre1">file table</i> that contains information about the files that the process has opened.</p>
<p id="P700049702700000000000000004502A" data-uri="chapter08.xhtml#P700049702700000000000000004502A" class="pcalibre8 pcalibre1 pcalibre2">At certain points during the execution of a process, the kernel can decide to preempt the current process and restart a previously preempted process. This decision is known as <i class="pcalibre17 pcalibre2 pcalibre1">scheduling</i> and is handled by code in the kernel, called the <i class="pcalibre17 pcalibre2 pcalibre1">scheduler</i>. When the kernel selects a new process to run, we say that the kernel has <i class="pcalibre17 pcalibre2 pcalibre1">scheduled</i> that process. After the kernel has scheduled a new process to run, it preempts the current process and transfers control to the new process using a mechanism called a <i class="pcalibre17 pcalibre2 pcalibre1">context switch</i> that (1) saves the context of the current process, (2) restores the saved context of some previously preempted process, and (3) passes control to this newly restored process.</p>
<p id="P700049702700000000000000004502B" data-uri="chapter08.xhtml#P700049702700000000000000004502B" class="pcalibre8 pcalibre1 pcalibre2">A context switch can occur while the kernel is executing a system call on behalf of the user. If the system call blocks because it is waiting for some event to occur, then the kernel can put the current process to sleep and switch to another process. For example, if a <code id="P700049702700000000000000004502C" data-uri="chapter08.xhtml#P700049702700000000000000004502C" class="pcalibre1 calibre1 pcalibre2">read</code> system call requires a disk access, the kernel can opt to perform a context switch and run another process instead of waiting for the data to arrive from the disk. Another example is the <code id="P700049702700000000000000004502D" data-uri="chapter08.xhtml#P700049702700000000000000004502D" class="pcalibre1 calibre1 pcalibre2">sleep</code> system call, which is an explicit request to put the calling process to sleep. In general, even if a system call does not block, the kernel can decide to perform a context switch rather than return control to the calling process.</p>
<p id="P700049702700000000000000004502E" data-uri="chapter08.xhtml#P700049702700000000000000004502E" class="pcalibre8 pcalibre1 pcalibre2">A context switch can also occur as a result of an interrupt. For example, all systems have some mechanism for generating periodic timer interrupts, typically every 1 ms or 10 ms. Each time a timer interrupt occurs, the kernel can decide that the current process has run long enough and switch to a new process.</p>
<p id="P700049702700000000000000004502F" data-uri="chapter08.xhtml#P700049702700000000000000004502F" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000006819"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.13 </span></a>shows an example of context switching between a pair of processes A and B. In this example, initially process A is running in user mode until it traps to the kernel by executing a <code id="P7000497027000000000000000045030" data-uri="chapter08.xhtml#P7000497027000000000000000045030" class="pcalibre1 calibre1 pcalibre2">read</code> system call. The trap handler in the kernel requests a DMA transfer from the disk controller and arranges for the disk to interrupt the</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000006835" data-uri="chapter08.xhtml#P7000497027000000000000000006835">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000006836" title="737" data-uri="chapter08.xhtml#P7000497027000000000000000006836" epub:type="pagebreak"></span><img alt="A diagram illustrates a process context switch." id="P7000497027000000000000000045031" data-uri="P700049702700000000000000000B76A" src="../images/p737-1.png" class="pcalibre1 pcalibre2 pcalibre249"/>
<figcaption id="P7000497027000000000000000045032" data-uri="chapter08.xhtml#P7000497027000000000000000045032" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000045033" data-uri="chapter08.xhtml#P7000497027000000000000000045033" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">8.14 </span>Anatomy of a process context switch.</h1></header>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000025356" data-uri="chapter08.xhtml#P7000497027000000000000000025356">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000045034" data-uri="chapter08.xhtml#P7000497027000000000000000045034" class="pcalibre1 pcalibre2 pcalibre10">A diagram shows a flow of steps over time, moving between Process A and Process B. The flow extends through user code in Process A to read, and then moves through kernel code (context switch), switching from Process A to Process B. In Process B, the flow moves through user code to disk interrupt, and then through kernel code (context switch) from Process B to Process A, to Return from read, before moving through user code in Process A.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000045035" data-uri="chapter08.xhtml#P7000497027000000000000000045035">processor after the disk controller has finished transferring the data from disk to memory.</p>
<p id="P7000497027000000000000000045036" data-uri="chapter08.xhtml#P7000497027000000000000000045036" class="pcalibre8 pcalibre1 pcalibre2">The disk will take a relatively long time to fetch the data (on the order of tens of milliseconds), so instead of waiting and doing nothing in the interim, the kernel performs a context switch from process A to B. Note that, before the switch, the kernel is executing instructions in user mode on behalf of process A (i.e., there is no separate kernel process). During the first part of the switch, the kernel is executing instructions in kernel mode on behalf of process A. Then at some point it begins executing instructions (still in kernel mode) on behalf of process B. And after the switch, the kernel is executing instructions in user mode on behalf of process B.</p>
<p id="P7000497027000000000000000045037" data-uri="chapter08.xhtml#P7000497027000000000000000045037" class="pcalibre8 pcalibre1 pcalibre2">Process B then runs for a while in user mode until the disk sends an interrupt to signal that data have been transferred from disk to memory. The kernel decides that process B has run long enough and performs a context switch from process B to A, returning control in process A to the instruction immediately following the <code id="P7000497027000000000000000045038" data-uri="chapter08.xhtml#P7000497027000000000000000045038" class="pcalibre1 calibre1 pcalibre2">read</code> system call. Process A continues to run until the next exception occurs, and so on.</p>
</section>
</section></body></html>
