<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.9 Enhancing Parallelism</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000004D16" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000004346A" data-uri="chapter05.xhtml#P700049702700000000000000004346A" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004D18" title="536" data-uri="chapter05.xhtml#P7000497027000000000000000004D18" epub:type="pagebreak"></span><span class="pcalibre1 pcalibre21 pcalibre2">5.9 </span>Enhancing Parallelism</h1></header>
<p id="P700049702700000000000000004346B" data-uri="chapter05.xhtml#P700049702700000000000000004346B" class="pcalibre8 pcalibre1 pcalibre2">At this point, our functions have hit the bounds imposed by the latencies of the arithmetic units. As we have noted, however, the functional units performing addition and multiplication are all fully pipelined, meaning that they can start new operations every clock cycle, and some of the operations can be performed by multiple functional units. The hardware has the potential to perform multiplications and additions at a much higher rate, but our code cannot take advantage of this capability, even with loop unrolling, since we are accumulating the value as a single variable <code id="P700049702700000000000000004346C" data-uri="chapter05.xhtml#P700049702700000000000000004346C" class="pcalibre1 calibre1 pcalibre2">acc</code>. We cannot compute a new value for <code id="P700049702700000000000000004346D" data-uri="chapter05.xhtml#P700049702700000000000000004346D" class="pcalibre1 calibre1 pcalibre2">acc</code> until the preceding computation has completed. Even though the functional unit computing a new value for <code id="P700049702700000000000000004346E" data-uri="chapter05.xhtml#P700049702700000000000000004346E" class="pcalibre1 calibre1 pcalibre2">acc</code> can start a new operation every clock cycle, it will only start one every <var class="pcalibre17 pcalibre2 pcalibre1">L</var> cycles, where <var class="pcalibre17 pcalibre2 pcalibre1">L</var> is the latency of the combining operation. We will now investigate ways to break this sequential dependency and get performance better than the latency bound.</p>
<section id="P7000497027000000000000000004D1D" data-uri="chapter05.xhtml#P7000497027000000000000000004D1D" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P700049702700000000000000004346F" data-uri="chapter05.xhtml#P700049702700000000000000004346F" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.9.1 </span>Multiple Accumulators</h1></header>
<p id="P7000497027000000000000000043470" data-uri="chapter05.xhtml#P7000497027000000000000000043470" class="pcalibre8 pcalibre1 pcalibre2">For a combining operation that is associative and commutative, such as integer addition or multiplication, we can improve performance by splitting the set of combining operations into two or more parts and combining the results at the end. For example, let <var class="pcalibre17 pcalibre2 pcalibre1">P<sub class="pcalibre1 pcalibre2 calibre14">n</sub></var> denote the product of elements <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">0</sub>, <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">1</sub>, . . ., <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14"><var class="pcalibre17 pcalibre2 pcalibre1">n</var>−1</sub>:</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000043471" data-uri="chapter05.xhtml#P7000497027000000000000000043471">
<m:math display="block" alttext="" data-uri="" altimg-width="67" altimg-height="45" altimg="../images/ch05-7.png"><m:mrow><m:msub><m:mi>p</m:mi><m:mi>n</m:mi></m:msub><m:mo>=</m:mo><m:munderover><m:mo>∏</m:mo><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mrow><m:msub><m:mi>a</m:mi><m:mi>i</m:mi></m:msub></m:mrow></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043472" data-uri="chapter05.xhtml#P7000497027000000000000000043472">Assuming <var class="pcalibre17 pcalibre2 pcalibre1">n</var> is even, we can also write this as <i class="pcalibre17 pcalibre2 pcalibre1">P<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i> = <i class="pcalibre17 pcalibre2 pcalibre1">PE<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i> × <i class="pcalibre17 pcalibre2 pcalibre1">PO<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i>, where <var class="pcalibre17 pcalibre2 pcalibre1">PE<sub class="pcalibre1 pcalibre2 calibre14">n</sub></var> is the product of the elements with even indices, and <var class="pcalibre17 pcalibre2 pcalibre1">PO<sub class="pcalibre1 pcalibre2 calibre14">n</sub></var> is the product of the elements with odd indices:</p>
<div class="pcalibre1 pcalibre2 informalequation" id="P7000497027000000000000000043473" data-uri="chapter05.xhtml#P7000497027000000000000000043473">
<m:math display="block" alttext="" data-uri="" altimg-width="113" altimg-height="105" altimg="../images/ch05-8.png"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi>P</m:mi><m:msub><m:mi>E</m:mi><m:mi>n</m:mi></m:msub></m:mrow></m:mtd><m:mtd columnalign="left"><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mrow><m:mstyle displaystyle="true"><m:munderover><m:mo>∏</m:mo><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>/</m:mo><m:mn>2</m:mn><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>2</m:mn><m:mi>i</m:mi></m:mrow></m:msub></m:mrow></m:mstyle></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi>P</m:mi><m:msub><m:mi>O</m:mi><m:mi>n</m:mi></m:msub></m:mrow></m:mtd><m:mtd columnalign="left"><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mrow><m:mstyle displaystyle="true"><m:munderover><m:mo>∏</m:mo><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>/</m:mo><m:mn>2</m:mn><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>2</m:mn><m:mi>i</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:mstyle></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p id="P7000497027000000000000000043474" data-uri="chapter05.xhtml#P7000497027000000000000000043474" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D29"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.21</span></a> shows code that uses this method. It uses both two-way loop unrolling, to combine more elements per iteration, and two-way parallelism, accumulating elements with even indices in variable <code id="P7000497027000000000000000043475" data-uri="chapter05.xhtml#P7000497027000000000000000043475" class="pcalibre1 calibre1 pcalibre2">acc0</code> and elements with odd indices in variable <code id="P7000497027000000000000000043476" data-uri="chapter05.xhtml#P7000497027000000000000000043476" class="pcalibre1 calibre1 pcalibre2">acc1</code>. We therefore refer to this as "2 × 2 loop unrolling." As before, we include a second loop to accumulate any remaining array elements for the case where the vector length is not a multiple of 2. We then apply the combining operation to <code id="P7000497027000000000000000043477" data-uri="chapter05.xhtml#P7000497027000000000000000043477" class="pcalibre1 calibre1 pcalibre2">acc0</code> and <code id="P7000497027000000000000000043478" data-uri="chapter05.xhtml#P7000497027000000000000000043478" class="pcalibre1 calibre1 pcalibre2">acc1</code> to compute the final result.</p>
<p id="P7000497027000000000000000043479" data-uri="chapter05.xhtml#P7000497027000000000000000043479" class="pcalibre8 pcalibre1 pcalibre2">Comparing loop unrolling alone to loop unrolling with two-way parallelism, we obtain the following performance:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004D29" data-uri="chapter05.xhtml#P7000497027000000000000000004D29">
<pre id="P700049702700000000000000004347A" data-uri="chapter05.xhtml#P700049702700000000000000004347A" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004347B" data-uri="chapter05.xhtml#P700049702700000000000000004347B" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000004D2C" title="537" data-uri="chapter05.xhtml#P7000497027000000000000000004D2C" epub:type="pagebreak"></span>1	/* 2 x 2 loop unrolling */
2	void combine6(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		long limit = length-1;
7		data_t *data = get_vec_start(v);
8		data_t acc0 = IDENT;
9		data_t acc1 = IDENT;
10	
11		/* Combine 2 elements at a time */
12		for (i = 0; i &lt; limit; i+=2) {
13			acc0 = acc0 OP data[i];
14			acc1 = acc1 OP data[i+1];
15		}
16
17		/* Finish any remaining elements */
18		for (;i &lt; length; i++) {
19			acc0 = acc0 OP data[i];
20		}
21		*dest = acc0 OP acc1;
22	}
</code></pre>
<figcaption id="P700049702700000000000000004347C" data-uri="chapter05.xhtml#P700049702700000000000000004347C" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004347D" data-uri="chapter05.xhtml#P700049702700000000000000004347D" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.21 </span>Applying 2 × 2 loop unrolling.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P700049702700000000000000004347E" data-uri="chapter05.xhtml#P700049702700000000000000004347E"><p id="P700049702700000000000000004347F" data-uri="chapter05.xhtml#P700049702700000000000000004347F" class="pcalibre1 pcalibre2 pcalibre10">By maintaining multiple accumulators, this approach can make better use of the multiple functional units and their pipelining capabilities.</p></div></figcaption></figure>
<table id="P7000497027000000000000000043480" data-uri="chapter05.xhtml#P7000497027000000000000000043480" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043481" data-uri="chapter05.xhtml#P7000497027000000000000000043481" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P7000497027000000000000000043482" data-uri="chapter05.xhtml#P7000497027000000000000000043482" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P7000497027000000000000000043483" data-uri="chapter05.xhtml#P7000497027000000000000000043483" class="pcalibre1 pcalibre2 calibre5"/>
<th colspan="2" id="P7000497027000000000000000043484" data-uri="chapter05.xhtml#P7000497027000000000000000043484" class="pcalibre1 pcalibre2 calibre5">Integer</th>
<th colspan="2" id="P7000497027000000000000000043485" data-uri="chapter05.xhtml#P7000497027000000000000000043485" class="pcalibre1 pcalibre2 calibre5">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043486" data-uri="chapter05.xhtml#P7000497027000000000000000043486" class="pcalibre1 pcalibre2 calibre5">Function</th>
<th id="P7000497027000000000000000043487" data-uri="chapter05.xhtml#P7000497027000000000000000043487" class="pcalibre1 pcalibre2 calibre5">Page</th>
<th id="P7000497027000000000000000043488" data-uri="chapter05.xhtml#P7000497027000000000000000043488" class="pcalibre1 pcalibre2 calibre5">Method</th>
<th id="P7000497027000000000000000043489" data-uri="chapter05.xhtml#P7000497027000000000000000043489" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P700049702700000000000000004348A" data-uri="chapter05.xhtml#P700049702700000000000000004348A" class="pcalibre1 pcalibre2 calibre5">*</th>
<th id="P700049702700000000000000004348B" data-uri="chapter05.xhtml#P700049702700000000000000004348B" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P700049702700000000000000004348C" data-uri="chapter05.xhtml#P700049702700000000000000004348C" class="pcalibre1 pcalibre2 calibre5">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004348D" data-uri="chapter05.xhtml#P700049702700000000000000004348D" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004348E" data-uri="chapter05.xhtml#P700049702700000000000000004348E" class="calibre3 pcalibre1 pcalibre2">combine4</code></td>
<td id="P700049702700000000000000004348F" data-uri="chapter05.xhtml#P700049702700000000000000004348F" class="pcalibre1 pcalibre2 calibre7">515</td>
<td id="P7000497027000000000000000043490" data-uri="chapter05.xhtml#P7000497027000000000000000043490" class="pcalibre1 pcalibre2 calibre7">Accumulate in temporary</td>
<td id="P7000497027000000000000000043491" data-uri="chapter05.xhtml#P7000497027000000000000000043491" class="pcalibre1 pcalibre2 calibre7">1.27</td>
<td id="P7000497027000000000000000043492" data-uri="chapter05.xhtml#P7000497027000000000000000043492" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P7000497027000000000000000043493" data-uri="chapter05.xhtml#P7000497027000000000000000043493" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P7000497027000000000000000043494" data-uri="chapter05.xhtml#P7000497027000000000000000043494" class="pcalibre1 pcalibre2 calibre7">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043495" data-uri="chapter05.xhtml#P7000497027000000000000000043495" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000043496" data-uri="chapter05.xhtml#P7000497027000000000000000043496" class="calibre3 pcalibre1 pcalibre2">combine5</code></td>
<td id="P7000497027000000000000000043497" data-uri="chapter05.xhtml#P7000497027000000000000000043497" class="pcalibre1 pcalibre2 calibre7">532</td>
<td id="P7000497027000000000000000043498" data-uri="chapter05.xhtml#P7000497027000000000000000043498" class="pcalibre1 pcalibre2 calibre7">2 × 1 unrolling</td>
<td id="P7000497027000000000000000043499" data-uri="chapter05.xhtml#P7000497027000000000000000043499" class="pcalibre1 pcalibre2 calibre7">1.01</td>
<td id="P700049702700000000000000004349A" data-uri="chapter05.xhtml#P700049702700000000000000004349A" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P700049702700000000000000004349B" data-uri="chapter05.xhtml#P700049702700000000000000004349B" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P700049702700000000000000004349C" data-uri="chapter05.xhtml#P700049702700000000000000004349C" class="pcalibre1 pcalibre2 calibre7">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004349D" data-uri="chapter05.xhtml#P700049702700000000000000004349D" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004349E" data-uri="chapter05.xhtml#P700049702700000000000000004349E" class="calibre3 pcalibre1 pcalibre2">combine6</code></td>
<td id="P700049702700000000000000004349F" data-uri="chapter05.xhtml#P700049702700000000000000004349F" class="pcalibre1 pcalibre2 calibre7">537</td>
<td id="P70004970270000000000000000434A0" data-uri="chapter05.xhtml#P70004970270000000000000000434A0" class="pcalibre1 pcalibre2 calibre7">2 × 2 unrolling</td>
<td id="P70004970270000000000000000434A1" data-uri="chapter05.xhtml#P70004970270000000000000000434A1" class="pcalibre1 pcalibre2 calibre7">0.81</td>
<td id="P70004970270000000000000000434A2" data-uri="chapter05.xhtml#P70004970270000000000000000434A2" class="pcalibre1 pcalibre2 calibre7">1.51</td>
<td id="P70004970270000000000000000434A3" data-uri="chapter05.xhtml#P70004970270000000000000000434A3" class="pcalibre1 pcalibre2 calibre7">1.51</td>
<td id="P70004970270000000000000000434A4" data-uri="chapter05.xhtml#P70004970270000000000000000434A4" class="pcalibre1 pcalibre2 calibre7">2.51</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P70004970270000000000000000434A5" data-uri="chapter05.xhtml#P70004970270000000000000000434A5" class="pcalibre1 pcalibre2 calibre7">Latency bound</td>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td id="P70004970270000000000000000434A6" data-uri="chapter05.xhtml#P70004970270000000000000000434A6" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P70004970270000000000000000434A7" data-uri="chapter05.xhtml#P70004970270000000000000000434A7" class="pcalibre1 pcalibre2 calibre7">3.00</td>
<td id="P70004970270000000000000000434A8" data-uri="chapter05.xhtml#P70004970270000000000000000434A8" class="pcalibre1 pcalibre2 calibre7">3.00</td>
<td id="P70004970270000000000000000434A9" data-uri="chapter05.xhtml#P70004970270000000000000000434A9" class="pcalibre1 pcalibre2 calibre7">5.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P70004970270000000000000000434AA" data-uri="chapter05.xhtml#P70004970270000000000000000434AA" class="pcalibre1 pcalibre2 calibre7">Throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td id="P70004970270000000000000000434AB" data-uri="chapter05.xhtml#P70004970270000000000000000434AB" class="pcalibre1 pcalibre2 calibre7">0.50</td>
<td id="P70004970270000000000000000434AC" data-uri="chapter05.xhtml#P70004970270000000000000000434AC" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P70004970270000000000000000434AD" data-uri="chapter05.xhtml#P70004970270000000000000000434AD" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P70004970270000000000000000434AE" data-uri="chapter05.xhtml#P70004970270000000000000000434AE" class="pcalibre1 pcalibre2 calibre7">0.50</td>
</tr>
</tbody>
</table>
<p id="P70004970270000000000000000434AF" data-uri="chapter05.xhtml#P70004970270000000000000000434AF" class="pcalibre8 pcalibre1 pcalibre2">We see that we have improved the performance for all cases, with integer product, floating-point addition, and floating-point multiplication improving by a factor of around 2, and integer addition improving somewhat as well. Most significantly, we have broken through the barrier imposed by the latency bound. The processor no longer needs to delay the start of one sum or product operation until the previous one has completed.</p>
<p id="P70004970270000000000000000434B0" data-uri="chapter05.xhtml#P70004970270000000000000000434B0" class="pcalibre8 pcalibre1 pcalibre2">To understand the performance of <code id="P70004970270000000000000000434B1" data-uri="chapter05.xhtml#P70004970270000000000000000434B1" class="pcalibre1 calibre1 pcalibre2">combine6</code>, we start with the code and operation sequence shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D63"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.22</span></a>. We can derive a template showing the</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004D63" data-uri="chapter05.xhtml#P7000497027000000000000000004D63">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004D64" title="538" data-uri="chapter05.xhtml#P7000497027000000000000000004D64" epub:type="pagebreak"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for combine6." id="P70004970270000000000000000434B2" data-uri="P700049702700000000000000000B71A" src="../images/p538-1.png" class="pcalibre1 pcalibre2 pcalibre197"/>
<figcaption id="P70004970270000000000000000434B3" data-uri="chapter05.xhtml#P70004970270000000000000000434B3" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000434B4" data-uri="chapter05.xhtml#P70004970270000000000000000434B4" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.22 </span>Graphical representation of inner-loop code for <code id="P70004970270000000000000000434B5" data-uri="chapter05.xhtml#P70004970270000000000000000434B5" class="pcalibre1 calibre1 pcalibre2">combine6</code>.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000434B6" data-uri="chapter05.xhtml#P70004970270000000000000000434B6"><p id="P70004970270000000000000000434B7" data-uri="chapter05.xhtml#P70004970270000000000000000434B7" class="pcalibre1 pcalibre2 pcalibre10">Each iteration has two <code id="P70004970270000000000000000434B8" data-uri="chapter05.xhtml#P70004970270000000000000000434B8" class="pcalibre1 calibre1 pcalibre2">vmulsd</code> instructions, each of which is translated into a load and a mul operation.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P700049702700000000000000002379E" data-uri="chapter05.xhtml#P700049702700000000000000002379E">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000434B9" data-uri="chapter05.xhtml#P70004970270000000000000000434B9" class="pcalibre8 pcalibre1 pcalibre2">A diagram has two rows of boxes, each with %rax, %rbp, %rdx, %rmm0, and %rmm1, with output from top %rax and %rbp to bottom %rax and %rbp, respectively. A column of boxes includes the seven operations summarized below, from top to bottom:</p>
<ul id="P70004970270000000000000000434BA" data-uri="chapter05.xhtml#P70004970270000000000000000434BA" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000434BB" data-uri="chapter05.xhtml#P70004970270000000000000000434BB" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434BC" data-uri="chapter05.xhtml#P70004970270000000000000000434BC" class="pcalibre1 pcalibre2 pcalibre10">First load: receives input from top %rax and %rdx; sends output to mul below</p></li>
<li id="P70004970270000000000000000434BD" data-uri="chapter05.xhtml#P70004970270000000000000000434BD" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434BE" data-uri="chapter05.xhtml#P70004970270000000000000000434BE" class="pcalibre1 pcalibre2 pcalibre10">First mul: receives input from load, with the two together representing vmulsd (%rax, %rdx, 8), %rmm0, %rmm0; receives input from top %rmm0 and sends output to bottom %rmm0.</p></li>
<li id="P70004970270000000000000000434BF" data-uri="chapter05.xhtml#P70004970270000000000000000434BF" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434C0" data-uri="chapter05.xhtml#P70004970270000000000000000434C0" class="pcalibre1 pcalibre2 pcalibre10">Second load: receives input from top %rax and %rdx; sends output to mul below</p></li>
<li id="P70004970270000000000000000434C1" data-uri="chapter05.xhtml#P70004970270000000000000000434C1" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434C2" data-uri="chapter05.xhtml#P70004970270000000000000000434C2" class="pcalibre1 pcalibre2 pcalibre10">Second mul: receives input from second load, with the two together representing vmulsd 8(%rax, %rdx, 8), %rmm1, %rmm1; receives input from top %rmm1 and sends output to bottom %rmm1</p></li>
<li id="P70004970270000000000000000434C3" data-uri="chapter05.xhtml#P70004970270000000000000000434C3" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434C4" data-uri="chapter05.xhtml#P70004970270000000000000000434C4" class="pcalibre1 pcalibre2 pcalibre10">add (addq $2, %rdx): receives input from top %rdx and sends output to bottom %rdx and cmp</p></li>
<li id="P70004970270000000000000000434C5" data-uri="chapter05.xhtml#P70004970270000000000000000434C5" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434C6" data-uri="chapter05.xhtml#P70004970270000000000000000434C6" class="pcalibre1 pcalibre2 pcalibre10">cmp (cmpq %rdx, %rbp): receives input from add above and top %rbp; sends output to jg below</p></li>
<li id="P70004970270000000000000000434C7" data-uri="chapter05.xhtml#P70004970270000000000000000434C7" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434C8" data-uri="chapter05.xhtml#P70004970270000000000000000434C8" class="pcalibre1 pcalibre2 pcalibre10">jg (jg loop): receives input from cmp above</p></li>
</ul>
</details>
</figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004D6C" data-uri="chapter05.xhtml#P7000497027000000000000000004D6C">
<img alt="A diagram depicts two data-flow graphs for combine6." id="P70004970270000000000000000434C9" data-uri="P700049702700000000000000000B71B" src="../images/p538-2.png" class="pcalibre1 pcalibre2 pcalibre198"/>
<figcaption id="P70004970270000000000000000434CA" data-uri="chapter05.xhtml#P70004970270000000000000000434CA" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000434CB" data-uri="chapter05.xhtml#P70004970270000000000000000434CB" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.23 </span>Abstracting <code id="P70004970270000000000000000434CC" data-uri="chapter05.xhtml#P70004970270000000000000000434CC" class="pcalibre1 calibre1 pcalibre2">combine6</code> operations as a data-flow graph.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000434CD" data-uri="chapter05.xhtml#P70004970270000000000000000434CD"><p id="P70004970270000000000000000434CE" data-uri="chapter05.xhtml#P70004970270000000000000000434CE" class="pcalibre1 pcalibre2 pcalibre10">We rearrange, simplify, and abstract the representation of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D63"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.22</span></a> to show the data dependencies between successive iterations (a). We see that there is no dependency between the two mul operations (b).</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000237B5" data-uri="chapter05.xhtml#P70004970270000000000000000237B5">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P70004970270000000000000000434CF" data-uri="chapter05.xhtml#P70004970270000000000000000434CF">
<li id="P70004970270000000000000000434D0" data-uri="chapter05.xhtml#P70004970270000000000000000434D0" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434D1" data-uri="chapter05.xhtml#P70004970270000000000000000434D1" class="pcalibre1 pcalibre2 pcalibre10">Data flows from top %rmm0 to first mul to bottom %rmm0; from top %rax to each load, each to each mul then %rmm0 and %rmm1, respectively; from top %rmm1 to second mule and bottom %rmm1; from top %rbp to cmp to jg; from top %rdx to each load and add, from which data is sent to bottom %rdx and to cmp.</p></li>
<li id="P70004970270000000000000000434D2" data-uri="chapter05.xhtml#P70004970270000000000000000434D2" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434D3" data-uri="chapter05.xhtml#P70004970270000000000000000434D3" class="pcalibre1 pcalibre2 pcalibre10">Data flows from top top %rmm0 to first mul to %rmm0, from top %rmm1 to second mul to bottom %rmm1, and from top %rdx to each load as well as add to bottom %rdx. First load and mul are within data [i] and second load and mul and add within data [i+1].</p></li>
</ol>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000434D4" data-uri="chapter05.xhtml#P70004970270000000000000000434D4">data dependencies between iterations through the process shown in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D6C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.23</span></a>. As with <code id="P70004970270000000000000000434D5" data-uri="chapter05.xhtml#P70004970270000000000000000434D5" class="pcalibre1 calibre1 pcalibre2">combine5</code>, the inner loop contains two <code id="P70004970270000000000000000434D6" data-uri="chapter05.xhtml#P70004970270000000000000000434D6" class="pcalibre1 calibre1 pcalibre2">vmulsd</code> operations, but these instructions translate into mul operations that read and write separate registers, with no data dependency between them (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D6C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.23(b)</span></a>). We then replicate this template <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 times (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D77"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.24</span></a>), modeling the execution of the function on a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>. We see that we now have two critical paths, one corresponding to computing the product of even-numbered elements (program value <code id="P70004970270000000000000000434D7" data-uri="chapter05.xhtml#P70004970270000000000000000434D7" class="pcalibre1 calibre1 pcalibre2">acc0</code>) and</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004D77" data-uri="chapter05.xhtml#P7000497027000000000000000004D77">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004D78" title="539" data-uri="chapter05.xhtml#P7000497027000000000000000004D78" epub:type="pagebreak"></span>
<img alt="A diagram shows critical paths through the each mul in data[0] and data[1], data[2] and data[3], and data[n minus 2] and data[n minus 1]." id="P70004970270000000000000000434D8" data-uri="P700049702700000000000000000B71C" src="../images/p539-1.png" class="pcalibre1 pcalibre2 pcalibre199"/>
<figcaption id="P70004970270000000000000000434D9" data-uri="chapter05.xhtml#P70004970270000000000000000434D9" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000434DA" data-uri="chapter05.xhtml#P70004970270000000000000000434DA" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.24 </span>Data-flow representation of <code id="P70004970270000000000000000434DB" data-uri="chapter05.xhtml#P70004970270000000000000000434DB" class="pcalibre1 calibre1 pcalibre2">combine6</code> operating on a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P70004970270000000000000000434DC" data-uri="chapter05.xhtml#P70004970270000000000000000434DC"><p id="P70004970270000000000000000434DD" data-uri="chapter05.xhtml#P70004970270000000000000000434DD" class="pcalibre1 pcalibre2 pcalibre10">We now have two critical paths, each containing <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 operations.</p></div>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000434DE" data-uri="chapter05.xhtml#P70004970270000000000000000434DE">one for the odd-numbered elements (program value <code id="P70004970270000000000000000434DF" data-uri="chapter05.xhtml#P70004970270000000000000000434DF" class="pcalibre1 calibre1 pcalibre2">acc1</code>). Each of these critical paths contains only <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 operations, thus leading to a CPE of around 5.00/2 = 2.50. A similar analysis explains our observed CPE of around <var class="pcalibre17 pcalibre2 pcalibre1">L</var>/2 for operations with latency <var class="pcalibre17 pcalibre2 pcalibre1">L</var> for the different combinations of data type and combining operation. Operationally, the programs are exploiting the capabilities of the functional units to increase their utilization by a factor of 2. The only exception is for integer addition. We have reduced the CPE to below 1.0, but there is still too much loop overhead to achieve the theoretical limit of 0.50.</p>
<p id="P70004970270000000000000000434E0" data-uri="chapter05.xhtml#P70004970270000000000000000434E0" class="pcalibre8 pcalibre1 pcalibre2">We can generalize the multiple accumulator transformation to unroll the loop by a factor of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> and accumulate <var class="pcalibre17 pcalibre2 pcalibre1">k</var> values in parallel, yielding <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × <i class="pcalibre17 pcalibre2 pcalibre1">k loop unrolling.</i> <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004D82"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.25</span></a> demonstrates the effect of applying this transformation for values up to <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 10. We can see that, for sufficiently large values of <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, the program can</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004D82" data-uri="chapter05.xhtml#P7000497027000000000000000004D82">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004D83" title="540" data-uri="chapter05.xhtml#P7000497027000000000000000004D83" epub:type="pagebreak"></span>
<img alt="A graph depicts CPE versus unrolling factor k." id="P70004970270000000000000000434E1" data-uri="P700049702700000000000000000B71D" src="../images/p540-1.png" class="pcalibre1 pcalibre2 calibre47"/>
<figcaption id="P70004970270000000000000000434E2" data-uri="chapter05.xhtml#P70004970270000000000000000434E2" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000434E3" data-uri="chapter05.xhtml#P70004970270000000000000000434E3" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.25 </span>CPE performance of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × <var class="pcalibre17 pcalibre2 pcalibre1">k</var> loop unrolling.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000434E4" data-uri="chapter05.xhtml#P70004970270000000000000000434E4"><p id="P70004970270000000000000000434E5" data-uri="chapter05.xhtml#P70004970270000000000000000434E5" class="pcalibre1 pcalibre2 pcalibre10">All of the CPEs improve with this transformation, achieving near or at their throughput bounds.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000237CD" data-uri="chapter05.xhtml#P70004970270000000000000000237CD">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000434E6" data-uri="chapter05.xhtml#P70004970270000000000000000434E6" class="pcalibre8 pcalibre1 pcalibre2">The four sets of points plotted each decreasing in CPE with increasing rolling factor k, as summarized below.</p>
<ul id="P70004970270000000000000000434E7" data-uri="chapter05.xhtml#P70004970270000000000000000434E7" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P70004970270000000000000000434E8" data-uri="chapter05.xhtml#P70004970270000000000000000434E8" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434E9" data-uri="chapter05.xhtml#P70004970270000000000000000434E9" class="pcalibre1 pcalibre2 pcalibre10">Double *: from 5 CPE at 1 to about 0.5 CPE at 10</p></li>
<li id="P70004970270000000000000000434EA" data-uri="chapter05.xhtml#P70004970270000000000000000434EA" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434EB" data-uri="chapter05.xhtml#P70004970270000000000000000434EB" class="pcalibre1 pcalibre2 pcalibre10">Double + and long *: each from 3 CPE at 1 to steady around 1 CPE by 3</p></li>
<li id="P70004970270000000000000000434EC" data-uri="chapter05.xhtml#P70004970270000000000000000434EC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000434ED" data-uri="chapter05.xhtml#P70004970270000000000000000434ED" class="pcalibre1 pcalibre2 pcalibre10">Long +: from about 1.5 CPE at 1 to steady around 0.5 CPE by 5</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000434EE" data-uri="chapter05.xhtml#P70004970270000000000000000434EE">achieve nearly the throughput bounds for all cases. Integer addition achieves a CPE of 0.54 with <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 7, close to the throughput bound of 0.50 caused by the two load units. Integer multiplication and floating-point addition achieve CPEs of 1.01 when <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≥ 3, approaching the throughput bound of 1.00 set by their functional units. Floating-point multiplication achieves a CPE of 0.51 for <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≥ 10, approaching the throughput bound of 0.50 set by the two floating-point multipliers and the two load units. It is worth noting that our code is able to achieve nearly twice the throughput with floating-point multiplication as it can with floating-point addition, even though multiplication is a more complex operation.</p>
<p id="P70004970270000000000000000434EF" data-uri="chapter05.xhtml#P70004970270000000000000000434EF" class="pcalibre8 pcalibre1 pcalibre2">In general, a program can achieve the throughput bound for an operation only when it can keep the pipelines filled for all of the functional units capable of performing that operation. For an operation with latency <var class="pcalibre17 pcalibre2 pcalibre1">L</var> and capacity <var class="pcalibre17 pcalibre2 pcalibre1">C</var>, this requires an unrolling factor <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≥ <i class="pcalibre17 pcalibre2 pcalibre1">C · L.</i> For example, floating-point multiplication has <var class="pcalibre17 pcalibre2 pcalibre1">C</var> = 2 and <var class="pcalibre17 pcalibre2 pcalibre1">L</var> = 5, necessitating an unrolling factor of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≥ 10. Floating-point addition has <var class="pcalibre17 pcalibre2 pcalibre1">C</var> = 1 and <var class="pcalibre17 pcalibre2 pcalibre1">L</var> = 3, achieving maximum throughput with <var class="pcalibre17 pcalibre2 pcalibre1">k</var> ≥ 3.</p>
<p id="P70004970270000000000000000434F0" data-uri="chapter05.xhtml#P70004970270000000000000000434F0" class="pcalibre8 pcalibre1 pcalibre2">In performing the <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × <var class="pcalibre17 pcalibre2 pcalibre1">k</var> unrolling transformation, we must consider whether it preserves the functionality of the original function. We have seen in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000000279.xhtml#P7000497027000000000000000000279"><span class="pcalibre1 pcalibre21 pcalibre2">Chapter </span><span class="pcalibre1 pcalibre21 pcalibre2">2</span></a> that two's-complement arithmetic is commutative and associative, even when overflow occurs. Hence, for an integer data type, the result computed by <code id="P70004970270000000000000000434F1" data-uri="chapter05.xhtml#P70004970270000000000000000434F1" class="pcalibre1 calibre1 pcalibre2">combine6</code> will be identical to that computed by <code id="P70004970270000000000000000434F2" data-uri="chapter05.xhtml#P70004970270000000000000000434F2" class="pcalibre1 calibre1 pcalibre2">combine5</code> under all possible conditions. Thus, an optimizing compiler could potentially convert the code shown in <code id="P70004970270000000000000000434F3" data-uri="chapter05.xhtml#P70004970270000000000000000434F3" class="pcalibre1 calibre1 pcalibre2">combine4</code> first to a two-way unrolled variant of <code id="P70004970270000000000000000434F4" data-uri="chapter05.xhtml#P70004970270000000000000000434F4" class="pcalibre1 calibre1 pcalibre2">combine5</code> by loop unrolling, and then to that of <code id="P70004970270000000000000000434F5" data-uri="chapter05.xhtml#P70004970270000000000000000434F5" class="pcalibre1 calibre1 pcalibre2">combine6</code> by introducing parallelism. Some compilers do either this or similar transformations to improve performance for integer data.</p>
<p id="P70004970270000000000000000434F6" data-uri="chapter05.xhtml#P70004970270000000000000000434F6" class="pcalibre8 pcalibre1 pcalibre2">On the other hand, floating-point multiplication and addition are not associative. Thus, <code id="P70004970270000000000000000434F7" data-uri="chapter05.xhtml#P70004970270000000000000000434F7" class="pcalibre1 calibre1 pcalibre2">combine5</code> and <code id="P70004970270000000000000000434F8" data-uri="chapter05.xhtml#P70004970270000000000000000434F8" class="pcalibre1 calibre1 pcalibre2">combine6</code> could produce different results due to rounding or overflow. Imagine, for example, a product computation in which all of the elements with even indices are numbers with very large absolute values, while those with odd indices are very close to 0.0. In such a case, product <i class="pcalibre17 pcalibre2 pcalibre1">PE<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i> might overflow, or <i class="pcalibre17 pcalibre2 pcalibre1">PO<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i> might underflow, even though computing product <i class="pcalibre17 pcalibre2 pcalibre1">P<sub class="pcalibre1 pcalibre2 calibre14">n</sub></i> proceeds <span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004D94" title="541" data-uri="chapter05.xhtml#P7000497027000000000000000004D94" epub:type="pagebreak"></span>normally. In most real-life applications, however, such patterns are unlikely. Since most physical phenomena are continuous, numerical data tend to be reasonably smooth and well behaved. Even when there are discontinuities, they do not generally cause periodic patterns that lead to a condition such as that sketched earlier. It is unlikely that multiplying the elements in strict order gives fundamentally better accuracy than does multiplying two groups independently and then multiplying those products together. For most applications, achieving a performance gain of 2× outweighs the risk of generating different results for strange data patterns. Nevertheless, a program developer should check with potential users to see if there are particular conditions that may cause the revised algorithm to be unacceptable. Most compilers do not attempt such transformations with floating-point code, since they have no way to judge the risks of introducing transformations that can change the program behavior, no matter how small.</p>
</section>
<section id="P7000497027000000000000000004D95" data-uri="chapter05.xhtml#P7000497027000000000000000004D95" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000434F9" data-uri="chapter05.xhtml#P70004970270000000000000000434F9" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">5.9.2 </span>Reassociation Transformation</h1></header>
<p id="P70004970270000000000000000434FA" data-uri="chapter05.xhtml#P70004970270000000000000000434FA" class="pcalibre8 pcalibre1 pcalibre2">We now explore another way to break the sequential dependencies and thereby improve performance beyond the latency bound. We saw that the <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 loop unrolling of <code id="P70004970270000000000000000434FB" data-uri="chapter05.xhtml#P70004970270000000000000000434FB" class="pcalibre1 calibre1 pcalibre2">combine5</code> did not change the set of operations performed in combining the vector elements to form their sum or product. By a very small change in the code, however, we can fundamentally change the way the combining is performed, and also greatly increase the program performance.</p>
<p id="P70004970270000000000000000434FC" data-uri="chapter05.xhtml#P70004970270000000000000000434FC" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DDC"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.26</span></a> shows a function <code id="P70004970270000000000000000434FD" data-uri="chapter05.xhtml#P70004970270000000000000000434FD" class="pcalibre1 calibre1 pcalibre2">combine7</code> that differs from the unrolled code of <code id="P70004970270000000000000000434FE" data-uri="chapter05.xhtml#P70004970270000000000000000434FE" class="pcalibre1 calibre1 pcalibre2">combine5</code> (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000004C94.xhtml#P7000497027000000000000000004C9D"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.16</span></a>) only in the way the elements are combined in the inner loop. In <code id="P70004970270000000000000000434FF" data-uri="chapter05.xhtml#P70004970270000000000000000434FF" class="pcalibre1 calibre1 pcalibre2">combine5</code>, the combining is performed by the statement</p>
<pre id="P7000497027000000000000000043500" data-uri="chapter05.xhtml#P7000497027000000000000000043500" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043501" data-uri="chapter05.xhtml#P7000497027000000000000000043501" class="calibre3 pcalibre1 pcalibre2">
12	acc = (acc OP data[i]) OP data[i+1];
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043502" data-uri="chapter05.xhtml#P7000497027000000000000000043502">while in <code id="P7000497027000000000000000043503" data-uri="chapter05.xhtml#P7000497027000000000000000043503" class="pcalibre1 calibre1 pcalibre2">combine7</code> it is performed by the statement</p>
<pre id="P7000497027000000000000000043504" data-uri="chapter05.xhtml#P7000497027000000000000000043504" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043505" data-uri="chapter05.xhtml#P7000497027000000000000000043505" class="calibre3 pcalibre1 pcalibre2">
12	acc = acc OP (data[i] OP data[i+1]);
</code></pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043506" data-uri="chapter05.xhtml#P7000497027000000000000000043506">differing only in how two parentheses are placed. We call this a <i class="pcalibre17 pcalibre2 pcalibre1">reassociation transformation</i>, because the parentheses shift the order in which the vector elements are combined with the accumulated value acc, yielding a form of loop unrolling we refer to as "2 × 1<var class="pcalibre17 pcalibre2 pcalibre1">a</var>."</p>
<p id="P7000497027000000000000000043507" data-uri="chapter05.xhtml#P7000497027000000000000000043507" class="pcalibre8 pcalibre1 pcalibre2">To an untrained eye, the two statements may seem essentially the same, but when we measure the CPE, we get a surprising result:</p>
<table id="P7000497027000000000000000043508" data-uri="chapter05.xhtml#P7000497027000000000000000043508" class="pcalibre1 pcalibre2 pcalibre43">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P7000497027000000000000000043509" data-uri="chapter05.xhtml#P7000497027000000000000000043509" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P700049702700000000000000004350A" data-uri="chapter05.xhtml#P700049702700000000000000004350A" class="pcalibre1 pcalibre2 calibre5"/>
<th id="P700049702700000000000000004350B" data-uri="chapter05.xhtml#P700049702700000000000000004350B" class="pcalibre1 pcalibre2 calibre5"/>
<th colspan="2" id="P700049702700000000000000004350C" data-uri="chapter05.xhtml#P700049702700000000000000004350C" class="pcalibre1 pcalibre2 calibre5">Integer</th>
<th colspan="2" id="P700049702700000000000000004350D" data-uri="chapter05.xhtml#P700049702700000000000000004350D" class="pcalibre1 pcalibre2 calibre5">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P700049702700000000000000004350E" data-uri="chapter05.xhtml#P700049702700000000000000004350E" class="pcalibre1 pcalibre2 calibre5">Function</th>
<th id="P700049702700000000000000004350F" data-uri="chapter05.xhtml#P700049702700000000000000004350F" class="pcalibre1 pcalibre2 calibre5">Page</th>
<th id="P7000497027000000000000000043510" data-uri="chapter05.xhtml#P7000497027000000000000000043510" class="pcalibre1 pcalibre2 calibre5">Method</th>
<th id="P7000497027000000000000000043511" data-uri="chapter05.xhtml#P7000497027000000000000000043511" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P7000497027000000000000000043512" data-uri="chapter05.xhtml#P7000497027000000000000000043512" class="pcalibre1 pcalibre2 calibre5">*</th>
<th id="P7000497027000000000000000043513" data-uri="chapter05.xhtml#P7000497027000000000000000043513" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P7000497027000000000000000043514" data-uri="chapter05.xhtml#P7000497027000000000000000043514" class="pcalibre1 pcalibre2 calibre5">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043515" data-uri="chapter05.xhtml#P7000497027000000000000000043515" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000043516" data-uri="chapter05.xhtml#P7000497027000000000000000043516" class="calibre3 pcalibre1 pcalibre2">combine4</code></td>
<td id="P7000497027000000000000000043517" data-uri="chapter05.xhtml#P7000497027000000000000000043517" class="pcalibre1 pcalibre2 calibre7">515</td>
<td id="P7000497027000000000000000043518" data-uri="chapter05.xhtml#P7000497027000000000000000043518" class="pcalibre1 pcalibre2 calibre7">Accumulate in temporary</td>
<td id="P7000497027000000000000000043519" data-uri="chapter05.xhtml#P7000497027000000000000000043519" class="pcalibre1 pcalibre2 calibre7">1.27</td>
<td id="P700049702700000000000000004351A" data-uri="chapter05.xhtml#P700049702700000000000000004351A" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P700049702700000000000000004351B" data-uri="chapter05.xhtml#P700049702700000000000000004351B" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P700049702700000000000000004351C" data-uri="chapter05.xhtml#P700049702700000000000000004351C" class="pcalibre1 pcalibre2 calibre7">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004351D" data-uri="chapter05.xhtml#P700049702700000000000000004351D" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004351E" data-uri="chapter05.xhtml#P700049702700000000000000004351E" class="calibre3 pcalibre1 pcalibre2">combine5</code></td>
<td id="P700049702700000000000000004351F" data-uri="chapter05.xhtml#P700049702700000000000000004351F" class="pcalibre1 pcalibre2 calibre7">532</td>
<td id="P7000497027000000000000000043520" data-uri="chapter05.xhtml#P7000497027000000000000000043520" class="pcalibre1 pcalibre2 calibre7">2 × 1 unrolling</td>
<td id="P7000497027000000000000000043521" data-uri="chapter05.xhtml#P7000497027000000000000000043521" class="pcalibre1 pcalibre2 calibre7">1.01</td>
<td id="P7000497027000000000000000043522" data-uri="chapter05.xhtml#P7000497027000000000000000043522" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P7000497027000000000000000043523" data-uri="chapter05.xhtml#P7000497027000000000000000043523" class="pcalibre1 pcalibre2 calibre7">3.01</td>
<td id="P7000497027000000000000000043524" data-uri="chapter05.xhtml#P7000497027000000000000000043524" class="pcalibre1 pcalibre2 calibre7">5.01</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P7000497027000000000000000043525" data-uri="chapter05.xhtml#P7000497027000000000000000043525" class="pcalibre1 pcalibre2 calibre7"><code id="P7000497027000000000000000043526" data-uri="chapter05.xhtml#P7000497027000000000000000043526" class="calibre3 pcalibre1 pcalibre2">combine6</code></td>
<td id="P7000497027000000000000000043527" data-uri="chapter05.xhtml#P7000497027000000000000000043527" class="pcalibre1 pcalibre2 calibre7">537</td>
<td id="P7000497027000000000000000043528" data-uri="chapter05.xhtml#P7000497027000000000000000043528" class="pcalibre1 pcalibre2 calibre7">2 × 2 unrolling</td>
<td id="P7000497027000000000000000043529" data-uri="chapter05.xhtml#P7000497027000000000000000043529" class="pcalibre1 pcalibre2 calibre7">0.81</td>
<td id="P700049702700000000000000004352A" data-uri="chapter05.xhtml#P700049702700000000000000004352A" class="pcalibre1 pcalibre2 calibre7">1.51</td>
<td id="P700049702700000000000000004352B" data-uri="chapter05.xhtml#P700049702700000000000000004352B" class="pcalibre1 pcalibre2 calibre7">1.51</td>
<td id="P700049702700000000000000004352C" data-uri="chapter05.xhtml#P700049702700000000000000004352C" class="pcalibre1 pcalibre2 calibre7">2.51</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P700049702700000000000000004352D" data-uri="chapter05.xhtml#P700049702700000000000000004352D" class="pcalibre1 pcalibre2 calibre7"><code id="P700049702700000000000000004352E" data-uri="chapter05.xhtml#P700049702700000000000000004352E" class="calibre3 pcalibre1 pcalibre2">combine7</code></td>
<td id="P700049702700000000000000004352F" data-uri="chapter05.xhtml#P700049702700000000000000004352F" class="pcalibre1 pcalibre2 calibre7">542</td>
<td id="P7000497027000000000000000043530" data-uri="chapter05.xhtml#P7000497027000000000000000043530" class="pcalibre1 pcalibre2 calibre7">2 × 1<var class="pcalibre17 pcalibre2 pcalibre1">a</var> unrolling</td>
<td id="P7000497027000000000000000043531" data-uri="chapter05.xhtml#P7000497027000000000000000043531" class="pcalibre1 pcalibre2 calibre7">1.01</td>
<td id="P7000497027000000000000000043532" data-uri="chapter05.xhtml#P7000497027000000000000000043532" class="pcalibre1 pcalibre2 calibre7">1.51</td>
<td id="P7000497027000000000000000043533" data-uri="chapter05.xhtml#P7000497027000000000000000043533" class="pcalibre1 pcalibre2 calibre7">1.51</td>
<td id="P7000497027000000000000000043534" data-uri="chapter05.xhtml#P7000497027000000000000000043534" class="pcalibre1 pcalibre2 calibre7">2.51</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P7000497027000000000000000043535" data-uri="chapter05.xhtml#P7000497027000000000000000043535" class="pcalibre1 pcalibre2 calibre7">Latency bound</td>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td id="P7000497027000000000000000043536" data-uri="chapter05.xhtml#P7000497027000000000000000043536" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P7000497027000000000000000043537" data-uri="chapter05.xhtml#P7000497027000000000000000043537" class="pcalibre1 pcalibre2 calibre7">3.00</td>
<td id="P7000497027000000000000000043538" data-uri="chapter05.xhtml#P7000497027000000000000000043538" class="pcalibre1 pcalibre2 calibre7">3.00</td>
<td id="P7000497027000000000000000043539" data-uri="chapter05.xhtml#P7000497027000000000000000043539" class="pcalibre1 pcalibre2 calibre7">5.00</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td colspan="2" id="P700049702700000000000000004353A" data-uri="chapter05.xhtml#P700049702700000000000000004353A" class="pcalibre1 pcalibre2 calibre7">Throughput bound</td>
<td class="pcalibre1 pcalibre2 calibre7"/>
<td id="P700049702700000000000000004353B" data-uri="chapter05.xhtml#P700049702700000000000000004353B" class="pcalibre1 pcalibre2 calibre7">0.50</td>
<td id="P700049702700000000000000004353C" data-uri="chapter05.xhtml#P700049702700000000000000004353C" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P700049702700000000000000004353D" data-uri="chapter05.xhtml#P700049702700000000000000004353D" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P700049702700000000000000004353E" data-uri="chapter05.xhtml#P700049702700000000000000004353E" class="pcalibre1 pcalibre2 calibre7">0.50</td>
</tr>
</tbody>
</table>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004DDC" data-uri="chapter05.xhtml#P7000497027000000000000000004DDC">
<pre id="P700049702700000000000000004353F" data-uri="chapter05.xhtml#P700049702700000000000000004353F" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043540" data-uri="chapter05.xhtml#P7000497027000000000000000043540" class="calibre3 pcalibre1 pcalibre2">
<span class="pcalibre1 pcalibre2 pcalibre123" id="P7000497027000000000000000004DDF" title="542" data-uri="chapter05.xhtml#P7000497027000000000000000004DDF" epub:type="pagebreak"></span>1	/* 2 x 1a loop unrolling */
2	void combine7(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		long limit = length-1;
7		data_t *data = get_vec_start(v);
8		data_t acc = IDENT; 9
10		/* Combine 2 elements at a time */
11		for (i = 0; i &lt; limit; i+=2) {
12			acc = acc OP (data[i] OP data[i+1]);
13		} 
14
15		/* Finish any remaining elements */
16		for (;i &lt; length; i++) {
17			acc = acc OP data[i];
18		}
19		*dest = acc;
20	}
</code></pre>
<figcaption id="P7000497027000000000000000043541" data-uri="chapter05.xhtml#P7000497027000000000000000043541" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043542" data-uri="chapter05.xhtml#P7000497027000000000000000043542" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.26 </span>Applying 2 × 1<var class="pcalibre17 pcalibre2 pcalibre1">a</var> unrolling.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000043543" data-uri="chapter05.xhtml#P7000497027000000000000000043543"><p id="P7000497027000000000000000043544" data-uri="chapter05.xhtml#P7000497027000000000000000043544" class="pcalibre1 pcalibre2 pcalibre10">By reassociating the arithmetic, this approach increases the number of operations that can be performed in parallel.</p></div></figcaption></figure>
<p id="P7000497027000000000000000043545" data-uri="chapter05.xhtml#P7000497027000000000000000043545" class="pcalibre8 pcalibre1 pcalibre2">The integer addition case matches the performance of <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 unrolling (<code id="P7000497027000000000000000043546" data-uri="chapter05.xhtml#P7000497027000000000000000043546" class="pcalibre1 calibre1 pcalibre2">combine5</code>), while the other three cases match the performance of the versions with parallel accumulators (<code id="P7000497027000000000000000043547" data-uri="chapter05.xhtml#P7000497027000000000000000043547" class="pcalibre1 calibre1 pcalibre2">combine6</code>), doubling the performance relative to <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1 unrolling. These cases have broken through the barrier imposed by the latency bound.</p>
<p id="P7000497027000000000000000043548" data-uri="chapter05.xhtml#P7000497027000000000000000043548" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DEE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.27</span></a> illustrates how the code for the inner loop of <code id="P7000497027000000000000000043549" data-uri="chapter05.xhtml#P7000497027000000000000000043549" class="pcalibre1 calibre1 pcalibre2">combine7</code> (for the case of multiplication as the combining operation and double as data type) gets decoded into operations and the resulting data dependencies. We see that the load operations resulting from the <code id="P700049702700000000000000004354A" data-uri="chapter05.xhtml#P700049702700000000000000004354A" class="pcalibre1 calibre1 pcalibre2">vmovsd</code> and the first <code id="P700049702700000000000000004354B" data-uri="chapter05.xhtml#P700049702700000000000000004354B" class="pcalibre1 calibre1 pcalibre2">vmulsd</code> instructions load vector elements <var class="pcalibre17 pcalibre2 pcalibre1">i</var> and <var class="pcalibre17 pcalibre2 pcalibre1">i</var> + 1 from memory, and the first mul operation multiplies them together. The second mul operation then multiples this result by the accumulated value <code id="P700049702700000000000000004354C" data-uri="chapter05.xhtml#P700049702700000000000000004354C" class="pcalibre1 calibre1 pcalibre2">acc</code>. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DF8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.28(a)</span></a> shows how we rearrange, refine, and abstract the operations of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DEE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.27</span></a> to get a template representing the data dependencies for one iteration (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DF8"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.28(b)</span></a>). As with the templates for <code id="P700049702700000000000000004354D" data-uri="chapter05.xhtml#P700049702700000000000000004354D" class="pcalibre1 calibre1 pcalibre2">combine5</code> and <code id="P700049702700000000000000004354E" data-uri="chapter05.xhtml#P700049702700000000000000004354E" class="pcalibre1 calibre1 pcalibre2">combine7</code>, we have two load and two mul operations, but only one of the mul operations forms a data-dependency chain between loop registers. When we then replicate this template <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 times to show the computations performed in multiplying <var class="pcalibre17 pcalibre2 pcalibre1">n</var> vector elements (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004E00"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.29</span></a>), we see that we only have <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 operations along the critical path. The first multiplication within each iteration can be performed without waiting for the accumulated value from the previous iteration. Thus, we reduce the minimum possible CPE by a factor of around 2.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004DEE" data-uri="chapter05.xhtml#P7000497027000000000000000004DEE">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004DEF" title="543" data-uri="chapter05.xhtml#P7000497027000000000000000004DEF" epub:type="pagebreak"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for combine7." id="P700049702700000000000000004354F" data-uri="P700049702700000000000000000B71E" src="../images/p543-1.png" class="pcalibre1 pcalibre2 calibre48"/>
<figcaption id="P7000497027000000000000000043550" data-uri="chapter05.xhtml#P7000497027000000000000000043550" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043551" data-uri="chapter05.xhtml#P7000497027000000000000000043551" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.27 </span>Graphical representation of inner-loop code for <code id="P7000497027000000000000000043552" data-uri="chapter05.xhtml#P7000497027000000000000000043552" class="pcalibre1 calibre1 pcalibre2">combine7</code>.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000043553" data-uri="chapter05.xhtml#P7000497027000000000000000043553"><p id="P7000497027000000000000000043554" data-uri="chapter05.xhtml#P7000497027000000000000000043554" class="pcalibre1 pcalibre2 pcalibre10">Each iteration gets decoded into similar operations as for <code id="P7000497027000000000000000043555" data-uri="chapter05.xhtml#P7000497027000000000000000043555" class="pcalibre1 calibre1 pcalibre2">combine5</code> or <code id="P7000497027000000000000000043556" data-uri="chapter05.xhtml#P7000497027000000000000000043556" class="pcalibre1 calibre1 pcalibre2">combine6</code>, but with different data dependencies.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P700049702700000000000000002383F" data-uri="chapter05.xhtml#P700049702700000000000000002383F">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000043557" data-uri="chapter05.xhtml#P7000497027000000000000000043557" class="pcalibre8 pcalibre1 pcalibre2">A diagram has two rows of boxes, each with %rax, %rbp, %rdx, %rmm0, and %rmm1, with output from top %rax and %rbp to bottom %rax and %rbp, respectively. A column of boxes includes the seven operations summarized below, from top to bottom:</p>
<ul id="P7000497027000000000000000043558" data-uri="chapter05.xhtml#P7000497027000000000000000043558" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000043559" data-uri="chapter05.xhtml#P7000497027000000000000000043559" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004355A" data-uri="chapter05.xhtml#P700049702700000000000000004355A" class="pcalibre1 pcalibre2 pcalibre10">First load (vmovsd (%rax, %rdx, 8) %rmm0): receives input from top %rax and %rdx; sends output to first mul below</p></li>
<li id="P700049702700000000000000004355B" data-uri="chapter05.xhtml#P700049702700000000000000004355B" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004355C" data-uri="chapter05.xhtml#P700049702700000000000000004355C" class="pcalibre1 pcalibre2 pcalibre10">Second load: receives input from top %rax and %rdx; sends output to first mul below</p></li>
<li id="P700049702700000000000000004355D" data-uri="chapter05.xhtml#P700049702700000000000000004355D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004355E" data-uri="chapter05.xhtml#P700049702700000000000000004355E" class="pcalibre1 pcalibre2 pcalibre10">First mul: receives input from each load, with it and the second load together representing vmulsd 8(%rax, %rdx, 8), %rmm0, %rmm0; sends output to second mul</p></li>
<li id="P700049702700000000000000004355F" data-uri="chapter05.xhtml#P700049702700000000000000004355F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043560" data-uri="chapter05.xhtml#P7000497027000000000000000043560" class="pcalibre1 pcalibre2 pcalibre10">Second mul (vmulsd %rmm0, %rmm1, %rmm1): receives input from first mul and rop %rmm1 and sends output to bottom %rmm1</p></li>
<li id="P7000497027000000000000000043561" data-uri="chapter05.xhtml#P7000497027000000000000000043561" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043562" data-uri="chapter05.xhtml#P7000497027000000000000000043562" class="pcalibre1 pcalibre2 pcalibre10">add (addq $2, %rdx): receives input from top %rdx and sends output to bottom %rdx and cmp</p></li>
<li id="P7000497027000000000000000043563" data-uri="chapter05.xhtml#P7000497027000000000000000043563" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043564" data-uri="chapter05.xhtml#P7000497027000000000000000043564" class="pcalibre1 pcalibre2 pcalibre10">cmp (cmpq %rdx, %rbp): receives input from add above and top %rbp; sends output to jg below</p></li>
<li id="P7000497027000000000000000043565" data-uri="chapter05.xhtml#P7000497027000000000000000043565" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043566" data-uri="chapter05.xhtml#P7000497027000000000000000043566" class="pcalibre1 pcalibre2 pcalibre10">jg (jg loop): receives input from cmp above</p></li>
</ul>
</details>
</figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004DF8" data-uri="chapter05.xhtml#P7000497027000000000000000004DF8">
<img alt="A diagram depicts two data-flow graphs for combine7." id="P7000497027000000000000000043567" data-uri="P700049702700000000000000000B71F" src="../images/p543-2.png" class="pcalibre200 pcalibre1 pcalibre2"/>
<figcaption id="P7000497027000000000000000043568" data-uri="chapter05.xhtml#P7000497027000000000000000043568" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043569" data-uri="chapter05.xhtml#P7000497027000000000000000043569" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.28 </span>Abstracting <code id="P700049702700000000000000004356A" data-uri="chapter05.xhtml#P700049702700000000000000004356A" class="pcalibre1 calibre1 pcalibre2">combine7</code> operations as a data-flow graph.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004356B" data-uri="chapter05.xhtml#P700049702700000000000000004356B"><p id="P700049702700000000000000004356C" data-uri="chapter05.xhtml#P700049702700000000000000004356C" class="pcalibre1 pcalibre2 pcalibre10">We rearrange, simplify, and abstract the representation of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004DEE"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">5.27</span></a> to show the data dependencies between successive iterations. The upper mul operation multiplies two 2-vector elements with each other, while the lower one multiplies the result by loop variable <code id="P700049702700000000000000004356D" data-uri="chapter05.xhtml#P700049702700000000000000004356D" class="pcalibre1 calibre1 pcalibre2">acc</code>.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000023857" data-uri="chapter05.xhtml#P7000497027000000000000000023857">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P700049702700000000000000004356E" data-uri="chapter05.xhtml#P700049702700000000000000004356E">
<li id="P700049702700000000000000004356F" data-uri="chapter05.xhtml#P700049702700000000000000004356F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043570" data-uri="chapter05.xhtml#P7000497027000000000000000043570" class="pcalibre1 pcalibre2 pcalibre10">Data flows from top %rmm1 to second mul to bottom %rmm1; from top %rax to each load, each to first mul then second mul then bottom %rmm1; from top %rbp to cmp to jg; from top %rdx to each load and add, from which data is sent to bottom %rdx and to cmp.</p></li>
<li id="P7000497027000000000000000043571" data-uri="chapter05.xhtml#P7000497027000000000000000043571" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043572" data-uri="chapter05.xhtml#P7000497027000000000000000043572" class="pcalibre1 pcalibre2 pcalibre10">Data flows from top top %rmm1 to second mul to bottom %rmm1 and from top %rdx to each load, each to second mul then first mul, as well as add to bottom %rdx. The two loads are within data [i] and the two muls and add within data [i+1].</p></li>
</ol>
</details>
</figcaption></figure>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004E00" data-uri="chapter05.xhtml#P7000497027000000000000000004E00">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004E01" title="544" data-uri="chapter05.xhtml#P7000497027000000000000000004E01" epub:type="pagebreak"></span>
<img alt="A diagram shows a critical paths through the second mul in groups data[0] and data[1], data[2] and data[3], and data[n minus 2] and data[n minus 1]." id="P7000497027000000000000000043573" data-uri="P700049702700000000000000000B720" src="../images/p544-1.png" class="pcalibre201 pcalibre2 pcalibre1"/>
<figcaption id="P7000497027000000000000000043574" data-uri="chapter05.xhtml#P7000497027000000000000000043574" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000043575" data-uri="chapter05.xhtml#P7000497027000000000000000043575" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.29 </span>Data-flow representation of <code id="P7000497027000000000000000043576" data-uri="chapter05.xhtml#P7000497027000000000000000043576" class="pcalibre1 calibre1 pcalibre2">combine7</code> operating on a vector of length <var class="pcalibre17 pcalibre2 pcalibre1">n</var>.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P7000497027000000000000000043577" data-uri="chapter05.xhtml#P7000497027000000000000000043577"><p id="P7000497027000000000000000043578" data-uri="chapter05.xhtml#P7000497027000000000000000043578" class="pcalibre1 pcalibre2 pcalibre10">We have a single critical path, but it contains only <var class="pcalibre17 pcalibre2 pcalibre1">n</var>/2 operations.</p></div>
</figcaption></figure>
<p id="P7000497027000000000000000043579" data-uri="chapter05.xhtml#P7000497027000000000000000043579" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004E0A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.30</span></a> demonstrates the effect of applying the reassociation transformation to achieve what we refer to as <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1<i class="pcalibre17 pcalibre2 pcalibre1">a loop unrolling</i> for values up to <var class="pcalibre17 pcalibre2 pcalibre1">k</var> = 10. We can see that this transformation yields performance results similar to what is achieved by maintaining <var class="pcalibre17 pcalibre2 pcalibre1">k</var> separate accumulators with <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × <var class="pcalibre17 pcalibre2 pcalibre1">k</var> unrolling. In all cases, we come close to the throughput bounds imposed by the functional units.</p>
<p id="P700049702700000000000000004357A" data-uri="chapter05.xhtml#P700049702700000000000000004357A" class="pcalibre8 pcalibre1 pcalibre2">In performing the reassociation transformation, we once again change the order in which the vector elements will be combined together. For integer addition and multiplication, the fact that these operations are associative implies that this reordering will have no effect on the result. For the floating-point cases, we must once again assess whether this reassociation is likely to significantly affect</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004E0A" data-uri="chapter05.xhtml#P7000497027000000000000000004E0A">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004E0B" title="545" data-uri="chapter05.xhtml#P7000497027000000000000000004E0B" epub:type="pagebreak"></span>
<img alt="A graph depicts CPE versus unrolling factor k." id="P700049702700000000000000004357B" data-uri="P700049702700000000000000000B721" src="../images/p545-1.png" class="pcalibre1 pcalibre2 calibre47"/>
<figcaption id="P700049702700000000000000004357C" data-uri="chapter05.xhtml#P700049702700000000000000004357C" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004357D" data-uri="chapter05.xhtml#P700049702700000000000000004357D" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">5.30 </span>CPE performance for <var class="pcalibre17 pcalibre2 pcalibre1">k</var> × 1<var class="pcalibre17 pcalibre2 pcalibre1">a</var> loop unrolling.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004357E" data-uri="chapter05.xhtml#P700049702700000000000000004357E"><p id="P700049702700000000000000004357F" data-uri="chapter05.xhtml#P700049702700000000000000004357F" class="pcalibre1 pcalibre2 pcalibre10">All of the CPEs improve with this transformation, nearly approaching their throughput bounds.</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P700049702700000000000000002386A" data-uri="chapter05.xhtml#P700049702700000000000000002386A">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P7000497027000000000000000043580" data-uri="chapter05.xhtml#P7000497027000000000000000043580" class="pcalibre8 pcalibre1 pcalibre2">The four sets of points plotted each decreasing in CPE with increasing rolling factor k, as summarized below.</p>
<ul id="P7000497027000000000000000043581" data-uri="chapter05.xhtml#P7000497027000000000000000043581" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000043582" data-uri="chapter05.xhtml#P7000497027000000000000000043582" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043583" data-uri="chapter05.xhtml#P7000497027000000000000000043583" class="pcalibre1 pcalibre2 pcalibre10">Double *: from 5 CPE at 1 to about 0.5 CPE at 10</p></li>
<li id="P7000497027000000000000000043584" data-uri="chapter05.xhtml#P7000497027000000000000000043584" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043585" data-uri="chapter05.xhtml#P7000497027000000000000000043585" class="pcalibre1 pcalibre2 pcalibre10">Double + and long *: each from 3 CPE at 1 to steady around 1 CPE by 3</p></li>
<li id="P7000497027000000000000000043586" data-uri="chapter05.xhtml#P7000497027000000000000000043586" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000043587" data-uri="chapter05.xhtml#P7000497027000000000000000043587" class="pcalibre1 pcalibre2 pcalibre10">Long +: from about 1.5 CPE at 1 to steady around 0.5 CPE by 5</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000043588" data-uri="chapter05.xhtml#P7000497027000000000000000043588">the outcome. We would argue that the difference would be immaterial for most applications.</p>
<p id="P7000497027000000000000000043589" data-uri="chapter05.xhtml#P7000497027000000000000000043589" class="pcalibre8 pcalibre1 pcalibre2">In summary, a reassociation transformation can reduce the number of operations along the critical path in a computation, resulting in better performance by better utilizing the multiple functional units and their pipelining capabilities. Most compilers will not attempt any reassociations of floating-point operations, since these operations are not guaranteed to be associative. Current versions of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>do perform reassociations of integer operations, but not always with good effects. In general, we have found that unrolling a loop and accumulating multiple values in parallel is a more reliable way to achieve improved program performance.</p>
<section id="P7000497027000000000000000004E13" data-uri="chapter05.xhtml#P7000497027000000000000000004E13" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P700049702700000000000000004358A" data-uri="chapter05.xhtml#P700049702700000000000000004358A" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">5.8 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005148">576</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P700049702700000000000000004358B" data-uri="chapter05.xhtml#P700049702700000000000000004358B">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P700049702700000000000000004358C" data-uri="chapter05.xhtml#P700049702700000000000000004358C">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P700049702700000000000000004358D" data-uri="chapter05.xhtml#P700049702700000000000000004358D"><p id="P700049702700000000000000004358E" data-uri="chapter05.xhtml#P700049702700000000000000004358E" class="pcalibre1 pcalibre2 pcalibre10">Consider the following function for computing the product of an array of <var class="pcalibre17 pcalibre2 pcalibre1">n</var> double-precision numbers. We have unrolled the loop by a factor of 3.</p>
<pre id="P700049702700000000000000004358F" data-uri="chapter05.xhtml#P700049702700000000000000004358F" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043590" data-uri="chapter05.xhtml#P7000497027000000000000000043590" class="calibre3 pcalibre1 pcalibre2">
double aprod(double a[], long n)
{
	long i;
	double x, y, z;
	double r = 1;
	for (i = 0; i &lt; n-2; i+= 3) {
		x = a[i]; y = a[i+1]; z = a[i+2];
		r = r * x * y * z; /* Product computation */
		}
	for (;i &lt; n; i++)
		r *= a[i];
	return r;
}
</code></pre>
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004E1B" title="546" data-uri="chapter05.xhtml#P7000497027000000000000000004E1B" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000043591" data-uri="chapter05.xhtml#P7000497027000000000000000043591" class="pcalibre1 pcalibre2 pcalibre10">For the line labeled "Product computation," we can use parentheses to create five different associations of the computation, as follows:</p>
<pre id="P7000497027000000000000000043592" data-uri="chapter05.xhtml#P7000497027000000000000000043592" class="calibre2 pcalibre2 pcalibre1"><code id="P7000497027000000000000000043593" data-uri="chapter05.xhtml#P7000497027000000000000000043593" class="calibre3 pcalibre1 pcalibre2">
r = ((r * x) * y) * z; /* A1 */
r = (r * (x * y)) * z; /* A2 */
r = r * ((x * y) * z); /* A3 */
r = r * (x * (y * z)); /* A4 */
r = (r * x) * (y * z); /* A5 */
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre10" id="P7000497027000000000000000043594" data-uri="chapter05.xhtml#P7000497027000000000000000043594">Assume we run these functions on a machine where floating-point multiplication has a latency of 5 clock cycles. Determine the lower bound on the CPE set by the data dependencies of the multiplication. (<i class="pcalibre17 pcalibre2 pcalibre1">Hint:</i> It helps to draw a data-flow representation of how <code id="P7000497027000000000000000043595" data-uri="chapter05.xhtml#P7000497027000000000000000043595" class="pcalibre1 calibre1 pcalibre2">r</code> is computed on every iteration.)</p></div></li>
</ol>
</section>
<aside class="pcalibre31 pcalibre32 pcalibre2" id="P7000497027000000000000000004E21" data-uri="chapter05.xhtml#P7000497027000000000000000004E21"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre33" id="P7000497027000000000000000043596" data-uri="chapter05.xhtml#P7000497027000000000000000043596" epub:type="title"><span class="pcalibre1 pcalibre2 pcalibre34">Web Aside OPT:SIMD </span>Achieving greater parallelism with vector instructions</h1></header>
<p id="P7000497027000000000000000043597" data-uri="chapter05.xhtml#P7000497027000000000000000043597" class="pcalibre1 pcalibre2 pcalibre40">As described in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000001E06.xhtml#P7000497027000000000000000001E06"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">3.1</span></a>, Intel introduced the SSE instructions in 1999, where SSE is the acronym for "streaming SIMD extensions" and, in turn, SIMD (pronounced "sim-dee") is the acronym for "single instruction, multiple data." The SSE capability has gone through multiple generations, with more recent versions being named <i class="pcalibre17 pcalibre2 pcalibre1">advanced vector extensions</i>, or AVX. The SIMD execution model involves operating on entire vectors of data within single instructions. These vectors are held in a special set of <i class="pcalibre17 pcalibre2 pcalibre1">vector registers</i>, named <code id="P7000497027000000000000000043598" data-uri="chapter05.xhtml#P7000497027000000000000000043598" class="pcalibre1 calibre1 pcalibre2">%ymm0-%ymm15</code>. Current AVX vector registers are 32 bytes long, and therefore each can hold eight 32-bit numbers or four 64-bit numbers, where the numbers can be either integer or floating-point values. AVX instructions can then perform vector operations on these registers, such as adding or multiplying eight or four sets of values in parallel. For example, if YMM register <code id="P7000497027000000000000000043599" data-uri="chapter05.xhtml#P7000497027000000000000000043599" class="pcalibre1 calibre1 pcalibre2">%ymm0</code> contains eight single-precision floating-point numbers, which we denote <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">0</sub>, . . ., <var class="pcalibre17 pcalibre2 pcalibre1">a</var><sub class="pcalibre1 pcalibre2 calibre14">7</sub>, and <code id="P700049702700000000000000004359A" data-uri="chapter05.xhtml#P700049702700000000000000004359A" class="pcalibre1 calibre1 pcalibre2">%rcx</code> contains the memory address of a sequence of eight single-precision floating-point numbers, which we denote <var class="pcalibre17 pcalibre2 pcalibre1">b</var><sub class="pcalibre1 pcalibre2 calibre14">0</sub>, . . ., <var class="pcalibre17 pcalibre2 pcalibre1">b</var><sub class="pcalibre1 pcalibre2 calibre14">7</sub>, then the instruction</p>
<pre id="P700049702700000000000000004359B" data-uri="chapter05.xhtml#P700049702700000000000000004359B" class="calibre2 pcalibre2 pcalibre1"><code id="P700049702700000000000000004359C" data-uri="chapter05.xhtml#P700049702700000000000000004359C" class="calibre3 pcalibre1 pcalibre2">
vmulps (%rcs), %ymm0, %ymm1
</code></pre>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P700049702700000000000000004359D" data-uri="chapter05.xhtml#P700049702700000000000000004359D">will read the eight values from memory and perform eight multiplications in parallel, computing <i class="pcalibre17 pcalibre2 pcalibre1">a<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i> ← <i class="pcalibre17 pcalibre2 pcalibre1">a<sub class="pcalibre1 pcalibre2 calibre14">i</sub> · b<sub class="pcalibre1 pcalibre2 calibre14">i</sub></i>, for 0 &lt; <var class="pcalibre17 pcalibre2 pcalibre1">i</var> ≤ 7 and storing the resulting eight products in vector register <code id="P700049702700000000000000004359E" data-uri="chapter05.xhtml#P700049702700000000000000004359E" class="pcalibre1 calibre1 pcalibre2">%ymm1</code>. We see that a single instruction is able to generate a computation over multiple data values, hence the term "SIMD."</p>
<p id="P700049702700000000000000004359F" data-uri="chapter05.xhtml#P700049702700000000000000004359F" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>supports extensions to the C language that let programmers express a program in terms of vector operations that can be compiled into the vector instructions of AVX (as well as code based on the earlier SSE instructions). This coding style is preferable to writing code directly in assembly language, since <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>can also generate code for the vector instructions found on other processors.</p>
<p id="P70004970270000000000000000435A0" data-uri="chapter05.xhtml#P70004970270000000000000000435A0" class="pcalibre1 pcalibre2 pcalibre40">Using a combination of <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>instructions, loop unrolling, and multiple accumulators, we are able to achieve the following performance for our combining functions:</p>
<p id="P70004970270000000000000000435A1" data-uri="chapter05.xhtml#P70004970270000000000000000435A1" class="pcalibre1 pcalibre2 pcalibre40"><span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004E2E" title="547" data-uri="chapter05.xhtml#P7000497027000000000000000004E2E" epub:type="pagebreak"></span></p>
<table class="pcalibre1 informaltable pcalibre2" id="P70004970270000000000000000435A2" data-uri="chapter05.xhtml#P70004970270000000000000000435A2">
<thead class="pcalibre44 pcalibre2 pcalibre1">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P70004970270000000000000000435A3" data-uri="chapter05.xhtml#P70004970270000000000000000435A3" class="pcalibre1 pcalibre2 calibre5"/>
<th colspan="4" id="P70004970270000000000000000435A4" data-uri="chapter05.xhtml#P70004970270000000000000000435A4" class="pcalibre1 pcalibre2 calibre5">Integer</th>
<th colspan="4" id="P70004970270000000000000000435A5" data-uri="chapter05.xhtml#P70004970270000000000000000435A5" class="pcalibre1 pcalibre2 calibre5">Floating point</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P70004970270000000000000000435A6" data-uri="chapter05.xhtml#P70004970270000000000000000435A6" class="pcalibre1 pcalibre2 calibre5"/>
<th colspan="2" id="P70004970270000000000000000435A7" data-uri="chapter05.xhtml#P70004970270000000000000000435A7" class="pcalibre1 pcalibre2 calibre5">int</th>
<th colspan="2" id="P70004970270000000000000000435A8" data-uri="chapter05.xhtml#P70004970270000000000000000435A8" class="pcalibre1 pcalibre2 calibre5">long</th>
<th colspan="2" id="P70004970270000000000000000435A9" data-uri="chapter05.xhtml#P70004970270000000000000000435A9" class="pcalibre1 pcalibre2 calibre5">int</th>
<th colspan="2" id="P70004970270000000000000000435AA" data-uri="chapter05.xhtml#P70004970270000000000000000435AA" class="pcalibre1 pcalibre2 calibre5">long</th>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<th id="P70004970270000000000000000435AB" data-uri="chapter05.xhtml#P70004970270000000000000000435AB" class="pcalibre1 pcalibre2 calibre5">Method</th>
<th id="P70004970270000000000000000435AC" data-uri="chapter05.xhtml#P70004970270000000000000000435AC" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P70004970270000000000000000435AD" data-uri="chapter05.xhtml#P70004970270000000000000000435AD" class="pcalibre1 pcalibre2 calibre5">*</th>
<th id="P70004970270000000000000000435AE" data-uri="chapter05.xhtml#P70004970270000000000000000435AE" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P70004970270000000000000000435AF" data-uri="chapter05.xhtml#P70004970270000000000000000435AF" class="pcalibre1 pcalibre2 calibre5">*</th>
<th id="P70004970270000000000000000435B0" data-uri="chapter05.xhtml#P70004970270000000000000000435B0" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P70004970270000000000000000435B1" data-uri="chapter05.xhtml#P70004970270000000000000000435B1" class="pcalibre1 pcalibre2 calibre5">*</th>
<th id="P70004970270000000000000000435B2" data-uri="chapter05.xhtml#P70004970270000000000000000435B2" class="pcalibre1 pcalibre2 calibre5">+</th>
<th id="P70004970270000000000000000435B3" data-uri="chapter05.xhtml#P70004970270000000000000000435B3" class="pcalibre1 pcalibre2 calibre5">*</th>
</tr>
</thead>
<tbody class="pcalibre1 pcalibre2 calibre6">
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000435B4" data-uri="chapter05.xhtml#P70004970270000000000000000435B4" class="pcalibre1 pcalibre2 calibre7">Scalar 10 × 10</td>
<td id="P70004970270000000000000000435B5" data-uri="chapter05.xhtml#P70004970270000000000000000435B5" class="pcalibre1 pcalibre2 calibre7">0.54</td>
<td id="P70004970270000000000000000435B6" data-uri="chapter05.xhtml#P70004970270000000000000000435B6" class="pcalibre1 pcalibre2 calibre7">1.01</td>
<td id="P70004970270000000000000000435B7" data-uri="chapter05.xhtml#P70004970270000000000000000435B7" class="pcalibre1 pcalibre2 calibre7">0.55</td>
<td id="P70004970270000000000000000435B8" data-uri="chapter05.xhtml#P70004970270000000000000000435B8" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P70004970270000000000000000435B9" data-uri="chapter05.xhtml#P70004970270000000000000000435B9" class="pcalibre1 pcalibre2 calibre7">1.01</td>
<td id="P70004970270000000000000000435BA" data-uri="chapter05.xhtml#P70004970270000000000000000435BA" class="pcalibre1 pcalibre2 calibre7">0.51</td>
<td id="P70004970270000000000000000435BB" data-uri="chapter05.xhtml#P70004970270000000000000000435BB" class="pcalibre1 pcalibre2 calibre7">1.01</td>
<td id="P70004970270000000000000000435BC" data-uri="chapter05.xhtml#P70004970270000000000000000435BC" class="pcalibre1 pcalibre2 calibre7">0.52</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000435BD" data-uri="chapter05.xhtml#P70004970270000000000000000435BD" class="pcalibre1 pcalibre2 calibre7">Scalar throughput bound</td>
<td id="P70004970270000000000000000435BE" data-uri="chapter05.xhtml#P70004970270000000000000000435BE" class="pcalibre1 pcalibre2 calibre7">0.50</td>
<td id="P70004970270000000000000000435BF" data-uri="chapter05.xhtml#P70004970270000000000000000435BF" class="pcalibre1 pcalibre2 calibre7">0.50</td>
<td id="P70004970270000000000000000435C0" data-uri="chapter05.xhtml#P70004970270000000000000000435C0" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P70004970270000000000000000435C1" data-uri="chapter05.xhtml#P70004970270000000000000000435C1" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P70004970270000000000000000435C2" data-uri="chapter05.xhtml#P70004970270000000000000000435C2" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P70004970270000000000000000435C3" data-uri="chapter05.xhtml#P70004970270000000000000000435C3" class="pcalibre1 pcalibre2 calibre7">1.00</td>
<td id="P70004970270000000000000000435C4" data-uri="chapter05.xhtml#P70004970270000000000000000435C4" class="pcalibre1 pcalibre2 calibre7">0.50</td>
<td id="P70004970270000000000000000435C5" data-uri="chapter05.xhtml#P70004970270000000000000000435C5" class="pcalibre1 pcalibre2 calibre7">0.50</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000435C6" data-uri="chapter05.xhtml#P70004970270000000000000000435C6" class="pcalibre1 pcalibre2 calibre7">Vector 8 × 8</td>
<td id="P70004970270000000000000000435C7" data-uri="chapter05.xhtml#P70004970270000000000000000435C7" class="pcalibre1 pcalibre2 calibre7">0.05</td>
<td id="P70004970270000000000000000435C8" data-uri="chapter05.xhtml#P70004970270000000000000000435C8" class="pcalibre1 pcalibre2 calibre7">0.24</td>
<td id="P70004970270000000000000000435C9" data-uri="chapter05.xhtml#P70004970270000000000000000435C9" class="pcalibre1 pcalibre2 calibre7">0.13</td>
<td id="P70004970270000000000000000435CA" data-uri="chapter05.xhtml#P70004970270000000000000000435CA" class="pcalibre1 pcalibre2 calibre7">1.51</td>
<td id="P70004970270000000000000000435CB" data-uri="chapter05.xhtml#P70004970270000000000000000435CB" class="pcalibre1 pcalibre2 calibre7">0.12</td>
<td id="P70004970270000000000000000435CC" data-uri="chapter05.xhtml#P70004970270000000000000000435CC" class="pcalibre1 pcalibre2 calibre7">0.08</td>
<td id="P70004970270000000000000000435CD" data-uri="chapter05.xhtml#P70004970270000000000000000435CD" class="pcalibre1 pcalibre2 calibre7">0.25</td>
<td id="P70004970270000000000000000435CE" data-uri="chapter05.xhtml#P70004970270000000000000000435CE" class="pcalibre1 pcalibre2 calibre7">0.16</td>
</tr>
<tr class="pcalibre45 pcalibre1 pcalibre2">
<td id="P70004970270000000000000000435CF" data-uri="chapter05.xhtml#P70004970270000000000000000435CF" class="pcalibre1 pcalibre2 calibre7">Vector throughput bound</td>
<td id="P70004970270000000000000000435D0" data-uri="chapter05.xhtml#P70004970270000000000000000435D0" class="pcalibre1 pcalibre2 calibre7">0.06</td>
<td id="P70004970270000000000000000435D1" data-uri="chapter05.xhtml#P70004970270000000000000000435D1" class="pcalibre1 pcalibre2 calibre7">0.12</td>
<td id="P70004970270000000000000000435D2" data-uri="chapter05.xhtml#P70004970270000000000000000435D2" class="pcalibre1 pcalibre2 calibre7">0.12</td>
<td id="P70004970270000000000000000435D3" data-uri="chapter05.xhtml#P70004970270000000000000000435D3" class="pcalibre1 pcalibre2 calibre7">—</td>
<td id="P70004970270000000000000000435D4" data-uri="chapter05.xhtml#P70004970270000000000000000435D4" class="pcalibre1 pcalibre2 calibre7">0.12</td>
<td id="P70004970270000000000000000435D5" data-uri="chapter05.xhtml#P70004970270000000000000000435D5" class="pcalibre1 pcalibre2 calibre7">0.06</td>
<td id="P70004970270000000000000000435D6" data-uri="chapter05.xhtml#P70004970270000000000000000435D6" class="pcalibre1 pcalibre2 calibre7">0.25</td>
<td id="P70004970270000000000000000435D7" data-uri="chapter05.xhtml#P70004970270000000000000000435D7" class="pcalibre1 pcalibre2 calibre7">0.12</td>
</tr>
</tbody>
</table>
<p class="pcalibre1 pcalibre2 pcalibre40" id="P70004970270000000000000000435D8" data-uri="chapter05.xhtml#P70004970270000000000000000435D8">In this chart, the first set of numbers is for conventional, <i class="pcalibre17 pcalibre2 pcalibre1">scalar</i> code written in the style of <code id="P70004970270000000000000000435D9" data-uri="chapter05.xhtml#P70004970270000000000000000435D9" class="pcalibre1 calibre1 pcalibre2">combine6</code>, unrolling by a factor of 10 and maintaining 10 accumulators. The second set of numbers is for code written in a form that <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>can compile into AVX vector code. In addition to using vector operations, this version unrolls the main loop by a factor of 8 and maintains eight separate vector accumulators. We show results for both 32-bit and 64-bit numbers, since the vector instructions achieve 8-way parallelism in the first case, but only 4-way parallelism in the second.</p>
<p id="P70004970270000000000000000435DA" data-uri="chapter05.xhtml#P70004970270000000000000000435DA" class="pcalibre1 pcalibre2 pcalibre10">We can see that the vector code achieves almost an eightfold improvement on the four 32-bit cases, and a fourfold improvement on three of the four 64-bit cases. Only the long integer multiplication code does not perform well when we attempt to express it in vector code. The AVX instruction set does not include one to do parallel multiplication of 64-bit integers, and so <span class="pcalibre1 pcalibre29 pcalibre2">gcc </span>cannot generate vector code for this case. Using vector instructions creates a new throughput bound for the combining operations. These are eight times lower for 32-bit operations and four times lower for 64-bit operations than the scalar limits. Our code comes close to achieving these bounds for several combinations of data type and operation.</p>
</aside>
</section>
</section></body></html>
