<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>4.4 General Principles of Pipelining</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P7000497027000000000000000004152" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P70004970270000000000000000423CF" data-uri="chapter04.xhtml#P70004970270000000000000000423CF" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.4 </span>General Principles of Pipelining</h1></header>
<p id="P70004970270000000000000000423D0" data-uri="chapter04.xhtml#P70004970270000000000000000423D0" class="pcalibre8 pcalibre1 pcalibre2">Before attempting to design a pipelined Y86-64 processor, let us consider some general properties and principles of pipelined systems. Such systems are familiar to anyone who has been through the serving line at a cafeteria or run a car through an automated car wash. In a pipelined system, the task to be performed is divided into a series of discrete stages. In a cafeteria, this involves supplying salad, a main dish, dessert, and beverage. In a car wash, this involves spraying water and soap, scrubbing, applying wax, and drying. Rather than having one customer run through the entire sequence from beginning to end before the next can begin, we allow multiple customers to proceed through the system at once. In a traditional cafeteria line, the customers maintain the same order in the pipeline and pass through all stages, even if they do not want some of the courses. In the case of the car wash, a new car is allowed to enter the spraying stage as the preceding car moves from the spraying stage to the scrubbing stage. In general, the cars must move through the system at the same rate to avoid having one car crash into the next.</p>
<p id="P70004970270000000000000000423D1" data-uri="chapter04.xhtml#P70004970270000000000000000423D1" class="pcalibre8 pcalibre1 pcalibre2">A key feature of pipelining is that it increases the <i class="pcalibre17 pcalibre2 pcalibre1">throughput</i> of the system (i.e., the number of customers served per unit time), but it may also slightly increase the <i class="pcalibre17 pcalibre2 pcalibre1">latency</i> (i.e., the time required to service an individual customer). For example, a customer in a cafeteria who only wants a dessert could pass through a nonpipelined system very quickly, stopping only at the dessert stage. A customer in a pipelined system who attempts to go directly to the dessert stage risks incurring the wrath of other customers.</p>
<section id="P7000497027000000000000000004156" data-uri="chapter04.xhtml#P7000497027000000000000000004156" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P70004970270000000000000000423D2" data-uri="chapter04.xhtml#P70004970270000000000000000423D2" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.4.1 </span>Computational Pipelines</h1></header>
<p id="P70004970270000000000000000423D3" data-uri="chapter04.xhtml#P70004970270000000000000000423D3" class="pcalibre8 pcalibre1 pcalibre2">Shifting our focus to computational pipelines, the "customers" are instructions and the stages perform some portion of the instruction execution. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004159"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.32</span></a>(a) shows an example of a simple nonpipelined hardware system. It consists of some logic that performs a computation, followed by a register to hold the results of this computation. A clock signal controls the loading of the register at some regular time interval. An example of such a system is the decoder in a compact disk (CD) player. The incoming signals are the bits read from the surface of the CD, and</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004159" data-uri="chapter04.xhtml#P7000497027000000000000000004159">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000415A" title="413" data-uri="chapter04.xhtml#P700049702700000000000000000415A" epub:type="pagebreak"></span><img alt="Diagrams illustrate unpipelined hardware and a pipeline." id="P70004970270000000000000000423D4" data-uri="P700049702700000000000000000B6E2" src="../images/p413-1.png" class="pcalibre158 pcalibre1 pcalibre2"/>
<figcaption id="P70004970270000000000000000423D5" data-uri="chapter04.xhtml#P70004970270000000000000000423D5" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000423D6" data-uri="chapter04.xhtml#P70004970270000000000000000423D6" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.32 </span>Unpipelined computation hardware.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000423D7" data-uri="chapter04.xhtml#P70004970270000000000000000423D7"><p id="P70004970270000000000000000423D8" data-uri="chapter04.xhtml#P70004970270000000000000000423D8" class="pcalibre8 pcalibre1 pcalibre2"> On each 320 ps cycle, the system spends 300 ps evaluating a combinational logic function and 20 ps storing the results in an output register.</p><p id="P70004970270000000000000000423D9" data-uri="chapter04.xhtml#P70004970270000000000000000423D9" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000226B1" data-uri="chapter04.xhtml#P70004970270000000000000000226B1">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000423DA" data-uri="chapter04.xhtml#P70004970270000000000000000423DA" class="pcalibre8 pcalibre1 pcalibre2">Diagrams are summarized below.</p>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P70004970270000000000000000423DB" data-uri="chapter04.xhtml#P70004970270000000000000000423DB">
<li id="P70004970270000000000000000423DC" data-uri="chapter04.xhtml#P70004970270000000000000000423DC" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000423DD" data-uri="chapter04.xhtml#P70004970270000000000000000423DD" class="pcalibre1 pcalibre2 pcalibre10">Hardware: Unpipelined: combination logic, with 300 ps, leading to Reg, with 20 ps, to Clock, with delay = 320 ps and throughput = 3.12 GIPS</p></li>
<li id="P70004970270000000000000000423DE" data-uri="chapter04.xhtml#P70004970270000000000000000423DE" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000423DF" data-uri="chapter04.xhtml#P70004970270000000000000000423DF" class="pcalibre1 pcalibre2 pcalibre10">Pipeline diagram: Blue boxes move over time from I1 to I2 to I3.</p></li>
</ol>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000423E0" data-uri="chapter04.xhtml#P70004970270000000000000000423E0">the logic decodes these to generate audio signals. The computational block in the figure is implemented as combinational logic, meaning that the signals will pass through a series of logic gates, with the outputs becoming some function of the inputs after some time delay.</p>
<p id="P70004970270000000000000000423E1" data-uri="chapter04.xhtml#P70004970270000000000000000423E1" class="pcalibre8 pcalibre1 pcalibre2">In contemporary logic design, we measure circuit delays in units of <i class="pcalibre17 pcalibre2 pcalibre1">picoseconds</i> (abbreviated "ps"), or 10<sup class="pcalibre1 pcalibre2 pcalibre85">-12</sup> seconds. In this example, we assume the combinational logic requires 300 ps, while the loading of the register requires 20 ps. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004159"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.32</span></a> shows a form of timing diagram known as a <i class="pcalibre17 pcalibre2 pcalibre1">pipeline diagram</i>. In this diagram, time flows from left to right. A series of instructions (here named <code id="P70004970270000000000000000423E2" data-uri="chapter04.xhtml#P70004970270000000000000000423E2" class="pcalibre1 calibre1 pcalibre2">I1, I2</code>, and <code id="P70004970270000000000000000423E3" data-uri="chapter04.xhtml#P70004970270000000000000000423E3" class="pcalibre1 calibre1 pcalibre2">I3</code>) are written from top to bottom. The solid rectangles indicate the times during which these instructions are executed. In this implementation, we must complete one instruction before beginning the next. Hence, the boxes do not overlap one another vertically. The following formula gives the maximum rate at which we could operate the system:</p>

<div class="pcalibre1 pcalibre2 informalequation" id="P70004970270000000000000000423E4" data-uri="chapter04.xhtml#P70004970270000000000000000423E4">
<m:math display="block" alttext="" data-uri="" altimg-width="460" altimg-height="36" altimg="../images/ch04-eq1.png"><m:mrow><m:mi>T</m:mi><m:mi>h</m:mi><m:mi>r</m:mi><m:mi>o</m:mi><m:mi>u</m:mi><m:mi>g</m:mi><m:mi>h</m:mi><m:mi>p</m:mi><m:mi>u</m:mi><m:mi>t</m:mi><m:mo>=</m:mo><m:mfrac><m:mrow><m:mn>1</m:mn><m:mtext> </m:mtext><m:mtext>instruction</m:mtext></m:mrow><m:mrow><m:mo stretchy="false">(</m:mo><m:mn>20</m:mn><m:mo>+</m:mo><m:mn>300</m:mn><m:mo stretchy="false">)</m:mo><m:mtext> </m:mtext><m:mtext>picoseconds</m:mtext></m:mrow></m:mfrac><m:mo>.</m:mo><m:mfrac><m:mrow><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>000</m:mn><m:mtext> </m:mtext><m:mtext>picoseconds</m:mtext></m:mrow><m:mrow><m:mn>1</m:mn><m:mtext> </m:mtext><m:mtext>nanosecond</m:mtext></m:mrow></m:mfrac><m:mo>≈</m:mo><m:mn>3.12</m:mn><m:mtext> </m:mtext><m:mtext>GIPS</m:mtext></m:mrow></m:math>
</div>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000423E5" data-uri="chapter04.xhtml#P70004970270000000000000000423E5">We express throughput in units of giga-instructions per second (abbreviated GIPS), or billions of instructions per second. The total time required to perform a single instruction from beginning to end is known as the <i class="pcalibre17 pcalibre2 pcalibre1">latency</i>. In this system, the latency is 320 ps, the reciprocal of the throughput.</p>
<p id="P70004970270000000000000000423E6" data-uri="chapter04.xhtml#P70004970270000000000000000423E6" class="pcalibre8 pcalibre1 pcalibre2">Suppose we could divide the computation performed by our system into three stages, A, B, and C, where each requires 100 ps, as illustrated in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000416C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.33</span></a>. Then we could put <i class="pcalibre17 pcalibre2 pcalibre1">pipeline registers</i> between the stages so that each instruction moves through the system in three steps, requiring three complete clock cycles from beginning to end. As the pipeline diagram in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000416C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.33</span></a> illustrates, we could allow <code id="P70004970270000000000000000423E7" data-uri="chapter04.xhtml#P70004970270000000000000000423E7" class="pcalibre1 calibre1 pcalibre2">I2</code> to enter stage A as soon as <code id="P70004970270000000000000000423E8" data-uri="chapter04.xhtml#P70004970270000000000000000423E8" class="pcalibre1 calibre1 pcalibre2">I1</code> moves from A to B, and so on. In steady state, all three stages would be active, with one instruction leaving and a new one entering the system every clock cycle. We can see this during the third clock cycle in the pipeline diagram where <code id="P70004970270000000000000000423E9" data-uri="chapter04.xhtml#P70004970270000000000000000423E9" class="pcalibre1 calibre1 pcalibre2">I1</code> is in stage C, <code id="P70004970270000000000000000423EA" data-uri="chapter04.xhtml#P70004970270000000000000000423EA" class="pcalibre1 calibre1 pcalibre2">I2</code> is in stage B, and <code id="P70004970270000000000000000423EB" data-uri="chapter04.xhtml#P70004970270000000000000000423EB" class="pcalibre1 calibre1 pcalibre2">I3</code> is in stage A. In</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000416C" data-uri="chapter04.xhtml#P700049702700000000000000000416C">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000416D" title="414" data-uri="chapter04.xhtml#P700049702700000000000000000416D" epub:type="pagebreak"></span><img alt="Diagrams illustrate three-stage pipeline hardware and a pipeline." id="P70004970270000000000000000423EC" data-uri="P700049702700000000000000000B6E3" src="../images/p414-1.png" class="pcalibre159 pcalibre2 pcalibre1"/>
<figcaption id="P70004970270000000000000000423ED" data-uri="chapter04.xhtml#P70004970270000000000000000423ED" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000423EE" data-uri="chapter04.xhtml#P70004970270000000000000000423EE" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.33 </span>Three-stage pipelined computation hardware.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000423EF" data-uri="chapter04.xhtml#P70004970270000000000000000423EF"><p id="P70004970270000000000000000423F0" data-uri="chapter04.xhtml#P70004970270000000000000000423F0" class="pcalibre8 pcalibre1 pcalibre2"> The computation is split into stages A, B, and C. On each 120 ps cycle, each instruction progresses through one stage.</p><p id="P70004970270000000000000000423F1" data-uri="chapter04.xhtml#P70004970270000000000000000423F1" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000226C9" data-uri="chapter04.xhtml#P70004970270000000000000000226C9">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000423F2" data-uri="chapter04.xhtml#P70004970270000000000000000423F2" class="pcalibre8 pcalibre1 pcalibre2">Diagrams are summarized below.</p>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P70004970270000000000000000423F3" data-uri="chapter04.xhtml#P70004970270000000000000000423F3">
<li id="P70004970270000000000000000423F4" data-uri="chapter04.xhtml#P70004970270000000000000000423F4" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000423F5" data-uri="chapter04.xhtml#P70004970270000000000000000423F5" class="pcalibre1 pcalibre2 pcalibre10">Hardware: Three-stage pipeline: a series of comb. Logic (A, B, and C), each with 100 ps and leading to Reg with 20 ps, each connected to clock. Delay = 360 ps and throughput = 8.33 GIPS.</p></li>
<li id="P70004970270000000000000000423F6" data-uri="chapter04.xhtml#P70004970270000000000000000423F6" class="pcalibre39 pcalibre2 pcalibre1"><p id="P70004970270000000000000000423F7" data-uri="chapter04.xhtml#P70004970270000000000000000423F7" class="pcalibre1 pcalibre2 pcalibre10">Pipeline diagram: Blue boxes each divided into A, B, and C move over time from I1 to I2 to I3, with A under the previous B and B under the previous C.</p></li>
</ol>
</details>
</figcaption>
</figure>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004173" data-uri="chapter04.xhtml#P7000497027000000000000000004173">
<img alt="A diagram illustrates three-stage pipeline timing." id="P70004970270000000000000000423F8" data-uri="P700049702700000000000000000B6E4" src="../images/p414-2.png" class="pcalibre160 pcalibre2 pcalibre1"/>
<figcaption id="P70004970270000000000000000423F9" data-uri="chapter04.xhtml#P70004970270000000000000000423F9" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P70004970270000000000000000423FA" data-uri="chapter04.xhtml#P70004970270000000000000000423FA" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.34 </span>Three-stage pipeline timing.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P70004970270000000000000000423FB" data-uri="chapter04.xhtml#P70004970270000000000000000423FB"><p id="P70004970270000000000000000423FC" data-uri="chapter04.xhtml#P70004970270000000000000000423FC" class="pcalibre8 pcalibre1 pcalibre2"> The rising edge of the clock signal controls the movement of instructions from one pipeline stage to the next.</p><p id="P70004970270000000000000000423FD" data-uri="chapter04.xhtml#P70004970270000000000000000423FD" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000226D5" data-uri="chapter04.xhtml#P70004970270000000000000000226D5">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P70004970270000000000000000423FE" data-uri="chapter04.xhtml#P70004970270000000000000000423FE" class="pcalibre1 pcalibre2 pcalibre10">A diagram of three-stage pipeline timing I1 A from 0 to 120; I1 B and I2 A between 120 and 240; I1 C, I2 B, I3 C between 240 and 360; I2 C and I3 B between 360 and 480; and I3 C between 480 and 600.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P70004970270000000000000000423FF" data-uri="chapter04.xhtml#P70004970270000000000000000423FF">this system, we could cycle the clocks every 100 + 20 = 120 picoseconds, giving a throughput of around 8.33 GIPS. Since processing a single instruction requires 3 clock cycles, the latency of this pipeline is 3 × 120 = 360 ps. We have increased the throughput of the system by a factor of 8.33/3.12 = 2.67 at the expense of some added hardware and a slight increase in the latency (360/320 = 1.12). The increased latency is due to the time overhead of the added pipeline registers.</p>
</section>
<section id="P700049702700000000000000000417A" data-uri="chapter04.xhtml#P700049702700000000000000000417A" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000042400" data-uri="chapter04.xhtml#P7000497027000000000000000042400" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.4.2 </span>A Detailed Look at Pipeline Operation</h1></header>
<p id="P7000497027000000000000000042401" data-uri="chapter04.xhtml#P7000497027000000000000000042401" class="pcalibre8 pcalibre1 pcalibre2">To better understand how pipelining works, let us look in some detail at the timing and operation of pipeline computations. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004173"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.34</span></a> shows the pipeline diagram for the three-stage pipeline we have already looked at (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000416C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.33</span></a>). The transfer of the instructions between pipeline stages is controlled by a clock signal, as shown above the pipeline diagram. Every 120 ps, this signal rises from 0 to 1, initiating the next set of pipeline stage evaluations.</p>
<p id="P7000497027000000000000000042402" data-uri="chapter04.xhtml#P7000497027000000000000000042402" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004180"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.35</span></a> traces the circuit activity between times 240 and 360, as instruction <code id="P7000497027000000000000000042403" data-uri="chapter04.xhtml#P7000497027000000000000000042403" class="pcalibre1 calibre1 pcalibre2">I1</code> (shown in dark gray) propagates through stage C, <code id="P7000497027000000000000000042404" data-uri="chapter04.xhtml#P7000497027000000000000000042404" class="pcalibre1 calibre1 pcalibre2">I2</code> (shown in blue)</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P7000497027000000000000000004180" data-uri="chapter04.xhtml#P7000497027000000000000000004180">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P7000497027000000000000000004181" title="415" data-uri="chapter04.xhtml#P7000497027000000000000000004181" epub:type="pagebreak"></span><img alt="A diagram illustrates four stages in one clock cycle of a pipeline operation." id="P7000497027000000000000000042405" data-uri="P700049702700000000000000000B6E5" src="../images/p415-1.png" class="pcalibre161 pcalibre1 pcalibre2"/>
<figcaption id="P7000497027000000000000000042406" data-uri="chapter04.xhtml#P7000497027000000000000000042406" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000042407" data-uri="chapter04.xhtml#P7000497027000000000000000042407" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.35 </span>One clock cycle of pipeline operation.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000042408" data-uri="chapter04.xhtml#P7000497027000000000000000042408"><p id="P7000497027000000000000000042409" data-uri="chapter04.xhtml#P7000497027000000000000000042409" class="pcalibre8 pcalibre1 pcalibre2"> Just before the clock rises at time 240 (point 1), instructions <code id="P700049702700000000000000004240A" data-uri="chapter04.xhtml#P700049702700000000000000004240A" class="pcalibre1 calibre1 pcalibre2">I1</code> (shown in dark gray) and <code id="P700049702700000000000000004240B" data-uri="chapter04.xhtml#P700049702700000000000000004240B" class="pcalibre1 calibre1 pcalibre2">I2</code> (shown in blue) have completed stages B and A. After the clock rises, these instructions begin propagating through stages C and B, while instruction <code id="P700049702700000000000000004240C" data-uri="chapter04.xhtml#P700049702700000000000000004240C" class="pcalibre1 calibre1 pcalibre2">I3</code> (shown in light gray) begins propagating through stage A (points 2 and 3). Just before the clock rises again, the results for the instructions have propagated to the inputs of the pipeline registers (point 4).</p><p id="P700049702700000000000000004240D" data-uri="chapter04.xhtml#P700049702700000000000000004240D" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P70004970270000000000000000226E5" data-uri="chapter04.xhtml#P70004970270000000000000000226E5">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P700049702700000000000000004240E" data-uri="chapter04.xhtml#P700049702700000000000000004240E" class="pcalibre8 pcalibre1 pcalibre2">A diagram shows I1 B and I2 A between time 120 and 240 and I1 C, I2 B, and I3 A between 240 and 360, with four times within illustrates, as summarized below.</p>
<ul id="P700049702700000000000000004240F" data-uri="chapter04.xhtml#P700049702700000000000000004240F" class="pcalibre1 pcalibre2 pcalibre62">
<li id="P7000497027000000000000000042410" data-uri="chapter04.xhtml#P7000497027000000000000000042410" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042411" data-uri="chapter04.xhtml#P7000497027000000000000000042411" class="pcalibre1 pcalibre2 pcalibre10">Time 239: A series of Comb. Logic (A, B, and C) each with 100 ps, separated by Reg connected to a clock, each with 20 ps. Comb logic A corresponds with I2 and the first Reg and Comb. Logic B correspond with I1.</p></li>
<li id="P7000497027000000000000000042412" data-uri="chapter04.xhtml#P7000497027000000000000000042412" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042413" data-uri="chapter04.xhtml#P7000497027000000000000000042413" class="pcalibre1 pcalibre2 pcalibre10">Time 241: A series of Comb. Logic (A, B, and C) each with 100 ps, separated by Reg connected to a clock, each with 20 ps. The first Reg corresponds with I2 and the second with I1.</p></li>
<li id="P7000497027000000000000000042414" data-uri="chapter04.xhtml#P7000497027000000000000000042414" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042415" data-uri="chapter04.xhtml#P7000497027000000000000000042415" class="pcalibre1 pcalibre2 pcalibre10">Time 300: A series of Comb. Logic (A, B, and C) each with 100 ps, separated by Reg connected to a clock, each with 20 ps. Part of Comb logic A corresponds with I3, the first Reg and part of Comb logic B with I2, and the second Reg and part of Comb logic C with I1.</p></li>
<li id="P7000497027000000000000000042416" data-uri="chapter04.xhtml#P7000497027000000000000000042416" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042417" data-uri="chapter04.xhtml#P7000497027000000000000000042417" class="pcalibre1 pcalibre2 pcalibre10">Time 359: A series of Comb. Logic (A, B, and C) each with 100 ps, separated by Reg connected to a clock, each with 20 ps. Comb logic A corresponds with I3, the first Reg and Comb. Logic B correspond with I2, and the second Reg and Comb logic C correspond with I1.</p></li>
</ul>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000042418" data-uri="chapter04.xhtml#P7000497027000000000000000042418" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000418B" title="416" data-uri="chapter04.xhtml#P700049702700000000000000000418B" epub:type="pagebreak"></span>propagates through stage B, and <code id="P7000497027000000000000000042419" data-uri="chapter04.xhtml#P7000497027000000000000000042419" class="pcalibre1 calibre1 pcalibre2">I3</code> (shown in light gray) propagates through stage A. Just before the rising clock at time 240 (point 1), the values computed in stage A for instruction <code id="P700049702700000000000000004241A" data-uri="chapter04.xhtml#P700049702700000000000000004241A" class="pcalibre1 calibre1 pcalibre2">I2</code> have reached the input of the first pipeline register, but its state and output remain set to those computed during stage A for instruction <code id="P700049702700000000000000004241B" data-uri="chapter04.xhtml#P700049702700000000000000004241B" class="pcalibre1 calibre1 pcalibre2">I1</code>. The values computed in stage B for instruction <code id="P700049702700000000000000004241C" data-uri="chapter04.xhtml#P700049702700000000000000004241C" class="pcalibre1 calibre1 pcalibre2">I1</code> have reached the input of the second pipeline register. As the clock rises, these inputs are loaded into the pipeline registers, becoming the register outputs (point 2). In addition, the input to stage A is set to initiate the computation of instruction <code id="P700049702700000000000000004241D" data-uri="chapter04.xhtml#P700049702700000000000000004241D" class="pcalibre1 calibre1 pcalibre2">I3</code>. The signals then propagate through the combinational logic for the different stages (point 3). As the curved wave fronts in the diagram at point 3 suggest, signals can propagate through different sections at different rates. Before time 360, the result values reach the inputs of the pipeline registers (point 4). When the clock rises at time 360, each of the instructions will have progressed through one pipeline stage.</p>
<p id="P700049702700000000000000004241E" data-uri="chapter04.xhtml#P700049702700000000000000004241E" class="pcalibre8 pcalibre1 pcalibre2">We can see from this detailed view of pipeline operation that slowing down the clock would not change the pipeline behavior. The signals propagate to the pipeline register inputs, but no change in the register states will occur until the clock rises. On the other hand, we could have disastrous effects if the clock were run too fast. The values would not have time to propagate through the combinational logic, and so the register inputs would not yet be valid when the clock rises.</p>
<p id="P700049702700000000000000004241F" data-uri="chapter04.xhtml#P700049702700000000000000004241F" class="pcalibre8 pcalibre1 pcalibre2">As with our discussion of the timing for the SEQ processor (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000003D54_split_000.xhtml#P7000497027000000000000000004004"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">4.3.3</span></a>), we see that the simple mechanism of having clocked registers between blocks of combinational logic suffices to control the flow of instructions in the pipeline. As the clock rises and falls repeatedly, the different instructions flow through the stages of the pipeline without interfering with one another.</p>
</section>
<section id="P7000497027000000000000000004193" data-uri="chapter04.xhtml#P7000497027000000000000000004193" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000042420" data-uri="chapter04.xhtml#P7000497027000000000000000042420" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.4.3 </span>Limitations of Pipelining</h1></header>
<p id="P7000497027000000000000000042421" data-uri="chapter04.xhtml#P7000497027000000000000000042421" class="pcalibre8 pcalibre1 pcalibre2">The example of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000416C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.33</span></a> shows an ideal pipelined system in which we are able to divide the computation into three independent stages, each requiring one-third of the time required by the original logic. Unfortunately, other factors often arise that diminish the effectiveness of pipelining.</p>
<section id="P7000497027000000000000000004196" data-uri="chapter04.xhtml#P7000497027000000000000000004196" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000042422" data-uri="chapter04.xhtml#P7000497027000000000000000042422" epub:type="title">Nonuniform Partitioning</h1></header>
<p id="P7000497027000000000000000042423" data-uri="chapter04.xhtml#P7000497027000000000000000042423" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P700049702700000000000000000419A"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.36</span></a> shows a system in which we divide the computation into three stages as before, but the delays through the stages range from 50 to 150 ps. The sum of the delays through all of the stages remains 300 ps. However, the rate at which we can operate the clock is limited by the delay of the slowest stage. As the pipeline diagram in this figure shows, stage A will be idle (shown as a white box) for 100 ps every clock cycle, while stage C will be idle for 50 ps every clock cycle. Only stage B will be continuously active. We must set the clock cycle to 150 + 20 = 170 picoseconds, giving a throughput of 5.88 GIPS. In addition, the latency would increase to 510 ps due to the slower clock rate.</p>
<p id="P7000497027000000000000000042424" data-uri="chapter04.xhtml#P7000497027000000000000000042424" class="pcalibre8 pcalibre1 pcalibre2">Devising a partitioning of the system computation into a series of stages having uniform delays can be a major challenge for hardware designers. Often,</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000000419A" data-uri="chapter04.xhtml#P700049702700000000000000000419A">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P700049702700000000000000000419B" title="417" data-uri="chapter04.xhtml#P700049702700000000000000000419B" epub:type="pagebreak"></span><img alt="Diagrams illustrate three-stage pipeline with nonuniform stage delays hardware and a pipeline diagram." id="P7000497027000000000000000042425" data-uri="P700049702700000000000000000B6E6" src="../images/p417-1.png" class="calibre35 pcalibre1 pcalibre2"/>
<figcaption id="P7000497027000000000000000042426" data-uri="chapter04.xhtml#P7000497027000000000000000042426" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P7000497027000000000000000042427" data-uri="chapter04.xhtml#P7000497027000000000000000042427" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.36 </span>Limitations of pipelining due to nonuniform stage delays.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000042428" data-uri="chapter04.xhtml#P7000497027000000000000000042428"><p id="P7000497027000000000000000042429" data-uri="chapter04.xhtml#P7000497027000000000000000042429" class="pcalibre8 pcalibre1 pcalibre2"> The system throughput is limited by the speed of the slowest stage.</p><p id="P700049702700000000000000004242A" data-uri="chapter04.xhtml#P700049702700000000000000004242A" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000022702" data-uri="chapter04.xhtml#P7000497027000000000000000022702">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<p id="P700049702700000000000000004242B" data-uri="chapter04.xhtml#P700049702700000000000000004242B" class="pcalibre8 pcalibre1 pcalibre2">Diagrams are summarized below.</p>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P700049702700000000000000004242C" data-uri="chapter04.xhtml#P700049702700000000000000004242C">
<li id="P700049702700000000000000004242D" data-uri="chapter04.xhtml#P700049702700000000000000004242D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004242E" data-uri="chapter04.xhtml#P700049702700000000000000004242E" class="pcalibre1 pcalibre2 pcalibre10">Hardware: Three-stage pipeline, nonuniform stage delays: A series of Comb logic A separated by Reg with 20 ps: Comb logic A = 50 ps, Comb logic B = 150 ps, and Comb logic C = 100 ps. Delay  = 510 ps and throughput = 5.88 GIPS.</p></li>
<li id="P700049702700000000000000004242F" data-uri="chapter04.xhtml#P700049702700000000000000004242F" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042430" data-uri="chapter04.xhtml#P7000497027000000000000000042430" class="pcalibre1 pcalibre2 pcalibre10">Pipeline diagram: I1, I2, and I3 each are divided into unequal sections for A, B, and C.</p></li>
</ol>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000042431" data-uri="chapter04.xhtml#P7000497027000000000000000042431">some of the hardware units in a processor, such as the ALU and the memories, cannot be subdivided into multiple units with shorter delay. This makes it difficult to create a set of balanced stages. We will not concern ourselves with this level of detail in designing our pipelined Y86-64 processor, but it is important to appreciate the importance of timing optimization in actual system design.</p>
<section id="P70004970270000000000000000041A2" data-uri="chapter04.xhtml#P70004970270000000000000000041A2" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P7000497027000000000000000042432" data-uri="chapter04.xhtml#P7000497027000000000000000042432" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.28 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000047F7">489</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000042433" data-uri="chapter04.xhtml#P7000497027000000000000000042433">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000042434" data-uri="chapter04.xhtml#P7000497027000000000000000042434">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000042435" data-uri="chapter04.xhtml#P7000497027000000000000000042435"><p id="P7000497027000000000000000042436" data-uri="chapter04.xhtml#P7000497027000000000000000042436" class="pcalibre1 pcalibre2 pcalibre10">Suppose we analyze the combinational logic of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004159"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.32</span></a> and determine that it can be separated into a sequence of six blocks, named A to F, having delays of 80, 30, 60, 50, 70, and 10 ps, respectively, illustrated as follows:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000041A8" data-uri="chapter04.xhtml#P70004970270000000000000000041A8">
<img alt="A diagram shows a flow through the following” A 80 ps, B 30 ps, C 60 ps, D 50 ps, E 70 ps, F 10 ps, Reg 20 ps." id="P7000497027000000000000000042437" data-uri="P700049702700000000000000000B6E7" src="../images/p417-2.png" class="pcalibre1 pcalibre2 calibre36"/>
</figure>
<p id="P7000497027000000000000000042438" data-uri="chapter04.xhtml#P7000497027000000000000000042438" class="pcalibre1 pcalibre2 pcalibre10">We can create pipelined versions of this design by inserting pipeline registers between pairs of these blocks. Different combinations of pipeline depth (how many stages) and maximum throughput arise, depending on where we insert the pipeline registers. Assume that a pipeline register has a delay of 20 ps.</p>
<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000042439" data-uri="chapter04.xhtml#P7000497027000000000000000042439">
<li id="P700049702700000000000000004243A" data-uri="chapter04.xhtml#P700049702700000000000000004243A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004243B" data-uri="chapter04.xhtml#P700049702700000000000000004243B" class="pcalibre1 pcalibre2 pcalibre10">Inserting a single register gives a two-stage pipeline. Where should the register be inserted to maximize throughput? What would be the throughput and latency?</p></li>
<li id="P700049702700000000000000004243C" data-uri="chapter04.xhtml#P700049702700000000000000004243C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004243D" data-uri="chapter04.xhtml#P700049702700000000000000004243D" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000041B0" title="418" data-uri="chapter04.xhtml#P70004970270000000000000000041B0" epub:type="pagebreak"></span>Where should two registers be inserted to maximize the throughput of a three-stage pipeline? What would be the throughput and latency?</p></li>
<li id="P700049702700000000000000004243E" data-uri="chapter04.xhtml#P700049702700000000000000004243E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004243F" data-uri="chapter04.xhtml#P700049702700000000000000004243F" class="pcalibre1 pcalibre2 pcalibre10">Where should three registers be inserted to maximize the throughput of a 4-stage pipeline? What would be the throughput and latency?</p></li>
<li id="P7000497027000000000000000042440" data-uri="chapter04.xhtml#P7000497027000000000000000042440" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042441" data-uri="chapter04.xhtml#P7000497027000000000000000042441" class="pcalibre1 pcalibre2 pcalibre10">What is the minimum number of stages that would yield a design with the maximum achievable throughput? Describe this design, its throughput, and its latency.</p></li>
</ol>
</div>
</li>
</ol>

</section>
</section>
<section id="P70004970270000000000000000041B5" data-uri="chapter04.xhtml#P70004970270000000000000000041B5" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre65 pcalibre2" id="P7000497027000000000000000042442" data-uri="chapter04.xhtml#P7000497027000000000000000042442" epub:type="title">Diminishing Returns of Deep Pipelining</h1></header>
<p id="P7000497027000000000000000042443" data-uri="chapter04.xhtml#P7000497027000000000000000042443" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000041BF"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.37</span></a> illustrates another limitation of pipelining. In this example, we have divided the computation into six stages, each requiring 50 ps. Inserting a pipeline register between each pair of stages yields a six-stage pipeline. The minimum clock period for this system is 50 + 20 = 70 picoseconds, giving a throughput of 14.29 GIPS. Thus, in doubling the number of pipeline stages, we improve the performance by a factor of 14.29/8.33 = 1.71. Even though we have cut the time required for each computation block by a factor of 2, we do not get a doubling of the throughput, due to the delay through the pipeline registers. This delay becomes a limiting factor in the throughput of the pipeline. In our new design, this delay consumes 28.6% of the total clock period.</p>
<p id="P7000497027000000000000000042444" data-uri="chapter04.xhtml#P7000497027000000000000000042444" class="pcalibre8 pcalibre1 pcalibre2">Modern processors employ very deep pipelines (15 or more stages) in an attempt to maximize the processor clock rate. The processor architects divide the instruction execution into a large number of very simple steps so that each stage can have a very small delay. The circuit designers carefully design the pipeline registers to minimize their delay. The chip designers must also carefully design the clock distribution network to ensure that the clock changes at the exact same time across the entire chip. All of these factors contribute to the challenge of designing high-speed microprocessors.</p>
<section id="P70004970270000000000000000041B9" data-uri="chapter04.xhtml#P70004970270000000000000000041B9" epub:type="practice" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre127 pcalibre2" id="P7000497027000000000000000042445" data-uri="chapter04.xhtml#P7000497027000000000000000042445" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">Practice Problem </span><span class="pcalibre1 pcalibre21 pcalibre2">4.29 </span>(solution page <a class="pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre15 pcalibre13" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P700049702700000000000000000480E">490</a>)</h1></header>
<ol class="pcalibre1 pcalibre2 pcalibre77" id="P7000497027000000000000000042446" data-uri="chapter04.xhtml#P7000497027000000000000000042446">
<li class="pcalibre1 pcalibre2 pcalibre78" id="P7000497027000000000000000042447" data-uri="chapter04.xhtml#P7000497027000000000000000042447">
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000042448" data-uri="chapter04.xhtml#P7000497027000000000000000042448"><p id="P7000497027000000000000000042449" data-uri="chapter04.xhtml#P7000497027000000000000000042449" class="pcalibre1 pcalibre2 pcalibre10">Suppose we could take the system of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P7000497027000000000000000004159"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.32</span></a> and divide it into an arbitrary number of pipeline stages <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, each having a delay of 300/<var class="pcalibre17 pcalibre2 pcalibre1">k</var>, and with each pipeline register having a delay of 20 ps.</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000041BF" data-uri="chapter04.xhtml#P70004970270000000000000000041BF">
<img alt="A diagram shows a flow of six Comb logic of 50 ps, each followed by Reg of 20 ps, with Delay = 420 ps, throughput = 14.29 GIPS." id="P700049702700000000000000004244A" data-uri="P700049702700000000000000000B6E8" src="../images/p418-1.png" class="pcalibre1 pcalibre2 pcalibre162"/>
<figcaption id="P700049702700000000000000004244B" data-uri="chapter04.xhtml#P700049702700000000000000004244B" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004244C" data-uri="chapter04.xhtml#P700049702700000000000000004244C" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.37 </span>Limitations of pipelining due to overhead.</h1></header>
<div class="pcalibre1 caption pcalibre2" id="P700049702700000000000000004244D" data-uri="chapter04.xhtml#P700049702700000000000000004244D"><p id="P700049702700000000000000004244E" data-uri="chapter04.xhtml#P700049702700000000000000004244E" class="pcalibre1 pcalibre2 pcalibre10"> As the combinational logic is split into shorter blocks, the delay due to register updating becomes a limiting factor.</p><p id="P700049702700000000000000004244F" data-uri="chapter04.xhtml#P700049702700000000000000004244F" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
</figcaption>
</figure>

<ol class="pcalibre1 pcalibre2 pcalibre79" id="P7000497027000000000000000042450" data-uri="chapter04.xhtml#P7000497027000000000000000042450">
<li id="P7000497027000000000000000042451" data-uri="chapter04.xhtml#P7000497027000000000000000042451" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042452" data-uri="chapter04.xhtml#P7000497027000000000000000042452" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000041C8" title="419" data-uri="chapter04.xhtml#P70004970270000000000000000041C8" epub:type="pagebreak"></span>What would be the latency and the throughput of the system, as functions of <var class="pcalibre17 pcalibre2 pcalibre1">k</var>?</p></li>
<li id="P7000497027000000000000000042453" data-uri="chapter04.xhtml#P7000497027000000000000000042453" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042454" data-uri="chapter04.xhtml#P7000497027000000000000000042454" class="pcalibre1 pcalibre2 pcalibre10">What would be the ultimate limit on the throughput?</p></li>
</ol>
</div>
</li>
</ol>
</section>
</section>
</section>
<section id="P70004970270000000000000000041CB" data-uri="chapter04.xhtml#P70004970270000000000000000041CB" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre30 pcalibre1 pcalibre2" id="P7000497027000000000000000042455" data-uri="chapter04.xhtml#P7000497027000000000000000042455" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">4.4.4 </span>Pipelining a System with Feedback</h1></header>
<p id="P7000497027000000000000000042456" data-uri="chapter04.xhtml#P7000497027000000000000000042456" class="pcalibre8 pcalibre1 pcalibre2">Up to this point, we have considered only systems in which the objects passing through the pipeline—whether cars, people, or instructions—are completely independent of one another. For a system that executes machine programs such as x86-64 or Y86-64, however, there are potential dependencies between successive instructions. For example, consider the following Y86-64 instruction sequence:</p>
<figure class="pcalibre2 pcalibre32 pcalibre35" id="P700049702700000000000000002272E" data-uri="chapter04.xhtml#P700049702700000000000000002272E">
<img alt="A sequence has elements connected between lines." id="P7000497027000000000000000042457" data-uri="P700049702700000000000000000B6E9" src="../images/p419-1.png" class="pcalibre1 pcalibre163 pcalibre2"/>
<figcaption id="P7000497027000000000000000042458" data-uri="chapter04.xhtml#P7000497027000000000000000042458" class="pcalibre1 pcalibre2 calibre4">
<details class="pcalibre1 pcalibre2 pcalibre59" id="P7000497027000000000000000022731" data-uri="chapter04.xhtml#P7000497027000000000000000022731">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol id="P7000497027000000000000000042459" data-uri="chapter04.xhtml#P7000497027000000000000000042459" class="pcalibre1 calibre19 pcalibre2">
<li id="P700049702700000000000000004245A" data-uri="chapter04.xhtml#P700049702700000000000000004245A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004245B" data-uri="chapter04.xhtml#P700049702700000000000000004245B" class="pcalibre1 pcalibre2 pcalibre10">Irmovq $50, %rax</p></li>
<li id="P700049702700000000000000004245C" data-uri="chapter04.xhtml#P700049702700000000000000004245C" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004245D" data-uri="chapter04.xhtml#P700049702700000000000000004245D" class="pcalibre1 pcalibre2 pcalibre10">Addq %rax (from above), %rbx</p></li>
<li id="P700049702700000000000000004245E" data-uri="chapter04.xhtml#P700049702700000000000000004245E" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004245F" data-uri="chapter04.xhtml#P700049702700000000000000004245F" class="pcalibre1 pcalibre2 pcalibre10">Mrmovq 100(%rbx [from above]), %rdx</p></li>
</ol>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000042460" data-uri="chapter04.xhtml#P7000497027000000000000000042460" class="pcalibre8 pcalibre1 pcalibre2">In this three-instruction sequence, there is a <i class="pcalibre17 pcalibre2 pcalibre1">data dependency</i> between each successive pair of instructions, as indicated by the circled register names and the arrows between them. The <code id="P7000497027000000000000000042461" data-uri="chapter04.xhtml#P7000497027000000000000000042461" class="pcalibre1 calibre1 pcalibre2">irmovq</code> instruction (line 1) stores its result in <code id="P7000497027000000000000000042462" data-uri="chapter04.xhtml#P7000497027000000000000000042462" class="pcalibre1 calibre1 pcalibre2">%rax</code>, which then must be read by the <code id="P7000497027000000000000000042463" data-uri="chapter04.xhtml#P7000497027000000000000000042463" class="pcalibre1 calibre1 pcalibre2">addq</code> instruction (line 2); and this instruction stores its result in <code id="P7000497027000000000000000042464" data-uri="chapter04.xhtml#P7000497027000000000000000042464" class="pcalibre1 calibre1 pcalibre2">%rbx</code>, which must then be read by the <code id="P7000497027000000000000000042465" data-uri="chapter04.xhtml#P7000497027000000000000000042465" class="pcalibre1 calibre1 pcalibre2">mrmovq</code> instruction (line 3).</p>
<p id="P7000497027000000000000000042466" data-uri="chapter04.xhtml#P7000497027000000000000000042466" class="pcalibre8 pcalibre1 pcalibre2">Another source of sequential dependencies occurs due to the instruction control flow. Consider the following Y86-64 instruction sequence:</p>
<pre id="P7000497027000000000000000042467" data-uri="chapter04.xhtml#P7000497027000000000000000042467" class="calibre2 pcalibre2 pcalibre1">
<code id="P7000497027000000000000000042468" data-uri="chapter04.xhtml#P7000497027000000000000000042468" class="calibre3 pcalibre1 pcalibre2">1	loop:
2	  subq %rdx,%rbx
3	  jne targ
4	  irmovq $10,%rdx
5	  jmp loop
6	targ:
7	  halt
</code>
</pre>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P7000497027000000000000000042469" data-uri="chapter04.xhtml#P7000497027000000000000000042469">The <code id="P700049702700000000000000004246A" data-uri="chapter04.xhtml#P700049702700000000000000004246A" class="pcalibre1 calibre1 pcalibre2">jne</code> instruction (line 3) creates a <i class="pcalibre17 pcalibre2 pcalibre1">control dependency</i> since the outcome of the conditional test determines whether the next instruction to execute will be the <code id="P700049702700000000000000004246B" data-uri="chapter04.xhtml#P700049702700000000000000004246B" class="pcalibre1 calibre1 pcalibre2">irmovq</code> instruction (line 4) or the halt instruction (line 7). In our design for SEQ, these dependencies were handled by the feedback paths shown on the right-hand side of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000003D54_split_000.xhtml#P7000497027000000000000000003FAD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.22</span></a>. This feedback brings the updated register values down to the register file and the new PC value down to the PC register.</p>
<p id="P700049702700000000000000004246C" data-uri="chapter04.xhtml#P700049702700000000000000004246C" class="pcalibre8 pcalibre1 pcalibre2"><a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000041DD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.38</span></a> illustrates the perils of introducing pipelining into a system containing feedback paths. In the original system (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000041DD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.38</span></a>(a)), the result of each</p>

<figure class="pcalibre2 pcalibre32 pcalibre35" id="P70004970270000000000000000041DD" data-uri="chapter04.xhtml#P70004970270000000000000000041DD">
<span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000041DE" title="420" data-uri="chapter04.xhtml#P70004970270000000000000000041DE" epub:type="pagebreak"></span><img alt="Diagrams illustrate hardware and corresponding pipeline diagrams." id="P700049702700000000000000004246D" data-uri="P700049702700000000000000000B6EB" src="../images/p420-1.png" class="pcalibre1 pcalibre2 pcalibre164"/>
<figcaption id="P700049702700000000000000004246E" data-uri="chapter04.xhtml#P700049702700000000000000004246E" class="pcalibre1 pcalibre2 calibre4"><header class="pcalibre1 pcalibre2 pcalibre3"><h1 class="pcalibre1 pcalibre2 pcalibre36" id="P700049702700000000000000004246F" data-uri="chapter04.xhtml#P700049702700000000000000004246F" epub:type="title"><span class="label pcalibre1 pcalibre2">Figure </span><span class="pcalibre1 pcalibre2 pcalibre37">4.38 </span>Limitations of pipelining due to logical dependencies.</h1></header>
<div class="pcalibre1 pcalibre2 pcalibre7" id="P7000497027000000000000000042470" data-uri="chapter04.xhtml#P7000497027000000000000000042470"><p id="P7000497027000000000000000042471" data-uri="chapter04.xhtml#P7000497027000000000000000042471" class="pcalibre8 pcalibre1 pcalibre2"> In going from an unpipelined system with feedback (a) to a pipelined one (c), we change its computational behavior, as can be seen by the two pipeline diagrams (b and d).</p><p id="P7000497027000000000000000042472" data-uri="chapter04.xhtml#P7000497027000000000000000042472" class="pcalibre1 pcalibre2 pcalibre10">
</p></div>
<details class="pcalibre1 pcalibre2 pcalibre59" id="P700049702700000000000000002274B" data-uri="chapter04.xhtml#P700049702700000000000000002274B">
<summary class="pcalibre1 pcalibre2 pcalibre61 pcalibre60"><span class="pcalibre1 pcalibre2 pcalibre37">Description</span></summary>
<ol class="pcalibre1 pcalibre2 pcalibre141" id="P7000497027000000000000000042473" data-uri="chapter04.xhtml#P7000497027000000000000000042473">
<li id="P7000497027000000000000000042474" data-uri="chapter04.xhtml#P7000497027000000000000000042474" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042475" data-uri="chapter04.xhtml#P7000497027000000000000000042475" class="pcalibre1 pcalibre2 pcalibre10">Hardware: Unpipelined with feedback: Combinational logic to Reg, back to Combinational logic</p></li>
<li id="P7000497027000000000000000042476" data-uri="chapter04.xhtml#P7000497027000000000000000042476" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042477" data-uri="chapter04.xhtml#P7000497027000000000000000042477" class="pcalibre1 pcalibre2 pcalibre10">Pipeline diagram: I1 to I2 to I3, with end of each looping to the beginning of the next</p></li>
<li id="P7000497027000000000000000042478" data-uri="chapter04.xhtml#P7000497027000000000000000042478" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000042479" data-uri="chapter04.xhtml#P7000497027000000000000000042479" class="pcalibre1 pcalibre2 pcalibre10">Hardware: Three-stage pipeline with feedback: series from Comb logic A to Comb logic B to Comb logic C, back to Comb logic A (each followed by Reg)</p></li>
<li id="P700049702700000000000000004247A" data-uri="chapter04.xhtml#P700049702700000000000000004247A" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004247B" data-uri="chapter04.xhtml#P700049702700000000000000004247B" class="pcalibre1 pcalibre2 pcalibre10">Pipeline diagram: I1, I2, I3, and I4 each composed of A, B, and C, with A below B above and B below C above; I1 C loops to I4 A.</p></li>
</ol>
</details>
</figcaption>
</figure>
<p class="pcalibre8 pcalibre1 pcalibre2" id="P700049702700000000000000004247C" data-uri="chapter04.xhtml#P700049702700000000000000004247C">instruction is fed back around to the next instruction. This is illustrated by the pipeline diagram (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000041DD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.38</span></a>(b)), where the result of <code id="P700049702700000000000000004247D" data-uri="chapter04.xhtml#P700049702700000000000000004247D" class="pcalibre1 calibre1 pcalibre2">I1</code> becomes an input to <code id="P700049702700000000000000004247E" data-uri="chapter04.xhtml#P700049702700000000000000004247E" class="pcalibre1 calibre1 pcalibre2">I2</code>, and so on. If we attempt to convert this to a three-stage pipeline in the most straightforward manner (<a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000041DD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.38</span></a>(c)), we change the behavior of the system. As <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000041DD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.38</span></a>(c) shows, the result of <code id="P700049702700000000000000004247F" data-uri="chapter04.xhtml#P700049702700000000000000004247F" class="pcalibre1 calibre1 pcalibre2">I1</code> becomes an input to <code id="P7000497027000000000000000042480" data-uri="chapter04.xhtml#P7000497027000000000000000042480" class="pcalibre1 calibre1 pcalibre2">I4</code>. In attempting to speed up the system via pipelining, we have changed the system behavior.</p>

<p id="P7000497027000000000000000042481" data-uri="chapter04.xhtml#P7000497027000000000000000042481" class="pcalibre8 pcalibre1 pcalibre2"><span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000041EA" title="421" data-uri="chapter04.xhtml#P70004970270000000000000000041EA" epub:type="pagebreak"></span>When we introduce pipelining into a Y86-64 processor, we must deal with feedback effects properly. Clearly, it would be unacceptable to alter the system behavior as occurred in the example of <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="#P70004970270000000000000000041DD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">4.38</span></a>. Somehow we must deal with the data and control dependencies between instructions so that the resulting behavior matches the model defined by the ISA.</p>
</section>
</section></body></html>
