<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>9.4 VM as a Tool for Memory Management</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="pcalibre1 pcalibre2 pcalibre">
<section id="P70004970270000000000000000070D3" class="pcalibre1 pcalibre2 pcalibre3"><header class="pcalibre1 pcalibre2 calibre"><h1 class="pcalibre1 pcalibre2 pcalibre4" id="P700049702700000000000000004591B" data-uri="chapter09.xhtml#P700049702700000000000000004591B" epub:type="title"><span class="pcalibre1 pcalibre21 pcalibre2">9.4 </span>VM as a Tool for Memory Management</h1></header>
<p id="P700049702700000000000000004591C" data-uri="chapter09.xhtml#P700049702700000000000000004591C" class="pcalibre8 pcalibre1 pcalibre2">In the last section, we saw how virtual memory provides a mechanism for using the DRAM to cache pages from a typically larger virtual address space. Interestingly, some early systems such as the DEC PDP-11/70 supported a virtual address space that was <i class="pcalibre17 pcalibre2 pcalibre1">smaller</i> than the available physical memory. Yet virtual memory was still a useful mechanism because it greatly simplified memory management and provided a natural way to protect memory.</p>
<p id="P700049702700000000000000004591D" data-uri="chapter09.xhtml#P700049702700000000000000004591D" class="pcalibre8 pcalibre1 pcalibre2">Thus far, we have assumed a single page table that maps a single virtual address space to the physical address space. In fact, operating systems provide a separate page table, and thus a separate virtual address space, for each process. <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007062.xhtml#P70004970270000000000000000070CD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.9</span></a> shows the basic idea. In the example, the page table for process <var class="pcalibre17 pcalibre2 pcalibre1">i</var> maps VP 1 to PP 2 and VP 2 to PP 7. Similarly, the page table for process <var class="pcalibre17 pcalibre2 pcalibre1">j</var> maps VP 1 to PP 7 and VP 2 to PP 10. Notice that multiple virtual pages can be mapped to the same shared physical page.</p>
<p id="P700049702700000000000000004591E" data-uri="chapter09.xhtml#P700049702700000000000000004591E" class="pcalibre8 pcalibre1 pcalibre2">The combination of demand paging and separate virtual address spaces has a profound impact on the way that memory is used and managed in a system. In particular, VM simplifies linking and loading, the sharing of code and data, and allocating memory to applications.</p>
<ul id="P700049702700000000000000004591F" data-uri="chapter09.xhtml#P700049702700000000000000004591F" class="pcalibre1 calibre9 pcalibre2">
<li id="P7000497027000000000000000045920" data-uri="chapter09.xhtml#P7000497027000000000000000045920" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045921" data-uri="chapter09.xhtml#P7000497027000000000000000045921" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Simplifying linking. </span>A separate address space allows each process to use the same basic format for its memory image, regardless of where the code and data actually reside in physical memory. For example, as we saw in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000070F6.xhtml#P700049702700000000000000000713C"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">8.13</span></a>, every process on a given Linux system has a similar memory format. For 64-bit address spaces, the code segment <i class="pcalibre17 pcalibre2 pcalibre1">always</i> starts at virtual address <code id="P7000497027000000000000000045922" data-uri="chapter09.xhtml#P7000497027000000000000000045922" class="pcalibre1 calibre1 pcalibre2">0x400000</code>. The data segment follows the code segment after a suitable alignment gap. The stack occupies the highest portion of the user process address space and <span class="pcalibre1 pcalibre2 pcalibre5" id="P70004970270000000000000000070DC" title="812" data-uri="chapter09.xhtml#P70004970270000000000000000070DC" epub:type="pagebreak"></span>grows downward. Such uniformity greatly simplifies the design and implementation of linkers, allowing them to produce fully linked executables that are independent of the ultimate location of the code and data in physical memory.</p></li>
<li id="P7000497027000000000000000045923" data-uri="chapter09.xhtml#P7000497027000000000000000045923" class="pcalibre39 pcalibre2 pcalibre1"><p id="P7000497027000000000000000045924" data-uri="chapter09.xhtml#P7000497027000000000000000045924" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Simplifying loading. </span>Virtual memory also makes it easy to load executable and shared object files into memory. To load the <code id="P7000497027000000000000000045925" data-uri="chapter09.xhtml#P7000497027000000000000000045925" class="pcalibre1 calibre1 pcalibre2">.text</code> and <code id="P7000497027000000000000000045926" data-uri="chapter09.xhtml#P7000497027000000000000000045926" class="pcalibre1 calibre1 pcalibre2">.data</code> sections of an object file into a newly created process, the Linux loader allocates virtual pages for the code and data segments, marks them as invalid (i.e., not cached), and points their page table entries to the appropriate locations in the object file. The interesting point is that the loader never actually copies any data from disk into memory. The data are paged in automatically and on demand by the virtual memory system the first time each page is referenced, either by the CPU when it fetches an instruction or by an executing instruction when it references a memory location.</p>
<p id="P7000497027000000000000000045927" data-uri="chapter09.xhtml#P7000497027000000000000000045927" class="pcalibre1 pcalibre2 pcalibre63">This notion of mapping a set of contiguous virtual pages to an arbitrary location in an arbitrary file is known as <i class="pcalibre17 pcalibre2 pcalibre1">memory mapping.</i> Linux provides a system call called <code id="P7000497027000000000000000045928" data-uri="chapter09.xhtml#P7000497027000000000000000045928" class="pcalibre1 calibre1 pcalibre2">mmap</code> that allows application programs to do their own memory mapping. We will describe application-level memory mapping in more detail in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP70004970270000000000000000072B5.xhtml#P70004970270000000000000000072B5"><span class="pcalibre1 pcalibre21 pcalibre2">Section </span><span class="pcalibre1 pcalibre21 pcalibre2">9.8</span></a>.</p></li>
<li id="P7000497027000000000000000045929" data-uri="chapter09.xhtml#P7000497027000000000000000045929" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004592A" data-uri="chapter09.xhtml#P700049702700000000000000004592A" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Simplifying sharing. </span>Separate address spaces provide the operating system with a consistent mechanism for managing sharing between user processes and the operating system itself. In general, each process has its own private code, data, heap, and stack areas that are not shared with any other process. In this case, the operating system creates page tables that map the corresponding virtual pages to disjoint physical pages.</p>
<p id="P700049702700000000000000004592B" data-uri="chapter09.xhtml#P700049702700000000000000004592B" class="pcalibre1 pcalibre2 pcalibre63">However, in some instances it is desirable for processes to share code and data. For example, every process must call the same operating system kernel code, and every C program makes calls to routines in the standard C library such as <code id="P700049702700000000000000004592C" data-uri="chapter09.xhtml#P700049702700000000000000004592C" class="pcalibre1 calibre1 pcalibre2">printf</code>. Rather than including separate copies of the kernel and standard C library in each process, the operating system can arrange for multiple processes to share a single copy of this code by mapping the appropriate virtual pages in different processes to the same physical pages, as we saw in <a class="pcalibre15 pcalibre1 pcalibre2 pcalibre16 pcalibre14 pcalibre28" href="fileP7000497027000000000000000007062.xhtml#P70004970270000000000000000070CD"><span class="pcalibre1 pcalibre21 pcalibre2">Figure </span><span class="pcalibre1 pcalibre21 pcalibre2">9.9</span></a>.</p></li>
<li id="P700049702700000000000000004592D" data-uri="chapter09.xhtml#P700049702700000000000000004592D" class="pcalibre39 pcalibre2 pcalibre1"><p id="P700049702700000000000000004592E" data-uri="chapter09.xhtml#P700049702700000000000000004592E" class="pcalibre1 pcalibre2 pcalibre10"><span class="pcalibre1 pcalibre2 pcalibre41">Simplifying memory allocation. </span>Virtual memory provides a simple mechanism for allocating additional memory to user processes. When a program running in a user process requests additional heap space (e.g., as a result of calling <code id="P700049702700000000000000004592F" data-uri="chapter09.xhtml#P700049702700000000000000004592F" class="pcalibre1 calibre1 pcalibre2">malloc</code>), the operating system allocates an appropriate number, say, <var class="pcalibre17 pcalibre2 pcalibre1">k</var>, of contiguous virtual memory pages, and maps them to <var class="pcalibre17 pcalibre2 pcalibre1">k</var> arbitrary physical pages located anywhere in physical memory. Because of the way page tables work, there is no need for the operating system to locate <var class="pcalibre17 pcalibre2 pcalibre1">k</var> contiguous pages of physical memory. The pages can be scattered randomly in physical memory.</p></li>
</ul>
</section></body></html>
